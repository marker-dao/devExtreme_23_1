"use strict";

var _globals = require("@jest/globals");
var _fx = _interopRequireDefault(require("../../../../common/core/animation/fx"));
var _renderer = _interopRequireDefault(require("../../../../core/renderer"));
var _callbacks = _interopRequireDefault(require("../../../../core/utils/callbacks"));
var _wrapInstance = _interopRequireDefault(require("../../../grids/grid_core/__tests__/__mock__/helpers/wrapInstance"));
var _ai_prompt_editor = require("../../../grids/grid_core/__tests__/__mock__/model/ai_prompt_editor");
var _ai_prompt_editor2 = require("./ai_prompt_editor/ai_prompt_editor");
var _m_ai_prompt_editor_view = require("./m_ai_prompt_editor_view");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); } /* eslint-disable @typescript-eslint/no-explicit-any */
_globals.jest.mock('./ai_prompt_editor/ai_prompt_editor', () => {
  const original = _globals.jest.requireActual('./ai_prompt_editor/ai_prompt_editor');
  return _extends({}, original, {
    AIPromptEditor: _globals.jest.fn(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const instance = new original.AIPromptEditor(...args);
      return (0, _wrapInstance.default)(instance);
    })
  });
});
_globals.jest.spyOn(_m_ai_prompt_editor_view.AIPromptEditorView.prototype, 'getController');
const mockColumnsController = {
  addCommandColumn: _globals.jest.fn(),
  columnOption: _globals.jest.fn(),
  getColumnByPath: _globals.jest.fn(),
  getColumnOptionNameByFullName: _globals.jest.fn(),
  getVisibleIndex: _globals.jest.fn().mockReturnValue(0),
  aiColumnOptionChanged: (0, _callbacks.default)()
};
const mockAIColumnController = {
  abortAIColumnRequest: _globals.jest.fn(),
  sendRequest: _globals.jest.fn(),
  getAIColumns: _globals.jest.fn().mockReturnValue([]),
  aiRequestCompleted: (0, _callbacks.default)(),
  aiRequestRejected: (0, _callbacks.default)(),
  promptEditorRequested: (0, _callbacks.default)()
};
const mockColumn = {
  type: 'ai',
  alignment: 'left',
  name: 'aiColumn',
  index: 0
};
const createComponentMock = _globals.jest.fn((el, Widget, options) => new Widget(el, options));
const createAIPromptEditorView = () => {
  const $container = (0, _renderer.default)('<div>').appendTo(document.body);
  const $cellElement = (0, _renderer.default)('<div>').appendTo(document.body);
  const mockComponent = {
    element: () => $container.get(0),
    _createComponent: createComponentMock,
    _controllers: {
      columns: mockColumnsController,
      aiColumn: mockAIColumnController
    }
  };
  const aiPromptEditorView = new _m_ai_prompt_editor_view.AIPromptEditorView(mockComponent);
  aiPromptEditorView.init();
  aiPromptEditorView.render($container);
  return {
    $container,
    cellElement: $cellElement[0],
    aiPromptEditorView,
    aiPromptEditorPOM: new _ai_prompt_editor.AIPromptEditorModel(aiPromptEditorView.element().get(0))
  };
};
const beforeTest = () => {
  _fx.default.off = true;
  _globals.jest.useFakeTimers();
  _globals.jest.clearAllMocks();
};
const afterTest = () => {
  document.body.innerHTML = '';
  _fx.default.off = false;
  _globals.jest.useRealTimers();
  mockAIColumnController.aiRequestCompleted.empty();
  mockAIColumnController.aiRequestRejected.empty();
  mockColumnsController.aiColumnOptionChanged.empty();
};
(0, _globals.describe)('AIPromptEditorView', () => {
  (0, _globals.beforeEach)(beforeTest);
  (0, _globals.afterEach)(afterTest);
  (0, _globals.describe)('initialization', () => {
    (0, _globals.it)('should initialize controllers', () => {
      const {
        aiPromptEditorView
      } = createAIPromptEditorView();
      (0, _globals.expect)(aiPromptEditorView.getController).toHaveBeenCalledWith('columns');
      (0, _globals.expect)(aiPromptEditorView.getController).toHaveBeenCalledWith('aiColumn');
    });
  });
  (0, _globals.describe)('Methods', () => {
    (0, _globals.describe)('show', () => {
      (0, _globals.it)('should create new AIPromptEditor instance', async () => {
        const {
          $container,
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).toHaveBeenCalledWith({
          prompt: '',
          container: aiPromptEditorView.element(),
          createComponent: _globals.expect.any(Function),
          onStop: _globals.expect.any(Function),
          onSubmit: _globals.expect.any(Function),
          onRefresh: _globals.expect.any(Function),
          popupOptions: {
            container: document.body,
            onHiding: _globals.expect.any(Function),
            position: {
              my: 'right top',
              at: 'right bottom',
              of: '.dx-header-row td[aria-colindex="1"]',
              collision: 'fit',
              boundary: $container.get(0)
            }
          },
          editorOptions: {}
        });
        (0, _globals.expect)(aiPromptEditorView.getPromptEditorInstance().show).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(aiPromptEditorPOM.isVisible()).toBe(true);
      });
      (0, _globals.it)('should update existing AIPromptEditor instance', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).toHaveBeenCalledWith(_globals.expect.objectContaining({
          popupOptions: _globals.expect.objectContaining({
            position: _globals.expect.objectContaining({
              of: '.dx-header-row td[aria-colindex="1"]'
            })
          })
        }));
        (0, _globals.expect)(aiPromptEditorView.getPromptEditorInstance().updateOptions).toHaveBeenCalledTimes(0);
        const newColumn = _extends({}, mockColumn, {
          ai: {
            prompt: 'updated prompt'
          }
        });
        mockColumnsController.getVisibleIndex.mockReturnValue(1);
        await aiPromptEditorView.show(cellElement, newColumn);
        (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).toHaveBeenCalledTimes(1); // Only one instance created
        (0, _globals.expect)(aiPromptEditorView.getPromptEditorInstance().updateOptions).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(aiPromptEditorView.getPromptEditorInstance().updateOptions).toHaveBeenCalledWith(_globals.expect.objectContaining({
          popupOptions: _globals.expect.objectContaining({
            position: _globals.expect.objectContaining({
              of: '.dx-header-row td[aria-colindex="2"]'
            })
          })
        }));
        (0, _globals.expect)(aiPromptEditorPOM.getTextArea().getInputElement().value).toBe('updated prompt');
      });
      (0, _globals.it)('should configure popup position correctly for left alignment', async () => {
        const {
          cellElement,
          aiPromptEditorView
        } = createAIPromptEditorView();
        const leftAlignedColumn = _extends({}, mockColumn, {
          alignment: 'left'
        });
        await aiPromptEditorView.show(cellElement, leftAlignedColumn);
        (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).toHaveBeenCalledWith(_globals.expect.objectContaining({
          popupOptions: _globals.expect.objectContaining({
            position: _globals.expect.objectContaining({
              my: 'right top',
              at: 'right bottom'
            })
          })
        }));
      });
      (0, _globals.it)('should configure popup position correctly for right alignment', async () => {
        const {
          cellElement,
          aiPromptEditorView
        } = createAIPromptEditorView();
        const rightAlignedColumn = _extends({}, mockColumn, {
          alignment: 'right'
        });
        await aiPromptEditorView.show(cellElement, rightAlignedColumn);
        (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).toHaveBeenCalledWith(_globals.expect.objectContaining({
          popupOptions: _globals.expect.objectContaining({
            position: _globals.expect.objectContaining({
              my: 'left top',
              at: 'left bottom'
            })
          })
        }));
      });
      (0, _globals.describe)('when called with invalid parameters', () => {
        (0, _globals.it)('should return false if cell element is null', async () => {
          const {
            aiPromptEditorView
          } = createAIPromptEditorView();
          const result = await aiPromptEditorView.show(null, mockColumn);
          (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).not.toHaveBeenCalled();
          (0, _globals.expect)(result).toBe(false);
        });
        (0, _globals.it)('should return false if column is null', async () => {
          const {
            cellElement,
            aiPromptEditorView
          } = createAIPromptEditorView();
          const result = await aiPromptEditorView.show(cellElement, null);
          (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).not.toHaveBeenCalled();
          (0, _globals.expect)(result).toBe(false);
        });
        (0, _globals.it)('should return false if column type is not ai', async () => {
          const {
            cellElement,
            aiPromptEditorView
          } = createAIPromptEditorView();
          const result = await aiPromptEditorView.show(cellElement, _extends({}, mockColumn, {
            type: ''
          }));
          (0, _globals.expect)(_ai_prompt_editor2.AIPromptEditor).not.toHaveBeenCalled();
          (0, _globals.expect)(result).toBe(false);
        });
      });
    });
    (0, _globals.describe)('hide', () => {
      (0, _globals.it)('should call hide method', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        const result = await aiPromptEditorView.hide();
        (0, _globals.expect)(aiPromptEditorView.getPromptEditorInstance().hide).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(aiPromptEditorPOM.isVisible()).toBe(false);
        (0, _globals.expect)(result).toBe(false);
      });
    });
  });
  (0, _globals.describe)('event handlers in AIPromptEditor config', () => {
    (0, _globals.describe)('onSubmit', () => {
      (0, _globals.it)('should update column option and prompt editor state', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithIndex = _extends({}, mockColumn, {
          index: 2
        });
        await aiPromptEditorView.show(cellElement, columnWithIndex);
        aiPromptEditorPOM.getTextArea().setValue('test prompt');
        aiPromptEditorPOM.getApplyButton().getElement().click();
        (0, _globals.expect)(aiPromptEditorView.getPromptEditorInstance().updateStateOnAction).toHaveBeenCalledWith('apply');
        (0, _globals.expect)(mockColumnsController.columnOption).toHaveBeenCalledWith(2, 'ai.prompt', 'test prompt', true);
      });
    });
    (0, _globals.describe)('onStop', () => {
      (0, _globals.it)('should abort AI request and update prompt editor state', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        mockAIColumnController.sendRequest.mockImplementation(() => {
          setTimeout(() => {
            mockAIColumnController.aiRequestCompleted.fire();
          });
        });
        await aiPromptEditorView.show(cellElement, mockColumn);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getTextArea().setValue('test prompt');
        aiPromptEditorPOM.getApplyButton().getElement().click();
        promptEditorInstance.updateStateOnAction.mockClear();
        aiPromptEditorPOM.getStopButton().getElement().click();
        _globals.jest.runAllTimers();
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
        (0, _globals.expect)(mockAIColumnController.abortAIColumnRequest).toHaveBeenCalledTimes(1);
      });
    });
    (0, _globals.describe)('onRefresh', () => {
      (0, _globals.it)('should refresh AI column and update prompt editor state', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = _extends({}, mockColumn, {
          name: 'testColumn',
          ai: {
            prompt: 'test prompt'
          }
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getRefreshButton().getElement().click();
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('regenerate');
        (0, _globals.expect)(mockAIColumnController.sendRequest).toHaveBeenCalledWith('testColumn', false, false);
      });
      (0, _globals.it)('should update prompt editor state on completion', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = _extends({}, mockColumn, {
          name: 'testColumn',
          ai: {
            prompt: 'test prompt'
          }
        });
        mockAIColumnController.sendRequest.mockImplementation(() => {
          setTimeout(() => {
            mockAIColumnController.aiRequestCompleted.fire();
          });
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getRefreshButton().getElement().click();
        promptEditorInstance.updateStateOnAction.mockClear();
        _globals.jest.runAllTimers();
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
      });
      (0, _globals.it)('should update prompt editor state on error', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = _extends({}, mockColumn, {
          name: 'testColumn',
          ai: {
            prompt: 'test prompt'
          }
        });
        mockAIColumnController.sendRequest.mockImplementation(() => {
          setTimeout(() => {
            mockAIColumnController.aiRequestRejected.fire();
          });
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getRefreshButton().getElement().click();
        promptEditorInstance.updateStateOnAction.mockClear();
        _globals.jest.runAllTimers();
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
      });
    });
    (0, _globals.describe)('onHiding', () => {
      (0, _globals.it)('should update prompt editor state and abort AI request', async () => {
        const {
          cellElement,
          aiPromptEditorView
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        await aiPromptEditorView.hide();
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
        (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
        (0, _globals.expect)(mockAIColumnController.abortAIColumnRequest).toHaveBeenCalledTimes(1);
      });
    });
  });
  (0, _globals.describe)('aiColumnOptionChanged callback', () => {
    (0, _globals.it)('should handle ai.prompt option change', async () => {
      const {
        cellElement,
        aiPromptEditorView
      } = createAIPromptEditorView();
      mockAIColumnController.sendRequest.mockImplementation(() => {
        setTimeout(() => {
          mockAIColumnController.aiRequestCompleted.fire();
        });
      });
      await aiPromptEditorView.show(cellElement, mockColumn);
      const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
      promptEditorInstance.getEditorValue.mockReturnValue('new prompt value');
      mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
      (0, _globals.expect)(promptEditorInstance.updatePrompt).toHaveBeenCalledWith('new prompt value');
      (0, _globals.expect)(mockAIColumnController.sendRequest).toHaveBeenCalledWith('aiColumn', false, false);
    });
    (0, _globals.it)('should update prompt editor state on completion', async () => {
      const {
        cellElement,
        aiPromptEditorView
      } = createAIPromptEditorView();
      mockAIColumnController.sendRequest.mockImplementation(() => {
        mockAIColumnController.aiRequestCompleted.fire();
      });
      await aiPromptEditorView.show(cellElement, mockColumn);
      const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
      promptEditorInstance.getEditorValue.mockReturnValue('new prompt value');
      mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
      (0, _globals.expect)(promptEditorInstance.updatePrompt).toHaveBeenCalledWith('new prompt value');
      (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
    });
    (0, _globals.it)('should update prompt editor state on error', async () => {
      const {
        cellElement,
        aiPromptEditorView
      } = createAIPromptEditorView();
      mockAIColumnController.sendRequest.mockImplementation(() => {
        mockAIColumnController.aiRequestRejected.fire();
      });
      await aiPromptEditorView.show(cellElement, mockColumn);
      mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
      const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
      (0, _globals.expect)(promptEditorInstance.updatePrompt).toHaveBeenCalledWith('new prompt value');
      (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
      (0, _globals.expect)(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
    });
    (0, _globals.describe)('when prompt editor is not initialized', () => {
      (0, _globals.it)('should handle callback without errors', () => {
        createAIPromptEditorView();
        (0, _globals.expect)(() => {
          mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
        }).not.toThrow();
        (0, _globals.expect)(mockAIColumnController.sendRequest).toHaveBeenCalledWith('aiColumn', false, true);
      });
    });
  });
});