/**
* DevExtreme (esm/__internal/scheduler/appointment_popup/appointment_popup.test.js)
* Version: 26.1.0
* Build date: Tue Jan 13 2026
*
* Copyright (c) 2012 - 2026 Developer Express Inc. ALL RIGHTS RESERVED
* Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
*/
import { afterEach, beforeEach, describe, expect, it, jest } from '@jest/globals';
import { CustomStore } from '../../../common/data/custom_store';
import $ from '../../../core/renderer';
import { toMilliseconds } from '../../utils/toMilliseconds';
import fx from '../../../common/core/animation/fx';
import { createScheduler } from '../__tests__/__mock__/create_scheduler';
import { setupSchedulerTestEnvironment } from '../__tests__/__mock__/m_mock_scheduler';
import { DEFAULT_SCHEDULER_OPTIONS } from '../utils/options/constants';
const CLASSES = {
  icon: 'dx-scheduler-form-icon',
  hidden: 'dx-hidden',
  scheduler: 'dx-scheduler',
  mainGroupHidden: 'dx-scheduler-form-main-group-hidden',
  recurrenceGroupHidden: 'dx-scheduler-form-recurrence-group-hidden'
};
const recurringAppointment = {
  text: 'recurring-app',
  startDate: new Date(2017, 4, 1, 9, 30),
  endDate: new Date(2017, 4, 1, 11),
  recurrenceRule: 'FREQ=DAILY;COUNT=5'
};
const commonAppointment = {
  text: 'common-app',
  startDate: new Date(2017, 4, 9, 9, 30),
  endDate: new Date(2017, 4, 9, 11)
};
const disabledAppointment = {
  text: 'disabled-app',
  startDate: new Date(2017, 4, 22, 9, 30),
  endDate: new Date(2017, 4, 22, 11, 30),
  disabled: true
};
const allDayAppointment = {
  text: 'all-day-app',
  startDate: new Date(2017, 4, 1),
  endDate: new Date(2017, 4, 1),
  allDay: true
};
const getDefaultConfig = () => ({
  dataSource: [],
  views: ['month'],
  currentView: 'month',
  currentDate: new Date(2017, 4, 25),
  firstDayOfWeek: 1,
  startDayHour: 9,
  height: 600,
  width: 600
});
describe('Appointment Form', () => {
  beforeEach(() => {
    fx.off = true;
    setupSchedulerTestEnvironment({
      height: 600
    });
  });
  afterEach(() => {
    const $scheduler = $(document.querySelector(`.${CLASSES.scheduler}`));
    // @ts-expect-error
    $scheduler.dxScheduler('dispose');
    document.body.innerHTML = '';
    fx.off = false;
    jest.useRealTimers();
  });
  describe('Changes saving/canceling', () => {
    it('should update appointment on save button click', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, commonAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.setInputValue('subjectEditor', 'New Subject');
      POM.popup.getSaveButton().click();
      expect(dataSource.items()[0]).toMatchObject(Object.assign({}, commonAppointment, {
        text: 'New Subject'
      }));
    });
    it('should not update appointment on cancel button click', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, commonAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.setInputValue('subjectEditor', 'New Subject');
      POM.popup.getCancelButton().click();
      expect(dataSource.items()[0]).toMatchObject(commonAppointment);
    });
    it('should update recurring appointment on save button click in recurrence form', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, recurringAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.getEditSeriesButton().click();
      POM.popup.setInputValue('subjectEditor', 'New Subject');
      POM.popup.openRecurrenceSettings();
      POM.popup.getSaveButton().click();
      expect(dataSource.items()[0]).toMatchObject(Object.assign({}, recurringAppointment, {
        text: 'New Subject'
      }));
    });
    it('should not update recurring appointment on cancel button click in recurrence form', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, recurringAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.getEditSeriesButton().click();
      POM.popup.setInputValue('subjectEditor', 'New Subject');
      POM.popup.openRecurrenceSettings();
      POM.popup.getCancelButton().click();
      expect(dataSource.items()[0]).toMatchObject(recurringAppointment);
    });
    it('should update appointment recurrence rule changes on save button click', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, commonAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.selectRepeatValue('daily');
      POM.popup.getSaveButton().click();
      expect(dataSource.items()[0]).toMatchObject(Object.assign({}, commonAppointment, {
        recurrenceRule: 'FREQ=DAILY'
      }));
    });
    it('should not update appointment recurrence rule changes on cancel button click', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, commonAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.selectRepeatValue('daily');
      POM.popup.getCancelButton().click();
      expect(dataSource.items()[0]).toMatchObject(commonAppointment);
    });
    it('should not update recurrence rule on save button click if recurrence rule was not changed', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, recurringAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.getEditSeriesButton().click();
      POM.popup.getSaveButton().click();
      expect(dataSource.items()[0]).toMatchObject(recurringAppointment);
    });
    it('should update recurrence rule on save button click if repeat editor value was set to never', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, recurringAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.getEditSeriesButton().click();
      POM.popup.selectRepeatValue('never');
      POM.popup.getSaveButton().click();
      expect(dataSource.items()[0]).toMatchObject(Object.assign({}, recurringAppointment, {
        recurrenceRule: ''
      }));
    });
    it('should update appointment when data source is a custom store', async () => {
      const appointment = Object.assign({}, commonAppointment, {
        id: 0
      });
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: {
          store: {
            type: 'array',
            key: 'id',
            data: [appointment]
          }
        }
      }));
      scheduler.showAppointmentPopup(appointment);
      POM.popup.setInputValue('subjectEditor', 'Updated subject');
      scheduler.hideAppointmentPopup(true);
      const items = scheduler.getDataSource().items();
      expect(items).toHaveLength(1);
      expect(items[0]).toMatchObject(Object.assign({}, appointment, {
        text: 'Updated subject'
      }));
    });
    it('should create appointment when data source is a custom store', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: {
          store: {
            type: 'array',
            key: 'id',
            data: []
          }
        }
      }));
      scheduler.showAppointmentPopup();
      POM.popup.setInputValue('subjectEditor', 'New subject');
      POM.popup.setInputValue('startDateEditor', new Date(2017, 4, 25, 9, 0));
      POM.popup.setInputValue('startTimeEditor', new Date(2017, 4, 25, 9, 0));
      POM.popup.setInputValue('endDateEditor', new Date(2017, 4, 25, 10, 0));
      POM.popup.setInputValue('endTimeEditor', new Date(2017, 4, 25, 10, 0));
      POM.popup.setInputValue('descriptionEditor', 'New appointment description');
      scheduler.hideAppointmentPopup(true);
      const items = scheduler.getDataSource().items();
      expect(items).toHaveLength(1);
      expect(items[0]).toMatchObject({
        text: 'New subject',
        startDate: new Date(2017, 4, 25, 9, 0),
        endDate: new Date(2017, 4, 25, 10, 0),
        description: 'New appointment description'
      });
    });
    it('should update resource value on save button click', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [{
          text: 'Resource test app',
          startDate: new Date(2017, 4, 9, 9, 30),
          endDate: new Date(2017, 4, 9, 11),
          roomId: 1
        }],
        resources: [{
          fieldExpr: 'roomId',
          dataSource: [{
            text: 'Room 1',
            id: 1,
            color: '#00af2c'
          }, {
            text: 'Room 2',
            id: 2,
            color: '#56ca85'
          }, {
            text: 'Room 3',
            id: 3,
            color: '#8ecd3c'
          }]
        }]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.setInputValue('roomId', 2);
      POM.popup.getSaveButton().click();
      expect(dataSource.items()[0].roomId).toBe(2);
    });
    it('should create separate appointment when saving single appointment from series', async () => {
      const appointment = {
        text: 'recurring-app',
        startDate: '2017-05-01T09:30:00.000Z',
        endDate: '2017-05-01T11:00:00.000Z',
        recurrenceRule: 'FREQ=DAILY;COUNT=5'
      };
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, appointment)]
      }));
      const dataSource = scheduler.getDataSource();
      POM.openPopupByDblClick('recurring-app');
      POM.popup.getEditAppointmentButton().click();
      POM.popup.setInputValue('subjectEditor', 'single appointment');
      scheduler.hideAppointmentPopup(true);
      expect(dataSource.items()).toHaveLength(2);
      expect(dataSource.items()[0]).toEqual(Object.assign({}, appointment, {
        recurrenceException: '20170501T093000Z'
      }));
      expect(dataSource.items()[1]).toEqual(Object.assign({}, appointment, {
        text: 'single appointment',
        recurrenceRule: '',
        allDay: false
      }));
    });
  });
  describe('Validation', () => {
    it.each(['startDateEditor', 'startTimeEditor', 'endDateEditor', 'endTimeEditor'])('should not close popup on save button click when %s is empty', async editorName => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment));
      POM.popup.setInputValue(editorName, null);
      POM.popup.getSaveButton().click();
      expect(POM.isPopupVisible()).toBe(true);
    });
    it.each(['startTimeEditor', 'endDateEditor', 'endTimeEditor'])('should not close popup on save button click in recurrence form when %s editor is empty', async editorName => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment));
      POM.popup.setInputValue(editorName, null);
      POM.popup.selectRepeatValue('daily');
      POM.popup.getSaveButton().click();
      expect(POM.isPopupVisible()).toBe(true);
    });
    it('should close popup on save button click in recurrence form when startEditor editor is empty', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment));
      POM.popup.setInputValue('startDateEditor', null);
      POM.popup.selectRepeatValue('daily');
      expect(POM.popup.getInputValue('recurrenceStartDateEditor')).toBe('5/9/2017');
      POM.popup.getSaveButton().click();
      expect(POM.isPopupVisible()).toBe(false);
    });
  });
  describe('State', () => {
    it('should have empty description, subject and timezone inputs when opening second common appointment', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: true,
          allowTimeZoneEditing: true
        }
      }));
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment));
      POM.popup.setInputValue('descriptionEditor', 'temp');
      POM.popup.setInputValue('startDateTimeZoneEditor', 'America/Los_Angeles');
      POM.popup.setInputValue('endDateTimeZoneEditor', 'America/Anchorage');
      POM.popup.getSaveButton().click();
      scheduler.showAppointmentPopup();
      expect(POM.popup.getInputValue('subjectEditor')).toBe('');
      expect(POM.popup.getInputValue('descriptionEditor')).toBe('');
      expect(POM.popup.getInputValue('startDateTimeZoneEditor')).toBe('');
      expect(POM.popup.getInputValue('endDateTimeZoneEditor')).toBe('');
    });
    it('should have correct form data when opening second appointment', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.form.option('formData')).toMatchObject(Object.assign({}, commonAppointment));
      POM.popup.getCancelButton().click();
      scheduler.showAppointmentPopup(allDayAppointment);
      expect(POM.popup.form.option('formData')).toMatchObject(Object.assign({}, allDayAppointment));
    });
    it('should have empty resource editor value when opening second appointment', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        resources: [{
          fieldExpr: 'roomId',
          dataSource: [{
            text: 'Room 1',
            id: 1,
            color: '#00af2c'
          }, {
            text: 'Room 2',
            id: 2,
            color: '#56ca85'
          }, {
            text: 'Room 3',
            id: 3,
            color: '#8ecd3c'
          }]
        }]
      }));
      scheduler.showAppointmentPopup({
        text: 'Resource test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11),
        roomId: 1
      });
      POM.popup.setInputValue('roomId', 2);
      scheduler.hideAppointmentPopup(true);
      scheduler.showAppointmentPopup();
      expect(POM.popup.getInputValue('roomId')).toBe('');
    });
    it('should have correct repeat editor value when opening recurring appointment after common appointment', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment));
      POM.popup.getSaveButton().click();
      scheduler.showAppointmentPopup(Object.assign({}, recurringAppointment));
      POM.popup.getEditSeriesButton().click();
      expect(POM.popup.getInputValue('repeatEditor')).toBe('Daily');
    });
    it('should have correct editor values when opening for empty date cell - 1', async () => {
      const {
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        currentView: 'week'
      }));
      POM.dblClickDateTableCell(0, 0);
      expect(POM.popup.getInputValue('subjectEditor')).toBe('');
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/22/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toBe('9:00 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/22/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toBe('9:30 AM');
      expect(POM.popup.getInputValue('allDayEditor')).toBe('false');
      expect(POM.popup.getInputValue('descriptionEditor')).toBe('');
    });
    it('should have correct editor values when opening for empty date cell - 2', async () => {
      const {
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        currentView: 'week'
      }));
      POM.dblClickDateTableCell(1, 1);
      expect(POM.popup.getInputValue('subjectEditor')).toBe('');
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/23/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toBe('9:30 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/23/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toBe('10:00 AM');
      expect(POM.popup.getInputValue('allDayEditor')).toBe('false');
      expect(POM.popup.getInputValue('descriptionEditor')).toBe('');
    });
    it('should have correct editor values when opening for empty all day cell', async () => {
      const {
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        currentView: 'week'
      }));
      POM.dblClickAllDayTableCell(1);
      expect(POM.popup.getInputValue('subjectEditor')).toBe('');
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/23/2017');
      expect(POM.popup.isInputVisible('startTimeEditor')).toBe(false);
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/23/2017');
      expect(POM.popup.isInputVisible('endTimeEditor')).toBe(false);
      expect(POM.popup.getInputValue('allDayEditor')).toBe('true');
      expect(POM.popup.getInputValue('descriptionEditor')).toBe('');
    });
  });
  describe('Readonly state', () => {
    it('form should be readonly when editing.allowUpdating is false', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: false
        }
      }));
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment));
      expect(POM.popup.form.option('readOnly')).toBe(true);
    });
    it('form should not be readonly when editing.allowUpdating is false and adding a new appointment', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: false,
          allowAdding: true
        }
      }));
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment), true);
      expect(POM.popup.form.option('readOnly')).toBe(false);
    });
    it('form should be readonly after adding new appointment if editing.allowUpdating is false', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: false,
          allowAdding: true
        }
      }));
      const dataSource = scheduler.getDataSource();
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment), true);
      scheduler.hideAppointmentPopup(true);
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      expect(POM.popup.form.option('readOnly')).toBe(true);
    });
    it('form should be readonly when appointment is disabled', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, disabledAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      expect(POM.popup.form.option('readOnly')).toBe(true);
    });
  });
  describe('startDate/endDate editors behavior', () => {
    it.each([['startDateEditor', 'startTimeEditor'], ['endDateEditor', 'endTimeEditor'], ['startTimeEditor', 'startDateEditor'], ['endTimeEditor', 'endDateEditor']])('when %s value is set to null, %s value should not be null', async (dateEditorName, timeEditorName) => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(Object.assign({}, commonAppointment));
      POM.popup.setInputValue(dateEditorName, null);
      expect(POM.popup.getInputValue(timeEditorName)).not.toBeNull();
    });
    it('should update endDate when startDate is changed to a value greater than endDate', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('startDateEditor', new Date(2017, 4, 10));
      expect(POM.popup.getInputValue('startTimeEditor')).toEqual('9:30 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toEqual('5/10/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toEqual('11:00 AM');
    });
    it('should update endDate when startTime is changed to a value greater than endDate time', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('startTimeEditor', new Date(2017, 4, 9, 12));
      expect(POM.popup.getInputValue('startDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('endDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toEqual('1:30 PM');
    });
    it('should update startDate when endDate is changed to a value less than startDate', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('endDateEditor', new Date(2017, 4, 8));
      expect(POM.popup.getInputValue('startDateEditor')).toEqual('5/8/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toEqual('9:30 AM');
      expect(POM.popup.getInputValue('endTimeEditor')).toEqual('11:00 AM');
    });
    it('should update startDate when endTime is changed to a value less than startDate time', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('endTimeEditor', new Date(2017, 4, 9, 9, 0));
      expect(POM.popup.getInputValue('startDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toEqual('7:30 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toEqual('5/9/2017');
    });
    it('should not update endDate when startDate is changed to a value less than endDate', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('startDateEditor', new Date(2017, 4, 8));
      expect(POM.popup.getInputValue('startTimeEditor')).toEqual('9:30 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toEqual('11:00 AM');
    });
    it('should not update endDate when startTime is changed to a value less than endDate time', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('startTimeEditor', new Date(2017, 4, 9, 10, 0));
      expect(POM.popup.getInputValue('startDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('endDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toEqual('11:00 AM');
    });
    it('should not update startDate when endDate is changed to a value greater than startDate', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('endDateEditor', new Date(2017, 4, 10));
      expect(POM.popup.getInputValue('startDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toEqual('9:30 AM');
      expect(POM.popup.getInputValue('endTimeEditor')).toEqual('11:00 AM');
    });
    it('should not update startDate when endTime is changed to a value greater than startDate time', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup({
        text: 'test app',
        startDate: new Date(2017, 4, 9, 9, 30),
        endDate: new Date(2017, 4, 9, 11)
      });
      POM.popup.setInputValue('endTimeEditor', new Date(2017, 4, 9, 12));
      expect(POM.popup.getInputValue('startDateEditor')).toEqual('5/9/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toEqual('9:30 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toEqual('5/9/2017');
    });
  });
  describe.each([['Field expressions', 'customField'], ['Nested field expressions', 'nested.customField']])('%s', exprValue => {
    it.each([['textExpr', 'subjectEditor', 'qwerty'], ['allDayExpr', 'allDayEditor', true], ['startDateTimeZoneExpr', 'startDateTimeZoneEditor', 'Pacific/Midway'], ['endDateTimeZoneExpr', 'endDateTimeZoneEditor', 'Pacific/Midway'], ['descriptionExpr', 'descriptionEditor', 'qwerty']])('should update correct field if %s is defined', async (fieldExpr, editorName, value) => {
      const defaultField = DEFAULT_SCHEDULER_OPTIONS[fieldExpr];
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: true,
          allowTimeZoneEditing: true
        },
        [fieldExpr]: exprValue
      }));
      scheduler.showAppointmentPopup();
      POM.popup.setInputValue(editorName, value);
      scheduler.hideAppointmentPopup(true);
      const customFieldValue = scheduler.option(`dataSource[0].${exprValue}`);
      const defaultFieldValue = scheduler.option(`dataSource[0].${defaultField}`);
      expect(customFieldValue).toBe(value);
      expect(defaultFieldValue).toBeUndefined();
    });
    it.each([['startDateExpr', 'startDateEditor', 'startTimeEditor'], ['endDateExpr', 'endDateEditor', 'endTimeEditor']])('should update correct field if %s is defined', async (fieldExpr, dateEditorName, timeEditorName) => {
      const value = new Date(2017, 4, 9, 9, 30);
      const defaultField = DEFAULT_SCHEDULER_OPTIONS[fieldExpr];
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: true,
          allowTimeZoneEditing: true
        },
        [fieldExpr]: exprValue
      }));
      scheduler.showAppointmentPopup();
      POM.popup.setInputValue(dateEditorName, value);
      POM.popup.setInputValue(timeEditorName, value);
      scheduler.hideAppointmentPopup(true);
      const customFieldValue = scheduler.option(`dataSource[0].${exprValue}`);
      const defaultFieldValue = scheduler.option(`dataSource[0].${defaultField}`);
      expect(customFieldValue).toEqual(new Date(value));
      expect(defaultFieldValue).toBeUndefined();
    });
    it('should update correct field if recurrenceRuleExpr is defined', async () => {
      const fieldExpr = 'recurrenceRuleExpr';
      const defaultField = DEFAULT_SCHEDULER_OPTIONS[fieldExpr];
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: true,
          allowTimeZoneEditing: true
        },
        [fieldExpr]: exprValue
      }));
      scheduler.showAppointmentPopup();
      POM.popup.selectRepeatValue('daily');
      scheduler.hideAppointmentPopup(true);
      const customFieldValue = scheduler.option(`dataSource[0].${exprValue}`);
      const defaultFieldValue = scheduler.option(`dataSource[0].${defaultField}`);
      expect(customFieldValue).toBe('FREQ=DAILY');
      expect(defaultFieldValue).toBeUndefined();
    });
    it('should update correct resource field if fieldExpr for resource is defined', async () => {
      const defaultField = 'roomId';
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: true,
          allowTimeZoneEditing: true
        },
        resources: [{
          fieldExpr: exprValue,
          allowMultiple: false,
          dataSource: [{
            text: 'Room 1',
            id: 1,
            color: '#00af2c'
          }, {
            text: 'Room 2',
            id: 2,
            color: '#56ca85'
          }, {
            text: 'Room 3',
            id: 3,
            color: '#8ecd3c'
          }]
        }]
      }));
      scheduler.showAppointmentPopup();
      POM.popup.setInputValue(exprValue, 2);
      scheduler.hideAppointmentPopup(true);
      const customFieldValue = scheduler.option(`dataSource[0].${exprValue}`);
      const defaultFieldValue = scheduler.option(`dataSource[0].${defaultField}`);
      expect(customFieldValue).toBe(2);
      expect(defaultFieldValue).toBeUndefined();
    });
  });
  describe('allDay switch', () => {
    it('should be turned on when opening allDay appointment', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(allDayAppointment);
      expect(POM.popup.getInputValue('allDayEditor')).toBe('true');
    });
    it('should be turned off when opening non-allDay appointment', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.getInputValue('allDayEditor')).toBe('false');
    });
    it('should hide time editors when switched on', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.startDate).toBeDefined();
      expect(POM.popup.startTime).toBeDefined();
      expect(POM.popup.endDate).toBeDefined();
      expect(POM.popup.endTime).toBeDefined();
      POM.popup.getSwitchByName('allDay').click();
      expect(POM.popup.startDate).toBeDefined();
      expect(POM.popup.startTime).toBeNull();
      expect(POM.popup.endDate).toBeDefined();
      expect(POM.popup.endTime).toBeNull();
    });
    it('should show time editors when switched off', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(allDayAppointment);
      expect(POM.popup.startDate).toBeDefined();
      expect(POM.popup.startTime).toBeNull();
      expect(POM.popup.endDate).toBeDefined();
      expect(POM.popup.endTime).toBeNull();
      POM.popup.getSwitchByName('allDay').click();
      expect(POM.popup.startDate).toBeDefined();
      expect(POM.popup.startTime).toBeDefined();
      expect(POM.popup.endDate).toBeDefined();
      expect(POM.popup.endTime).toBeDefined();
    });
    it('should set correct dates when switching on then off in day view', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        currentView: 'day'
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      POM.popup.getSwitchByName('allDay').click();
      POM.popup.getSwitchByName('allDay').click();
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/9/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toBe('9:00 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/9/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toBe('9:30 AM');
    });
    it('should set correct dates when switching off then on in day view', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        currentView: 'day'
      }));
      scheduler.showAppointmentPopup(allDayAppointment);
      POM.popup.getSwitchByName('allDay').click();
      POM.popup.getSwitchByName('allDay').click();
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/1/2017');
      expect(POM.popup.isInputVisible('startTimeEditor')).toBeFalsy();
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/1/2017');
      expect(POM.popup.isInputVisible('endTimeEditor')).toBeFalsy();
    });
    it('should set correct dates when switching on then off in month view', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        currentView: 'month'
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      POM.popup.getSwitchByName('allDay').click();
      POM.popup.getSwitchByName('allDay').click();
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/9/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toBe('9:00 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/10/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toBe('12:00 AM');
    });
    it('should set correct dates when switching off then on in month view', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        currentView: 'month'
      }));
      scheduler.showAppointmentPopup(allDayAppointment);
      POM.popup.getSwitchByName('allDay').click();
      POM.popup.getSwitchByName('allDay').click();
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/1/2017');
      expect(POM.popup.isInputVisible('startTimeEditor')).toBeFalsy();
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/1/2017');
      expect(POM.popup.isInputVisible('endTimeEditor')).toBeFalsy();
    });
    it('should show correct dates after switching off allDay and canceling changes (T832711)', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(undefined);
      scheduler.showAppointmentPopup(allDayAppointment);
      POM.popup.getSwitchByName('allDay').click();
      POM.popup.getCancelButton().click();
      scheduler.showAppointmentPopup(allDayAppointment);
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/1/2017');
      expect(POM.popup.isInputVisible('startTimeEditor')).toBeFalsy();
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/1/2017');
      expect(POM.popup.isInputVisible('endTimeEditor')).toBeFalsy();
    });
    it('should show correct dates after switching on allDay and canceling changes (T832711)', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      POM.popup.getSwitchByName('allDay').click();
      POM.popup.getCancelButton().click();
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.getInputValue('startDateEditor')).toBe('5/9/2017');
      expect(POM.popup.getInputValue('startTimeEditor')).toBe('9:30 AM');
      expect(POM.popup.getInputValue('endDateEditor')).toBe('5/9/2017');
      expect(POM.popup.getInputValue('endTimeEditor')).toBe('11:00 AM');
    });
  });
  describe('Timezone Editors', () => {
    it('should have correct timezone editors values', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: true,
          allowTimeZoneEditing: true
        }
      }));
      scheduler.showAppointmentPopup({
        text: 'Watercolor Landscape',
        startDate: new Date('2020-06-01T17:30:00.000Z'),
        endDate: new Date('2020-06-01T19:00:00.000Z'),
        startDateTimeZone: 'Etc/GMT+10',
        endDateTimeZone: 'US/Alaska'
      });
      expect(POM.popup.getInputValue('startDateTimeZoneEditor')).toBe('Etc/GMT+10');
      expect(POM.popup.getInputValue('endDateTimeZoneEditor')).toBe('US/Alaska');
    });
    it('should be shown when editing.allowTimeZoneEditing is true', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowTimeZoneEditing: true
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.startTimeZone).toBeDefined();
      expect(POM.popup.endTimeZone).toBeDefined();
    });
    it('should be hidden when editing.allowTimeZoneEditing is false', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowTimeZoneEditing: false
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.startTimeZone).toBeNull();
      expect(POM.popup.endTimeZone).toBeNull();
    });
    it('change of startTimeZone value should trigger endTimeZone value change', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowTimeZoneEditing: true
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      // @ts-expect-error
      const startTimeZoneSelectBox = $(POM.popup.startTimeZone).dxSelectBox('instance');
      // @ts-expect-error
      const endTimeZoneSelectBox = $(POM.popup.endTimeZone).dxSelectBox('instance');
      startTimeZoneSelectBox.option('value', 'America/Los_Angeles');
      expect(startTimeZoneSelectBox.option('value')).toBe('America/Los_Angeles');
      expect(endTimeZoneSelectBox.option('value')).toBe('America/Los_Angeles');
    });
    it('change of endTimeZone value should not trigger startTimeZone value change', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowTimeZoneEditing: true
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      // @ts-expect-error
      const startTimeZoneSelectBox = $(POM.popup.startTimeZone).dxSelectBox('instance');
      // @ts-expect-error
      const endTimeZoneSelectBox = $(POM.popup.endTimeZone).dxSelectBox('instance');
      startTimeZoneSelectBox.option('value', 'America/Los_Angeles');
      endTimeZoneSelectBox.option('value', 'America/New_York');
      expect(startTimeZoneSelectBox.option('value')).toBe('America/Los_Angeles');
      expect(endTimeZoneSelectBox.option('value')).toBe('America/New_York');
    });
  });
  describe('Resources', () => {
    it('should have correct resource editor value', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [{
          text: 'Resource test app',
          startDate: new Date(2017, 4, 9, 9, 30),
          endDate: new Date(2017, 4, 9, 11),
          roomId: 2
        }],
        resources: [{
          fieldExpr: 'roomId',
          dataSource: [{
            text: 'Room 1',
            id: 1,
            color: '#00af2c'
          }, {
            text: 'Room 2',
            id: 2,
            color: '#56ca85'
          }, {
            text: 'Room 3',
            id: 3,
            color: '#8ecd3c'
          }]
        }]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      expect(POM.popup.getInputValue('roomId')).toBe('Room 2');
    });
    it('should create resourceEditorsGroup when resources have no custom icons', async () => {
      var _mainGroup$items, _resourcesGroup$items;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [{
          text: 'Resource test app',
          startDate: new Date(2017, 4, 9, 9, 30),
          endDate: new Date(2017, 4, 9, 11),
          roomId: 1,
          ownerId: 2
        }],
        resources: [{
          fieldExpr: 'roomId',
          dataSource: [{
            text: 'Room 1',
            id: 1
          }, {
            text: 'Room 2',
            id: 2
          }]
        }, {
          fieldExpr: 'ownerId',
          dataSource: [{
            text: 'Owner 1',
            id: 1
          }, {
            text: 'Owner 2',
            id: 2
          }]
        }]
      }));
      const dataSource = scheduler.getDataSource();
      const appointment = dataSource.items()[0];
      scheduler.showAppointmentPopup(appointment);
      const formItems = POM.popup.form.option('items');
      const mainGroup = formItems.find(item => item.name === 'mainGroup');
      const resourcesGroup = mainGroup === null || mainGroup === void 0 || (_mainGroup$items = mainGroup.items) === null || _mainGroup$items === void 0 ? void 0 : _mainGroup$items.find(item => item.name === 'resourcesGroup');
      expect(resourcesGroup).toBeDefined();
      expect(resourcesGroup === null || resourcesGroup === void 0 || (_resourcesGroup$items = resourcesGroup.items) === null || _resourcesGroup$items === void 0 ? void 0 : _resourcesGroup$items.length).toBe(2);
      expect(resourcesGroup === null || resourcesGroup === void 0 ? void 0 : resourcesGroup.items).toEqual(expect.arrayContaining([expect.objectContaining({
        name: 'resourcesGroupContent',
        itemType: 'group',
        items: expect.arrayContaining([expect.objectContaining({
          name: 'roomId'
        }), expect.objectContaining({
          name: 'ownerId'
        })])
      })]));
    });
    it('should create individual resource groups when resources have custom icons', async () => {
      var _mainGroup$items2, _resourcesGroup$items2;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [{
          text: 'Resource test app',
          startDate: new Date(2017, 4, 9, 9, 30),
          endDate: new Date(2017, 4, 9, 11),
          roomId: 1,
          ownerId: 2
        }],
        resources: [{
          fieldExpr: 'roomId',
          icon: 'home',
          dataSource: [{
            text: 'Room 1',
            id: 1
          }, {
            text: 'Room 2',
            id: 2
          }]
        }, {
          fieldExpr: 'ownerId',
          icon: 'user',
          dataSource: [{
            text: 'Owner 1',
            id: 1
          }, {
            text: 'Owner 2',
            id: 2
          }]
        }]
      }));
      const dataSource = scheduler.getDataSource();
      const appointment = dataSource.items()[0];
      scheduler.showAppointmentPopup(appointment);
      const formItems = POM.popup.form.option('items');
      const mainGroup = formItems.find(item => item.name === 'mainGroup');
      const resourcesGroup = mainGroup === null || mainGroup === void 0 || (_mainGroup$items2 = mainGroup.items) === null || _mainGroup$items2 === void 0 ? void 0 : _mainGroup$items2.find(item => item.name === 'resourcesGroup');
      expect(resourcesGroup).toBeDefined();
      expect(resourcesGroup === null || resourcesGroup === void 0 || (_resourcesGroup$items2 = resourcesGroup.items) === null || _resourcesGroup$items2 === void 0 ? void 0 : _resourcesGroup$items2.length).toBe(2);
      expect(resourcesGroup === null || resourcesGroup === void 0 ? void 0 : resourcesGroup.items).toEqual(expect.arrayContaining([expect.objectContaining({
        name: 'roomIdGroup',
        itemType: 'group',
        items: expect.arrayContaining([expect.objectContaining({
          name: 'roomId'
        }), expect.objectContaining({
          name: 'roomIdIcon'
        })])
      }), expect.objectContaining({
        name: 'ownerIdGroup',
        itemType: 'group',
        items: expect.arrayContaining([expect.objectContaining({
          name: 'ownerId'
        }), expect.objectContaining({
          name: 'ownerIdIcon'
        })])
      })]));
    });
    it('should create dxTagBox for resource with multiple selection', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [{
          text: 'Resource test app',
          startDate: new Date(2017, 4, 9, 9, 30),
          endDate: new Date(2017, 4, 9, 11),
          ownerId: [1, 2]
        }],
        resources: [{
          fieldExpr: 'ownerId',
          allowMultiple: true,
          dataSource: [{
            text: 'Owner 1',
            id: 1
          }, {
            text: 'Owner 2',
            id: 2
          }, {
            text: 'Owner 3',
            id: 3
          }]
        }]
      }));
      const dataSource = scheduler.getDataSource();
      const appointment = dataSource.items()[0];
      scheduler.showAppointmentPopup(appointment);
      const resourceEditor = POM.popup.form.getEditor('ownerId');
      expect(resourceEditor.NAME).toBe('dxTagBox');
      expect(resourceEditor.option('value')).toEqual([1, 2]);
    });
    it('should create dxSelectBox for resource with single selection', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [{
          text: 'Resource test app',
          startDate: new Date(2017, 4, 9, 9, 30),
          endDate: new Date(2017, 4, 9, 11),
          ownerId: 2
        }],
        resources: [{
          fieldExpr: 'ownerId',
          allowMultiple: false,
          dataSource: [{
            text: 'Owner 1',
            id: 1
          }, {
            text: 'Owner 2',
            id: 2
          }, {
            text: 'Owner 3',
            id: 3
          }]
        }]
      }));
      const dataSource = scheduler.getDataSource();
      const appointment = dataSource.items()[0];
      scheduler.showAppointmentPopup(appointment);
      const resourceEditor = POM.popup.form.getEditor('ownerId');
      expect(resourceEditor.NAME).toBe('dxSelectBox');
      expect(resourceEditor.option('value')).toEqual(2);
    });
    it('should load resource dataSource only once', async () => {
      const resourceDataSource = new CustomStore({
        load: () => [{
          text: 'Owner 1',
          id: 1
        }, {
          text: 'Owner 2',
          id: 2
        }, {
          text: 'Owner 3',
          id: 3
        }],
        byKey: () => {}
      });
      const loadSpy = jest.spyOn(resourceDataSource, 'load');
      const byKeySpy = jest.spyOn(resourceDataSource, 'byKey');
      const {
        scheduler
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [{
          text: 'Resource test app',
          startDate: new Date(2017, 4, 9, 9, 30),
          endDate: new Date(2017, 4, 9, 11),
          ownerId: [2]
        }],
        resources: [{
          allowMultiple: true,
          fieldExpr: 'ownerId',
          dataSource: resourceDataSource
        }]
      }));
      const dataSource = scheduler.getDataSource();
      const appointment = dataSource.items()[0];
      expect(loadSpy).toHaveBeenCalledTimes(1);
      scheduler.showAppointmentPopup(appointment);
      expect(loadSpy).toHaveBeenCalledTimes(1);
      expect(byKeySpy).toHaveBeenCalledTimes(0);
    });
  });
  describe('Recurrence Form', () => {
    it('should allow opening recurrence settings when allowUpdating is false', async () => {
      const appointment = {
        text: 'Recurrent Appointment',
        startDate: new Date(2017, 4, 1, 9, 30),
        endDate: new Date(2017, 4, 1, 11),
        recurrenceRule: 'FREQ=WEEKLY;BYDAY=MO,WE,FR;COUNT=10'
      };
      const {
        POM,
        scheduler
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: false
        }
      }));
      scheduler.showAppointmentPopup(appointment);
      expect(POM.popup.isRecurrenceGroupVisible()).toBe(false);
      POM.popup.openRecurrenceSettings();
      expect(POM.popup.isRecurrenceGroupVisible()).toBe(true);
    });
    it('should have disabled week day buttons when allowUpdating is false', async () => {
      const {
        POM,
        scheduler
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, recurringAppointment, {
          recurrenceRule: 'FREQ=WEEKLY;BYDAY=WE,TU,TH,FR,SA'
        })],
        editing: {
          allowUpdating: false
        }
      }));
      const dataSource = scheduler.getDataSource();
      const appointment = dataSource.items()[0];
      scheduler.showAppointmentPopup(appointment);
      POM.popup.openRecurrenceSettings();
      const weekDayButtons = POM.popup.recurrenceWeekDayButtons;
      expect(weekDayButtons).toBeTruthy();
      const firstButton = weekDayButtons === null || weekDayButtons === void 0 ? void 0 : weekDayButtons.querySelector('.dx-button');
      expect(firstButton).toBeTruthy();
      // @ts-expect-error
      const buttonInstance = $(firstButton).dxButton('instance');
      expect(buttonInstance === null || buttonInstance === void 0 ? void 0 : buttonInstance.option('disabled')).toBe(true);
    });
    it('should be visible after changing repeat editor\'s value', async () => {
      var _POM$popup$mainGroup, _POM$popup$recurrence, _POM$popup$mainGroup2, _POM$popup$recurrence2, _POM$popup$mainGroup3, _POM$popup$recurrence3;
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup();
      expect(POM.popup.isMainGroupVisible()).toBe(true);
      expect((_POM$popup$mainGroup = POM.popup.mainGroup) === null || _POM$popup$mainGroup === void 0 ? void 0 : _POM$popup$mainGroup.getAttribute('tabindex')).toBeNull();
      expect(POM.popup.isRecurrenceGroupVisible()).toBe(false);
      expect((_POM$popup$recurrence = POM.popup.recurrenceGroup) === null || _POM$popup$recurrence === void 0 ? void 0 : _POM$popup$recurrence.getAttribute('tabindex')).toBe('-1');
      POM.popup.selectRepeatValue('weekly');
      await new Promise(process.nextTick);
      const popupHeight = POM.popup.component.option('height');
      expect(popupHeight).toBeDefined();
      expect(typeof popupHeight).toBe('number');
      expect(POM.popup.isMainGroupVisible()).toBe(false);
      expect((_POM$popup$mainGroup2 = POM.popup.mainGroup) === null || _POM$popup$mainGroup2 === void 0 ? void 0 : _POM$popup$mainGroup2.getAttribute('tabindex')).toBe('-1');
      expect(POM.popup.isRecurrenceGroupVisible()).toBe(true);
      expect((_POM$popup$recurrence2 = POM.popup.recurrenceGroup) === null || _POM$popup$recurrence2 === void 0 ? void 0 : _POM$popup$recurrence2.getAttribute('tabindex')).toBeNull();
      POM.popup.getBackButton().click();
      expect(POM.popup.component.option('height')).toBe('auto');
      expect(POM.popup.isMainGroupVisible()).toBe(true);
      expect((_POM$popup$mainGroup3 = POM.popup.mainGroup) === null || _POM$popup$mainGroup3 === void 0 ? void 0 : _POM$popup$mainGroup3.getAttribute('tabindex')).toBeNull();
      expect(POM.popup.isRecurrenceGroupVisible()).toBe(false);
      expect((_POM$popup$recurrence3 = POM.popup.recurrenceGroup) === null || _POM$popup$recurrence3 === void 0 ? void 0 : _POM$popup$recurrence3.getAttribute('tabindex')).toBe('-1');
    });
    it('should open main form when opening recurring appointment', async () => {
      const appointment = {
        text: 'Recurrent Appointment',
        startDate: new Date(2017, 4, 1, 9, 30),
        endDate: new Date(2017, 4, 1, 11),
        recurrenceRule: 'FREQ=WEEKLY;BYDAY=MO,WE,FR;COUNT=10'
      };
      const {
        POM,
        scheduler
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(appointment);
      POM.popup.getEditSeriesButton().click();
      expect(POM.popup.isMainGroupVisible()).toBe(true);
      expect(POM.popup.isRecurrenceGroupVisible()).toBe(false);
    });
    describe('State', () => {
      it('should have correct input values for appointment with hour frequency', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=HOURLY;INTERVAL=2;COUNT=10',
          repeatEnd: 'count'
        });
        POM.popup.getEditSeriesButton().click();
        expect(POM.popup.getInputValue('repeatEditor')).toBe('Hourly');
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceStartDateEditor')).toBe('5/1/2017');
        expect(POM.popup.getInputValue('recurrenceCountEditor')).toBe('2');
        expect(POM.popup.getInputValue('recurrencePeriodEditor')).toBe('Hour(s)');
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe('10 occurrence(s)');
      });
      it('should have correct input values for appointment with daily frequency', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=DAILY;INTERVAL=2;COUNT=10',
          repeatEnd: 'count'
        });
        POM.popup.getEditSeriesButton().click();
        expect(POM.popup.getInputValue('repeatEditor')).toBe('Daily');
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceStartDateEditor')).toBe('5/1/2017');
        expect(POM.popup.getInputValue('recurrenceCountEditor')).toBe('2');
        expect(POM.popup.getInputValue('recurrencePeriodEditor')).toBe('Day(s)');
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe('10 occurrence(s)');
      });
      it('should have correct input values for appointment with week frequency', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=WEEKLY;INTERVAL=2;BYDAY=MO,WE,FR;COUNT=10',
          repeatEnd: 'count'
        });
        POM.popup.getEditSeriesButton().click();
        expect(POM.popup.getInputValue('repeatEditor')).toBe('Weekly');
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceStartDateEditor')).toBe('5/1/2017');
        expect(POM.popup.getInputValue('recurrenceCountEditor')).toBe('2');
        expect(POM.popup.getInputValue('recurrencePeriodEditor')).toBe('Week(s)');
        const expectedWeekDaysSelection = [true, false, true, false, true, false, false];
        expect(POM.popup.getWeekDaysSelection()).toEqual(expectedWeekDaysSelection);
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe('10 occurrence(s)');
      });
      it('should have correct input values for appointment with monthly frequency', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=MONTHLY;INTERVAL=2;BYMONTHDAY=1;COUNT=10',
          repeatEnd: 'count'
        });
        POM.popup.getEditSeriesButton().click();
        expect(POM.popup.getInputValue('repeatEditor')).toBe('Monthly');
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceStartDateEditor')).toBe('5/1/2017');
        expect(POM.popup.getInputValue('recurrenceCountEditor')).toBe('2');
        expect(POM.popup.getInputValue('recurrencePeriodEditor')).toBe('Month(s)');
        expect(POM.popup.getInputValue('recurrenceDayOfMonthEditor')).toBe('1');
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe('10 occurrence(s)');
      });
      it('should have correct input values for appointment with yearly frequency', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=YEARLY;INTERVAL=2;BYMONTHDAY=1;BYMONTH=5;COUNT=10',
          repeatEnd: 'count'
        });
        POM.popup.getEditSeriesButton().click();
        expect(POM.popup.getInputValue('repeatEditor')).toBe('Yearly');
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceStartDateEditor')).toBe('5/1/2017');
        expect(POM.popup.getInputValue('recurrenceCountEditor')).toBe('2');
        expect(POM.popup.getInputValue('recurrencePeriodEditor')).toBe('Year(s)');
        expect(POM.popup.getInputValue('recurrenceDayOfYearDayEditor')).toBe('1');
        expect(POM.popup.getInputValue('recurrenceDayOfYearMonthEditor')).toBe('May');
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe('10 occurrence(s)');
      });
      it('should have correct input values for appointment with no end', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=DAILY;INTERVAL=2',
          repeatEnd: 'never'
        });
        POM.popup.getEditSeriesButton().click();
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceRepeatEndEditor')).toBe('never');
      });
      it('should have correct input values for appointment with end by date', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=DAILY;INTERVAL=2;UNTIL=20170601T000000Z',
          repeatEnd: 'until'
        });
        POM.popup.getEditSeriesButton().click();
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceRepeatEndEditor')).toBe('until');
        expect(POM.popup.getInputValue('recurrenceEndUntilEditor')).toBe('6/1/2017');
      });
      it('should have correct input values for appointment with end by count', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=DAILY;INTERVAL=2;COUNT=10',
          repeatEnd: 'count'
        });
        POM.popup.getEditSeriesButton().click();
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceRepeatEndEditor')).toBe('count');
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe('10 occurrence(s)');
      });
      it('should have correct input values when opening second weekly recurring appointment', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        const appointment1 = {
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11),
          recurrenceRule: 'FREQ=WEEKLY;INTERVAL=1;BYDAY=MO,WE,FR;COUNT=5',
          repeatEnd: 'count'
        };
        const appointment2 = {
          text: 'Meeting',
          startDate: new Date(2017, 4, 2, 10, 30),
          endDate: new Date(2017, 4, 2, 11),
          recurrenceRule: 'FREQ=WEEKLY;INTERVAL=1;BYDAY=TU,TH;COUNT=5',
          repeatEnd: 'count'
        };
        scheduler.showAppointmentPopup(appointment1);
        POM.popup.getEditSeriesButton().click();
        POM.popup.openRecurrenceSettings();
        scheduler.hideAppointmentPopup();
        scheduler.showAppointmentPopup(appointment2);
        POM.popup.getEditSeriesButton().click();
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('repeatEditor')).toBe('Weekly');
        expect(POM.popup.getInputValue('recurrenceStartDateEditor')).toBe('5/2/2017');
        expect(POM.popup.getInputValue('recurrenceCountEditor')).toBe('1');
        expect(POM.popup.getInputValue('recurrencePeriodEditor')).toBe('Week(s)');
        const expectedWeekDaysSelection = [false, true, false, true, false, false, false];
        expect(POM.popup.getWeekDaysSelection()).toEqual(expectedWeekDaysSelection);
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe('5 occurrence(s)');
      });
    });
    describe('Repeat End Values Preservation', () => {
      it('should preserve count value when switching between recurrence types', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        const testCount = 15;
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11)
        });
        POM.popup.selectRepeatValue('daily');
        POM.popup.setInputValue('recurrenceRepeatEndEditor', 'count');
        POM.popup.setInputValue('recurrenceEndCountEditor', testCount);
        POM.popup.getBackButton().click();
        POM.popup.selectRepeatValue('weekly');
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceEndCountEditor')).toBe(`${testCount} occurrence(s)`);
        scheduler.hideAppointmentPopup();
      });
      it('should preserve until value when switching between recurrence types', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        const testUntilDate = new Date(2017, 5, 16);
        scheduler.showAppointmentPopup({
          text: 'Meeting',
          startDate: new Date(2017, 4, 1, 10, 30),
          endDate: new Date(2017, 4, 1, 11)
        });
        POM.popup.selectRepeatValue('daily');
        POM.popup.setInputValue('recurrenceRepeatEndEditor', 'until');
        POM.popup.setInputValue('recurrenceEndUntilEditor', testUntilDate);
        POM.popup.getBackButton().click();
        POM.popup.selectRepeatValue('weekly');
        POM.popup.openRecurrenceSettings();
        expect(POM.popup.getInputValue('recurrenceEndUntilEditor')).toBe('6/16/2017');
        scheduler.hideAppointmentPopup();
      });
    });
    describe('Repeat End Editors Disabled State', () => {
      ['never', 'until', 'count'].forEach(repeatEndValue => {
        it(`should set correct disabled state when repeatEnd is ${repeatEndValue}`, async () => {
          const {
            scheduler,
            POM
          } = await createScheduler(getDefaultConfig());
          let recurrenceRule = '';
          switch (repeatEndValue) {
            case 'count':
              recurrenceRule = 'FREQ=DAILY;COUNT=10';
              break;
            case 'until':
              recurrenceRule = 'FREQ=DAILY;UNTIL=20170615T000000Z';
              break;
            default:
              recurrenceRule = 'FREQ=DAILY';
          }
          scheduler.showAppointmentPopup({
            text: 'Meeting',
            startDate: new Date(2017, 4, 1, 10, 30),
            endDate: new Date(2017, 4, 1, 11),
            recurrenceRule
          });
          POM.popup.getEditSeriesButton().click();
          POM.popup.openRecurrenceSettings();
          const untilEditor = POM.popup.form.getEditor('recurrenceEndUntilEditor');
          const countEditor = POM.popup.form.getEditor('recurrenceEndCountEditor');
          expect(untilEditor === null || untilEditor === void 0 ? void 0 : untilEditor.option('disabled')).toBe(repeatEndValue !== 'until');
          expect(countEditor === null || countEditor === void 0 ? void 0 : countEditor.option('disabled')).toBe(repeatEndValue !== 'count');
        });
      });
    });
  });
  describe('firstDayOfWeek', () => {
    it('should apply firstDayOfWeek to week day buttons', async () => {
      const {
        POM,
        scheduler
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      POM.popup.selectRepeatValue('weekly');
      const dayButtonsMonday = $(POM.popup.recurrenceWeekDayButtons).find('.dx-button');
      expect(dayButtonsMonday.length).toBe(7);
      expect(dayButtonsMonday.eq(0).text()).toBe('M');
      expect(dayButtonsMonday.eq(6).text()).toBe('S');
      scheduler.hideAppointmentPopup();
      scheduler.option('firstDayOfWeek', 0);
      scheduler.showAppointmentPopup(commonAppointment);
      POM.popup.selectRepeatValue('weekly');
      const dayButtonsSunday = $(POM.popup.recurrenceWeekDayButtons).find('.dx-button');
      expect(dayButtonsSunday.length).toBe(7);
      expect(dayButtonsSunday.eq(0).text()).toBe('S');
      expect(dayButtonsSunday.eq(1).text()).toBe('M');
      expect(dayButtonsSunday.eq(6).text()).toBe('S');
    });
    it('should apply firstDayOfWeek to recurrence form startDate calendar', async () => {
      const {
        POM,
        scheduler
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      POM.popup.selectRepeatValue('weekly');
      const recurrenceStartDateEditor = POM.popup.form.getEditor('recurrenceStartDateEditor');
      expect(recurrenceStartDateEditor).toBeDefined();
      expect(recurrenceStartDateEditor === null || recurrenceStartDateEditor === void 0 ? void 0 : recurrenceStartDateEditor.option('calendarOptions.firstDayOfWeek')).toBe(1);
      scheduler.option('firstDayOfWeek', 0);
      scheduler.showAppointmentPopup(commonAppointment);
      POM.popup.selectRepeatValue('weekly');
      const recurrenceStartDateEditorAfter = POM.popup.form.getEditor('recurrenceStartDateEditor');
      expect(recurrenceStartDateEditorAfter).toBeDefined();
      expect(recurrenceStartDateEditorAfter === null || recurrenceStartDateEditorAfter === void 0 ? void 0 : recurrenceStartDateEditorAfter.option('calendarOptions.firstDayOfWeek')).toBe(0);
    });
    it('should apply firstDayOfWeek to startDate calendar', async () => {
      const {
        POM,
        scheduler
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      const startDateEditor = POM.popup.form.getEditor('startDateEditor');
      expect(startDateEditor).toBeDefined();
      expect(startDateEditor === null || startDateEditor === void 0 ? void 0 : startDateEditor.option('calendarOptions.firstDayOfWeek')).toBe(1);
      scheduler.option('firstDayOfWeek', 0);
      scheduler.showAppointmentPopup(commonAppointment);
      const startDateEditorAfter = POM.popup.form.getEditor('startDateEditor');
      expect(startDateEditorAfter).toBeDefined();
      expect(startDateEditorAfter === null || startDateEditorAfter === void 0 ? void 0 : startDateEditorAfter.option('calendarOptions.firstDayOfWeek')).toBe(0);
    });
    it('should apply firstDayOfWeek to endDate calendar', async () => {
      const {
        POM,
        scheduler
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      const endDateEditor = POM.popup.form.getEditor('endDateEditor');
      expect(endDateEditor).toBeDefined();
      expect(endDateEditor === null || endDateEditor === void 0 ? void 0 : endDateEditor.option('calendarOptions.firstDayOfWeek')).toBe(1);
      scheduler.option('firstDayOfWeek', 0);
      scheduler.showAppointmentPopup(commonAppointment);
      const endDateEditorAfter = POM.popup.form.getEditor('endDateEditor');
      expect(endDateEditorAfter).toBeDefined();
      expect(endDateEditorAfter === null || endDateEditorAfter === void 0 ? void 0 : endDateEditorAfter.option('calendarOptions.firstDayOfWeek')).toBe(0);
    });
  });
  describe('Icons', () => {
    describe('Subject icon', () => {
      it('has default color when appointment has no resources', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup(commonAppointment);
        const $icon = $(POM.popup.subjectIcon);
        expect($icon.css('color')).toBe('');
      });
      it('has default color when showAppointmentPopup is called without data', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        scheduler.showAppointmentPopup();
        const $icon = $(POM.popup.subjectIcon);
        expect($icon.css('color')).toBe('');
      });
      it('has resource color when appointment has resource', async () => {
        const resourceColor1 = 'rgb(255, 0, 0)';
        const resourceColor2 = 'rgb(0, 0, 255)';
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          resources: [{
            fieldExpr: 'roomId',
            dataSource: [{
              id: 1,
              text: 'Room 1',
              color: resourceColor1
            }, {
              id: 2,
              text: 'Room 2',
              color: resourceColor2
            }]
          }]
        }));
        scheduler.showAppointmentPopup(Object.assign({}, commonAppointment, {
          roomId: 1
        }));
        await new Promise(process.nextTick);
        const $icon = $(POM.popup.subjectIcon);
        expect($icon.css('color')).toBe(resourceColor1);
        POM.popup.setInputValue('roomId', 2);
        await new Promise(process.nextTick);
        expect($icon.css('color')).toBe(resourceColor2);
      });
    });
    describe('Resource icons', () => {
      it.each([{
        iconsShowMode: 'both',
        visibleMain: true,
        visibleRecurrence: true
      }, {
        iconsShowMode: 'main',
        visibleMain: true,
        visibleRecurrence: false
      }, {
        iconsShowMode: 'recurrence',
        visibleMain: false,
        visibleRecurrence: true
      }, {
        iconsShowMode: 'none',
        visibleMain: false,
        visibleRecurrence: false
      }])('should shown icons correctly when iconsShowMode is \'$iconsShowMode\'', async _ref => {
        var _POM$popup$mainGroup4, _POM$popup$recurrence4;
        let {
          iconsShowMode,
          visibleMain,
          visibleRecurrence
        } = _ref;
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          editing: {
            form: {
              iconsShowMode
            }
          }
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        const mainFormIcons = ((_POM$popup$mainGroup4 = POM.popup.mainGroup) === null || _POM$popup$mainGroup4 === void 0 ? void 0 : _POM$popup$mainGroup4.querySelectorAll(`.${CLASSES.icon}`)) ?? [];
        const recurrenceFormIcons = ((_POM$popup$recurrence4 = POM.popup.recurrenceGroup) === null || _POM$popup$recurrence4 === void 0 ? void 0 : _POM$popup$recurrence4.querySelectorAll(`.${CLASSES.icon}`)) ?? [];
        expect(mainFormIcons.length).toBe(4);
        expect(recurrenceFormIcons.length).toBe(3);
        const mainIconsCorrect = Array.from(mainFormIcons).every(icon => {
          const isVisible = !icon.classList.contains(CLASSES.hidden);
          return isVisible === visibleMain;
        });
        const recurrenceIconsCorrect = Array.from(recurrenceFormIcons).every(icon => {
          const isVisible = !icon.classList.contains(CLASSES.hidden);
          return isVisible === visibleRecurrence;
        });
        expect(mainIconsCorrect).toBe(true);
        expect(recurrenceIconsCorrect).toBe(true);
      });
    });
  });
  describe('Callbacks', () => {
    describe('OnAppointmentFormOpening', () => {
      it('should be called when showing appointment popup', async () => {
        const onAppointmentFormOpening = jest.fn();
        const {
          scheduler
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          onAppointmentFormOpening
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        const arg = onAppointmentFormOpening.mock.calls[0][0];
        expect(onAppointmentFormOpening).toHaveBeenCalledTimes(1);
        expect(arg).toHaveProperty('popup');
        expect(arg).toHaveProperty('form');
        expect(arg.appointmentData).toEqual(expect.objectContaining(Object.assign({}, commonAppointment)));
      });
      it('should correctly handle e.cancel=true', async () => {
        const {
          POM,
          scheduler
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)],
          onAppointmentFormOpening: e => {
            e.cancel = true;
          }
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        expect(POM.isPopupVisible()).toBe(false);
      });
      it('should handle e.cancel value: false', async () => {
        const {
          POM,
          scheduler
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)],
          onAppointmentFormOpening: e => {
            e.cancel = false;
          }
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        expect(POM.isPopupVisible()).toBe(true);
      });
    });
    describe('onAppointmentAdding', () => {
      it('should be called when saving new appointment', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(getDefaultConfig());
        const addAppointmentSpy = jest.spyOn(scheduler, 'addAppointment');
        scheduler.showAppointmentPopup(Object.assign({}, commonAppointment), true);
        POM.popup.getSaveButton().click();
        expect(addAppointmentSpy).toHaveBeenCalledTimes(1);
        expect(addAppointmentSpy).toHaveBeenCalledWith(expect.objectContaining(Object.assign({}, commonAppointment)));
      });
      it('should correctly handle e.cancel=true', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          onAppointmentAdding: e => {
            e.cancel = true;
          }
        }));
        scheduler.showAppointmentPopup(Object.assign({}, commonAppointment), true);
        POM.popup.getSaveButton().click();
        const dataSource = scheduler.getDataSource();
        expect(dataSource.items().length).toBe(0);
      });
      it('should correctly handle e.cancel=false', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          onAppointmentAdding: e => {
            e.cancel = false;
          }
        }));
        scheduler.showAppointmentPopup(Object.assign({}, commonAppointment), true);
        POM.popup.getSaveButton().click();
        const dataSource = scheduler.getDataSource();
        expect(dataSource.items().length).toBe(1);
        expect(dataSource.items()[0]).toMatchObject(commonAppointment);
      });
    });
    describe('onAppointmentUpdating', () => {
      it('should be called when saving appointment', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)]
        }));
        const updateAppointmentSpy = jest.spyOn(scheduler, 'updateAppointment');
        const dataSource = scheduler.getDataSource();
        const updatedItem = dataSource.items()[0];
        scheduler.showAppointmentPopup(updatedItem);
        POM.popup.setInputValue('subjectEditor', 'Updated Subject');
        POM.popup.getSaveButton().click();
        expect(updateAppointmentSpy).toHaveBeenCalledTimes(1);
        expect(updateAppointmentSpy).toHaveBeenCalledWith(updatedItem, updatedItem);
      });
      it('should correctly handle e.cancel=true (T907281)', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)],
          onAppointmentUpdating: e => {
            e.cancel = true;
          }
        }));
        const dataSource = scheduler.getDataSource();
        const updatedItem = dataSource.items()[0];
        scheduler.showAppointmentPopup(updatedItem);
        POM.popup.setInputValue('subjectEditor', 'Updated Subject');
        POM.popup.getSaveButton().click();
        expect(dataSource.items()[0]).toEqual(commonAppointment);
      });
      it('should correctly handle e.cancel=false (T907281)', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)],
          onAppointmentUpdating: e => {
            e.cancel = false;
          }
        }));
        const dataSource = scheduler.getDataSource();
        const updatedItem = dataSource.items()[0];
        scheduler.showAppointmentPopup(updatedItem);
        POM.popup.setInputValue('subjectEditor', 'New Subject');
        POM.popup.getSaveButton().click();
        expect(dataSource.items()[0]).toEqual(Object.assign({
          allDay: false,
          recurrenceRule: ''
        }, commonAppointment, {
          text: 'New Subject'
        }));
      });
    });
    describe('onAppointmentDeleting', () => {
      it('should be called when deleting appointment', async () => {
        const {
          scheduler
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)]
        }));
        const deleteAppointmentSpy = jest.spyOn(scheduler, 'deleteAppointment');
        const dataSource = scheduler.getDataSource();
        const dataItem = dataSource.items()[0];
        scheduler.deleteAppointment(dataItem);
        expect(deleteAppointmentSpy).toHaveBeenCalledTimes(1);
        expect(deleteAppointmentSpy).toHaveBeenCalledWith(dataItem);
      });
      it('should correctly handle e.cancel=true', async () => {
        const {
          scheduler
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)],
          onAppointmentDeleting: e => {
            e.cancel = true;
          }
        }));
        const dataSource = scheduler.getDataSource();
        const dataItem = dataSource.items()[0];
        scheduler.deleteAppointment(dataItem);
        expect(dataSource.items().length).toBe(1);
      });
      it('should correctly handle e.cancel=false', async () => {
        const {
          scheduler
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          dataSource: [Object.assign({}, commonAppointment)],
          onAppointmentDeleting: e => {
            e.cancel = false;
          }
        }));
        const dataSource = scheduler.getDataSource();
        const dataItem = dataSource.items()[0];
        scheduler.deleteAppointment(dataItem);
        expect(dataSource.items().length).toBe(0);
      });
    });
  });
  describe('showAppointmentPopup', () => {
    it('should open appointment popup without data', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup();
      const expectedStartDate = new Date(scheduler.option('currentDate'));
      const expectedEndDate = new Date(expectedStartDate.getTime() + scheduler.option('cellDuration') * toMilliseconds('minute'));
      expect(POM.popup.component.option('visible')).toBe(true);
      expect(POM.popup.form.option('formData')).toEqual({
        text: undefined,
        allDay: false,
        startDate: expectedStartDate,
        endDate: expectedEndDate,
        description: undefined,
        recurrenceRule: '',
        startDateTimeZone: undefined,
        endDateTimeZone: undefined
      });
    });
    it('should open appointment popup with correct data', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(getDefaultConfig());
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.component.option('visible')).toBe(true);
      expect(POM.popup.form.option('formData')).toMatchObject(Object.assign({}, commonAppointment));
    });
  });
  describe('hideAppointmentPopup', () => {
    it('should hide appointment popup without saving changes', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, commonAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.setInputValue('subjectEditor', 'New Subject');
      scheduler.hideAppointmentPopup(false);
      expect(dataSource.items()[0]).toMatchObject(commonAppointment);
    });
    it('should hide appointment popup with saving changes', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, commonAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.setInputValue('subjectEditor', 'New Subject');
      scheduler.hideAppointmentPopup(true);
      expect(dataSource.items()[0]).toMatchObject(Object.assign({}, commonAppointment, {
        text: 'New Subject'
      }));
    });
    it('should hide appointment popup with saving changes when recurrence form is opened', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        dataSource: [Object.assign({}, commonAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const item = dataSource.items()[0];
      scheduler.showAppointmentPopup(item);
      POM.popup.selectRepeatValue('weekly');
      POM.popup.setInputValue('recurrenceStartDateEditor', new Date(2024, 4, 25));
      scheduler.hideAppointmentPopup(true);
      expect(dataSource.items()[0]).toMatchObject(Object.assign({}, commonAppointment, {
        startDate: new Date(2024, 4, 25, 9, 30),
        endDate: new Date(2024, 4, 25, 11),
        recurrenceRule: 'FREQ=WEEKLY;BYDAY=TU'
      }));
    });
  });
  describe('Customization', () => {
    it('should propagate editing.form options to the form instance', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            height: 500
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formHeight = form.option('height');
      expect(formHeight).toBe(500);
    });
    it('should merge editing.form options with default form configuration', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            height: 500,
            elementAttr: {
              id: 'custom-form'
            }
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formHeight = form.option('height');
      const elementAttr = form.option('elementAttr');
      const {
        class: className,
        id
      } = elementAttr;
      expect(formHeight).toBe(500);
      expect(className).toBe('dx-scheduler-form');
      expect(id).toBe('custom-form');
    });
  });
});
describe('Appointment Popup', () => {
  beforeEach(() => {
    fx.off = true;
    setupSchedulerTestEnvironment({
      height: 600
    });
  });
  afterEach(() => {
    const $scheduler = $(document.querySelector(`.${CLASSES.scheduler}`));
    // @ts-expect-error
    $scheduler.dxScheduler('dispose');
    document.body.innerHTML = '';
    fx.off = false;
    jest.useRealTimers();
  });
  it('should open on double click on appointment', async () => {
    const {
      POM
    } = await createScheduler(Object.assign({}, getDefaultConfig(), {
      dataSource: [Object.assign({}, commonAppointment)]
    }));
    expect(POM.isPopupVisible()).toBe(false);
    POM.openPopupByDblClick('common-app');
    expect(POM.isPopupVisible()).toBe(true);
    expect(POM.popup.form.option('formData')).toMatchObject(Object.assign({}, commonAppointment));
  });
  it('should open on tooltip click', async () => {
    var _POM$getAppointment$e, _POM$getTooltipAppoin;
    const {
      POM
    } = await createScheduler(Object.assign({}, getDefaultConfig(), {
      dataSource: [Object.assign({}, commonAppointment)]
    }));
    expect(POM.isPopupVisible()).toBe(false);
    jest.useFakeTimers();
    (_POM$getAppointment$e = POM.getAppointment('common-app').element) === null || _POM$getAppointment$e === void 0 || _POM$getAppointment$e.click();
    jest.runAllTimers();
    (_POM$getTooltipAppoin = POM.getTooltipAppointment()) === null || _POM$getTooltipAppoin === void 0 || _POM$getTooltipAppoin.click();
    expect(POM.isPopupVisible()).toBe(true);
    expect(POM.popup.form.option('formData')).toMatchObject(Object.assign({}, commonAppointment));
  });
  describe('Toolbar', () => {
    describe('Popup Title', () => {
      it('should display "New Appointment" when creating new appointment', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          editing: {
            allowAdding: true
          }
        }));
        scheduler.showAppointmentPopup();
        const toolbarItems = POM.popup.component.option('toolbarItems');
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const titleItem = toolbarItems === null || toolbarItems === void 0 ? void 0 : toolbarItems.find(item => item.cssClass === 'dx-toolbar-label');
        expect(titleItem === null || titleItem === void 0 ? void 0 : titleItem.text).toBe('New Appointment');
      });
      it('should display "Edit Appointment" when editing existing appointment', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          editing: {
            allowUpdating: true
          }
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        const toolbarItems = POM.popup.component.option('toolbarItems');
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const titleItem = toolbarItems === null || toolbarItems === void 0 ? void 0 : toolbarItems.find(item => item.cssClass === 'dx-toolbar-label');
        expect(titleItem === null || titleItem === void 0 ? void 0 : titleItem.text).toBe('Edit Appointment');
      });
    });
    it.each([{
      allowUpdating: false,
      disabled: false
    }, {
      allowUpdating: false,
      disabled: true
    }, {
      allowUpdating: true,
      disabled: false
    }, {
      allowUpdating: true,
      disabled: true
    }])('Buttons visibility in main form when %p', async _ref2 => {
      let {
        allowUpdating,
        disabled
      } = _ref2;
      const shouldHaveSaveButton = allowUpdating && !disabled;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating
        }
      }));
      scheduler.showAppointmentPopup(disabled ? disabledAppointment : commonAppointment);
      const toolbarItems = POM.popup.component.option('toolbarItems') ?? [];
      expect(toolbarItems).toEqual(expect.arrayContaining([expect.objectContaining({
        shortcut: 'cancel'
      })]));
      const doneButtonMatcher = expect.arrayContaining([expect.objectContaining({
        shortcut: 'done'
      })]);
      if (shouldHaveSaveButton) {
        expect(toolbarItems).toEqual(doneButtonMatcher);
      } else {
        expect(toolbarItems).not.toEqual(doneButtonMatcher);
      }
      await POM.popup.component.hide();
    });
    it.each([{
      allowUpdating: false,
      disabled: false
    }, {
      allowUpdating: false,
      disabled: true
    }, {
      allowUpdating: true,
      disabled: false
    }, {
      allowUpdating: true,
      disabled: true
    }])('Buttons visibility in recurrence form when %p', async _ref3 => {
      let {
        allowUpdating,
        disabled
      } = _ref3;
      const shouldHaveSaveButton = allowUpdating && !disabled;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating
        },
        dataSource: [Object.assign({}, commonAppointment), Object.assign({}, disabledAppointment)]
      }));
      const dataSource = scheduler.getDataSource();
      const appointment = disabled ? dataSource.items()[1] : dataSource.items()[0];
      scheduler.showAppointmentPopup(appointment);
      scheduler.showAppointmentPopup(disabled ? disabledAppointment : commonAppointment);
      POM.popup.selectRepeatValue('daily');
      await new Promise(process.nextTick);
      const toolbarItems = POM.popup.component.option('toolbarItems') ?? [];
      expect(toolbarItems).toEqual(expect.arrayContaining([expect.objectContaining({
        shortcut: 'cancel'
      })]));
      const doneButtonMatcher = expect.arrayContaining([expect.objectContaining({
        shortcut: 'done'
      })]);
      if (shouldHaveSaveButton) {
        expect(toolbarItems).toEqual(doneButtonMatcher);
      } else {
        expect(toolbarItems).not.toEqual(doneButtonMatcher);
      }
      await POM.popup.component.hide();
    });
    it('Buttons visibility after editing option changed', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowUpdating: true,
          allowAdding: true
        }
      }));
      const getToolbarItems = () => POM.popup.component.option('toolbarItems') ?? [];
      const doneButtonMatcher = expect.arrayContaining([expect.objectContaining({
        shortcut: 'done'
      })]);
      const cancelButtonMatcher = expect.arrayContaining([expect.objectContaining({
        shortcut: 'cancel'
      })]);
      scheduler.showAppointmentPopup();
      expect(getToolbarItems()).toEqual(doneButtonMatcher);
      expect(getToolbarItems()).toEqual(cancelButtonMatcher);
      scheduler.option('editing', {
        allowUpdating: false,
        allowAdding: true
      });
      scheduler.showAppointmentPopup(commonAppointment);
      expect(getToolbarItems()).not.toEqual(doneButtonMatcher);
      expect(getToolbarItems()).toEqual(cancelButtonMatcher);
      await POM.popup.component.hide();
      scheduler.showAppointmentPopup();
      expect(getToolbarItems()).toEqual(doneButtonMatcher);
      expect(getToolbarItems()).toEqual(cancelButtonMatcher);
    });
  });
  describe('Customization', () => {
    it('should pass custom popup options from editing.popup to appointment popup', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            showTitle: true,
            title: 'Custom Appointment Form',
            maxHeight: '80%',
            dragEnabled: true
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.component.option('showTitle')).toBe(true);
      expect(POM.popup.component.option('title')).toBe('Custom Appointment Form');
      expect(POM.popup.component.option('maxHeight')).toBe('80%');
      expect(POM.popup.component.option('dragEnabled')).toBe(true);
    });
    it('should use default popup options when editing.popup is not specified', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.component.option('showTitle')).toBe(false);
      expect(POM.popup.component.option('height')).toBe('auto');
      expect(POM.popup.component.option('maxHeight')).toBe('90%');
    });
    it('should merge custom popup options with default options', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            showTitle: true,
            title: 'My Form'
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.component.option('showTitle')).toBe(true);
      expect(POM.popup.component.option('title')).toBe('My Form');
      expect(POM.popup.component.option('showCloseButton')).toBe(false);
      expect(POM.popup.component.option('enableBodyScroll')).toBe(false);
      expect(POM.popup.component.option('preventScrollEvents')).toBe(false);
    });
    it('should allow overriding default popup options', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            showCloseButton: true,
            enableBodyScroll: true
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.popup.component.option('showCloseButton')).toBe(true);
      expect(POM.popup.component.option('enableBodyScroll')).toBe(true);
    });
    it('should apply wrapperAttr configuration to popup', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            wrapperAttr: {
              id: 'test'
            }
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const wrapperAttr = POM.popup.component.option('wrapperAttr');
      expect(wrapperAttr.id).toBe('test');
      expect(wrapperAttr.class).toBeDefined();
    });
    it('should call onInitialized callback when popup is initialized', async () => {
      const onInitialized = jest.fn();
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            onInitialized
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.isPopupVisible()).toBe(true);
      expect(onInitialized).toHaveBeenCalled();
      expect(onInitialized).toHaveBeenCalledTimes(1);
    });
    it('should call onShowing callback when popup is shown', async () => {
      const onShowing = jest.fn();
      const onAppointmentFormOpening = jest.fn();
      const {
        scheduler
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            onShowing
          }
        },
        onAppointmentFormOpening
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(onShowing).toHaveBeenCalled();
      expect(onShowing).toHaveBeenCalledTimes(1);
      expect(onAppointmentFormOpening).toHaveBeenCalled();
      expect(onAppointmentFormOpening).toHaveBeenCalledTimes(1);
    });
    it('should call onHiding callback when popup is hidden', async () => {
      const onHiding = jest.fn();
      const {
        scheduler
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            onHiding
          }
        }
      }));
      const focusSpy = jest.spyOn(scheduler, 'focus');
      scheduler.showAppointmentPopup(commonAppointment);
      expect(onHiding).not.toHaveBeenCalled();
      expect(focusSpy).not.toHaveBeenCalled();
      scheduler.hideAppointmentPopup();
      expect(onHiding).toHaveBeenCalled();
      expect(onHiding).toHaveBeenCalledTimes(1);
      expect(focusSpy).toHaveBeenCalled();
      expect(focusSpy).toHaveBeenCalledTimes(1);
      focusSpy.mockRestore();
    });
    it('should preserve custom toolbarItems when popup opens', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          popup: {
            toolbarItems: [{
              toolbar: 'top',
              location: 'before',
              text: 'Custom Title',
              cssClass: 'custom-title'
            }, {
              toolbar: 'top',
              location: 'after',
              widget: 'dxButton',
              options: {
                text: 'Custom Save'
              }
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const toolbarItems = POM.popup.component.option('toolbarItems');
      expect(toolbarItems).toBeDefined();
      expect(toolbarItems).toHaveLength(2);
      expect(toolbarItems).toContainEqual(expect.objectContaining({
        cssClass: 'custom-title',
        location: 'before',
        text: 'Custom Title',
        toolbar: 'top'
      }));
      expect(toolbarItems).toContainEqual(expect.objectContaining({
        toolbar: 'top',
        location: 'after',
        widget: 'dxButton',
        options: expect.objectContaining({
          text: 'Custom Save'
        })
      }));
    });
    it('should preserve custom toolbarItems when popup is reopened', async () => {
      var _toolbarItems$;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            toolbarItems: [{
              toolbar: 'top',
              location: 'before',
              text: 'Custom Toolbar'
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      scheduler.hideAppointmentPopup();
      scheduler.showAppointmentPopup(allDayAppointment);
      const toolbarItems = POM.popup.component.option('toolbarItems');
      expect(toolbarItems).toBeDefined();
      expect(toolbarItems).toHaveLength(1);
      expect(toolbarItems === null || toolbarItems === void 0 || (_toolbarItems$ = toolbarItems[0]) === null || _toolbarItems$ === void 0 ? void 0 : _toolbarItems$.text).toBe('Custom Toolbar');
    });
    it('should open popup if popup.deferRendering is false', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          popup: {
            deferRendering: false
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      expect(POM.isPopupVisible()).toBe(true);
    });
    describe('Popup width and maxWidth options', () => {
      // Mock window width to avoid fullscreen mode
      beforeEach(() => {
        Object.defineProperty(document.documentElement, 'clientWidth', {
          value: 1280
        });
      });
      it('should use custom maxWidth when specified', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          editing: {
            allowAdding: true,
            allowUpdating: true,
            popup: {
              maxWidth: 500
            }
          }
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        const maxWidth = POM.popup.component.option('maxWidth');
        expect(maxWidth).toBe(500);
      });
      it('should use custom width as maxWidth when maxWidth is not specified', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          editing: {
            allowAdding: true,
            allowUpdating: true,
            popup: {
              width: 600
            }
          }
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        const width = POM.popup.component.option('width');
        expect(width).toBe(600);
        const maxWidth = POM.popup.component.option('maxWidth');
        expect(maxWidth).toBe(600);
      });
      it('should use maxWidth option value (not width) for maxWidth when both maxWidth and width are specified', async () => {
        const {
          scheduler,
          POM
        } = await createScheduler(Object.assign({}, getDefaultConfig(), {
          editing: {
            allowAdding: true,
            allowUpdating: true,
            popup: {
              width: 600,
              maxWidth: 500
            }
          }
        }));
        scheduler.showAppointmentPopup(commonAppointment);
        const width = POM.popup.component.option('width');
        expect(width).toBe(600);
        const maxWidth = POM.popup.component.option('maxWidth');
        expect(maxWidth).toBe(500);
      });
    });
  });
});
describe('Appointment Popup Content', () => {
  it.todo('appointmentPopup should not prevent mouse/touch events by default (T968188)');
  it.todo('showAppointmentPopup method with passed a recurrence appointment should render popup(T698732)');
  it.todo('showAppointmentPopup should render a popup only once');
  it.todo('showAppointmentPopup should work correctly after scheduler repainting');
  it.todo('changing editing should work correctly after showing popup');
  it.todo('showAppointmentPopup should render a popup form only once');
  it.todo('popup should have right height');
  it.todo('showAppointmentPopup should render a popup content only once');
  it.todo('Popup should contain editors and components with right dx-rtl classes and rtlEnabled option value');
  it.todo('Popup should contains caption textbox with right value');
  it.todo('Confirm dialog should be shown when showAppointmentPopup for recurrence appointment was called');
  it.todo('Recurrence Editor should have right freq editor value if recurrence rule was set on init');
  it.todo('Popup should contain recurrence editor with right config');
  it.todo('Recurrence editor should change value if freq editor value changed');
  it.todo('Recurrence editor should has right startDate after form items change');
  it.todo('There are no exceptions when select date on the appointment popup,if dates are undefined');
  it.todo('Validate works always before done click');
  it.todo('Load panel should not be shown if validation is fail');
  it.todo('Done button default configuration should be correct');
  it.todo('Done button custom configuration should be correct');
  it.todo('Load panel should be hidden if event validation fail');
  it.todo('Load panel should be hidden at the second appointment form opening');
});
describe('Timezone Editors', () => {
  it.todo('timeZone editors should have correct options');
  it.todo('timeZone editor should have correct display value for timezones with different offsets');
  it.todo('dataSource of timezoneEditor should be filtered');
});
describe('Customize form items', () => {
  beforeEach(() => {
    fx.off = true;
    setupSchedulerTestEnvironment({
      height: 600
    });
  });
  afterEach(() => {
    const $scheduler = $(document.querySelector(`.${CLASSES.scheduler}`));
    // @ts-expect-error
    $scheduler.dxScheduler('dispose');
    document.body.innerHTML = '';
    fx.off = false;
    jest.useRealTimers();
  });
  describe('Basic form customization', () => {
    it('should use default form when editing.items is not set', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems).toBeDefined();
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBeGreaterThan(0);
    });
    it('should show empty form when editing.items is empty array', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: []
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect((formItems === null || formItems === void 0 ? void 0 : formItems.length) ?? 0).toBe(0);
    });
    it('should show mainGroup when specified in string array', async () => {
      var _formItems$;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: ['mainGroup']
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(1);
      expect(formItems === null || formItems === void 0 || (_formItems$ = formItems[0]) === null || _formItems$ === void 0 ? void 0 : _formItems$.name).toBe('mainGroup');
    });
    it('should hide group when visible is false', async () => {
      var _formItems$2;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: [{
              name: 'mainGroup',
              visible: false
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(1);
      expect(formItems === null || formItems === void 0 || (_formItems$2 = formItems[0]) === null || _formItems$2 === void 0 ? void 0 : _formItems$2.visible).toBe(false);
    });
    it('should show group when visible is true', async () => {
      var _formItems$3;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: [{
              name: 'mainGroup',
              visible: true
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(1);
      expect(formItems === null || formItems === void 0 || (_formItems$3 = formItems[0]) === null || _formItems$3 === void 0 ? void 0 : _formItems$3.visible).toBe(true);
    });
    it('should filter children when items array is specified', async () => {
      var _mainGroup$items3, _mainGroup$items4;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: [{
              name: 'mainGroup',
              visible: true,
              items: ['subjectGroup']
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      const mainGroup = formItems === null || formItems === void 0 ? void 0 : formItems[0];
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(1);
      expect(mainGroup === null || mainGroup === void 0 || (_mainGroup$items3 = mainGroup.items) === null || _mainGroup$items3 === void 0 ? void 0 : _mainGroup$items3.length).toBe(1);
      expect(mainGroup === null || mainGroup === void 0 || (_mainGroup$items4 = mainGroup.items) === null || _mainGroup$items4 === void 0 || (_mainGroup$items4 = _mainGroup$items4[0]) === null || _mainGroup$items4 === void 0 ? void 0 : _mainGroup$items4.name).toBe('subjectGroup');
    });
    it('should handle non-existent groups gracefully', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: ['nonExistentGroup']
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect((formItems === null || formItems === void 0 ? void 0 : formItems.length) ?? 0).toBe(1);
    });
    it('should call custom onContentReady and onInitialized and preserving default', async () => {
      const onContentReady = jest.fn();
      const onInitialized = jest.fn();
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          form: {
            onContentReady,
            onInitialized
          }
        }
      }));
      scheduler.showAppointmentPopup();
      const recurrenceGroup = $(POM.popup.recurrenceGroup);
      POM.popup.selectRepeatValue('weekly');
      await new Promise(process.nextTick);
      const mainGroup = $(POM.popup.mainGroup);
      expect(mainGroup.hasClass(CLASSES.mainGroupHidden)).toBe(true);
      expect(recurrenceGroup.hasClass(CLASSES.recurrenceGroupHidden)).toBe(false);
      expect(onContentReady).toHaveBeenCalled();
      expect(onInitialized).toHaveBeenCalled();
    });
  });
  it('should call custom onContentReady and onInitialized and preserving default', async () => {
    const onContentReady = jest.fn();
    const onInitialized = jest.fn();
    const {
      scheduler,
      POM
    } = await createScheduler(Object.assign({}, getDefaultConfig(), {
      editing: {
        form: {
          onContentReady,
          onInitialized
        }
      }
    }));
    scheduler.showAppointmentPopup();
    POM.popup.selectRepeatValue('weekly');
    await new Promise(process.nextTick);
    expect(POM.popup.isMainGroupVisible()).toBe(false);
    expect(POM.popup.isRecurrenceGroupVisible()).toBe(true);
    expect(onContentReady).toHaveBeenCalled();
    expect(onInitialized).toHaveBeenCalled();
  });
  describe('Form customization with editing.items', () => {
    it('should handle empty items array', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: []
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(0);
    });
    it('should handle string array configuration', async () => {
      var _formItems$4;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: ['mainGroup']
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(1);
      expect(formItems === null || formItems === void 0 || (_formItems$4 = formItems[0]) === null || _formItems$4 === void 0 ? void 0 : _formItems$4.name).toBe('mainGroup');
    });
    it('should handle object configuration with visible false', async () => {
      var _formItems$5;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: [{
              name: 'mainGroup',
              visible: false
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(1);
      expect(formItems === null || formItems === void 0 || (_formItems$5 = formItems[0]) === null || _formItems$5 === void 0 ? void 0 : _formItems$5.visible).toBe(false);
    });
    it('should handle object configuration with custom items', async () => {
      var _mainGroup$items5, _mainGroup$items6, _mainGroup$items7;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: [{
              name: 'mainGroup',
              items: ['subjectGroup', 'dateGroup']
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      const mainGroup = formItems === null || formItems === void 0 ? void 0 : formItems[0];
      expect(mainGroup === null || mainGroup === void 0 || (_mainGroup$items5 = mainGroup.items) === null || _mainGroup$items5 === void 0 ? void 0 : _mainGroup$items5.length).toBe(2);
      expect(mainGroup === null || mainGroup === void 0 || (_mainGroup$items6 = mainGroup.items) === null || _mainGroup$items6 === void 0 || (_mainGroup$items6 = _mainGroup$items6[0]) === null || _mainGroup$items6 === void 0 ? void 0 : _mainGroup$items6.name).toBe('subjectGroup');
      expect(mainGroup === null || mainGroup === void 0 || (_mainGroup$items7 = mainGroup.items) === null || _mainGroup$items7 === void 0 || (_mainGroup$items7 = _mainGroup$items7[1]) === null || _mainGroup$items7 === void 0 ? void 0 : _mainGroup$items7.name).toBe('dateGroup');
    });
    it('should handle non-existent group names', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: ['nonExistentGroup']
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(1);
    });
    it('should handle undefined items', async () => {
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: undefined
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBeGreaterThan(0);
    });
    it('should handle mixed configurations', async () => {
      var _formItems$6, _formItems$7, _formItems$8;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: ['mainGroup', {
              name: 'mainGroup',
              visible: false
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      expect(formItems === null || formItems === void 0 ? void 0 : formItems.length).toBe(2);
      expect(formItems === null || formItems === void 0 || (_formItems$6 = formItems[0]) === null || _formItems$6 === void 0 ? void 0 : _formItems$6.name).toBe('mainGroup');
      expect(formItems === null || formItems === void 0 || (_formItems$7 = formItems[1]) === null || _formItems$7 === void 0 ? void 0 : _formItems$7.name).toBe('mainGroup');
      expect(formItems === null || formItems === void 0 || (_formItems$8 = formItems[1]) === null || _formItems$8 === void 0 ? void 0 : _formItems$8.visible).toBe(false);
    });
    it('should handle empty items array in object config', async () => {
      var _mainGroup$items8;
      const {
        scheduler,
        POM
      } = await createScheduler(Object.assign({}, getDefaultConfig(), {
        editing: {
          allowAdding: true,
          allowUpdating: true,
          form: {
            items: [{
              name: 'mainGroup',
              items: []
            }]
          }
        }
      }));
      scheduler.showAppointmentPopup(commonAppointment);
      const {
        form
      } = POM.popup;
      const formItems = form.option('items');
      const mainGroup = formItems === null || formItems === void 0 ? void 0 : formItems[0];
      expect(mainGroup === null || mainGroup === void 0 || (_mainGroup$items8 = mainGroup.items) === null || _mainGroup$items8 === void 0 ? void 0 : _mainGroup$items8.length).toBe(0);
    });
  });
});
