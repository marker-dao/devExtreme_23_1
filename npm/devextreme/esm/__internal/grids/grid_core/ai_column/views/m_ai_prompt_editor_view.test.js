/**
* DevExtreme (esm/__internal/grids/grid_core/ai_column/views/m_ai_prompt_editor_view.test.js)
* Version: 26.1.0
* Build date: Tue Jan 13 2026
*
* Copyright (c) 2012 - 2026 Developer Express Inc. ALL RIGHTS RESERVED
* Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
*/
/* eslint-disable @typescript-eslint/no-explicit-any */
import { afterEach, beforeEach, describe, expect, it, jest } from '@jest/globals';
import fx from '../../../../../common/core/animation/fx';
import $ from '../../../../../core/renderer';
import Callbacks from '../../../../../core/utils/callbacks';
import wrapInstanceWithMocks from '../../../../grids/grid_core/__tests__/__mock__/helpers/wrapInstance';
import { AIPromptEditorModel } from '../../../../grids/grid_core/__tests__/__mock__/model/ai_prompt_editor';
import { AIPromptEditor } from '../../ai_prompt_editor/ai_prompt_editor';
import { AIPromptEditorView } from './m_ai_prompt_editor_view';
jest.mock('../../ai_prompt_editor/ai_prompt_editor', () => {
  const original = jest.requireActual('../../ai_prompt_editor/ai_prompt_editor');
  return Object.assign({}, original, {
    AIPromptEditor: jest.fn(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const instance = new original.AIPromptEditor(...args);
      return wrapInstanceWithMocks(instance);
    })
  });
});
jest.spyOn(AIPromptEditorView.prototype, 'getController');
const mockColumnsController = {
  addCommandColumn: jest.fn(),
  columnOption: jest.fn(),
  getColumnByPath: jest.fn(),
  getColumnOptionNameByFullName: jest.fn(),
  getVisibleIndex: jest.fn().mockReturnValue(0),
  aiColumnOptionChanged: Callbacks()
};
const mockAIColumnController = {
  abortAIColumnRequest: jest.fn(),
  sendRequest: jest.fn(),
  getAIColumns: jest.fn().mockReturnValue([]),
  aiRequestCompleted: Callbacks(),
  aiRequestRejected: Callbacks(),
  promptEditorRequested: Callbacks()
};
const mockColumn = {
  type: 'ai',
  alignment: 'left',
  name: 'aiColumn',
  index: 0
};
const createComponentMock = jest.fn((el, Widget, options) => new Widget(el, options));
const createAIPromptEditorView = () => {
  const $container = $('<div>').appendTo(document.body);
  const $cellElement = $('<div>').appendTo(document.body);
  const mockComponent = {
    element: () => $container.get(0),
    _createComponent: createComponentMock,
    _controllers: {
      columns: mockColumnsController,
      aiColumn: mockAIColumnController
    }
  };
  const aiPromptEditorView = new AIPromptEditorView(mockComponent);
  aiPromptEditorView.init();
  aiPromptEditorView.render($container);
  return {
    $container,
    cellElement: $cellElement[0],
    aiPromptEditorView,
    aiPromptEditorPOM: new AIPromptEditorModel(aiPromptEditorView.element().get(0))
  };
};
const beforeTest = () => {
  fx.off = true;
  jest.useFakeTimers();
  jest.clearAllMocks();
};
const afterTest = () => {
  document.body.innerHTML = '';
  fx.off = false;
  jest.useRealTimers();
  mockAIColumnController.aiRequestCompleted.empty();
  mockAIColumnController.aiRequestRejected.empty();
  mockColumnsController.aiColumnOptionChanged.empty();
};
describe('AIPromptEditorView', () => {
  beforeEach(beforeTest);
  afterEach(afterTest);
  describe('initialization', () => {
    it('should initialize controllers', () => {
      const {
        aiPromptEditorView
      } = createAIPromptEditorView();
      expect(aiPromptEditorView.getController).toHaveBeenCalledWith('columns');
      expect(aiPromptEditorView.getController).toHaveBeenCalledWith('aiColumn');
    });
  });
  describe('Methods', () => {
    describe('show', () => {
      it('should create new AIPromptEditor instance', async () => {
        const {
          $container,
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        expect(AIPromptEditor).toHaveBeenCalledTimes(1);
        expect(AIPromptEditor).toHaveBeenCalledWith({
          prompt: '',
          container: aiPromptEditorView.element(),
          createComponent: expect.any(Function),
          onStop: expect.any(Function),
          onSubmit: expect.any(Function),
          onRefresh: expect.any(Function),
          popupOptions: {
            container: document.body,
            onHiding: expect.any(Function),
            position: {
              my: 'right top',
              at: 'right bottom',
              of: '.dx-header-row td[aria-colindex="1"]',
              collision: 'fit',
              boundary: $container.get(0)
            }
          },
          editorOptions: {}
        });
        expect(aiPromptEditorView.getPromptEditorInstance().show).toHaveBeenCalledTimes(1);
        expect(aiPromptEditorPOM.isVisible()).toBe(true);
      });
      it('should update existing AIPromptEditor instance', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        expect(AIPromptEditor).toHaveBeenCalledTimes(1);
        expect(AIPromptEditor).toHaveBeenCalledWith(expect.objectContaining({
          popupOptions: expect.objectContaining({
            position: expect.objectContaining({
              of: '.dx-header-row td[aria-colindex="1"]'
            })
          })
        }));
        expect(aiPromptEditorView.getPromptEditorInstance().updateOptions).toHaveBeenCalledTimes(0);
        const newColumn = Object.assign({}, mockColumn, {
          ai: {
            prompt: 'updated prompt'
          }
        });
        mockColumnsController.getVisibleIndex.mockReturnValue(1);
        await aiPromptEditorView.show(cellElement, newColumn);
        expect(AIPromptEditor).toHaveBeenCalledTimes(1); // Only one instance created
        expect(aiPromptEditorView.getPromptEditorInstance().updateOptions).toHaveBeenCalledTimes(1);
        expect(aiPromptEditorView.getPromptEditorInstance().updateOptions).toHaveBeenCalledWith(expect.objectContaining({
          popupOptions: expect.objectContaining({
            position: expect.objectContaining({
              of: '.dx-header-row td[aria-colindex="2"]'
            })
          })
        }));
        expect(aiPromptEditorPOM.getTextArea().getInputElement().value).toBe('updated prompt');
      });
      it('should configure popup position correctly for left alignment', async () => {
        const {
          cellElement,
          aiPromptEditorView
        } = createAIPromptEditorView();
        const leftAlignedColumn = Object.assign({}, mockColumn, {
          alignment: 'left'
        });
        await aiPromptEditorView.show(cellElement, leftAlignedColumn);
        expect(AIPromptEditor).toHaveBeenCalledWith(expect.objectContaining({
          popupOptions: expect.objectContaining({
            position: expect.objectContaining({
              my: 'right top',
              at: 'right bottom'
            })
          })
        }));
      });
      it('should configure popup position correctly for right alignment', async () => {
        const {
          cellElement,
          aiPromptEditorView
        } = createAIPromptEditorView();
        const rightAlignedColumn = Object.assign({}, mockColumn, {
          alignment: 'right'
        });
        await aiPromptEditorView.show(cellElement, rightAlignedColumn);
        expect(AIPromptEditor).toHaveBeenCalledWith(expect.objectContaining({
          popupOptions: expect.objectContaining({
            position: expect.objectContaining({
              my: 'left top',
              at: 'left bottom'
            })
          })
        }));
      });
      describe('when called with invalid parameters', () => {
        it('should return false if cell element is null', async () => {
          const {
            aiPromptEditorView
          } = createAIPromptEditorView();
          const result = await aiPromptEditorView.show(null, mockColumn);
          expect(AIPromptEditor).not.toHaveBeenCalled();
          expect(result).toBe(false);
        });
        it('should return false if column is null', async () => {
          const {
            cellElement,
            aiPromptEditorView
          } = createAIPromptEditorView();
          const result = await aiPromptEditorView.show(cellElement, null);
          expect(AIPromptEditor).not.toHaveBeenCalled();
          expect(result).toBe(false);
        });
        it('should return false if column type is not ai', async () => {
          const {
            cellElement,
            aiPromptEditorView
          } = createAIPromptEditorView();
          const result = await aiPromptEditorView.show(cellElement, Object.assign({}, mockColumn, {
            type: ''
          }));
          expect(AIPromptEditor).not.toHaveBeenCalled();
          expect(result).toBe(false);
        });
      });
    });
    describe('hide', () => {
      it('should call hide method', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        const result = await aiPromptEditorView.hide();
        expect(aiPromptEditorView.getPromptEditorInstance().hide).toHaveBeenCalledTimes(1);
        expect(aiPromptEditorPOM.isVisible()).toBe(false);
        expect(result).toBe(false);
      });
    });
  });
  describe('event handlers in AIPromptEditor config', () => {
    describe('onSubmit', () => {
      it('should update column option and prompt editor state', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithIndex = Object.assign({}, mockColumn, {
          index: 2
        });
        await aiPromptEditorView.show(cellElement, columnWithIndex);
        aiPromptEditorPOM.getTextArea().setValue('test prompt');
        aiPromptEditorPOM.getApplyButton().getElement().click();
        expect(aiPromptEditorView.getPromptEditorInstance().updateStateOnAction).toHaveBeenCalledWith('apply');
        expect(mockColumnsController.columnOption).toHaveBeenCalledWith(2, 'ai.prompt', 'test prompt', true);
      });
      it('should not trigger loading state when prompt has not changed', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = Object.assign({}, mockColumn, {
          index: 2,
          ai: {
            prompt: 'existing prompt'
          }
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        aiPromptEditorPOM.getTextArea().setValue('existing prompt');
        aiPromptEditorPOM.getApplyButton().getElement().click();
        expect(aiPromptEditorView.getPromptEditorInstance().updateStateOnAction).not.toHaveBeenCalled();
        expect(mockColumnsController.columnOption).not.toHaveBeenCalled();
      });
      it('should trigger loading state only when prompt has changed', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = Object.assign({}, mockColumn, {
          index: 2,
          ai: {
            prompt: 'old prompt'
          }
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        aiPromptEditorPOM.getTextArea().setValue('new prompt');
        aiPromptEditorPOM.getApplyButton().getElement().click();
        expect(aiPromptEditorView.getPromptEditorInstance().updateStateOnAction).toHaveBeenCalledWith('apply');
        expect(mockColumnsController.columnOption).toHaveBeenCalledWith(2, 'ai.prompt', 'new prompt', true);
      });
    });
    describe('onStop', () => {
      it('should abort AI request and update prompt editor state', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        mockAIColumnController.sendRequest.mockImplementation(() => {
          setTimeout(() => {
            mockAIColumnController.aiRequestCompleted.fire();
          });
        });
        await aiPromptEditorView.show(cellElement, mockColumn);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getTextArea().setValue('test prompt');
        aiPromptEditorPOM.getApplyButton().getElement().click();
        promptEditorInstance.updateStateOnAction.mockClear();
        aiPromptEditorPOM.getStopButton().getElement().click();
        jest.runAllTimers();
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
        expect(mockAIColumnController.abortAIColumnRequest).toHaveBeenCalledTimes(1);
      });
    });
    describe('onRefresh', () => {
      it('should refresh AI column and update prompt editor state', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = Object.assign({}, mockColumn, {
          name: 'testColumn',
          ai: {
            prompt: 'test prompt'
          }
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getRefreshButton().getElement().click();
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('regenerate');
        expect(mockAIColumnController.sendRequest).toHaveBeenCalledWith('testColumn', false, false);
      });
      it('should update prompt editor state on completion', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = Object.assign({}, mockColumn, {
          name: 'testColumn',
          ai: {
            prompt: 'test prompt'
          }
        });
        mockAIColumnController.sendRequest.mockImplementation(() => {
          setTimeout(() => {
            mockAIColumnController.aiRequestCompleted.fire();
          });
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getRefreshButton().getElement().click();
        promptEditorInstance.updateStateOnAction.mockClear();
        jest.runAllTimers();
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
      });
      it('should update prompt editor state on error', async () => {
        const {
          cellElement,
          aiPromptEditorView,
          aiPromptEditorPOM
        } = createAIPromptEditorView();
        const columnWithPrompt = Object.assign({}, mockColumn, {
          name: 'testColumn',
          ai: {
            prompt: 'test prompt'
          }
        });
        mockAIColumnController.sendRequest.mockImplementation(() => {
          setTimeout(() => {
            mockAIColumnController.aiRequestRejected.fire();
          });
        });
        await aiPromptEditorView.show(cellElement, columnWithPrompt);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        aiPromptEditorPOM.getRefreshButton().getElement().click();
        promptEditorInstance.updateStateOnAction.mockClear();
        jest.runAllTimers();
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
      });
    });
    describe('onHiding', () => {
      it('should update prompt editor state and abort AI request', async () => {
        const {
          cellElement,
          aiPromptEditorView
        } = createAIPromptEditorView();
        await aiPromptEditorView.show(cellElement, mockColumn);
        const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
        await aiPromptEditorView.hide();
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
        expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
        expect(mockAIColumnController.abortAIColumnRequest).toHaveBeenCalledTimes(1);
      });
    });
  });
  describe('aiColumnOptionChanged callback', () => {
    it('should handle ai.prompt option change', async () => {
      const {
        cellElement,
        aiPromptEditorView
      } = createAIPromptEditorView();
      mockAIColumnController.sendRequest.mockImplementation(() => {
        setTimeout(() => {
          mockAIColumnController.aiRequestCompleted.fire();
        });
      });
      await aiPromptEditorView.show(cellElement, mockColumn);
      const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
      promptEditorInstance.getEditorValue.mockReturnValue('new prompt value');
      mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
      expect(promptEditorInstance.updatePrompt).toHaveBeenCalledWith('new prompt value');
      expect(mockAIColumnController.sendRequest).toHaveBeenCalledWith('aiColumn', false, false);
    });
    it('should update prompt editor state on completion', async () => {
      const {
        cellElement,
        aiPromptEditorView
      } = createAIPromptEditorView();
      mockAIColumnController.sendRequest.mockImplementation(() => {
        mockAIColumnController.aiRequestCompleted.fire();
      });
      await aiPromptEditorView.show(cellElement, mockColumn);
      const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
      promptEditorInstance.getEditorValue.mockReturnValue('new prompt value');
      mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
      expect(promptEditorInstance.updatePrompt).toHaveBeenCalledWith('new prompt value');
      expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
    });
    it('should update prompt editor state on error', async () => {
      const {
        cellElement,
        aiPromptEditorView
      } = createAIPromptEditorView();
      mockAIColumnController.sendRequest.mockImplementation(() => {
        mockAIColumnController.aiRequestRejected.fire();
      });
      await aiPromptEditorView.show(cellElement, mockColumn);
      mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
      const promptEditorInstance = aiPromptEditorView.getPromptEditorInstance();
      expect(promptEditorInstance.updatePrompt).toHaveBeenCalledWith('new prompt value');
      expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledTimes(1);
      expect(promptEditorInstance.updateStateOnAction).toHaveBeenCalledWith('stop');
    });
    describe('when prompt editor is not initialized', () => {
      it('should handle callback without errors', () => {
        createAIPromptEditorView();
        expect(() => {
          mockColumnsController.aiColumnOptionChanged.fire(mockColumn, 'ai.prompt', 'new prompt value');
        }).not.toThrow();
        expect(mockAIColumnController.sendRequest).toHaveBeenCalledWith('aiColumn', false, true);
      });
    });
  });
});
