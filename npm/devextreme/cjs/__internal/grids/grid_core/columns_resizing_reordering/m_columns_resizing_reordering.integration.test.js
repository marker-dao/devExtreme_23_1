/**
* DevExtreme (cjs/__internal/grids/grid_core/columns_resizing_reordering/m_columns_resizing_reordering.integration.test.js)
* Version: 25.2.0
* Build date: Fri Nov 07 2025
*
* Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
* Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
*/
"use strict";

var _globals = require("@jest/globals");
var _drag = require("../../../../common/core/events/drag");
var _renderer = _interopRequireDefault(require("../../../../core/renderer"));
var _data_grid = _interopRequireDefault(require("../../../../ui/data_grid"));
var _ui = _interopRequireDefault(require("../../../../ui/widget/ui.errors"));
var _data_grid2 = require("../../../grids/data_grid/__tests__/__mock__/model/data_grid");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const SELECTORS = {
  gridContainer: '#gridContainer'
};
const GRID_CONTAINER_ID = 'gridContainer';
const createDataGrid = async function () {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new Promise(resolve => {
    const $container = (0, _renderer.default)('<div>').attr('id', GRID_CONTAINER_ID).appendTo(document.body);
    const instance = new _data_grid.default($container.get(0), options);
    const component = new _data_grid2.DataGridModel($container.get(0));
    _globals.jest.runAllTimers();
    resolve({
      $container,
      component,
      instance
    });
  });
};
const beforeTest = () => {
  _globals.jest.useFakeTimers();
  _globals.jest.spyOn(_ui.default, 'log').mockImplementation(_globals.jest.fn());
};
const afterTest = () => {
  const $container = (0, _renderer.default)(SELECTORS.gridContainer);
  const dataGrid = $container.dxDataGrid('instance');
  dataGrid.dispose();
  $container.remove();
  _globals.jest.clearAllMocks();
  _globals.jest.useRealTimers();
};
(0, _globals.describe)('Performance optimization', () => {
  (0, _globals.beforeEach)(beforeTest);
  (0, _globals.afterEach)(afterTest);
  const createGridWith200Columns = async () => {
    const columns = [{
      dataField: 'id',
      caption: 'ID',
      width: '100px',
      fixed: true
    }, {
      caption: 'Name',
      columns: [{
        dataField: 'name.first',
        caption: 'First name',
        width: '150px'
      }, {
        dataField: 'name.last',
        caption: 'Last name',
        width: '150px'
      }]
    }, ...Array.from({
      length: 198
    }, (_, index) => ({
      dataField: `values.${index}`,
      caption: `Value ${index + 1}`,
      width: '100px'
    }))];
    const dataSource = [{
      id: 1,
      name: {
        first: 'John',
        last: 'Doe'
      },
      values: Array.from({
        length: 198
      }, (_, index) => index + 1)
    }];
    return createDataGrid({
      dataSource,
      columns,
      width: '100%',
      showBorders: true,
      showColumnLines: true,
      allowColumnResizing: true,
      allowColumnReordering: true
    });
  };
  (0, _globals.describe)('ColumnsResizerViewController', () => {
    (0, _globals.it)('should call "_pointCreated" 202 times when generating points by columns (1 fixed + 1 group + 2 group children + 198 regular)', async () => {
      const {
        instance
      } = await createGridWith200Columns();
      const columnsResizerController = instance.getController('columnsResizer');
      const pointCreatedSpy = _globals.jest.spyOn(columnsResizerController, '_pointCreated');
      columnsResizerController.pointsByColumns();
      (0, _globals.expect)(pointCreatedSpy).toHaveBeenCalledTimes(202);
    });
    (0, _globals.it)('should call "getColumnElements" as many times as there are head rows', async () => {
      const {
        instance
      } = await createGridWith200Columns();
      const columnsResizerController = instance.getController('columnsResizer');
      const columnHeadersView = instance.getView('columnHeadersView');
      const columnHeadersViewSpy = _globals.jest.spyOn(columnHeadersView, 'getColumnElements');
      columnsResizerController.pointsByColumns();
      (0, _globals.expect)(columnHeadersViewSpy).toHaveBeenCalledTimes(2);
    });
  });
  (0, _globals.describe)('DraggingHeaderViewController', () => {
    const getDragEvent = (eventName, headerOffset, dragOffset) => {
      const dragEndEvent = document.createEvent('CustomEvent');
      dragEndEvent.initCustomEvent(eventName, true, true);
      dragEndEvent.pageX = headerOffset.left + dragOffset.left;
      dragEndEvent.pageY = headerOffset.top + dragOffset.top;
      dragEndEvent.pointerType = 'mouse';
      return dragEndEvent;
    };
    (0, _globals.it)('should call "getBoundingRect" once for each dragging panel view', async () => {
      var _$headerCell$get, _$headerCell$get2, _$headerCell$get3;
      const {
        instance
      } = await createGridWith200Columns();
      const columnHeadersView = instance.getView('columnHeadersView');
      const columnChooserView = instance.getView('columnChooserView');
      const headerPanelView = instance.getView('headerPanel');
      const getBoundingViewMocks = [_globals.jest.spyOn(columnHeadersView, 'getBoundingRect'), _globals.jest.spyOn(columnChooserView, 'getBoundingRect'), _globals.jest.spyOn(headerPanelView, 'getBoundingRect')];
      const $headerCell = (0, _renderer.default)(columnHeadersView.element()).find('.dx-header-row td').eq(5);
      const headerOffset = $headerCell.offset();
      if (!headerOffset) {
        throw new Error('Header cell not found');
      }
      const dragStartOffset = {
        left: 10,
        top: 10
      };
      const dragStartEvent = getDragEvent(_drag.start, headerOffset, dragStartOffset);
      (_$headerCell$get = $headerCell.get(0)) === null || _$headerCell$get === void 0 || _$headerCell$get.dispatchEvent(dragStartEvent);
      const dragMoveOffset = {
        left: 500,
        top: 10
      };
      const dragMoveEvent = getDragEvent(_drag.move, headerOffset, dragMoveOffset);
      (_$headerCell$get2 = $headerCell.get(0)) === null || _$headerCell$get2 === void 0 || _$headerCell$get2.dispatchEvent(dragMoveEvent);
      const dragEndOffset = {
        left: 500,
        top: 10
      };
      const dragEndEvent = getDragEvent(_drag.end, headerOffset, dragEndOffset);
      (_$headerCell$get3 = $headerCell.get(0)) === null || _$headerCell$get3 === void 0 || _$headerCell$get3.dispatchEvent(dragEndEvent);
      getBoundingViewMocks.forEach(getBoundingViewMock => {
        (0, _globals.expect)(getBoundingViewMock).toHaveBeenCalledTimes(1);
      });
    });
  });
});
