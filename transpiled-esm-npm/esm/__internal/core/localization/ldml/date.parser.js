import { escapeRegExp } from '../../../core/utils/m_common';
import { logger } from '../../../core/utils/m_console';
const FORMAT_TYPES = {
  3: 'abbreviated',
  4: 'wide',
  5: 'narrow'
};
const monthRegExpGenerator = (count, dateParts) => {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES)
    // eslint-disable-next-line @typescript-eslint/no-shadow
    .map(count => ['format', 'standalone'].map(type => dateParts.getMonthNames(FORMAT_TYPES[count], type).join('|')).join('|')).join('|');
  }
  return count === 2 ? '1[012]|0?[1-9]' : '0??[1-9]|1[012]';
};
const PATTERN_REGEXPS = {
  ':': (count, dateParts) => {
    var _dateParts$getTimeSep;
    const countSuffix = count > 1 ? `{${count}}` : '';
    let timeSeparator = escapeRegExp((_dateParts$getTimeSep = dateParts.getTimeSeparator) === null || _dateParts$getTimeSep === void 0 ? void 0 : _dateParts$getTimeSep.call(dateParts));
    if (timeSeparator !== ':') {
      timeSeparator = `${timeSeparator}|:`;
    }
    return `${timeSeparator}${countSuffix}`;
  },
  y(count) {
    return count === 2 ? `[0-9]{${count}}` : '[0-9]+?';
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q(count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').join('|');
    }
    return '0?[1-4]';
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  E(_count, _dateParts) {
    return '\\D*';
  },
  a(count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format').join('|');
  },
  d(count) {
    return count === 2 ? '3[01]|[12][0-9]|0?[1-9]' : '0??[1-9]|[12][0-9]|3[01]';
  },
  H(count) {
    return count === 2 ? '2[0-3]|1[0-9]|0?[0-9]' : '0??[0-9]|1[0-9]|2[0-3]';
  },
  h(count) {
    return count === 2 ? '1[012]|0?[1-9]' : '0??[1-9]|1[012]';
  },
  m(count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  s(count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  S(count) {
    return `[0-9]{1,${count}}`;
  },
  w(count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  x(count) {
    return count === 3 ? '[+-](?:2[0-3]|[01][0-9]):(?:[0-5][0-9])|Z' : '[+-](?:2[0-3]|[01][0-9])(?:[0-5][0-9])|Z';
  }
};
const parseNumber = Number;
// eslint-disable-next-line arrow-body-style
const caseInsensitiveIndexOf = (array, value) => {
  return array.map(item => item.toLowerCase()).indexOf(value.toLowerCase());
};
const monthPatternParser = (text, count, dateParts) => {
  if (count > 2) {
    return ['format', 'standalone']
    // eslint-disable-next-line @typescript-eslint/no-shadow
    .map(type => Object.keys(FORMAT_TYPES).map(count => {
      const monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);
      return caseInsensitiveIndexOf(monthNames, text);
    })).reduce((a, b) => a.concat(b)).filter(index => index >= 0)[0];
  }
  return parseNumber(text) - 1;
};
const PATTERN_PARSERS = {
  y(text, count) {
    const year = parseNumber(text);
    if (count === 2) {
      return year < 30 ? 2000 + year : 1900 + year;
    }
    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q(text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').indexOf(text);
    }
    return parseNumber(text) - 1;
  },
  E(text, count, dateParts) {
    const dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a(text, count, dateParts) {
    const periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S(text, count) {
    // eslint-disable-next-line no-param-reassign
    count = Math.max(count, 3);
    // eslint-disable-next-line no-param-reassign
    text = text.slice(0, 3);
    while (count < 3) {
      // eslint-disable-next-line no-param-reassign
      text = `${text}0`;
      // eslint-disable-next-line no-param-reassign
      count += 1;
    }
    return parseNumber(text);
  }
};
const ORDERED_PATTERNS = ['y', 'M', 'd', 'h', 'm', 's', 'S'];
const PATTERN_SETTERS = {
  y: 'setFullYear',
  M: 'setMonth',
  L: 'setMonth',
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  a(date, value, datePartValues) {
    let hours = date.getHours();
    const hourPartValue = datePartValues.h;
    if (hourPartValue !== undefined && hourPartValue !== hours) {
      hours -= 1;
    }
    if (!value && hours === 12) {
      hours = 0;
    } else if (value && hours !== 12) {
      hours += 12;
    }
    date.setHours(hours);
  },
  d: 'setDate',
  H: 'setHours',
  h: 'setHours',
  m: 'setMinutes',
  s: 'setSeconds',
  S: 'setMilliseconds'
};
const getSameCharCount = (text, index) => {
  const char = text[index];
  if (!char) {
    return 0;
  }
  let count = 0;
  do {
    // eslint-disable-next-line no-param-reassign
    index += 1;
    count += 1;
  } while (text[index] === char);
  return count;
};
const createPattern = (char, count) => {
  let result = '';
  for (let i = 0; i < count; i += 1) {
    result += char;
  }
  return result;
};
const digitFieldSymbols = ['d', 'H', 'h', 'm', 's', 'w', 'M', 'L', 'Q'];
export const isPossibleForParsingFormat = patterns => {
  const isDigitPattern = pattern => {
    if (!pattern) {
      return false;
    }
    const char = pattern[0];
    return ['y', 'S'].includes(char) || digitFieldSymbols.includes(char) && pattern.length < 3;
  };
  const isAmbiguousDigitPattern = pattern => !pattern.startsWith('S') && pattern.length !== 2;
  let possibleForParsing = true;
  let ambiguousDigitPatternsCount = 0;
  // eslint-disable-next-line @typescript-eslint/no-shadow
  return patterns.every((pattern, index, patterns) => {
    if (isDigitPattern(pattern)) {
      if (isAmbiguousDigitPattern(pattern)) {
        // eslint-disable-next-line no-plusplus
        possibleForParsing = ++ambiguousDigitPatternsCount < 2;
      }
      if (!isDigitPattern(patterns[index + 1])) {
        ambiguousDigitPatternsCount = 0;
      }
    }
    return possibleForParsing;
  });
};
export const getRegExpInfo = (format, dateParts) => {
  let regexpText = '';
  let stubText = '';
  let isEscaping = false;
  const patterns = [];
  const addPreviousStub = () => {
    if (stubText) {
      patterns.push(`'${stubText}'`);
      regexpText += `${escapeRegExp(stubText)})`;
      stubText = '';
    }
  };
  for (let i = 0; i < format.length; i += 1) {
    const char = format[i];
    const isEscapeChar = char === '\'';
    const regexpPart = PATTERN_REGEXPS[char];
    if (isEscapeChar) {
      isEscaping = !isEscaping;
      if (format[i - 1] !== '\'') {
        // eslint-disable-next-line no-continue
        continue;
      }
    }
    if (regexpPart && !isEscaping) {
      const count = getSameCharCount(format, i);
      const pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += `(${regexpPart(count, dateParts)})`;
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += '(';
      }
      stubText += char;
    }
  }
  addPreviousStub();
  if (!isPossibleForParsingFormat(patterns)) {
    logger.warn(`The following format may be parsed incorrectly: ${format}.`);
  }
  return {
    patterns,
    regexp: new RegExp(`^${regexpText}$`, 'i')
  };
};
export const getPatternSetters = () => PATTERN_SETTERS;
const setPatternPart = (date, pattern, text, dateParts, datePartValues) => {
  const patternChar = pattern[0];
  const partSetter = PATTERN_SETTERS[patternChar];
  const partParser = PATTERN_PARSERS[patternChar];
  if (partSetter && partParser) {
    const value = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value;
    if (date[partSetter]) {
      date[partSetter](value);
    } else {
      partSetter(date, value, datePartValues);
    }
  }
};
const setPatternPartFromNow = (date, pattern, now) => {
  const setterName = PATTERN_SETTERS[pattern];
  const getterName = `g${setterName.substr(1)}`;
  const value = now[getterName]();
  date[setterName](value);
};
const getShortPatterns = fullPatterns => fullPatterns.map(pattern => {
  if (pattern.startsWith('\'')) {
    return '';
  }
  return pattern.startsWith('H') ? 'h' : pattern[0];
});
const getMaxOrderedPatternIndex = patterns => {
  const indexes = patterns.map(pattern => ORDERED_PATTERNS.indexOf(pattern));
  return Math.max(...indexes);
};
const getOrderedFormatPatterns = formatPatterns => {
  const otherPatterns = formatPatterns.filter(pattern => !ORDERED_PATTERNS.includes(pattern));
  return ORDERED_PATTERNS.concat(otherPatterns);
};
export const getParser = (format, dateParts) => {
  const regExpInfo = getRegExpInfo(format, dateParts);
  return text => {
    const regExpResult = regExpInfo.regexp.exec(text);
    if (regExpResult) {
      const now = new Date();
      const date = new Date(now.getFullYear(), 0, 1);
      const formatPatterns = getShortPatterns(regExpInfo.patterns);
      const maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      const orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      const datePartValues = {};
      orderedFormatPatterns.forEach((pattern, index) => {
        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {
          return;
        }
        const patternIndex = formatPatterns.indexOf(pattern);
        if (patternIndex >= 0) {
          const regExpPattern = regExpInfo.patterns[patternIndex];
          const regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }
    return null;
  };
};