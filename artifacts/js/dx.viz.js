/*!
* DevExtreme (dx.viz.js)
* Version: 23.2.0
* Build date: Fri Aug 11 2023
*
* Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
* Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
*/
"use strict";

/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 81589:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var inferno_1 = __webpack_require__(65414);
var effect_host_1 = __webpack_require__(53213);
var areObjectsEqual = function (firstObject, secondObject) {
    var bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
    if (!bothAreObjects) {
        return firstObject === secondObject;
    }
    var firstObjectKeys = Object.keys(firstObject);
    var secondObjectKeys = Object.keys(secondObject);
    if (firstObjectKeys.length !== secondObjectKeys.length) {
        return false;
    }
    var hasDifferentElement = firstObjectKeys.some(function (key) { return firstObject[key] !== secondObject[key]; });
    return !hasDifferentElement;
};
var BaseInfernoComponent = /** @class */ (function (_super) {
    __extends(BaseInfernoComponent, _super);
    function BaseInfernoComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._pendingContext = _this.context;
        return _this;
    }
    BaseInfernoComponent.prototype.componentWillReceiveProps = function (_, context) {
        this._pendingContext = context !== null && context !== void 0 ? context : {};
    };
    BaseInfernoComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        return (!areObjectsEqual(this.props, nextProps)
            || !areObjectsEqual(this.state, nextState)
            || !areObjectsEqual(this.context, this._pendingContext));
    };
    return BaseInfernoComponent;
}(inferno_1.Component));
exports.BaseInfernoComponent = BaseInfernoComponent;
var InfernoComponent = /** @class */ (function (_super) {
    __extends(InfernoComponent, _super);
    function InfernoComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._effects = [];
        return _this;
    }
    InfernoComponent.prototype.createEffects = function () {
        return [];
    };
    InfernoComponent.prototype.updateEffects = function () { };
    InfernoComponent.prototype.componentWillMount = function () {
        effect_host_1.InfernoEffectHost.lock();
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    InfernoComponent.prototype.componentWillUpdate = function (_nextProps, _nextState, _context) {
        effect_host_1.InfernoEffectHost.lock();
    };
    InfernoComponent.prototype.componentDidMount = function () {
        var _this = this;
        effect_host_1.InfernoEffectHost.callbacks.push(function () { _this._effects = _this.createEffects(); });
        effect_host_1.InfernoEffectHost.callEffects();
    };
    InfernoComponent.prototype.componentDidUpdate = function () {
        var _this = this;
        effect_host_1.InfernoEffectHost.callbacks.push(function () { return _this.updateEffects(); });
        effect_host_1.InfernoEffectHost.callEffects();
    };
    InfernoComponent.prototype.destroyEffects = function () {
        this._effects.forEach(function (e) { return e.dispose(); });
    };
    InfernoComponent.prototype.componentWillUnmount = function () {
        this.destroyEffects();
    };
    return InfernoComponent;
}(BaseInfernoComponent));
exports.InfernoComponent = InfernoComponent;
var InfernoWrapperComponent = /** @class */ (function (_super) {
    __extends(InfernoWrapperComponent, _super);
    function InfernoWrapperComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.vDomElement = null;
        return _this;
    }
    InfernoWrapperComponent.prototype.vDomUpdateClasses = function () {
        var el = this.vDomElement;
        var currentClasses = el.className.length
            ? el.className.split(' ')
            : [];
        var addedClasses = currentClasses.filter(function (className) { return el.dxClasses.previous.indexOf(className) < 0; });
        var removedClasses = el.dxClasses.previous.filter(function (className) { return currentClasses.indexOf(className) < 0; });
        addedClasses.forEach(function (value) {
            var indexInRemoved = el.dxClasses.removed.indexOf(value);
            if (indexInRemoved > -1) {
                el.dxClasses.removed.splice(indexInRemoved, 1);
            }
            else {
                el.dxClasses.added.push(value);
            }
        });
        removedClasses.forEach(function (value) {
            var indexInAdded = el.dxClasses.added.indexOf(value);
            if (indexInAdded > -1) {
                el.dxClasses.added.splice(indexInAdded, 1);
            }
            else {
                el.dxClasses.removed.push(value);
            }
        });
    };
    InfernoWrapperComponent.prototype.componentDidMount = function () {
        var el = inferno_1.findDOMfromVNode(this.$LI, true);
        this.vDomElement = el;
        _super.prototype.componentDidMount.call(this);
        el.dxClasses = el.dxClasses || {
            removed: [], added: [], previous: [],
        };
        el.dxClasses.previous = (el === null || el === void 0 ? void 0 : el.className.length) ? el.className.split(' ')
            : [];
    };
    InfernoWrapperComponent.prototype.componentDidUpdate = function () {
        _super.prototype.componentDidUpdate.call(this);
        var el = this.vDomElement;
        if (el !== null) {
            el.dxClasses.added.forEach(function (className) { return el.classList.add(className); });
            el.dxClasses.removed.forEach(function (className) { return el.classList.remove(className); });
            el.dxClasses.previous = el.className.length
                ? el.className.split(' ')
                : [];
        }
    };
    InfernoWrapperComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var shouldUpdate = _super.prototype.shouldComponentUpdate.call(this, nextProps, nextState);
        if (shouldUpdate) {
            this.vDomUpdateClasses();
        }
        return shouldUpdate;
    };
    return InfernoWrapperComponent;
}(InfernoComponent));
exports.InfernoWrapperComponent = InfernoWrapperComponent;


/***/ }),

/***/ 61080:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var inferno_1 = __webpack_require__(65414);
var contextId = 0;
exports.createContext = function (defaultValue) {
    var id = contextId++;
    return {
        id: id,
        defaultValue: defaultValue,
        Provider: /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.getChildContext = function () {
                var _a;
                return __assign(__assign({}, this.context), (_a = {}, _a[id] = this.props.value || defaultValue, _a));
            };
            class_1.prototype.render = function () {
                return this.props.children;
            };
            return class_1;
        }(inferno_1.Component)),
    };
};


/***/ }),

/***/ 43956:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var InfernoEffect = /** @class */ (function () {
    function InfernoEffect(effect, dependency) {
        this.dependency = dependency;
        this.effect = effect;
        this.destroy = effect();
    }
    InfernoEffect.prototype.update = function (dependency) {
        var currentDependency = this.dependency;
        if (dependency) {
            this.dependency = dependency;
        }
        if (!dependency || dependency.some(function (d, i) { return currentDependency[i] !== d; })) {
            this.dispose();
            this.destroy = this.effect();
        }
    };
    InfernoEffect.prototype.dispose = function () {
        if (this.destroy) {
            this.destroy();
        }
    };
    return InfernoEffect;
}());
exports.InfernoEffect = InfernoEffect;


/***/ }),

/***/ 53213:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfernoEffectHost = {
    lockCount: 0,
    lock: function () {
        this.lockCount++;
    },
    callbacks: [],
    callEffects: function () {
        this.lockCount--;
        if (this.lockCount < 0) {
            throw new Error('Unexpected Effect Call');
        }
        if (this.lockCount === 0) {
            var effects = this.callbacks;
            this.callbacks = [];
            effects.forEach(function (callback) { return callback(); });
        }
    },
};


/***/ }),

/***/ 74219:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__webpack_require__(81589));
__export(__webpack_require__(61080));
__export(__webpack_require__(43956));
__export(__webpack_require__(53213));
__export(__webpack_require__(53159));
__export(__webpack_require__(31620));
__export(__webpack_require__(67604));
__export(__webpack_require__(32423));
__export(__webpack_require__(73084));


/***/ }),

/***/ 67604:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var inferno_1 = __webpack_require__(65414);
var shared_1 = __webpack_require__(45786);
function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
    var flags;
    var children;
    while (vNode) {
        flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            return vNode.dom;
        }
        children = vNode.children;
        if (flags & 8192 /* Fragment */) {
            vNode = vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[children.length - 1];
        }
        else if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        else {
            vNode = children;
        }
    }
    return null;
}
function isSamePropsInnerHTML(dom, props) {
    return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context, isSVG, isClass, lifecycle) {
    var type = vNode.type;
    var ref = vNode.ref;
    var props = vNode.props || inferno_1.EMPTY_OBJ;
    var currentNode;
    if (isClass) {
        var instance = inferno_1._CI(vNode, type, props, context, isSVG, lifecycle);
        var input = instance.$LI;
        currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle);
        inferno_1._MCCC(ref, instance, lifecycle);
    }
    else {
        var input = inferno_1._HI(inferno_1._RFC(vNode, context));
        currentNode = hydrateVNode(input, parentDOM, dom, context, isSVG, lifecycle);
        vNode.children = input;
        inferno_1._MFCC(vNode, lifecycle);
    }
    return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context, isSVG, lifecycle) {
    var childFlags = parentVNode.childFlags;
    var children = parentVNode.children;
    var props = parentVNode.props;
    var flags = parentVNode.flags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        if (childFlags === 2 /* HasVNodeChildren */) {
            if (shared_1.isNull(currentNode)) {
                inferno_1._M(children, parentNode, context, isSVG, null, lifecycle);
            }
            else {
                currentNode = hydrateVNode(children, parentNode, currentNode, context, isSVG, lifecycle);
                currentNode = currentNode ? currentNode.nextSibling : null;
            }
        }
        else if (childFlags === 16 /* HasTextChildren */) {
            if (shared_1.isNull(currentNode)) {
                parentNode.appendChild(document.createTextNode(children));
            }
            else if (parentNode.childNodes.length !== 1 || currentNode.nodeType !== 3) {
                parentNode.textContent = children;
            }
            else if (currentNode.nodeValue !== children) {
                currentNode.nodeValue = children;
            }
            currentNode = null;
        }
        else if (childFlags & 12 /* MultipleChildren */) {
            var prevVNodeIsTextNode = false;
            for (var i = 0, len = children.length; i < len; ++i) {
                var child = children[i];
                if (shared_1.isNull(currentNode) || (prevVNodeIsTextNode && (child.flags & 16 /* Text */) > 0)) {
                    inferno_1._M(child, parentNode, context, isSVG, currentNode, lifecycle);
                }
                else {
                    currentNode = hydrateVNode(child, parentNode, currentNode, context, isSVG, lifecycle);
                    currentNode = currentNode ? currentNode.nextSibling : null;
                }
                prevVNodeIsTextNode = (child.flags & 16 /* Text */) > 0;
            }
        }
        // clear any other DOM nodes, there should be only a single entry for the root
        if ((flags & 8192 /* Fragment */) === 0) {
            var nextSibling = null;
            while (currentNode) {
                nextSibling = currentNode.nextSibling;
                parentNode.removeChild(currentNode);
                currentNode = nextSibling;
            }
        }
    }
    else if (!shared_1.isNull(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
        parentNode.textContent = ''; // dom has content, but VNode has no children remove everything from DOM
        if (flags & 448 /* FormElement */) {
            // If element is form element, we need to clear defaultValue also
            parentNode.defaultValue = '';
        }
    }
}
function hydrateElement(vNode, parentDOM, dom, context, isSVG, lifecycle) {
    var props = vNode.props;
    var className = vNode.className;
    var flags = vNode.flags;
    var ref = vNode.ref;
    isSVG = isSVG || (flags & 32 /* SvgElement */) > 0;
    if (dom.nodeType !== 1) {
        inferno_1._ME(vNode, null, context, isSVG, null, lifecycle);
        parentDOM.replaceChild(vNode.dom, dom);
    }
    else {
        vNode.dom = dom;
        hydrateChildren(vNode, dom, dom.firstChild, context, isSVG, lifecycle);
        if (!shared_1.isNull(props)) {
            inferno_1._MP(vNode, flags, props, dom, isSVG);
        }
        if (shared_1.isNullOrUndef(className)) {
            if (dom.className !== '') {
                dom.removeAttribute('class');
            }
        }
        else if (isSVG) {
            dom.setAttribute('class', className);
        }
        else {
            dom.className = className;
        }
        inferno_1._MR(ref, dom, lifecycle);
    }
    return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
    if (dom.nodeType !== 3) {
        parentDOM.replaceChild((vNode.dom = document.createTextNode(vNode.children)), dom);
    }
    else {
        var text = vNode.children;
        if (dom.nodeValue !== text) {
            dom.nodeValue = text;
        }
        vNode.dom = dom;
    }
    return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context, isSVG, lifecycle) {
    var children = vNode.children;
    if (vNode.childFlags === 2 /* HasVNodeChildren */) {
        hydrateText(children, parentDOM, dom);
        return children.dom;
    }
    hydrateChildren(vNode, parentDOM, dom, context, isSVG, lifecycle);
    return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context, isSVG, lifecycle) {
    var flags = (vNode.flags |= 16384 /* InUse */);
    if (flags & 14 /* Component */) {
        return hydrateComponent(vNode, parentDOM, currentDom, context, isSVG, (flags & 4 /* ComponentClass */) > 0, lifecycle);
    }
    if (flags & 481 /* Element */) {
        return hydrateElement(vNode, parentDOM, currentDom, context, isSVG, lifecycle);
    }
    if (flags & 16 /* Text */) {
        return hydrateText(vNode, parentDOM, currentDom);
    }
    if (flags & 512 /* Void */) {
        return (vNode.dom = currentDom);
    }
    if (flags & 8192 /* Fragment */) {
        return hydrateFragment(vNode, parentDOM, currentDom, context, isSVG, lifecycle);
    }
    shared_1.throwError();
    return null;
}
function hydrate(input, parentDOM, callback) {
    var dom = parentDOM.firstChild;
    if (shared_1.isNull(dom)) {
        inferno_1.render(input, parentDOM, callback);
    }
    else {
        var lifecycle = [];
        if (!shared_1.isInvalid(input)) {
            dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle);
        }
        // clear any other DOM nodes, there should be only a single entry for the root
        while (dom && (dom = dom.nextSibling)) {
            parentDOM.removeChild(dom);
        }
        if (lifecycle.length > 0) {
            var listener = void 0;
            while ((listener = lifecycle.shift()) !== undefined) {
                listener();
            }
        }
    }
    parentDOM.$V = input;
    if (shared_1.isFunction(callback)) {
        callback();
    }
}
exports.hydrate = hydrate;


/***/ }),

/***/ 45786:
/***/ (function(__unused_webpack_module, exports) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';
function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
exports.isNullOrUndef = isNullOrUndef;
function isInvalid(o) {
    return o === null || o === false || o === true || o === void 0;
}
exports.isInvalid = isInvalid;
function isFunction(o) {
    return typeof o === 'function';
}
exports.isFunction = isFunction;
function isNull(o) {
    return o === null;
}
exports.isNull = isNull;
function throwError(message) {
    if (!message) {
        message = exports.ERROR_MSG;
    }
    throw new Error("Inferno Error: " + message);
}
exports.throwError = throwError;


/***/ }),

/***/ 73084:
/***/ (function(__unused_webpack_module, exports) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var NUMBER_STYLES = new Set([
    'animationIterationCount',
    'borderImageOutset',
    'borderImageSlice',
    'border-imageWidth',
    'boxFlex',
    'boxFlexGroup',
    'boxOrdinalGroup',
    'columnCount',
    'fillOpacity',
    'flex',
    'flexGrow',
    'flexNegative',
    'flexOrder',
    'flexPositive',
    'flexShrink',
    'floodOpacity',
    'fontWeight',
    'gridColumn',
    'gridRow',
    'lineClamp',
    'lineHeight',
    'opacity',
    'order',
    'orphans',
    'stopOpacity',
    'strokeDasharray',
    'strokeDashoffset',
    'strokeMiterlimit',
    'strokeOpacity',
    'strokeWidth',
    'tabSize',
    'widows',
    'zIndex',
    'zoom',
]);
var isNumeric = function (value) {
    if (typeof value === 'number')
        return true;
    return !Number.isNaN(Number(value));
};
var getNumberStyleValue = function (style, value) { return (NUMBER_STYLES.has(style) ? value : value + "px"); };
var uppercasePattern = /[A-Z]/g;
var kebabCase = function (str) { return str.replace(uppercasePattern, '-$&').toLowerCase(); };
function normalizeStyles(styles) {
    if (!(styles instanceof Object)) {
        return undefined;
    }
    return Object
        .entries(styles)
        .reduce(function (acc, _a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        acc[kebabCase(key)] = isNumeric(value)
            ? getNumberStyleValue(key, value)
            : value;
        return acc;
    }, {});
}
exports.normalizeStyles = normalizeStyles;


/***/ }),

/***/ 53159:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var inferno_1 = __webpack_require__(65414);
exports.Portal = function (_a) {
    var container = _a.container, children = _a.children;
    if (container) {
        return inferno_1.createPortal(children, container);
    }
    return null;
};


/***/ }),

/***/ 31620:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var inferno_1 = __webpack_require__(65414);
var effect_1 = __webpack_require__(43956);
exports.createReRenderEffect = function () { return new effect_1.InfernoEffect(function () {
    inferno_1.rerender();
}, []); };


/***/ }),

/***/ 32423:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var inferno_1 = __webpack_require__(65414);
var inferno_create_element_1 = __webpack_require__(99038);
var getContainer = function (props) { var _a, _b; return ((_a = props.container) === null || _a === void 0 ? void 0 : _a.get(0)) || ((_b = props.item) === null || _b === void 0 ? void 0 : _b.get(0)); };
function renderTemplate(template, props, _component) {
    setTimeout(function () {
        inferno_1.render(inferno_create_element_1.createElement(template, props), getContainer(props));
    }, 0);
}
exports.renderTemplate = renderTemplate;
exports.hasTemplate = function (name, properties, _component) {
    var value = properties[name];
    return !!value && typeof value !== 'string';
};


/***/ }),

/***/ 99038:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createElement": function() { return /* binding */ createElement; }
/* harmony export */ });
/* harmony import */ var inferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65414);


function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
function isString(o) {
    return typeof o === 'string';
}
function isUndefined(o) {
    return o === void 0;
}

var componentHooks = {
    onComponentDidMount: 1,
    onComponentDidUpdate: 1,
    onComponentShouldUpdate: 1,
    onComponentWillMount: 1,
    onComponentWillUnmount: 1,
    onComponentWillUpdate: 1
};
function createElement(type, props, _children) {
    var arguments$1 = arguments;
    var children;
    var ref = null;
    var key = null;
    var className = null;
    var flags = 0;
    var newProps;
    var childLen = arguments.length - 2;
    if (childLen === 1) {
        children = _children;
    }
    else if (childLen > 1) {
        children = [];
        while (childLen-- > 0) {
            children[childLen] = arguments$1[childLen + 2];
        }
    }
    if (isString(type)) {
        flags = (0,inferno__WEBPACK_IMPORTED_MODULE_0__.getFlagsForElementVnode)(type);
        if (!isNullOrUndef(props)) {
            newProps = {};
            for (var prop in props) {
                if (prop === 'className' || prop === 'class') {
                    className = props[prop];
                }
                else if (prop === 'key') {
                    key = props.key;
                }
                else if (prop === 'children' && isUndefined(children)) {
                    children = props.children; // always favour children args over props
                }
                else if (prop === 'ref') {
                    ref = props.ref;
                }
                else {
                    if (prop === 'contenteditable') {
                        flags |= 4096 /* ContentEditable */;
                    }
                    newProps[prop] = props[prop];
                }
            }
        }
    }
    else {
        flags = 2 /* ComponentUnknown */;
        if (!isUndefined(children)) {
            if (!props) {
                props = {};
            }
            props.children = children;
        }
        if (!isNullOrUndef(props)) {
            newProps = {};
            for (var prop$1 in props) {
                if (prop$1 === 'key') {
                    key = props.key;
                }
                else if (prop$1 === 'ref') {
                    ref = props.ref;
                }
                else if (componentHooks[prop$1] === 1) {
                    if (!ref) {
                        ref = {};
                    }
                    ref[prop$1] = props[prop$1];
                }
                else {
                    newProps[prop$1] = props[prop$1];
                }
            }
        }
        return (0,inferno__WEBPACK_IMPORTED_MODULE_0__.createComponentVNode)(flags, type, newProps, key, ref);
    }
    if (flags & 8192 /* Fragment */) {
        return (0,inferno__WEBPACK_IMPORTED_MODULE_0__.createFragment)(childLen === 1 ? [children] : children, 0 /* UnknownChildren */, key);
    }
    return (0,inferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(flags, type, className, children, 0 /* UnknownChildren */, newProps, key, ref);
}




/***/ }),

/***/ 65414:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Component": function() { return /* reexport */ Component; },
  "EMPTY_OBJ": function() { return /* reexport */ EMPTY_OBJ; },
  "Fragment": function() { return /* reexport */ Fragment; },
  "_CI": function() { return /* reexport */ createClassComponentInstance; },
  "_HI": function() { return /* reexport */ normalizeRoot; },
  "_M": function() { return /* reexport */ mount; },
  "_MCCC": function() { return /* reexport */ mountClassComponentCallbacks; },
  "_ME": function() { return /* reexport */ mountElement; },
  "_MFCC": function() { return /* reexport */ mountFunctionalComponentCallbacks; },
  "_MP": function() { return /* reexport */ mountProps; },
  "_MR": function() { return /* reexport */ mountRef; },
  "_RFC": function() { return /* reexport */ renderFunctionalComponent; },
  "__render": function() { return /* reexport */ __render; },
  "createComponentVNode": function() { return /* reexport */ createComponentVNode; },
  "createFragment": function() { return /* reexport */ createFragment; },
  "createPortal": function() { return /* reexport */ createPortal; },
  "createRef": function() { return /* reexport */ createRef; },
  "createRenderer": function() { return /* reexport */ createRenderer; },
  "createTextVNode": function() { return /* reexport */ createTextVNode; },
  "createVNode": function() { return /* reexport */ createVNode; },
  "directClone": function() { return /* reexport */ directClone; },
  "findDOMfromVNode": function() { return /* reexport */ findDOMfromVNode; },
  "forwardRef": function() { return /* reexport */ forwardRef; },
  "getFlagsForElementVnode": function() { return /* reexport */ getFlagsForElementVnode; },
  "linkEvent": function() { return /* reexport */ linkEvent; },
  "normalizeProps": function() { return /* reexport */ normalizeProps; },
  "options": function() { return /* reexport */ options; },
  "render": function() { return /* reexport */ render; },
  "rerender": function() { return /* reexport */ rerender; },
  "version": function() { return /* reexport */ version; }
});

;// CONCATENATED MODULE: ../../node_modules/inferno/dist/index.esm.js
var isArray = Array.isArray;
function isStringOrNumber(o) {
    var type = typeof o;
    return type === 'string' || type === 'number';
}
function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
function isInvalid(o) {
    return o === null || o === false || o === true || o === void 0;
}
function isFunction(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isNull(o) {
    return o === null;
}
function isUndefined(o) {
    return o === void 0;
}
function combineFrom(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}

/**
 * Links given data to event as first parameter
 * @param {*} data data to be linked, it will be available in function as first parameter
 * @param {Function} event Function to be called when event occurs
 * @returns {{data: *, event: Function}}
 */
function linkEvent(data, event) {
    if (isFunction(event)) {
        return { data: data, event: event };
    }
    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers
}
// object.event should always be function, otherwise its badly created object.
function isLinkEventObject(o) {
    return !isNull(o) && typeof o === 'object';
}

// We need EMPTY_OBJ defined in one place.
// Its used for comparison so we cant inline it into shared
var EMPTY_OBJ = {};
var Fragment = '$F';
function normalizeEventName(name) {
    return name.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
    parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
    if (isNull(nextNode)) {
        appendChild(parentDOM, newNode);
    }
    else {
        parentDOM.insertBefore(newNode, nextNode);
    }
}
function documentCreateElement(tag, isSVG) {
    if (isSVG) {
        return document.createElementNS('http://www.w3.org/2000/svg', tag);
    }
    return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
    parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
    parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
    for (var i = 0; i < arrayFn.length; i++) {
        arrayFn[i]();
    }
}
function findChildVNode(vNode, startEdge, flags) {
    var children = vNode.children;
    if (flags & 4 /* ComponentClass */) {
        return children.$LI;
    }
    if (flags & 8192 /* Fragment */) {
        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];
    }
    return children;
}
function findDOMfromVNode(vNode, startEdge) {
    var flags;
    while (vNode) {
        flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            return vNode.dom;
        }
        vNode = findChildVNode(vNode, startEdge, flags);
    }
    return null;
}
function removeVNodeDOM(vNode, parentDOM) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            removeChild(parentDOM, vNode.dom);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    removeVNodeDOM(children[i], parentDOM);
                }
                return;
            }
        }
    } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            insertOrAppend(parentDOM, vNode.dom, nextNode);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    moveVNodeDOM(children[i], parentDOM, nextNode);
                }
                return;
            }
        }
    } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
    if (instance.constructor.getDerivedStateFromProps) {
        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
    }
    return state;
}
var renderCheck = {
    v: false
};
var options = {
    componentComparator: null,
    createVNode: null,
    renderComplete: null
};
function setTextContent(dom, children) {
    dom.textContent = children;
}
// Calling this function assumes, nextValue is linkEvent
function isLastValueSameLinkEvent(lastValue, nextValue) {
    return (isLinkEventObject(lastValue) &&
        lastValue.event === nextValue.event &&
        lastValue.data === nextValue.data);
}
function mergeUnsetProperties(to, from) {
    for (var propName in from) {
        if (isUndefined(to[propName])) {
            to[propName] = from[propName];
        }
    }
    return to;
}
function safeCall1(method, arg1) {
    return !!isFunction(method) && (method(arg1), true);
}

var keyPrefix = '$';
function V(childFlags, children, className, flags, key, props, ref, type) {
    this.childFlags = childFlags;
    this.children = children;
    this.className = className;
    this.dom = null;
    this.flags = flags;
    this.key = key === void 0 ? null : key;
    this.props = props === void 0 ? null : props;
    this.ref = ref === void 0 ? null : ref;
    this.type = type;
}
function createVNode(flags, type, className, children, childFlags, props, key, ref) {
    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);
    if (options.createVNode) {
        options.createVNode(vNode);
    }
    if (childFlag === 0 /* UnknownChildren */) {
        normalizeChildren(vNode, vNode.children);
    }
    return vNode;
}
function mergeDefaultHooks(flags, type, ref) {
    if (flags & 4 /* ComponentClass */) {
        return ref;
    }
    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;
    if (isNullOrUndef(defaultHooks)) {
        return ref;
    }
    if (isNullOrUndef(ref)) {
        return defaultHooks;
    }
    return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type, props) {
    // set default props
    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;
    if (isNullOrUndef(defaultProps)) {
        return props;
    }
    if (isNullOrUndef(props)) {
        return combineFrom(defaultProps, null);
    }
    return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type) {
    if (flags & 12 /* ComponentKnown */) {
        return flags;
    }
    if (type.prototype && type.prototype.render) {
        return 4 /* ComponentClass */;
    }
    if (type.render) {
        return 32776 /* ForwardRefComponent */;
    }
    return 8 /* ComponentFunction */;
}
function createComponentVNode(flags, type, props, key, ref) {
    flags = resolveComponentFlags(flags, type);
    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);
    if (options.createVNode) {
        options.createVNode(vNode);
    }
    return vNode;
}
function createTextVNode(text, key) {
    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);
}
function createFragment(children, childFlags, key) {
    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);
    switch (fragment.childFlags) {
        case 1 /* HasInvalidChildren */:
            fragment.children = createVoidVNode();
            fragment.childFlags = 2 /* HasVNodeChildren */;
            break;
        case 16 /* HasTextChildren */:
            fragment.children = [createTextVNode(children)];
            fragment.childFlags = 4 /* HasNonKeyedChildren */;
            break;
    }
    return fragment;
}
function normalizeProps(vNode) {
    var props = vNode.props;
    if (props) {
        var flags = vNode.flags;
        if (flags & 481 /* Element */) {
            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
                normalizeChildren(vNode, props.children);
            }
            if (props.className !== void 0) {
                if (isNullOrUndef(vNode.className)) {
                    vNode.className = props.className || null;
                }
                props.className = undefined;
            }
        }
        if (props.key !== void 0) {
            vNode.key = props.key;
            props.key = undefined;
        }
        if (props.ref !== void 0) {
            if (flags & 8 /* ComponentFunction */) {
                vNode.ref = combineFrom(vNode.ref, props.ref);
            }
            else {
                vNode.ref = props.ref;
            }
            props.ref = undefined;
        }
    }
    return vNode;
}
/*
 * Fragment is different than normal vNode,
 * because when it needs to be cloned we need to clone its children too
 * But not normalize, because otherwise those possibly get KEY and re-mount
 */
function cloneFragment(vNodeToClone) {
    var oldChildren = vNodeToClone.children;
    var childFlags = vNodeToClone.childFlags;
    return createFragment(childFlags === 2 /* HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;
    var props = vNodeToClone.props;
    if (flags & 14 /* Component */) {
        if (!isNull(props)) {
            var propsToClone = props;
            props = {};
            for (var key in propsToClone) {
                props[key] = propsToClone[key];
            }
        }
    }
    if ((flags & 8192 /* Fragment */) === 0) {
        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
    }
    return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
    return createTextVNode('', null);
}
function createPortal(children, container) {
    var normalizedRoot = normalizeRoot(children);
    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);
}
function _normalizeVNodes(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
        var n = nodes[index];
        if (!isInvalid(n)) {
            var newKey = currentKey + keyPrefix + index;
            if (isArray(n)) {
                _normalizeVNodes(n, result, 0, newKey);
            }
            else {
                if (isStringOrNumber(n)) {
                    n = createTextVNode(n, newKey);
                }
                else {
                    var oldKey = n.key;
                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;
                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {
                        n = directClone(n);
                    }
                    n.flags |= 65536 /* Normalized */;
                    if (!isPrefixedKey) {
                        if (isNull(oldKey)) {
                            n.key = newKey;
                        }
                        else {
                            n.key = currentKey + oldKey;
                        }
                    }
                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {
                        n.key = currentKey + oldKey;
                    }
                }
                result.push(n);
            }
        }
    }
}
function getFlagsForElementVnode(type) {
    switch (type) {
        case 'svg':
            return 32 /* SvgElement */;
        case 'input':
            return 64 /* InputElement */;
        case 'select':
            return 256 /* SelectElement */;
        case 'textarea':
            return 128 /* TextareaElement */;
        case Fragment:
            return 8192 /* Fragment */;
        default:
            return 1 /* HtmlElement */;
    }
}
function normalizeChildren(vNode, children) {
    var newChildren;
    var newChildFlags = 1 /* HasInvalidChildren */;
    // Don't change children to match strict equal (===) true in patching
    if (isInvalid(children)) {
        newChildren = children;
    }
    else if (isStringOrNumber(children)) {
        newChildFlags = 16 /* HasTextChildren */;
        newChildren = children;
    }
    else if (isArray(children)) {
        var len = children.length;
        for (var i = 0; i < len; ++i) {
            var n = children[i];
            if (isInvalid(n) || isArray(n)) {
                newChildren = newChildren || children.slice(0, i);
                _normalizeVNodes(children, newChildren, i, '');
                break;
            }
            else if (isStringOrNumber(n)) {
                newChildren = newChildren || children.slice(0, i);
                newChildren.push(createTextVNode(n, keyPrefix + i));
            }
            else {
                var key = n.key;
                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;
                var isNullKey = isNull(key);
                var isPrefixed = isString(key) && key[0] === keyPrefix;
                if (needsCloning || isNullKey || isPrefixed) {
                    newChildren = newChildren || children.slice(0, i);
                    if (needsCloning || isPrefixed) {
                        n = directClone(n);
                    }
                    if (isNullKey || isPrefixed) {
                        n.key = keyPrefix + i;
                    }
                    newChildren.push(n);
                }
                else if (newChildren) {
                    newChildren.push(n);
                }
                n.flags |= 65536 /* Normalized */;
            }
        }
        newChildren = newChildren || children;
        if (newChildren.length === 0) {
            newChildFlags = 1 /* HasInvalidChildren */;
        }
        else {
            newChildFlags = 8 /* HasKeyedChildren */;
        }
    }
    else {
        newChildren = children;
        newChildren.flags |= 65536 /* Normalized */;
        if (children.flags & 81920 /* InUseOrNormalized */) {
            newChildren = directClone(children);
        }
        newChildFlags = 2 /* HasVNodeChildren */;
    }
    vNode.children = newChildren;
    vNode.childFlags = newChildFlags;
    return vNode;
}
function normalizeRoot(input) {
    if (isInvalid(input) || isStringOrNumber(input)) {
        return createTextVNode(input, null);
    }
    if (isArray(input)) {
        return createFragment(input, 0 /* UnknownChildren */, null);
    }
    return input.flags & 16384 /* InUse */ ? directClone(input) : input;
}

var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var namespaces = {
    'xlink:actuate': xlinkNS,
    'xlink:arcrole': xlinkNS,
    'xlink:href': xlinkNS,
    'xlink:role': xlinkNS,
    'xlink:show': xlinkNS,
    'xlink:title': xlinkNS,
    'xlink:type': xlinkNS,
    'xml:base': xmlNS,
    'xml:lang': xmlNS,
    'xml:space': xmlNS
};

function getDelegatedEventObject(v) {
    return {
        onClick: v,
        onDblClick: v,
        onFocusIn: v,
        onFocusOut: v,
        onKeyDown: v,
        onKeyPress: v,
        onKeyUp: v,
        onMouseDown: v,
        onMouseMove: v,
        onMouseUp: v,
        onTouchEnd: v,
        onTouchMove: v,
        onTouchStart: v
    };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (!eventsObject) {
        eventsObject = dom.$EV = getDelegatedEventObject(null);
    }
    if (!eventsObject[name]) {
        if (++attachedEventCounts[name] === 1) {
            attachedEvents[name] = attachEventToDocument(name);
        }
    }
    return eventsObject;
}
function unmountSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (eventsObject && eventsObject[name]) {
        if (--attachedEventCounts[name] === 0) {
            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);
            attachedEvents[name] = null;
        }
        eventsObject[name] = null;
    }
}
function handleSyntheticEvent(name, lastEvent, nextEvent, dom) {
    if (isFunction(nextEvent)) {
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else if (isLinkEventObject(nextEvent)) {
        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
            return;
        }
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else {
        unmountSyntheticEvent(name, dom);
    }
}
// When browsers fully support event.composedPath we could loop it through instead of using parentNode property
function getTargetNode(event) {
    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name, eventData) {
    var dom = getTargetNode(event);
    do {
        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
        // because the event listener is on document.body
        // Don't process clicks on disabled elements
        if (isClick && dom.disabled) {
            return;
        }
        var eventsObject = dom.$EV;
        if (eventsObject) {
            var currentEvent = eventsObject[name];
            if (currentEvent) {
                // linkEvent object
                eventData.dom = dom;
                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }
        dom = dom.parentNode;
    } while (!isNull(dom));
}
function stopPropagation() {
    this.cancelBubble = true;
    if (!this.immediatePropagationStopped) {
        this.stopImmediatePropagation();
    }
}
function isDefaultPrevented() {
    return this.defaultPrevented;
}
function isPropagationStopped() {
    return this.cancelBubble;
}
function extendEventProperties(event) {
    // Event data needs to be object to save reference to currentTarget getter
    var eventData = {
        dom: document
    };
    event.isDefaultPrevented = isDefaultPrevented;
    event.isPropagationStopped = isPropagationStopped;
    event.stopPropagation = stopPropagation;
    Object.defineProperty(event, 'currentTarget', {
        configurable: true,
        get: function get() {
            return eventData.dom;
        }
    });
    return eventData;
}
function rootClickEvent(name) {
    return function (event) {
        if (event.button !== 0) {
            // Firefox incorrectly triggers click event for mid/right mouse buttons.
            // This bug has been active for 17 years.
            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051
            event.stopPropagation();
            return;
        }
        dispatchEvents(event, true, name, extendEventProperties(event));
    };
}
function rootEvent(name) {
    return function (event) {
        dispatchEvents(event, false, name, extendEventProperties(event));
    };
}
function attachEventToDocument(name) {
    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);
    document.addEventListener(normalizeEventName(name), attachedEvent);
    return attachedEvent;
}

function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}

function triggerEventListener(props, methodName, e) {
    if (props[methodName]) {
        var listener = props[methodName];
        if (listener.event) {
            listener.event(listener.data, e);
        }
        else {
            listener(e);
        }
    }
    else {
        var nativeListenerName = methodName.toLowerCase();
        if (props[nativeListenerName]) {
            props[nativeListenerName](e);
        }
    }
}
function createWrappedFunction(methodName, applyValue) {
    var fnMethod = function (e) {
        var vNode = this.$V;
        // If vNode is gone by the time event fires, no-op
        if (!vNode) {
            return;
        }
        var props = vNode.props || EMPTY_OBJ;
        var dom = vNode.dom;
        if (isString(methodName)) {
            triggerEventListener(props, methodName, e);
        }
        else {
            for (var i = 0; i < methodName.length; ++i) {
                triggerEventListener(props, methodName[i], e);
            }
        }
        if (isFunction(applyValue)) {
            var newVNode = this.$V;
            var newProps = newVNode.props || EMPTY_OBJ;
            applyValue(newProps, dom, false, newVNode);
        }
    };
    Object.defineProperty(fnMethod, 'wrapped', {
        configurable: false,
        enumerable: false,
        value: true,
        writable: false
    });
    return fnMethod;
}

function attachEvent(dom, eventName, handler) {
    var previousKey = "$" + eventName;
    var previousArgs = dom[previousKey];
    if (previousArgs) {
        if (previousArgs[1].wrapped) {
            return;
        }
        dom.removeEventListener(previousArgs[0], previousArgs[1]);
        dom[previousKey] = null;
    }
    if (isFunction(handler)) {
        dom.addEventListener(eventName, handler);
        dom[previousKey] = [eventName, handler];
    }
}

function isCheckedType(type) {
    return type === 'checkbox' || type === 'radio';
}
var onTextInputChange = createWrappedFunction('onInput', applyValueInput);
var wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);
/* tslint:disable-next-line:no-empty */
function emptywrapper(event) {
    event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
    if (isCheckedType(nextPropsOrEmpty.type)) {
        attachEvent(dom, 'change', wrappedOnChange);
        attachEvent(dom, 'click', emptywrapper);
    }
    else {
        attachEvent(dom, 'input', onTextInputChange);
    }
}
function applyValueInput(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef(value);
    if (type && type !== dom.type) {
        dom.setAttribute('type', type);
    }
    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!isNullOrUndef(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
    else {
        if (hasValue && dom.value !== value) {
            dom.defaultValue = value;
            dom.value = value;
        }
        else if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
}

function updateChildOptions(vNode, value) {
    if (vNode.type === 'option') {
        updateChildOption(vNode, value);
    }
    else {
        var children = vNode.children;
        var flags = vNode.flags;
        if (flags & 4 /* ComponentClass */) {
            updateChildOptions(children.$LI, value);
        }
        else if (flags & 8 /* ComponentFunction */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags & 12 /* MultipleChildren */) {
            for (var i = 0, len = children.length; i < len; ++i) {
                updateChildOptions(children[i], value);
            }
        }
    }
}
function updateChildOption(vNode, value) {
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {
        dom.selected = true;
    }
    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {
        dom.selected = props.selected || false;
    }
}
var onSelectChange = createWrappedFunction('onChange', applyValueSelect);
function selectEvents(dom) {
    attachEvent(dom, 'change', onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
        dom.multiple = multiplePropInBoolean;
    }
    var index = nextPropsOrEmpty.selectedIndex;
    if (index === -1) {
        dom.selectedIndex = -1;
    }
    var childFlags = vNode.childFlags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        var value = nextPropsOrEmpty.value;
        if (isNumber(index) && index > -1 && dom.options[index]) {
            value = dom.options[index].value;
        }
        if (mounting && isNullOrUndef(value)) {
            value = nextPropsOrEmpty.defaultValue;
        }
        updateChildOptions(vNode, value);
    }
}

var onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);
var wrappedOnChange$1 = createWrappedFunction('onChange');
function textAreaEvents(dom, nextPropsOrEmpty) {
    attachEvent(dom, 'input', onTextareaInputChange);
    if (nextPropsOrEmpty.onChange) {
        attachEvent(dom, 'change', wrappedOnChange$1);
    }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef(value)) {
        if (mounting) {
            var defaultValue = nextPropsOrEmpty.defaultValue;
            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
                dom.defaultValue = defaultValue;
                dom.value = defaultValue;
            }
        }
    }
    else if (domValue !== value) {
        /* There is value so keep it controlled */
        dom.defaultValue = value;
        dom.value = value;
    }
}

function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    if (flags & 64 /* InputElement */) {
        applyValueInput(nextPropsOrEmpty, dom);
    }
    else if (flags & 256 /* SelectElement */) {
        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
    }
    else if (flags & 128 /* TextareaElement */) {
        applyValueTextArea(nextPropsOrEmpty, dom, mounting);
    }
    if (isControlled) {
        dom.$V = vNode;
    }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
    if (flags & 64 /* InputElement */) {
        inputEvents(dom, nextPropsOrEmpty);
    }
    else if (flags & 256 /* SelectElement */) {
        selectEvents(dom);
    }
    else if (flags & 128 /* TextareaElement */) {
        textAreaEvents(dom, nextPropsOrEmpty);
    }
}
function isControlledFormElement(nextPropsOrEmpty) {
    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}

function createRef() {
    return {
        current: null
    };
}
function forwardRef(render) {
    // @ts-ignore
    return {
        render: render
    };
}
function unmountRef(ref) {
    if (ref) {
        if (!safeCall1(ref, null) && ref.current) {
            ref.current = null;
        }
    }
}
function mountRef(ref, value, lifecycle) {
    if (ref && (isFunction(ref) || ref.current !== void 0)) {
        lifecycle.push(function () {
            if (!safeCall1(ref, value) && ref.current !== void 0) {
                ref.current = value;
            }
        });
    }
}

function remove(vNode, parentDOM) {
    unmount(vNode);
    removeVNodeDOM(vNode, parentDOM);
}
function unmount(vNode) {
    var flags = vNode.flags;
    var children = vNode.children;
    var ref;
    if (flags & 481 /* Element */) {
        ref = vNode.ref;
        var props = vNode.props;
        unmountRef(ref);
        var childFlags = vNode.childFlags;
        if (!isNull(props)) {
            var keys = Object.keys(props);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                if (syntheticEvents[key]) {
                    unmountSyntheticEvent(key, vNode.dom);
                }
            }
        }
        if (childFlags & 12 /* MultipleChildren */) {
            unmountAllChildren(children);
        }
        else if (childFlags === 2 /* HasVNodeChildren */) {
            unmount(children);
        }
    }
    else if (children) {
        if (flags & 4 /* ComponentClass */) {
            if (isFunction(children.componentWillUnmount)) {
                children.componentWillUnmount();
            }
            unmountRef(vNode.ref);
            children.$UN = true;
            unmount(children.$LI);
        }
        else if (flags & 8 /* ComponentFunction */) {
            ref = vNode.ref;
            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {
                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
            }
            unmount(children);
        }
        else if (flags & 1024 /* Portal */) {
            remove(children, vNode.ref);
        }
        else if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags & 12 /* MultipleChildren */) {
                unmountAllChildren(children);
            }
        }
    }
}
function unmountAllChildren(children) {
    for (var i = 0, len = children.length; i < len; ++i) {
        unmount(children[i]);
    }
}
function clearDOM(dom) {
    // Optimization for clearing dom
    dom.textContent = '';
}
function removeAllChildren(dom, vNode, children) {
    unmountAllChildren(children);
    if (vNode.flags & 8192 /* Fragment */) {
        removeVNodeDOM(vNode, dom);
    }
    else {
        clearDOM(dom);
    }
}

function wrapLinkEvent(nextValue) {
    // This variable makes sure there is no "this" context in callback
    var ev = nextValue.event;
    return function (e) {
        ev(nextValue.data, e);
    };
}
function patchEvent(name, lastValue, nextValue, dom) {
    if (isLinkEventObject(nextValue)) {
        if (isLastValueSameLinkEvent(lastValue, nextValue)) {
            return;
        }
        nextValue = wrapLinkEvent(nextValue);
    }
    attachEvent(dom, normalizeEventName(name), nextValue);
}
// We are assuming here that we come from patchProp routine
// -nextAttrValue cannot be null or undefined
function patchStyle(lastAttrValue, nextAttrValue, dom) {
    if (isNullOrUndef(nextAttrValue)) {
        dom.removeAttribute('style');
        return;
    }
    var domStyle = dom.style;
    var style;
    var value;
    if (isString(nextAttrValue)) {
        domStyle.cssText = nextAttrValue;
        return;
    }
    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {
        for (style in nextAttrValue) {
            // do not add a hasOwnProperty check here, it affects performance
            value = nextAttrValue[style];
            if (value !== lastAttrValue[style]) {
                domStyle.setProperty(style, value);
            }
        }
        for (style in lastAttrValue) {
            if (isNullOrUndef(nextAttrValue[style])) {
                domStyle.removeProperty(style);
            }
        }
    }
    else {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            domStyle.setProperty(style, value);
        }
    }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
    var lastHtml = (lastValue && lastValue.__html) || '';
    var nextHtml = (nextValue && nextValue.__html) || '';
    if (lastHtml !== nextHtml) {
        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
            if (!isNull(lastVNode)) {
                if (lastVNode.childFlags & 12 /* MultipleChildren */) {
                    unmountAllChildren(lastVNode.children);
                }
                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {
                    unmount(lastVNode.children);
                }
                lastVNode.children = null;
                lastVNode.childFlags = 1 /* HasInvalidChildren */;
            }
            dom.innerHTML = nextHtml;
        }
    }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
    switch (prop) {
        case 'children':
        case 'childrenType':
        case 'className':
        case 'defaultValue':
        case 'key':
        case 'multiple':
        case 'ref':
        case 'selectedIndex':
            break;
        case 'autoFocus':
            dom.autofocus = !!nextValue;
            break;
        case 'allowfullscreen':
        case 'autoplay':
        case 'capture':
        case 'checked':
        case 'controls':
        case 'default':
        case 'disabled':
        case 'hidden':
        case 'indeterminate':
        case 'loop':
        case 'muted':
        case 'novalidate':
        case 'open':
        case 'readOnly':
        case 'required':
        case 'reversed':
        case 'scoped':
        case 'seamless':
        case 'selected':
            dom[prop] = !!nextValue;
            break;
        case 'defaultChecked':
        case 'value':
        case 'volume':
            if (hasControlledValue && prop === 'value') {
                break;
            }
            var value = isNullOrUndef(nextValue) ? '' : nextValue;
            if (dom[prop] !== value) {
                dom[prop] = value;
            }
            break;
        case 'style':
            patchStyle(lastValue, nextValue, dom);
            break;
        case 'dangerouslySetInnerHTML':
            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
            break;
        default:
            if (syntheticEvents[prop]) {
                handleSyntheticEvent(prop, lastValue, nextValue, dom);
            }
            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
                patchEvent(prop, lastValue, nextValue, dom);
            }
            else if (isNullOrUndef(nextValue)) {
                dom.removeAttribute(prop);
            }
            else if (isSVG && namespaces[prop]) {
                // We optimize for isSVG being false
                // If we end up in this path we can read property again
                dom.setAttributeNS(namespaces[prop], prop, nextValue);
            }
            else {
                dom.setAttribute(prop, nextValue);
            }
            break;
    }
}
function mountProps(vNode, flags, props, dom, isSVG) {
    var hasControlledValue = false;
    var isFormElement = (flags & 448 /* FormElement */) > 0;
    if (isFormElement) {
        hasControlledValue = isControlledFormElement(props);
        if (hasControlledValue) {
            addFormElementEventHandlers(flags, dom, props);
        }
    }
    for (var prop in props) {
        // do not add a hasOwnProperty check here, it affects performance
        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
    }
    if (isFormElement) {
        processElement(flags, vNode, dom, props, true, hasControlledValue);
    }
}

function renderNewInput(instance, props, context) {
    var nextInput = normalizeRoot(instance.render(props, instance.state, context));
    var childContext = context;
    if (isFunction(instance.getChildContext)) {
        childContext = combineFrom(context, instance.getChildContext());
    }
    instance.$CX = childContext;
    return nextInput;
}
function createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {
    var instance = new Component(props, context);
    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));
    instance.$SVG = isSVG;
    instance.$L = lifecycle;
    vNode.children = instance;
    instance.$BS = false;
    instance.context = context;
    if (instance.props === EMPTY_OBJ) {
        instance.props = props;
    }
    if (!usesNewAPI) {
        if (isFunction(instance.componentWillMount)) {
            instance.$BR = true;
            instance.componentWillMount();
            var pending = instance.$PS;
            if (!isNull(pending)) {
                var state = instance.state;
                if (isNull(state)) {
                    instance.state = pending;
                }
                else {
                    for (var key in pending) {
                        state[key] = pending[key];
                    }
                }
                instance.$PS = null;
            }
            instance.$BR = false;
        }
    }
    else {
        instance.state = createDerivedState(instance, props, instance.state);
    }
    instance.$LI = renderNewInput(instance, props, context);
    return instance;
}
function renderFunctionalComponent(vNode, context) {
    var props = vNode.props || EMPTY_OBJ;
    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);
}

function mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = (vNode.flags |= 16384 /* InUse */);
    if (flags & 481 /* Element */) {
        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 4 /* ComponentClass */) {
        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 8 /* ComponentFunction */) {
        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
        mountFunctionalComponentCallbacks(vNode, lifecycle);
    }
    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {
        mountText(vNode, parentDOM, nextNode);
    }
    else if (flags & 8192 /* Fragment */) {
        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);
    }
    else if (flags & 1024 /* Portal */) {
        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);
    }
    else ;
}
function mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {
    mount(vNode.children, vNode.ref, context, false, null, lifecycle);
    var placeHolderVNode = createVoidVNode();
    mountText(placeHolderVNode, parentDOM, nextNode);
    vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {
    var children = vNode.children;
    var childFlags = vNode.childFlags;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {
        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;
        children = vNode.children = createVoidVNode();
    }
    if (childFlags === 2 /* HasVNodeChildren */) {
        mount(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else {
        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
}
function mountText(vNode, parentDOM, nextNode) {
    var dom = (vNode.dom = document.createTextNode(vNode.children));
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
}
function mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = vNode.flags;
    var props = vNode.props;
    var className = vNode.className;
    var childFlags = vNode.childFlags;
    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));
    var children = vNode.children;
    if (!isNullOrUndef(className) && className !== '') {
        if (isSVG) {
            dom.setAttribute('class', className);
        }
        else {
            dom.className = className;
        }
    }
    if (childFlags === 16 /* HasTextChildren */) {
        setTextContent(dom, children);
    }
    else if (childFlags !== 1 /* HasInvalidChildren */) {
        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';
        if (childFlags === 2 /* HasVNodeChildren */) {
            if (children.flags & 16384 /* InUse */) {
                vNode.children = children = directClone(children);
            }
            mount(children, dom, context, childrenIsSVG, null, lifecycle);
        }
        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {
            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);
        }
    }
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
    if (!isNull(props)) {
        mountProps(vNode, flags, props, dom, isSVG);
    }
    mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {
    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child.flags & 16384 /* InUse */) {
            children[i] = child = directClone(child);
        }
        mount(child, dom, context, isSVG, nextNode, lifecycle);
    }
}
function mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);
    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
    return function () {
        instance.componentDidMount();
    };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
    mountRef(ref, instance, lifecycle);
    if (isFunction(instance.componentDidMount)) {
        lifecycle.push(createClassMountCallback(instance));
    }
}
function createOnMountCallback(ref, vNode) {
    return function () {
        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
    };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
    var ref = vNode.ref;
    if (!isNullOrUndef(ref)) {
        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
        if (isFunction(ref.onComponentDidMount)) {
            lifecycle.push(createOnMountCallback(ref, vNode));
        }
    }
}

function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    unmount(lastVNode);
    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {
        mount(nextVNode, null, context, isSVG, null, lifecycle);
        // Single DOM operation, when we have dom references available
        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
    }
    else {
        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
        removeVNodeDOM(lastVNode, parentDOM);
    }
}
function patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);
    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {
        if (lastVNode.flags & 16384 /* InUse */) {
            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
        }
        else {
            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one
            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (nextFlags & 481 /* Element */) {
        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);
    }
    else if (nextFlags & 4 /* ComponentClass */) {
        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 8 /* ComponentFunction */) {
        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 16 /* Text */) {
        patchText(lastVNode, nextVNode);
    }
    else if (nextFlags & 512 /* Void */) {
        nextVNode.dom = lastVNode.dom;
    }
    else if (nextFlags & 8192 /* Fragment */) {
        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
    }
    else {
        patchPortal(lastVNode, nextVNode, context, lifecycle);
    }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
    if (lastChildren !== nextChildren) {
        if (lastChildren !== '') {
            parentDOM.firstChild.nodeValue = nextChildren;
        }
        else {
            setTextContent(parentDOM, nextChildren);
        }
    }
}
function patchContentEditableChildren(dom, nextChildren) {
    if (dom.textContent !== nextChildren) {
        dom.textContent = nextChildren;
    }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    var lastChildren = lastVNode.children;
    var nextChildren = nextVNode.children;
    var lastChildFlags = lastVNode.childFlags;
    var nextChildFlags = nextVNode.childFlags;
    var nextNode = null;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {
        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;
        nextChildren = nextVNode.children = createVoidVNode();
    }
    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;
    if (lastChildFlags & 12 /* MultipleChildren */) {
        var lastLen = lastChildren.length;
        // We need to know Fragment's edge node when
        if (
        // It uses keyed algorithm
        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||
            // It transforms from many to single
            nextIsSingle ||
            // It will append more nodes
            (!nextIsSingle && nextChildren.length > lastLen)) {
            // When fragment has multiple children there is always at least one vNode
            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
        }
    }
    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context, lifecycle) {
    var lastContainer = lastVNode.ref;
    var nextContainer = nextVNode.ref;
    var nextChildren = nextVNode.children;
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);
    nextVNode.dom = lastVNode.dom;
    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
        var node = nextChildren.dom;
        removeChild(lastContainer, node);
        appendChild(nextContainer, node);
    }
}
function patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {
    var dom = (nextVNode.dom = lastVNode.dom);
    var lastProps = lastVNode.props;
    var nextProps = nextVNode.props;
    var isFormElement = false;
    var hasControlledValue = false;
    var nextPropsOrEmpty;
    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;
    // inlined patchProps  -- starts --
    if (lastProps !== nextProps) {
        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
        nextPropsOrEmpty = nextProps || EMPTY_OBJ;
        if (nextPropsOrEmpty !== EMPTY_OBJ) {
            isFormElement = (nextFlags & 448 /* FormElement */) > 0;
            if (isFormElement) {
                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
            }
            for (var prop in nextPropsOrEmpty) {
                var lastValue = lastPropsOrEmpty[prop];
                var nextValue = nextPropsOrEmpty[prop];
                if (lastValue !== nextValue) {
                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
        if (lastPropsOrEmpty !== EMPTY_OBJ) {
            for (var prop$1 in lastPropsOrEmpty) {
                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
    }
    var nextChildren = nextVNode.children;
    var nextClassName = nextVNode.className;
    // inlined patchProps  -- ends --
    if (lastVNode.className !== nextClassName) {
        if (isNullOrUndef(nextClassName)) {
            dom.removeAttribute('class');
        }
        else if (isSVG) {
            dom.setAttribute('class', nextClassName);
        }
        else {
            dom.className = nextClassName;
        }
    }
    if (nextFlags & 4096 /* ContentEditable */) {
        patchContentEditableChildren(dom, nextChildren);
    }
    else {
        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);
    }
    if (isFormElement) {
        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
    }
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, dom, lifecycle);
    }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {
    unmount(lastChildren);
    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
    removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {
    switch (lastChildFlags) {
        case 2 /* HasVNodeChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    remove(lastChildren, parentDOM);
                    break;
                case 16 /* HasTextChildren */:
                    unmount(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);
                    break;
            }
            break;
        case 1 /* HasInvalidChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    break;
                case 16 /* HasTextChildren */:
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        case 16 /* HasTextChildren */:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);
                    break;
                case 2 /* HasVNodeChildren */:
                    clearDOM(parentDOM);
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    clearDOM(parentDOM);
                    break;
                default:
                    clearDOM(parentDOM);
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        default:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    unmountAllChildren(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                case 2 /* HasVNodeChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    break;
                default:
                    var lastLength = lastChildren.length | 0;
                    var nextLength = nextChildren.length | 0;
                    // Fast path's for both algorithms
                    if (lastLength === 0) {
                        if (nextLength > 0) {
                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                        }
                    }
                    else if (nextLength === 0) {
                        removeAllChildren(parentDOM, parentVNode, lastChildren);
                    }
                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {
                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
                    }
                    else {
                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);
                    }
                    break;
            }
            break;
    }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
    lifecycle.push(function () {
        instance.componentDidUpdate(lastProps, lastState, snapshot);
    });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {
    var lastState = instance.state;
    var lastProps = instance.props;
    var usesNewAPI = Boolean(instance.$N);
    var hasSCU = isFunction(instance.shouldComponentUpdate);
    if (usesNewAPI) {
        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
    }
    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {
        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {
            instance.componentWillUpdate(nextProps, nextState, context);
        }
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
        var snapshot = null;
        var nextInput = renderNewInput(instance, nextProps, context);
        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {
            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
        }
        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
        // Dont update Last input, until patch has been succesfully executed
        instance.$LI = nextInput;
        if (isFunction(instance.componentDidUpdate)) {
            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
        }
    }
    else {
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
    }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = (nextVNode.children = lastVNode.children);
    // If Component has crashed, ignore it to stay functional
    if (isNull(instance)) {
        return;
    }
    instance.$L = lifecycle;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    var nextState = instance.state;
    if (!instance.$N) {
        if (isFunction(instance.componentWillReceiveProps)) {
            instance.$BR = true;
            instance.componentWillReceiveProps(nextProps, context);
            // If instance component was removed during its own update do nothing.
            if (instance.$UN) {
                return;
            }
            instance.$BR = false;
        }
        if (!isNull(instance.$PS)) {
            nextState = combineFrom(nextState, instance.$PS);
            instance.$PS = null;
        }
    }
    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, instance, lifecycle);
    }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var shouldUpdate = true;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastProps = lastVNode.props;
    var nextHooksDefined = !isNullOrUndef(nextRef);
    var lastInput = lastVNode.children;
    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {
        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
    }
    if (shouldUpdate !== false) {
        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {
            nextRef.onComponentWillUpdate(lastProps, nextProps);
        }
        var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));
        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);
        nextVNode.children = nextInput;
        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {
            nextRef.onComponentDidUpdate(lastProps, nextProps);
        }
    }
    else {
        nextVNode.children = lastInput;
    }
}
function patchText(lastVNode, nextVNode) {
    var nextText = nextVNode.children;
    var dom = (nextVNode.dom = lastVNode.dom);
    if (nextText !== lastVNode.children) {
        dom.nodeValue = nextText;
    }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
    var i = 0;
    var nextChild;
    var lastChild;
    for (; i < commonLength; ++i) {
        nextChild = nextChildren[i];
        lastChild = lastChildren[i];
        if (nextChild.flags & 16384 /* InUse */) {
            nextChild = nextChildren[i] = directClone(nextChild);
        }
        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);
        lastChildren[i] = nextChild;
    }
    if (lastChildrenLength < nextChildrenLength) {
        for (i = commonLength; i < nextChildrenLength; ++i) {
            nextChild = nextChildren[i];
            if (nextChild.flags & 16384 /* InUse */) {
                nextChild = nextChildren[i] = directClone(nextChild);
            }
            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (lastChildrenLength > nextChildrenLength) {
        for (i = commonLength; i < lastChildrenLength; ++i) {
            remove(lastChildren[i], dom);
        }
    }
}
function patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var j = 0;
    var aNode = a[j];
    var bNode = b[j];
    var nextPos;
    var nextNode;
    // Step 1
    // tslint:disable-next-line
    outer: {
        // Sync nodes with the same key at the beginning.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[j] = bNode;
            ++j;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[j];
            bNode = b[j];
        }
        aNode = a[aEnd];
        bNode = b[bEnd];
        // Sync nodes with the same key at the end.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[bEnd] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[aEnd] = bNode;
            aEnd--;
            bEnd--;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[aEnd];
            bNode = b[bEnd];
        }
    }
    if (j > aEnd) {
        if (j <= bEnd) {
            nextPos = bEnd + 1;
            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
            while (j <= bEnd) {
                bNode = b[j];
                if (bNode.flags & 16384 /* InUse */) {
                    b[j] = bNode = directClone(bNode);
                }
                ++j;
                mount(bNode, dom, context, isSVG, nextNode, lifecycle);
            }
        }
    }
    else if (j > bEnd) {
        while (j <= aEnd) {
            remove(a[j++], dom);
        }
    }
    else {
        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
    }
}
function patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
    var aNode;
    var bNode;
    var nextPos;
    var i = 0;
    var aStart = j;
    var bStart = j;
    var aLeft = aEnd - j + 1;
    var bLeft = bEnd - j + 1;
    var sources = new Int32Array(bLeft + 1);
    // Keep track if its possible to remove whole DOM using textContent = '';
    var canRemoveWholeContent = aLeft === aLength;
    var moved = false;
    var pos = 0;
    var patched = 0;
    // When sizes are small, just loop them through
    if (bLength < 4 || (aLeft | bLeft) < 32) {
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                for (j = bStart; j <= bEnd; j++) {
                    bNode = b[j];
                    if (aNode.key === bNode.key) {
                        sources[j - bStart] = i + 1;
                        if (canRemoveWholeContent) {
                            canRemoveWholeContent = false;
                            while (aStart < i) {
                                remove(a[aStart++], dom);
                            }
                        }
                        if (pos > j) {
                            moved = true;
                        }
                        else {
                            pos = j;
                        }
                        if (bNode.flags & 16384 /* InUse */) {
                            b[j] = bNode = directClone(bNode);
                        }
                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                        ++patched;
                        break;
                    }
                }
                if (!canRemoveWholeContent && j > bEnd) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    else {
        var keyIndex = {};
        // Map keys by their index
        for (i = bStart; i <= bEnd; ++i) {
            keyIndex[b[i].key] = i;
        }
        // Try to patch same keys
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                j = keyIndex[aNode.key];
                if (j !== void 0) {
                    if (canRemoveWholeContent) {
                        canRemoveWholeContent = false;
                        while (i > aStart) {
                            remove(a[aStart++], dom);
                        }
                    }
                    sources[j - bStart] = i + 1;
                    if (pos > j) {
                        moved = true;
                    }
                    else {
                        pos = j;
                    }
                    bNode = b[j];
                    if (bNode.flags & 16384 /* InUse */) {
                        b[j] = bNode = directClone(bNode);
                    }
                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                    ++patched;
                }
                else if (!canRemoveWholeContent) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    // fast-path: if nothing patched remove all old and add all new
    if (canRemoveWholeContent) {
        removeAllChildren(dom, parentVNode, a);
        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);
    }
    else if (moved) {
        var seq = lis_algorithm(sources);
        j = seq.length - 1;
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
            else if (j < 0 || i !== seq[j]) {
                pos = i + bStart;
                bNode = b[pos];
                nextPos = pos + 1;
                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
            }
            else {
                j--;
            }
        }
    }
    else if (patched !== bLeft) {
        // when patched count doesn't match b length we need to insert those new ones
        // loop backwards so we can use insertBefore
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
        }
    }
}
var result;
var p;
var maxLen = 0;
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function lis_algorithm(arr) {
    var arrI = 0;
    var i = 0;
    var j = 0;
    var k = 0;
    var u = 0;
    var v = 0;
    var c = 0;
    var len = arr.length;
    if (len > maxLen) {
        maxLen = len;
        result = new Int32Array(len);
        p = new Int32Array(len);
    }
    for (; i < len; ++i) {
        arrI = arr[i];
        if (arrI !== 0) {
            j = result[k];
            if (arr[j] < arrI) {
                p[i] = j;
                result[++k] = i;
                continue;
            }
            u = 0;
            v = k;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = k + 1;
    var seq = new Int32Array(u);
    v = result[u - 1];
    while (u-- > 0) {
        seq[u] = v;
        v = p[v];
        result[u] = 0;
    }
    return seq;
}

var hasDocumentAvailable = typeof document !== 'undefined';
if (hasDocumentAvailable) {
    /*
     * Defining $EV and $V properties on Node.prototype
     * fixes v8 "wrong map" de-optimization
     */
    if (window.Node) {
        Node.prototype.$EV = null;
        Node.prototype.$V = null;
    }
}
function __render(input, parentDOM, callback, context) {
    var lifecycle = [];
    var rootInput = parentDOM.$V;
    renderCheck.v = true;
    if (isNullOrUndef(rootInput)) {
        if (!isNullOrUndef(input)) {
            if (input.flags & 16384 /* InUse */) {
                input = directClone(input);
            }
            mount(input, parentDOM, context, false, null, lifecycle);
            parentDOM.$V = input;
            rootInput = input;
        }
    }
    else {
        if (isNullOrUndef(input)) {
            remove(rootInput, parentDOM);
            parentDOM.$V = null;
        }
        else {
            if (input.flags & 16384 /* InUse */) {
                input = directClone(input);
            }
            patch(rootInput, input, parentDOM, context, false, null, lifecycle);
            rootInput = parentDOM.$V = input;
        }
    }
    callAll(lifecycle);
    renderCheck.v = false;
    if (isFunction(callback)) {
        callback();
    }
    if (isFunction(options.renderComplete)) {
        options.renderComplete(rootInput, parentDOM);
    }
}
function render(input, parentDOM, callback, context) {
    if ( callback === void 0 ) callback = null;
    if ( context === void 0 ) context = EMPTY_OBJ;

    __render(input, parentDOM, callback, context);
}
function createRenderer(parentDOM) {
    return function renderer(lastInput, nextInput, callback, context) {
        if (!parentDOM) {
            parentDOM = lastInput;
        }
        render(nextInput, parentDOM, callback, context);
    };
}

var QUEUE = [];
var nextTick = typeof Promise !== 'undefined'
    ? Promise.resolve().then.bind(Promise.resolve())
    : function (a) {
        window.setTimeout(a, 0);
    };
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
    var pending = component.$PS;
    if (isFunction(newState)) {
        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
    }
    if (isNullOrUndef(pending)) {
        component.$PS = newState;
    }
    else {
        for (var stateKey in newState) {
            pending[stateKey] = newState[stateKey];
        }
    }
    if (!component.$BR) {
        if (!renderCheck.v) {
            if (QUEUE.length === 0) {
                applyState(component, force);
                if (isFunction(callback)) {
                    callback.call(component);
                }
                return;
            }
        }
        if (QUEUE.indexOf(component) === -1) {
            QUEUE.push(component);
        }
        if (force) {
            component.$F = true;
        }
        if (!microTaskPending) {
            microTaskPending = true;
            nextTick(rerender);
        }
        if (isFunction(callback)) {
            var QU = component.$QU;
            if (!QU) {
                QU = component.$QU = [];
            }
            QU.push(callback);
        }
    }
    else if (isFunction(callback)) {
        component.$L.push(callback.bind(component));
    }
}
function callSetStateCallbacks(component) {
    var queue = component.$QU;
    for (var i = 0; i < queue.length; ++i) {
        queue[i].call(component);
    }
    component.$QU = null;
}
function rerender() {
    var component;
    microTaskPending = false;
    while ((component = QUEUE.shift())) {
        if (!component.$UN) {
            var force = component.$F;
            component.$F = false;
            applyState(component, force);
            if (component.$QU) {
                callSetStateCallbacks(component);
            }
        }
    }
}
function applyState(component, force) {
    if (force || !component.$BR) {
        var pendingState = component.$PS;
        component.$PS = null;
        var lifecycle = [];
        renderCheck.v = true;
        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
        callAll(lifecycle);
        renderCheck.v = false;
    }
    else {
        component.state = component.$PS;
        component.$PS = null;
    }
}
var Component = function Component(props, context) {
    // Public
    this.state = null;
    // Internal properties
    this.$BR = false; // BLOCK RENDER
    this.$BS = true; // BLOCK STATE
    this.$PS = null; // PENDING STATE (PARTIAL or FULL)
    this.$LI = null; // LAST INPUT
    this.$UN = false; // UNMOUNTED
    this.$CX = null; // CHILDCONTEXT
    this.$QU = null; // QUEUE
    this.$N = false; // Uses new lifecycle API Flag
    this.$L = null; // Current lifecycle of this component
    this.$SVG = false; // Flag to keep track if component is inside SVG tree
    this.$F = false; // Force update flag
    this.props = props || EMPTY_OBJ;
    this.context = context || EMPTY_OBJ; // context should not be mutable
};
Component.prototype.forceUpdate = function forceUpdate (callback) {
    if (this.$UN) {
        return;
    }
    // Do not allow double render during force update
    queueStateChanges(this, {}, callback, true);
};
Component.prototype.setState = function setState (newState, callback) {
    if (this.$UN) {
        return;
    }
    if (!this.$BS) {
        queueStateChanges(this, newState, callback, false);
    }
};
Component.prototype.render = function render (_nextProps, _nextState, _nextContext) {
    return null;
};

var version = "7.4.11";



;// CONCATENATED MODULE: ../../node_modules/inferno/index.esm.js


if (false) {}


/***/ }),

/***/ 66798:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.registerPattern = exports.registerGradient = exports["default"] = void 0;
var _utils = __webpack_require__(19157);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var graphicObjects = {};
var registerPattern = function registerPattern(options) {
  var id = (0, _utils.getNextDefsSvgId)();
  graphicObjects[id] = _extends({
    type: 'pattern'
  }, options);
  return id;
};
exports.registerPattern = registerPattern;
var registerGradient = function registerGradient(type, options) {
  var id = (0, _utils.getNextDefsSvgId)();
  graphicObjects[id] = _extends({
    type
  }, options);
  return id;
};
exports.registerGradient = registerGradient;
var getGraphicObjects = function getGraphicObjects() {
  return graphicObjects;
};
var _default = {
  getGraphicObjects
};
exports["default"] = _default;

/***/ }),

/***/ 60082:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _data = __webpack_require__(47617);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _position = __webpack_require__(37518);
var _size = __webpack_require__(58664);
var _string = __webpack_require__(68752);
var _type = __webpack_require__(35922);
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
var _window = __webpack_require__(58201);
var _data_source = __webpack_require__(85273);
var _utils = __webpack_require__(9234);
var _utils2 = __webpack_require__(16454);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _load_panel = _interopRequireDefault(__webpack_require__(97218));
var _filtering = _interopRequireDefault(__webpack_require__(18740));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-check
// @ts-expect-error
// @ts-expect-error
var DATAGRID_SELECTION_DISABLED_CLASS = 'dx-selection-disabled';
var DATAGRID_GROUP_OPENED_CLASS = 'dx-datagrid-group-opened';
var DATAGRID_GROUP_CLOSED_CLASS = 'dx-datagrid-group-closed';
var DATAGRID_EXPAND_CLASS = 'dx-datagrid-expand';
var NO_DATA_CLASS = 'nodata';
var SCROLLING_MODE_INFINITE = 'infinite';
var SCROLLING_MODE_VIRTUAL = 'virtual';
var LEGACY_SCROLLING_MODE = 'scrolling.legacyMode';
var SCROLLING_MODE_OPTION = 'scrolling.mode';
var ROW_RENDERING_MODE_OPTION = 'scrolling.rowRenderingMode';
var DATE_INTERVAL_SELECTORS = {
  year(value) {
    return value && value.getFullYear();
  },
  month(value) {
    return value && value.getMonth() + 1;
  },
  day(value) {
    return value && value.getDate();
  },
  quarter(value) {
    return value && Math.floor(value.getMonth() / 3) + 1;
  },
  hour(value) {
    return value && value.getHours();
  },
  minute(value) {
    return value && value.getMinutes();
  },
  second(value) {
    return value && value.getSeconds();
  }
};
var getIntervalSelector = function getIntervalSelector() {
  var data = arguments[1];
  var value = this.calculateCellValue(data);
  if (!(0, _type.isDefined)(value)) {
    return null;
  }
  if (isDateType(this.dataType)) {
    var nameIntervalSelector = arguments[0];
    return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value);
  }
  if (this.dataType === 'number') {
    var groupInterval = arguments[0];
    return Math.floor(Number(value) / groupInterval) * groupInterval;
  }
};
var equalSelectors = function equalSelectors(selector1, selector2) {
  if ((0, _type.isFunction)(selector1) && (0, _type.isFunction)(selector2)) {
    if (selector1.originalCallback && selector2.originalCallback) {
      return selector1.originalCallback === selector2.originalCallback && selector1.columnIndex === selector2.columnIndex;
    }
  }
  return selector1 === selector2;
};
function isDateType(dataType) {
  return dataType === 'date' || dataType === 'datetime';
}
var setEmptyText = function setEmptyText($container) {
  $container.get(0).textContent = '\u00A0';
};
var normalizeSortingInfo = function normalizeSortingInfo(sort) {
  sort = sort || [];
  var result = (0, _utils2.normalizeSortingInfo)(sort);
  for (var i = 0; i < sort.length; i++) {
    if (sort && sort[i] && sort[i].isExpanded !== undefined) {
      result[i].isExpanded = sort[i].isExpanded;
    }
    if (sort && sort[i] && sort[i].groupInterval !== undefined) {
      result[i].groupInterval = sort[i].groupInterval;
    }
  }
  return result;
};
var formatValue = function formatValue(value, options) {
  var valueText = _format_helper.default.format(value, options.format) || value && value.toString() || '';
  var formatObject = {
    value,
    valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
    target: options.target || 'row',
    groupInterval: options.groupInterval
  };
  return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText;
};
var getSummaryText = function getSummaryText(summaryItem, summaryTexts) {
  var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts["".concat(summaryItem.summaryType, "OtherColumn")] || summaryTexts[summaryItem.summaryType];
  return formatValue(summaryItem.value, {
    format: summaryItem.valueFormat,
    getDisplayFormat(valueText) {
      return displayFormat ? (0, _string.format)(displayFormat, valueText, summaryItem.columnCaption) : valueText;
    },
    customizeText: summaryItem.customizeText
  });
};
var getWidgetInstance = function getWidgetInstance($element) {
  var editorData = $element.data && $element.data();
  var dxComponents = editorData && editorData.dxComponents;
  var widgetName = dxComponents && dxComponents[0];
  return widgetName && editorData[widgetName];
};
var equalFilterParameters = function equalFilterParameters(filter1, filter2) {
  if (Array.isArray(filter1) && Array.isArray(filter2)) {
    if (filter1.length !== filter2.length) {
      return false;
    }
    for (var i = 0; i < filter1.length; i++) {
      if (!equalFilterParameters(filter1[i], filter2[i])) {
        return false;
      }
    }
    return true;
  }
  if ((0, _type.isFunction)(filter1) && filter1.columnIndex >= 0 && (0, _type.isFunction)(filter2) && filter2.columnIndex >= 0) {
    return filter1.columnIndex === filter2.columnIndex && (0, _data.toComparable)(filter1.filterValue) === (0, _data.toComparable)(filter2.filterValue) && (0, _data.toComparable)(filter1.selectedFilterOperation) === (0, _data.toComparable)(filter2.selectedFilterOperation);
  }
  return (0, _data.toComparable)(filter1) == (0, _data.toComparable)(filter2); // eslint-disable-line eqeqeq
};

function normalizeGroupingLoadOptions(group) {
  if (!Array.isArray(group)) {
    group = [group];
  }
  return group.map(function (item, i) {
    if ((0, _type.isString)(item)) {
      return {
        selector: item,
        isExpanded: i < group.length - 1
      };
    }
    return item;
  });
}
var _default = {
  renderNoDataText($element) {
    var that = this;
    $element = $element || this.element();
    if (!$element) {
      return;
    }
    var noDataClass = that.addWidgetPrefix(NO_DATA_CLASS);
    var noDataElement = $element.find(".".concat(noDataClass)).last();
    var isVisible = this._dataController.isEmpty();
    var isLoading = this._dataController.isLoading();
    if (!noDataElement.length) {
      noDataElement = (0, _renderer.default)('<span>').addClass(noDataClass);
    }
    if (!noDataElement.parent().is($element)) {
      noDataElement.appendTo($element);
    }
    if (isVisible && !isLoading) {
      noDataElement.removeClass('dx-hidden').text(that._getNoDataText());
    } else {
      noDataElement.addClass('dx-hidden');
    }
  },
  renderLoadPanel($element, $container, isLocalStore) {
    var that = this;
    var loadPanelOptions;
    that._loadPanel && that._loadPanel.$element().remove();
    loadPanelOptions = that.option('loadPanel');
    if (loadPanelOptions && (loadPanelOptions.enabled === 'auto' ? !isLocalStore : loadPanelOptions.enabled)) {
      loadPanelOptions = (0, _extend.extend)({
        shading: false,
        message: loadPanelOptions.text,
        container: $container
      }, loadPanelOptions);
      that._loadPanel = that._createComponent((0, _renderer.default)('<div>').appendTo($container), _load_panel.default, loadPanelOptions);
    } else {
      that._loadPanel = null;
    }
  },
  calculateLoadPanelPosition($element) {
    // @ts-expect-error
    var $window = (0, _renderer.default)((0, _window.getWindow)());
    if ((0, _size.getHeight)($element) > (0, _size.getHeight)($window)) {
      return {
        of: $window,
        boundary: $element,
        collision: 'fit'
      };
    }
    return {
      of: $element
    };
  },
  getIndexByKey(key, items, keyName) {
    var index = -1;
    if (key !== undefined && Array.isArray(items)) {
      keyName = arguments.length <= 2 ? 'key' : keyName;
      for (var i = 0; i < items.length; i++) {
        var item = (0, _type.isDefined)(keyName) ? items[i][keyName] : items[i];
        if ((0, _common.equalByValue)(key, item)) {
          index = i;
          break;
        }
      }
    }
    return index;
  },
  combineFilters(filters, operation) {
    var _a;
    var resultFilter = [];
    operation = operation || 'and';
    for (var i = 0; i < filters.length; i++) {
      if (!filters[i]) {
        continue;
      }
      if (((_a = filters[i]) === null || _a === void 0 ? void 0 : _a.length) === 1 && filters[i][0] === '!') {
        if (operation === 'and') {
          return ['!'];
        }
        if (operation === 'or') {
          continue;
        }
      }
      if (resultFilter.length) {
        resultFilter.push(operation);
      }
      resultFilter.push(filters[i]);
    }
    if (resultFilter.length === 1) {
      // eslint-disable-next-line prefer-destructuring
      resultFilter = resultFilter[0];
    }
    if (resultFilter.length) {
      return resultFilter;
    }
    return undefined;
  },
  checkChanges(changes, changeNames) {
    var changesWithChangeNamesCount = 0;
    for (var i = 0; i < changeNames.length; i++) {
      if (changes[changeNames[i]]) {
        changesWithChangeNamesCount++;
      }
    }
    return changes.length && changes.length === changesWithChangeNamesCount;
  },
  equalFilterParameters,
  proxyMethod(instance, methodName, defaultResult) {
    if (!instance[methodName]) {
      instance[methodName] = function () {
        var dataSource = this._dataSource;
        return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;
      };
    }
  },
  formatValue,
  getFormatOptionsByColumn(column, target) {
    return {
      format: column.format,
      getDisplayFormat: column.getDisplayFormat,
      customizeText: column.customizeText,
      target,
      trueText: column.trueText,
      falseText: column.falseText
    };
  },
  getDisplayValue(column, value, data, rowType) {
    if (column.displayValueMap && column.displayValueMap[value] !== undefined) {
      return column.displayValueMap[value];
    }
    if (column.calculateDisplayValue && data && rowType !== 'group') {
      return column.calculateDisplayValue(data);
    }
    if (column.lookup && !(rowType === 'group' && (column.calculateGroupValue || column.calculateDisplayValue))) {
      return column.lookup.calculateCellValue(value);
    }
    return value;
  },
  getGroupRowSummaryText(summaryItems, summaryTexts) {
    var result = '(';
    for (var i = 0; i < summaryItems.length; i++) {
      var summaryItem = summaryItems[i];
      result += (i > 0 ? ', ' : '') + getSummaryText(summaryItem, summaryTexts);
    }
    // eslint-disable-next-line no-return-assign
    return result += ')';
  },
  getSummaryText,
  normalizeSortingInfo,
  getFormatByDataType(dataType) {
    // eslint-disable-next-line default-case
    switch (dataType) {
      case 'date':
        return 'shortDate';
      case 'datetime':
        return 'shortDateShortTime';
      default:
        return undefined;
    }
  },
  getHeaderFilterGroupParameters(column, remoteGrouping) {
    var result = [];
    var dataField = column.dataField || column.name;
    var groupInterval = _filtering.default.getGroupInterval(column);
    if (groupInterval) {
      (0, _iterator.each)(groupInterval, function (index, interval) {
        result.push(remoteGrouping ? {
          selector: dataField,
          groupInterval: interval,
          isExpanded: index < groupInterval.length - 1
        } : getIntervalSelector.bind(column, interval));
      });
      return result;
    }
    if (remoteGrouping) {
      result = [{
        selector: dataField,
        isExpanded: false
      }];
    } else {
      result = function result(data) {
        var result = column.calculateCellValue(data);
        if (result === undefined || result === '') {
          result = null;
        }
        return result;
      };
      if (column.sortingMethod) {
        result = [{
          selector: result,
          compare: column.sortingMethod.bind(column)
        }];
      }
    }
    return result;
  },
  equalSortParameters(sortParameters1, sortParameters2, ignoreIsExpanded) {
    sortParameters1 = normalizeSortingInfo(sortParameters1);
    sortParameters2 = normalizeSortingInfo(sortParameters2);
    if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
      if (sortParameters1.length !== sortParameters2.length) {
        return false;
      }
      for (var i = 0; i < sortParameters1.length; i++) {
        if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
          return false;
        }
      }
      return true;
    }
    return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length);
  },
  getPointsByColumns(items, pointCreated, isVertical, startColumnIndex) {
    var cellsLength = items.length;
    var notCreatePoint = false;
    var item;
    var offset;
    var columnIndex = startColumnIndex || 0;
    var result = [];
    var rtlEnabled;
    for (var i = 0; i <= cellsLength; i++) {
      if (i < cellsLength) {
        item = items.eq(i);
        offset = item.offset();
        rtlEnabled = item.css('direction') === 'rtl';
      }
      var point = {
        index: columnIndex,
        // @ts-expect-error
        x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? (0, _position.getBoundingRect)(item[0]).width : 0) : 0,
        y: offset ? offset.top + (isVertical && i === cellsLength ? (0, _position.getBoundingRect)(item[0]).height : 0) : 0,
        columnIndex
      };
      if (!isVertical && i > 0) {
        var prevItemOffset = items.eq(i - 1).offset();
        if (prevItemOffset.top < point.y) {
          point.y = prevItemOffset.top;
        }
      }
      if (pointCreated) {
        notCreatePoint = pointCreated(point);
      }
      if (!notCreatePoint) {
        result.push(point);
      }
      columnIndex++;
    }
    return result;
  },
  getExpandCellTemplate() {
    return {
      allowRenderToDetachedContainer: true,
      render(container, options) {
        var $container = (0, _renderer.default)(container);
        if ((0, _type.isDefined)(options.value) && !(options.data && options.data.isContinuation) && !options.row.isNewRow) {
          var rowsView = options.component.getView('rowsView');
          $container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
          (0, _renderer.default)('<div>').addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo($container);
          rowsView.setAria('label', options.value ? rowsView.localize('dxDataGrid-ariaCollapse') : rowsView.localize('dxDataGrid-ariaExpand'), $container);
        } else {
          setEmptyText($container);
        }
      }
    };
  },
  setEmptyText,
  isDateType,
  getSelectionRange(focusedElement) {
    try {
      if (focusedElement) {
        return {
          selectionStart: focusedElement.selectionStart,
          selectionEnd: focusedElement.selectionEnd
        };
      }
    } catch (e) {/* empty */}
    return {};
  },
  setSelectionRange(focusedElement, selectionRange) {
    try {
      if (focusedElement && focusedElement.setSelectionRange) {
        focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd);
      }
    } catch (e) {/* empty */}
  },
  focusAndSelectElement(component, $element) {
    var isFocused = $element.is(':focus');
    // @ts-expect-error
    _events_engine.default.trigger($element, 'focus');
    var isSelectTextOnEditingStart = component.option('editing.selectTextOnEditStart');
    var element = $element.get(0);
    if (!isFocused && isSelectTextOnEditingStart && $element.is('.dx-texteditor-input') && !$element.is('[readonly]')) {
      var editor = getWidgetInstance($element.closest('.dx-texteditor'));
      (0, _deferred.when)(editor && editor._loadItemDeferred).done(function () {
        element.select();
      });
    }
  },
  getWidgetInstance,
  getLastResizableColumnIndex(columns, resultWidths) {
    var hasResizableColumns = columns.some(function (column) {
      return column && !column.command && !column.fixed && column.allowResizing !== false;
    });
    var lastColumnIndex;
    for (lastColumnIndex = columns.length - 1; columns[lastColumnIndex]; lastColumnIndex--) {
      var column = columns[lastColumnIndex];
      var width = resultWidths && resultWidths[lastColumnIndex];
      var allowResizing = !hasResizableColumns || column.allowResizing !== false;
      if (!column.command && !column.fixed && width !== 'adaptiveHidden' && allowResizing) {
        break;
      }
    }
    return lastColumnIndex;
  },
  isElementInCurrentGrid(controller, $element) {
    if ($element && $element.length) {
      var $grid = $element.closest(".".concat(controller.getWidgetContainerClass())).parent();
      return $grid.is(controller.component.$element());
    }
    return false;
  },
  isVirtualRowRendering(that) {
    var rowRenderingMode = that.option(ROW_RENDERING_MODE_OPTION);
    var isVirtualMode = that.option(SCROLLING_MODE_OPTION) === SCROLLING_MODE_VIRTUAL;
    var isAppendMode = that.option(SCROLLING_MODE_OPTION) === SCROLLING_MODE_INFINITE;
    if (that.option(LEGACY_SCROLLING_MODE) === false && (isVirtualMode || isAppendMode)) {
      return true;
    }
    return rowRenderingMode === SCROLLING_MODE_VIRTUAL;
  },
  getPixelRatio(window) {
    return window.devicePixelRatio || 1;
  },
  getContentHeightLimit(browser) {
    if (browser.mozilla) {
      return 8000000;
    }
    return 15000000 / this.getPixelRatio((0, _window.getWindow)());
  },
  normalizeLookupDataSource(lookup) {
    var lookupDataSourceOptions;
    if (lookup.items) {
      lookupDataSourceOptions = lookup.items;
    } else {
      lookupDataSourceOptions = lookup.dataSource;
      if ((0, _type.isFunction)(lookupDataSourceOptions) && !_variable_wrapper.default.isWrapped(lookupDataSourceOptions)) {
        lookupDataSourceOptions = lookupDataSourceOptions({});
      }
    }
    return (0, _utils.normalizeDataSourceOptions)(lookupDataSourceOptions);
  },
  getWrappedLookupDataSource(column, dataSource, filter) {
    var _this = this;
    if (!dataSource) {
      return [];
    }
    var lookupDataSourceOptions = this.normalizeLookupDataSource(column.lookup);
    if (column.calculateCellValue !== column.defaultCalculateCellValue) {
      return lookupDataSourceOptions;
    }
    var hasGroupPaging = dataSource.remoteOperations().groupPaging;
    var hasLookupOptimization = column.displayField && (0, _type.isString)(column.displayField);
    var cachedUniqueRelevantItems;
    var previousTake;
    var previousSkip;
    var sliceItems = function sliceItems(items, loadOptions) {
      var _a;
      var start = (_a = loadOptions.skip) !== null && _a !== void 0 ? _a : 0;
      var end = loadOptions.take ? start + loadOptions.take : items.length;
      return items.slice(start, end);
    };
    var loadUniqueRelevantItems = function loadUniqueRelevantItems(loadOptions) {
      var group = normalizeGroupingLoadOptions(hasLookupOptimization ? [column.dataField, column.displayField] : column.dataField);
      // @ts-expect-error
      var d = new _deferred.Deferred();
      var canUseCache = cachedUniqueRelevantItems && (!hasGroupPaging || loadOptions.skip === previousSkip && loadOptions.take === previousTake);
      if (canUseCache) {
        d.resolve(sliceItems(cachedUniqueRelevantItems, loadOptions));
      } else {
        previousSkip = loadOptions.skip;
        previousTake = loadOptions.take;
        dataSource.load({
          filter,
          group,
          take: hasGroupPaging ? loadOptions.take : undefined,
          skip: hasGroupPaging ? loadOptions.skip : undefined
        }).done(function (items) {
          cachedUniqueRelevantItems = items;
          d.resolve(hasGroupPaging ? items : sliceItems(items, loadOptions));
        }).fail(d.fail);
      }
      return d;
    };
    var lookupDataSource = _extends(_extends({}, lookupDataSourceOptions), {
      __dataGridSourceFilter: filter,
      load: function load(loadOptions) {
        // @ts-expect-error
        var d = new _deferred.Deferred();
        loadUniqueRelevantItems(loadOptions).done(function (items) {
          if (items.length === 0) {
            d.resolve([]);
            return;
          }
          var filter = _this.combineFilters(items.flatMap(function (data) {
            return data.key;
          }).map(function (key) {
            return [column.lookup.valueExpr, key];
          }), 'or');
          var newDataSource = new _data_source.DataSource(_extends(_extends(_extends({}, lookupDataSourceOptions), loadOptions), {
            filter: _this.combineFilters([filter, loadOptions.filter], 'and'),
            paginate: false
          }));
          newDataSource
          // @ts-expect-error
          .load().done(d.resolve).fail(d.fail);
        }).fail(d.fail);
        return d;
      },
      key: column.lookup.valueExpr,
      byKey(key) {
        var d = (0, _deferred.Deferred)();
        this.load({
          filter: [column.lookup.valueExpr, '=', key]
        }).done(function (arr) {
          d.resolve(arr[0]);
        });
        return d.promise();
      }
    });
    return lookupDataSource;
  },
  logHeaderFilterDeprecatedWarningIfNeed(component) {
    var since = '23.1';
    var logWarning = component._logDeprecatedOptionWarning.bind(component);
    if ((0, _type.isDefined)(component.option('headerFilter.allowSearch'))) {
      logWarning('headerFilter.allowSearch', {
        since,
        alias: 'headerFilter.search.enabled'
      });
    }
    if ((0, _type.isDefined)(component.option('headerFilter.searchTimeout'))) {
      logWarning('headerFilter.searchTimeout', {
        since,
        alias: 'headerFilter.search.timeout'
      });
    }
    var specificName = component.NAME === 'dxPivotGrid' ? 'dataSource.fields' : 'columns';
    var columns = component.option(specificName);
    if (!Array.isArray(columns)) {
      return;
    }
    var logSpecificDeprecatedWarningIfNeed = function logSpecificDeprecatedWarningIfNeed(columns) {
      columns.forEach(function (column) {
        var _a;
        var headerFilter = column.headerFilter || {};
        if ((0, _type.isDefined)(headerFilter.allowSearch)) {
          logWarning("".concat(specificName, "[].headerFilter.allowSearch"), {
            since,
            alias: "".concat(specificName, "[].headerFilter.search.enabled")
          });
        }
        if ((0, _type.isDefined)(headerFilter.searchMode)) {
          logWarning("".concat(specificName, "[].headerFilter.searchMode"), {
            since,
            alias: "".concat(specificName, "[].headerFilter.search.mode")
          });
        }
        if ((_a = column.columns) === null || _a === void 0 ? void 0 : _a.length) {
          logSpecificDeprecatedWarningIfNeed(column.columns);
        }
      });
    };
    logSpecificDeprecatedWarningIfNeed(columns);
  }
};
exports["default"] = _default;

/***/ }),

/***/ 86988:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _position = _interopRequireDefault(__webpack_require__(49387));
var _translator = __webpack_require__(31648);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _element = __webpack_require__(6415);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _empty_template = __webpack_require__(10688);
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _inflector = __webpack_require__(78008);
var _position2 = __webpack_require__(37518);
var _size = __webpack_require__(58664);
var _string = __webpack_require__(68752);
var _type = __webpack_require__(35922);
var _view_port = __webpack_require__(77695);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _drag = __webpack_require__(23174);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
var _animator = _interopRequireDefault(__webpack_require__(6866));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } // @ts-expect-error
// @ts-expect-error
var window = (0, _window.getWindow)();
var KEYDOWN_EVENT = 'keydown';
var DRAGGABLE = 'dxDraggable';
var DRAGSTART_EVENT_NAME = (0, _index.addNamespace)(_drag.start, DRAGGABLE);
var DRAG_EVENT_NAME = (0, _index.addNamespace)(_drag.move, DRAGGABLE);
var DRAGEND_EVENT_NAME = (0, _index.addNamespace)(_drag.end, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = (0, _index.addNamespace)(_drag.enter, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = (0, _index.addNamespace)(_drag.leave, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.down, DRAGGABLE);
var KEYDOWN_EVENT_NAME = (0, _index.addNamespace)(KEYDOWN_EVENT, DRAGGABLE);
var CLONE_CLASS = 'clone';
var targetDraggable;
var sourceDraggable;
var ANONYMOUS_TEMPLATE_NAME = 'content';
var getMousePosition = function getMousePosition(event) {
  return {
    // @ts-expect-error
    x: event.pageX - (0, _renderer.default)(window).scrollLeft(),
    // @ts-expect-error
    y: event.pageY - (0, _renderer.default)(window).scrollTop()
  };
};
var GESTURE_COVER_CLASS = 'dx-gesture-cover';
var OVERLAY_WRAPPER_CLASS = 'dx-overlay-wrapper';
var OVERLAY_CONTENT_CLASS = 'dx-overlay-content';
var ScrollHelper = /*#__PURE__*/function () {
  function ScrollHelper(orientation, component) {
    this._$scrollableAtPointer = null;
    this._preventScroll = true;
    this._component = component;
    if (orientation === 'vertical') {
      this._scrollValue = 'scrollTop';
      this._overFlowAttr = 'overflowY';
      this._sizeAttr = 'height';
      this._scrollSizeProp = 'scrollHeight';
      this._clientSizeProp = 'clientHeight';
      this._limitProps = {
        start: 'top',
        end: 'bottom'
      };
    } else {
      this._scrollValue = 'scrollLeft';
      this._overFlowAttr = 'overflowX';
      this._sizeAttr = 'width';
      this._scrollSizeProp = 'scrollWidth';
      this._clientSizeProp = 'clientWidth';
      this._limitProps = {
        start: 'left',
        end: 'right'
      };
    }
  }
  var _proto = ScrollHelper.prototype;
  _proto.updateScrollable = function updateScrollable(elements, mousePosition) {
    var _this = this;
    var isScrollableFound = false;
    elements.some(function (element) {
      var $element = (0, _renderer.default)(element);
      var isTargetOverOverlayWrapper = $element.hasClass(OVERLAY_WRAPPER_CLASS);
      var isTargetOverOverlayContent = $element.hasClass(OVERLAY_CONTENT_CLASS);
      if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
        return true;
      }
      isScrollableFound = _this._trySetScrollable(element, mousePosition);
      return isScrollableFound;
    });
    if (!isScrollableFound) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  };
  _proto.isScrolling = function isScrolling() {
    return !!this._scrollSpeed;
  };
  _proto.isScrollable = function isScrollable($element) {
    return ($element.css(this._overFlowAttr) === 'auto' || $element.hasClass('dx-scrollable-container')) && $element.prop(this._scrollSizeProp) > Math.ceil(this._sizeAttr === 'width' ? (0, _size.getWidth)($element) : (0, _size.getHeight)($element));
  };
  _proto._trySetScrollable = function _trySetScrollable(element, mousePosition) {
    var that = this;
    var $element = (0, _renderer.default)(element);
    var distanceToBorders;
    var sensitivity = that._component.option('scrollSensitivity');
    var isScrollable = that.isScrollable($element);
    if (isScrollable) {
      distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);
      if (sensitivity > distanceToBorders[that._limitProps.start]) {
        if (!that._preventScroll) {
          that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
          that._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[that._limitProps.end]) {
        if (!that._preventScroll) {
          that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
          that._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        that._preventScroll = false;
      }
    }
    return isScrollable;
  };
  _proto._calculateDistanceToBorders = function _calculateDistanceToBorders($area, mousePosition) {
    var area = $area.get(0);
    var areaBoundingRect;
    if (area) {
      areaBoundingRect = (0, _position2.getBoundingRect)(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    }
    return {};
  };
  _proto._calculateScrollSpeed = function _calculateScrollSpeed(distance) {
    var component = this._component;
    var sensitivity = component.option('scrollSensitivity');
    var maxSpeed = component.option('scrollSpeed');
    return Math.ceil(Math.pow((sensitivity - distance) / sensitivity, 2) * maxSpeed);
  };
  _proto.scrollByStep = function scrollByStep() {
    var that = this;
    if (that._$scrollableAtPointer && that._scrollSpeed) {
      if (that._$scrollableAtPointer.hasClass('dx-scrollable-container')) {
        var $scrollable = that._$scrollableAtPointer.closest('.dx-scrollable');
        var scrollableInstance = $scrollable.data('dxScrollable') || $scrollable.data('dxScrollView');
        if (scrollableInstance) {
          var nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;
          scrollableInstance.scrollTo({
            [that._limitProps.start]: nextScrollPosition
          });
        }
      } else {
        var _nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;
        that._$scrollableAtPointer[that._scrollValue](_nextScrollPosition);
      }
      var dragMoveArgs = that._component._dragMoveArgs;
      if (dragMoveArgs) {
        that._component._dragMoveHandler(dragMoveArgs);
      }
    }
  };
  _proto.reset = function reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  };
  _proto.isOutsideScrollable = function isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }
    var scrollableSize = (0, _position2.getBoundingRect)($scrollable.get(0));
    var start = scrollableSize[this._limitProps.start];
    var size = scrollableSize[this._sizeAttr];
    var mousePosition = getMousePosition(event);
    var location = this._sizeAttr === 'width' ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  };
  return ScrollHelper;
}();
var ScrollAnimator = _animator.default.inherit({
  ctor(strategy) {
    this.callBase();
    this._strategy = strategy;
  },
  _step() {
    var horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    var verticalScrollHelper = this._strategy._verticalScrollHelper;
    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
    verticalScrollHelper && verticalScrollHelper.scrollByStep();
  }
});
var Draggable = _dom_component.default.inherit({
  reset: _common.noop,
  dragMove: _common.noop,
  dragEnter: _common.noop,
  dragLeave: _common.noop,
  dragEnd(sourceEvent) {
    var sourceDraggable = this._getSourceDraggable();
    sourceDraggable._fireRemoveEvent(sourceEvent);
    return (0, _deferred.Deferred)().resolve();
  },
  _fireRemoveEvent: _common.noop,
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDragCancel: null,
      onCancelByEsc: false,
      onDrop: null,
      immediate: true,
      dragDirection: 'both',
      boundary: undefined,
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      container: undefined,
      dragTemplate: undefined,
      contentTemplate: 'content',
      handle: '',
      filter: '',
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60,
      group: undefined,
      data: undefined
    });
  },
  _setOptionsByReference() {
    this.callBase.apply(this, arguments);
    (0, _extend.extend)(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  },
  _init() {
    this.callBase();
    this._attachEventHandlers();
    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper('horizontal', this);
    this._verticalScrollHelper = new ScrollHelper('vertical', this);
    this._initScrollTop = 0;
    this._initScrollLeft = 0;
  },
  _normalizeCursorOffset(offset) {
    if ((0, _type.isObject)(offset)) {
      offset = {
        h: offset.x,
        v: offset.y
      };
    }
    offset = (0, _common.splitPair)(offset).map(function (value) {
      return parseFloat(value);
    });
    return {
      left: offset[0],
      top: offset.length === 1 ? offset[0] : offset[1]
    };
  },
  _getNormalizedCursorOffset(offset, options) {
    if ((0, _type.isFunction)(offset)) {
      offset = offset.call(this, options);
    }
    return this._normalizeCursorOffset(offset);
  },
  _calculateElementOffset(options) {
    var elementOffset;
    var dragElementOffset;
    var event = options.event;
    var $element = (0, _renderer.default)(options.itemElement);
    var $dragElement = (0, _renderer.default)(options.dragElement);
    var isCloned = this._dragElementIsCloned();
    var cursorOffset = this.option('cursorOffset');
    var normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    var currentLocate = this._initialLocate = (0, _translator.locate)($dragElement);
    if (isCloned || options.initialOffset || cursorOffset) {
      elementOffset = options.initialOffset || $element.offset();
      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);
        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }
        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }
      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }
    return elementOffset;
  },
  _initPosition(options) {
    var $dragElement = (0, _renderer.default)(options.dragElement);
    var elementOffset = this._calculateElementOffset(options);
    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }
    this._startPosition = (0, _translator.locate)($dragElement);
  },
  _startAnimator() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  },
  _stopAnimator() {
    this._scrollAnimator.stop();
  },
  _addWidgetPrefix(className) {
    var componentName = this.NAME;
    return (0, _inflector.dasherize)(componentName) + (className ? "-".concat(className) : '');
  },
  _getItemsSelector() {
    return this.option('filter') || '';
  },
  _$content() {
    var $element = this.$element();
    var $wrapper = $element.children('.dx-template-wrapper');
    return $wrapper.length ? $wrapper : $element;
  },
  _attachEventHandlers() {
    var _this2 = this;
    if (this.option('disabled')) {
      return;
    }
    var $element = this._$content();
    var itemsSelector = this._getItemsSelector();
    var allowMoveByClick = this.option('allowMoveByClick');
    var data = {
      direction: this.option('dragDirection'),
      immediate: this.option('immediate'),
      checkDropTarget: function checkDropTarget($target, event) {
        var targetGroup = _this2.option('group');
        var sourceGroup = _this2._getSourceDraggable().option('group');
        var $scrollable = _this2._getScrollable($target);
        if (_this2._verticalScrollHelper.isOutsideScrollable($scrollable, event) || _this2._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }
        return sourceGroup && sourceGroup === targetGroup;
      }
    };
    if (allowMoveByClick) {
      $element = this._getArea();
      _events_engine.default.on($element, POINTERDOWN_EVENT_NAME, data, this._pointerDownHandler.bind(this));
    }
    if (itemsSelector[0] === '>') {
      itemsSelector = itemsSelector.slice(1);
    }
    // @ts-expect-error
    _events_engine.default.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data, this._dragStartHandler.bind(this));
    _events_engine.default.on($element, DRAG_EVENT_NAME, data, this._dragMoveHandler.bind(this));
    _events_engine.default.on($element, DRAGEND_EVENT_NAME, data, this._dragEndHandler.bind(this));
    _events_engine.default.on($element, DRAG_ENTER_EVENT_NAME, data, this._dragEnterHandler.bind(this));
    _events_engine.default.on($element, DRAGEND_LEAVE_EVENT_NAME, data, this._dragLeaveHandler.bind(this));
    if (this.option('onCancelByEsc')) {
      _events_engine.default.on($element, KEYDOWN_EVENT_NAME, this._keydownHandler.bind(this));
    }
  },
  _dragElementIsCloned() {
    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS));
  },
  _getDragTemplateArgs($element, $container) {
    return {
      container: (0, _element.getPublicElement)($container),
      model: {
        itemData: this.option('itemData'),
        itemElement: (0, _element.getPublicElement)($element)
      }
    };
  },
  _createDragElement($element) {
    var result = $element;
    var clone = this.option('clone');
    var $container = this._getContainer();
    var template = this.option('dragTemplate');
    if (template) {
      template = this._getTemplate(template);
      result = (0, _renderer.default)('<div>').appendTo($container);
      template.render(this._getDragTemplateArgs($element, result));
    } else if (clone) {
      result = (0, _renderer.default)('<div>').appendTo($container);
      $element.clone().css({
        width: $element.css('width'),
        height: $element.css('height')
      }).appendTo(result);
    }
    return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result.get(0) !== $element.get(0)).toggleClass('dx-rtl', this.option('rtlEnabled'));
  },
  _resetDragElement() {
    if (this._dragElementIsCloned()) {
      this._$dragElement.remove();
    } else {
      this._toggleDraggingClass(false);
    }
    this._$dragElement = null;
  },
  _resetSourceElement() {
    this._toggleDragSourceClass(false);
    this._$sourceElement = null;
  },
  _detachEventHandlers() {
    // @ts-expect-error
    _events_engine.default.off(this._$content(), ".".concat(DRAGGABLE));
    // @ts-expect-error
    _events_engine.default.off(this._getArea(), ".".concat(DRAGGABLE));
  },
  _move(position, $element) {
    (0, _translator.move)($element || this._$dragElement, position);
  },
  _getDraggableElement(e) {
    var $sourceElement = this._getSourceElement();
    if ($sourceElement) {
      return $sourceElement;
    }
    var allowMoveByClick = this.option('allowMoveByClick');
    if (allowMoveByClick) {
      return this.$element();
    }
    var $target = (0, _renderer.default)(e && e.target);
    var itemsSelector = this._getItemsSelector();
    if (itemsSelector[0] === '>') {
      var $items = this._$content().find(itemsSelector);
      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }
    return $target;
  },
  _getSourceElement() {
    var draggable = this._getSourceDraggable();
    return draggable._$sourceElement;
  },
  _pointerDownHandler(e) {
    if ((0, _index.needSkipEvent)(e)) {
      return;
    }
    var position = {};
    var $element = this.$element();
    var dragDirection = this.option('dragDirection');
    if (dragDirection === 'horizontal' || dragDirection === 'both') {
      position.left = e.pageX - $element.offset().left + (0, _translator.locate)($element).left - (0, _size.getWidth)($element) / 2;
    }
    if (dragDirection === 'vertical' || dragDirection === 'both') {
      position.top = e.pageY - $element.offset().top + (0, _translator.locate)($element).top - (0, _size.getHeight)($element) / 2;
    }
    this._move(position, $element);
    this._getAction('onDragMove')(this._getEventArgs(e));
  },
  _isValidElement(event, $element) {
    var handle = this.option('handle');
    var $target = (0, _renderer.default)(event.originalEvent && event.originalEvent.target);
    if (handle && !$target.closest(handle).length) {
      return false;
    }
    if (!$element.length) {
      return false;
    }
    return !$element.is('.dx-state-disabled, .dx-state-disabled *');
  },
  _dragStartHandler(e) {
    var $element = this._getDraggableElement(e);
    this.dragInProgress = true;
    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }
    if (this._$sourceElement) {
      return;
    }
    var dragStartArgs = this._getDragStartArgs(e, $element);
    this._getAction('onDragStart')(dragStartArgs);
    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }
    this.option('itemData', dragStartArgs.itemData);
    this._setSourceDraggable();
    this._$sourceElement = $element;
    var initialOffset = $element.offset();
    if (!this._hasClonedDraggable() && this.option('autoScroll')) {
      this._initScrollTop = this._getScrollableScrollTop();
      this._initScrollLeft = this._getScrollableScrollLeft();
      initialOffset = this._getDraggableElementOffset(initialOffset.left, initialOffset.top);
    }
    var $dragElement = this._$dragElement = this._createDragElement($element);
    this._toggleDraggingClass(true);
    this._toggleDragSourceClass(true);
    this._setGestureCoverCursor($dragElement.children());
    var isFixedPosition = $dragElement.css('position') === 'fixed';
    this._initPosition((0, _extend.extend)({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));
    this._getAction('onDraggableElementShown')(_extends(_extends({}, dragStartArgs), {
      dragElement: $dragElement
    }));
    var $area = this._getArea();
    var areaOffset = this._getAreaOffset($area);
    var boundOffset = this._getBoundOffset();
    var areaWidth = (0, _size.getOuterWidth)($area);
    var areaHeight = (0, _size.getOuterHeight)($area);
    var elementWidth = (0, _size.getWidth)($dragElement);
    var elementHeight = (0, _size.getHeight)($dragElement);
    var startOffset = {
      left: $dragElement.offset().left - areaOffset.left,
      top: $dragElement.offset().top - areaOffset.top
    };
    if ($area.length) {
      e.maxLeftOffset = startOffset.left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset.top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom;
    }
    if (this.option('autoScroll')) {
      this._startAnimator();
    }
  },
  _getAreaOffset($area) {
    var offset = $area && _position.default.offset($area);
    return offset || {
      left: 0,
      top: 0
    };
  },
  _toggleDraggingClass(value) {
    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix('dragging'), value);
  },
  _toggleDragSourceClass(value, $element) {
    var $sourceElement = $element || this._$sourceElement;
    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix('source'), value);
  },
  _setGestureCoverCursor($element) {
    (0, _renderer.default)(".".concat(GESTURE_COVER_CLASS)).css('cursor', $element.css('cursor'));
  },
  _getBoundOffset() {
    var boundOffset = this.option('boundOffset');
    if ((0, _type.isFunction)(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }
    return (0, _string.quadToObject)(boundOffset);
  },
  _getArea() {
    var area = this.option('boundary');
    if ((0, _type.isFunction)(area)) {
      area = area.call(this);
    }
    return (0, _renderer.default)(area);
  },
  _getContainer() {
    var container = this.option('container');
    if (container === undefined) {
      container = (0, _view_port.value)();
    }
    return (0, _renderer.default)(container);
  },
  _getDraggableElementOffset(initialOffsetX, initialOffsetY) {
    var _a, _b, _c, _d;
    var initScrollTop = this._initScrollTop;
    var initScrollLeft = this._initScrollLeft;
    var scrollTop = this._getScrollableScrollTop();
    var scrollLeft = this._getScrollableScrollLeft();
    var elementPosition = (0, _renderer.default)(this.element()).css('position');
    var isFixedPosition = elementPosition === 'fixed';
    var result = {
      left: ((_b = (_a = this._startPosition) === null || _a === void 0 ? void 0 : _a.left) !== null && _b !== void 0 ? _b : 0) + initialOffsetX,
      top: ((_d = (_c = this._startPosition) === null || _c === void 0 ? void 0 : _c.top) !== null && _d !== void 0 ? _d : 0) + initialOffsetY
    };
    if (isFixedPosition || this._hasClonedDraggable()) {
      return result;
    }
    return {
      left: (0, _type.isNumeric)(scrollLeft) ? result.left + scrollLeft - initScrollLeft : result.left,
      top: (0, _type.isNumeric)(scrollTop) ? result.top + scrollTop - initScrollTop : result.top
    };
  },
  _hasClonedDraggable() {
    return this.option('clone') || this.option('dragTemplate');
  },
  _dragMoveHandler(e) {
    this._dragMoveArgs = e;
    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }
    var offset = this._getDraggableElementOffset(e.offset.x, e.offset.y);
    this._move(offset);
    this._updateScrollable(e);
    var eventArgs = this._getEventArgs(e);
    this._getAction('onDragMove')(eventArgs);
    if (eventArgs.cancel === true) {
      return;
    }
    var targetDraggable = this._getTargetDraggable();
    targetDraggable.dragMove(e, scrollBy);
  },
  _updateScrollable(e) {
    var that = this;
    if (that.option('autoScroll')) {
      var mousePosition = getMousePosition(e);
      var allObjects = _dom_adapter.default.elementsFromPoint(mousePosition.x, mousePosition.y, this.$element().get(0));
      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  },
  _getScrollable($element) {
    var _this3 = this;
    var $scrollable;
    $element.parents().toArray().some(function (parent) {
      var $parent = (0, _renderer.default)(parent);
      if (_this3._horizontalScrollHelper.isScrollable($parent) || _this3._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
      return false;
    });
    return $scrollable;
  },
  _getScrollableScrollTop() {
    var _a, _b;
    return (_b = (_a = this._getScrollable((0, _renderer.default)(this.element()))) === null || _a === void 0 ? void 0 : _a.scrollTop()) !== null && _b !== void 0 ? _b : 0;
  },
  _getScrollableScrollLeft() {
    var _a, _b;
    return (_b = (_a = this._getScrollable((0, _renderer.default)(this.element()))) === null || _a === void 0 ? void 0 : _a.scrollLeft()) !== null && _b !== void 0 ? _b : 0;
  },
  _defaultActionArgs() {
    var args = this.callBase.apply(this, arguments);
    var component = this.option('component');
    if (component) {
      args.component = component;
      args.element = component.element();
    }
    return args;
  },
  _getEventArgs(e) {
    var sourceDraggable = this._getSourceDraggable();
    var targetDraggable = this._getTargetDraggable();
    return {
      event: e,
      itemData: sourceDraggable.option('itemData'),
      itemElement: (0, _element.getPublicElement)(sourceDraggable._$sourceElement),
      fromComponent: sourceDraggable.option('component') || sourceDraggable,
      toComponent: targetDraggable.option('component') || targetDraggable,
      fromData: sourceDraggable.option('data'),
      toData: targetDraggable.option('data')
    };
  },
  _getDragStartArgs(e, $itemElement) {
    var args = this._getEventArgs(e);
    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  },
  _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  },
  _dragEndHandler(e) {
    var _this4 = this;
    var d = (0, _deferred.Deferred)();
    var dragEndEventArgs = this._getEventArgs(e);
    var dropEventArgs = this._getEventArgs(e);
    var targetDraggable = this._getTargetDraggable();
    var needRevertPosition = true;
    this.dragInProgress = false;
    try {
      this._getAction('onDragEnd')(dragEndEventArgs);
    } finally {
      (0, _deferred.when)((0, _deferred.fromPromise)(dragEndEventArgs.cancel)).done(function (cancel) {
        if (!cancel) {
          if (targetDraggable !== _this4) {
            targetDraggable._getAction('onDrop')(dropEventArgs);
          }
          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            // eslint-disable-next-line @typescript-eslint/no-misused-promises
            (0, _deferred.when)((0, _deferred.fromPromise)(targetDraggable.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }
        d.resolve();
      })
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      .fail(d.resolve);
      d.done(function () {
        if (needRevertPosition) {
          _this4._revertItemToInitialPosition();
        }
        _this4._resetDragOptions(targetDraggable);
      });
    }
  },
  _isTargetOverAnotherDraggable(e) {
    var _this5 = this;
    var sourceDraggable = this._getSourceDraggable();
    if (this === sourceDraggable) {
      return false;
    }
    var $dragElement = sourceDraggable._$dragElement;
    var $sourceDraggableElement = sourceDraggable.$element();
    var $targetDraggableElement = this.$element();
    var mousePosition = getMousePosition(e);
    var elements = _dom_adapter.default.elementsFromPoint(mousePosition.x, mousePosition.y, this.element());
    var firstWidgetElement = elements.filter(function (element) {
      var $element = (0, _renderer.default)(element);
      if ($element.hasClass(_this5._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
      return false;
    })[0];
    var $sourceElement = this._getSourceElement();
    var isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    var isTargetOverNestedDraggable = (0, _renderer.default)(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  },
  _dragEnterHandler(e) {
    this._fireDragEnterEvent(e);
    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }
    var sourceDraggable = this._getSourceDraggable();
    sourceDraggable.dragEnter(e);
  },
  _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e);
    this._resetTargetDraggable();
    if (this !== this._getSourceDraggable()) {
      this.reset();
    }
    var sourceDraggable = this._getSourceDraggable();
    sourceDraggable.dragLeave(e);
  },
  _keydownHandler(e) {
    if (this.dragInProgress && e.key === 'Escape') {
      this._keydownEscapeHandler(e);
    }
  },
  _keydownEscapeHandler(e) {
    var $sourceElement = this._getSourceElement();
    if (!$sourceElement) {
      return;
    }
    var dragCancelEventArgs = this._getEventArgs(e);
    this._getAction('onDragCancel')(dragCancelEventArgs);
    if (dragCancelEventArgs.cancel) {
      return;
    }
    this.dragInProgress = false;
    sourceDraggable === null || sourceDraggable === void 0 ? void 0 : sourceDraggable._toggleDraggingClass(false);
    this._detachEventHandlers();
    this._revertItemToInitialPosition();
    var targetDraggable = this._getTargetDraggable();
    this._resetDragOptions(targetDraggable);
    this._attachEventHandlers();
  },
  _getAction(name) {
    return this["_".concat(name, "Action")] || this._createActionByOption(name);
  },
  _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initTemplates() {
    if (!this.option('contentTemplate')) return;
    this._templateManager.addDefaultTemplates({
      content: new _empty_template.EmptyTemplate()
    });
    this.callBase.apply(this, arguments);
  },
  _render() {
    this.callBase();
    this.$element().addClass(this._addWidgetPrefix());
    var transclude = this._templateManager.anonymousTemplateName === this.option('contentTemplate');
    var template = this._getTemplateByOption('contentTemplate');
    if (template) {
      (0, _renderer.default)(template.render({
        container: this.element(),
        transclude
      }));
    }
  },
  _optionChanged(args) {
    var name = args.name;
    switch (name) {
      case 'onDragStart':
      case 'onDragMove':
      case 'onDragEnd':
      case 'onDrop':
      case 'onDragEnter':
      case 'onDragLeave':
      case 'onDragCancel':
      case 'onDraggableElementShown':
        this["_".concat(name, "Action")] = this._createActionByOption(name);
        break;
      case 'dragTemplate':
      case 'contentTemplate':
      case 'container':
      case 'clone':
        break;
      case 'allowMoveByClick':
      case 'dragDirection':
      case 'disabled':
      case 'boundary':
      case 'filter':
      case 'immediate':
        this._resetDragElement();
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case 'onCancelByEsc':
        this._keydownHandler();
        break;
      case 'autoScroll':
        this._verticalScrollHelper.reset();
        this._horizontalScrollHelper.reset();
        break;
      case 'scrollSensitivity':
      case 'scrollSpeed':
      case 'boundOffset':
      case 'handle':
      case 'group':
      case 'data':
      case 'itemData':
        break;
      default:
        this.callBase(args);
    }
  },
  _getTargetDraggable() {
    return targetDraggable || this;
  },
  _getSourceDraggable() {
    return sourceDraggable || this;
  },
  _setTargetDraggable() {
    var currentGroup = this.option('group');
    var sourceDraggable = this._getSourceDraggable();
    if (currentGroup && currentGroup === sourceDraggable.option('group')) {
      targetDraggable = this;
    }
  },
  _setSourceDraggable() {
    sourceDraggable = this;
  },
  _resetSourceDraggable() {
    sourceDraggable = null;
  },
  _resetTargetDraggable() {
    targetDraggable = null;
  },
  _resetDragOptions(targetDraggable) {
    this.reset();
    targetDraggable.reset();
    this._stopAnimator();
    this._horizontalScrollHelper.reset();
    this._verticalScrollHelper.reset();
    this._resetDragElement();
    this._resetSourceElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
  },
  _dispose() {
    this.callBase();
    this._detachEventHandlers();
    this._resetDragElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
    this._$sourceElement = null;
    this._stopAnimator();
  },
  _fireDragEnterEvent(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);
    this._getAction('onDragEnter')(args);
  },
  _fireDragLeaveEvent(sourceEvent) {
    var args = this._getEventArgs(sourceEvent);
    this._getAction('onDragLeave')(args);
  }
});
(0, _component_registrator.default)(DRAGGABLE, Draggable);
var _default = Draggable;
exports["default"] = _default;

/***/ }),

/***/ 41690:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AdvancedChart = void 0;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _base_axis = __webpack_require__(41278);
var _series_family = __webpack_require__(1939);
var _utils = __webpack_require__(19157);
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var _range = __webpack_require__(21177);
var _m_base_chart = __webpack_require__(14107);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var isArray = Array.isArray;
var DEFAULT_AXIS_NAME = 'defaultAxisName';
var FONT = 'font';
var COMMON_AXIS_SETTINGS = 'commonAxisSettings';
var DEFAULT_PANE_NAME = 'default';
var VISUAL_RANGE = 'VISUAL_RANGE';
function prepareAxis(axisOptions) {
  return isArray(axisOptions) ? axisOptions.length === 0 ? [{}] : axisOptions : [axisOptions];
}
function processBubbleMargin(opt, bubbleSize) {
  if (opt.processBubbleSize) {
    opt.size = bubbleSize;
  }
  return opt;
}
function estimateBubbleSize(size, panesCount, maxSize, rotated) {
  var width = rotated ? size.width / panesCount : size.width;
  var height = rotated ? size.height : size.height / panesCount;
  return Math.min(width, height) * maxSize;
}
function setAxisVisualRangeByOption(arg, axis, isDirectOption, index) {
  var options;
  var visualRange;
  if (isDirectOption) {
    visualRange = arg.value;
    options = {
      skipEventRising: true
    };
    var wrappedVisualRange = wrapVisualRange(arg.fullName, visualRange);
    if (wrappedVisualRange) {
      options = {
        allowPartialUpdate: true
      };
      visualRange = wrappedVisualRange;
    }
  } else {
    visualRange = ((0, _type.isDefined)(index) ? arg.value[index] : arg.value).visualRange;
  }
  axis.visualRange(visualRange, options);
}
function getAxisTypes(groupsData, axis, isArgumentAxes) {
  if (isArgumentAxes) {
    return {
      argumentAxisType: groupsData.argumentAxisType,
      argumentType: groupsData.argumentType
    };
  }
  var _groupsData$groups$fi = groupsData.groups.filter(function (g) {
      return g.valueAxis === axis;
    })[0],
    valueAxisType = _groupsData$groups$fi.valueAxisType,
    valueType = _groupsData$groups$fi.valueType;
  return {
    valueAxisType,
    valueType
  };
}
function wrapVisualRange(fullName, value) {
  var pathElements = fullName.split('.');
  var destElem = pathElements[pathElements.length - 1];
  if (destElem === 'endValue' || destElem === 'startValue') {
    return {
      [destElem]: value
    };
  }
  return undefined;
}
var AdvancedChart = _m_base_chart.BaseChart.inherit({
  _fontFields: ["".concat(COMMON_AXIS_SETTINGS, ".label.").concat(FONT), "".concat(COMMON_AXIS_SETTINGS, ".title.").concat(FONT)],
  _partialOptionChangesMap: {
    visualRange: VISUAL_RANGE,
    _customVisualRange: VISUAL_RANGE,
    strips: 'REFRESH_AXES',
    constantLines: 'REFRESH_AXES'
  },
  _partialOptionChangesPath: {
    argumentAxis: ['strips', 'constantLines', 'visualRange', '_customVisualRange'],
    valueAxis: ['strips', 'constantLines', 'visualRange', '_customVisualRange']
  },
  _initCore() {
    this._panesClipRects = {};
    this.callBase();
  },
  _disposeCore() {
    var disposeObjectsInArray = this._disposeObjectsInArray;
    var panesClipRects = this._panesClipRects;
    this.callBase();
    disposeObjectsInArray.call(panesClipRects, 'fixed');
    disposeObjectsInArray.call(panesClipRects, 'base');
    disposeObjectsInArray.call(panesClipRects, 'wide');
    this._panesClipRects = null;
    this._labelsAxesGroup.linkOff();
    this._labelsAxesGroup.dispose();
    this._labelsAxesGroup = null;
  },
  _dispose() {
    var that = this;
    var disposeObjectsInArray = this._disposeObjectsInArray;
    that.callBase();
    that.panes = null;
    if (that._legend) {
      that._legend.dispose();
      that._legend = null;
    }
    disposeObjectsInArray.call(that, 'panesBackground');
    disposeObjectsInArray.call(that, 'seriesFamilies');
    that._disposeAxes();
  },
  _createPanes() {
    this._cleanPanesClipRects('fixed');
    this._cleanPanesClipRects('base');
    this._cleanPanesClipRects('wide');
  },
  _cleanPanesClipRects(clipArrayName) {
    var clipArray = this._panesClipRects[clipArrayName];
    (clipArray || []).forEach(function (clipRect) {
      return clipRect && clipRect.dispose();
    });
    this._panesClipRects[clipArrayName] = [];
  },
  _getElementsClipRectID(paneName) {
    var clipShape = this._panesClipRects.fixed[this._getPaneIndex(paneName)];
    return clipShape && clipShape.id;
  },
  _getPaneIndex(paneName) {
    var paneIndex;
    var name = paneName || DEFAULT_PANE_NAME;
    (0, _iterator.each)(this.panes, function (index, pane) {
      if (pane.name === name) {
        paneIndex = index;
        return false;
      }
      return undefined;
    });
    return paneIndex;
  },
  _updateSize() {
    this.callBase();
    (0, _utils.setCanvasValues)(this._canvas);
  },
  _reinitAxes() {
    this.panes = this._createPanes();
    this._populateAxes();
    this._axesReinitialized = true;
  },
  _populateAxes() {
    var that = this;
    var panes = that.panes;
    var rotated = that._isRotated();
    var argumentAxesOptions = prepareAxis(that.option('argumentAxis') || {})[0];
    var valueAxisOption = that.option('valueAxis');
    var valueAxesOptions = prepareAxis(valueAxisOption || {});
    var argumentAxesPopulatedOptions = [];
    var valueAxesPopulatedOptions = [];
    var axisNames = [];
    var valueAxesCounter = 0;
    var paneWithNonVirtualAxis;
    var crosshairMargins = that._getCrosshairMargins();
    function getNextAxisName() {
      return DEFAULT_AXIS_NAME + valueAxesCounter++;
    }
    if (rotated) {
      paneWithNonVirtualAxis = argumentAxesOptions.position === 'right' ? panes[panes.length - 1].name : panes[0].name;
    } else {
      paneWithNonVirtualAxis = argumentAxesOptions.position === 'top' ? panes[0].name : panes[panes.length - 1].name;
    }
    argumentAxesPopulatedOptions = (0, _utils.map)(panes, function (pane) {
      var virtual = pane.name !== paneWithNonVirtualAxis;
      return that._populateAxesOptions('argumentAxis', argumentAxesOptions, {
        pane: pane.name,
        name: null,
        optionPath: 'argumentAxis',
        crosshairMargin: rotated ? crosshairMargins.x : crosshairMargins.y
      }, rotated, virtual);
    });
    (0, _iterator.each)(valueAxesOptions, function (priority, axisOptions) {
      var _a;
      var axisPanes = [];
      var name = axisOptions.name;
      if (name && axisNames.includes(name)) {
        that._incidentOccurred('E2102');
        return;
      }
      if (name) {
        axisNames.push(name);
      }
      if (axisOptions.pane) {
        axisPanes.push(axisOptions.pane);
      }
      if ((_a = axisOptions.panes) === null || _a === void 0 ? void 0 : _a.length) {
        axisPanes = axisPanes.concat(axisOptions.panes.slice(0));
      }
      axisPanes = (0, _utils.unique)(axisPanes);
      if (!axisPanes.length) {
        axisPanes.push(undefined);
      }
      (0, _iterator.each)(axisPanes, function (_, pane) {
        var optionPath = isArray(valueAxisOption) ? "valueAxis[".concat(priority, "]") : 'valueAxis';
        valueAxesPopulatedOptions.push(that._populateAxesOptions('valueAxis', axisOptions, {
          name: name || getNextAxisName(),
          pane,
          priority,
          optionPath,
          crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
        }, rotated));
      });
    });
    that._redesignAxes(argumentAxesPopulatedOptions, true, paneWithNonVirtualAxis);
    that._redesignAxes(valueAxesPopulatedOptions, false);
  },
  _redesignAxes(options, isArgumentAxes, paneWithNonVirtualAxis) {
    var that = this;
    var axesBasis = [];
    var axes = isArgumentAxes ? that._argumentAxes : that._valueAxes;
    (0, _iterator.each)(options, function (_, opt) {
      var curAxes = axes && axes.filter(function (a) {
        return a.name === opt.name && (!(0, _type.isDefined)(opt.pane) && that.panes.some(function (p) {
          return p.name === a.pane;
        }) || a.pane === opt.pane);
      });
      if (curAxes && curAxes.length > 0) {
        (0, _iterator.each)(curAxes, function (_, axis) {
          var axisTypes = getAxisTypes(that._groupsData, axis, isArgumentAxes); // T891599
          axis.updateOptions(opt);
          if (isArgumentAxes) {
            axis.setTypes(axisTypes.argumentAxisType, axisTypes.argumentType, 'argumentType');
          } else {
            axis.setTypes(axisTypes.valueAxisType, axisTypes.valueType, 'valueType');
          }
          axis.validate();
          axesBasis.push({
            axis
          });
        });
      } else {
        axesBasis.push({
          options: opt
        });
      }
    });
    if (axes) {
      (0, _iterator.reverseEach)(axes, function (index, axis) {
        if (!axesBasis.some(function (basis) {
          return basis.axis && basis.axis === axis;
        })) {
          that._disposeAxis(index, isArgumentAxes);
        }
      });
    } else if (isArgumentAxes) {
      axes = that._argumentAxes = [];
    } else {
      axes = that._valueAxes = [];
    }
    (0, _iterator.each)(axesBasis, function (_, basis) {
      var axis = basis.axis;
      if (basis.axis && isArgumentAxes) {
        basis.axis.isVirtual = basis.axis.pane !== paneWithNonVirtualAxis;
      } else if (basis.options) {
        axis = that._createAxis(isArgumentAxes, basis.options, isArgumentAxes ? basis.options.pane !== paneWithNonVirtualAxis : undefined);
        axes.push(axis);
      }
      axis.applyVisualRangeSetter(that._getVisualRangeSetter());
    });
  },
  _disposeAxis(index, isArgumentAxis) {
    var axes = isArgumentAxis ? this._argumentAxes : this._valueAxes;
    var axis = axes[index];
    if (!axis) return;
    axis.dispose();
    axes.splice(index, 1);
  },
  _disposeAxes() {
    var that = this;
    var disposeObjectsInArray = that._disposeObjectsInArray;
    disposeObjectsInArray.call(that, '_argumentAxes');
    disposeObjectsInArray.call(that, '_valueAxes');
  },
  _appendAdditionalSeriesGroups() {
    this._crosshairCursorGroup.linkAppend();
    // this._legendGroup.linkAppend();
    this._scrollBar && this._scrollBarGroup.linkAppend(); // TODO: Must be appended in the same place where removed (chart)
  },

  _getLegendTargets() {
    var _this = this;
    return (this.series || []).map(function (s) {
      var item = _this._getLegendOptions(s);
      item.legendData.series = s;
      if (!s.getOptions().showInLegend) {
        item.legendData.visible = false;
      }
      return item;
    });
  },
  _legendItemTextField: 'name',
  _seriesPopulatedHandlerCore() {
    this._processSeriesFamilies();
    this._processValueAxisFormat();
  },
  _renderTrackers() {
    var that = this;
    var i;
    for (i = 0; i < that.series.length; ++i) {
      that.series[i].drawTrackers();
    }
    // TODO we don't need it
    // if (that._legend) {
    //    legendHasInsidePosition && that._legendGroup.append(that._renderer.root);
    // }
  },

  _specialProcessSeries() {
    this._processSeriesFamilies();
  },
  _processSeriesFamilies() {
    var _a;
    var that = this;
    var types = [];
    var families = [];
    var paneSeries;
    var themeManager = that._themeManager;
    var negativesAsZeroes = themeManager.getOptions('negativesAsZeroes');
    var negativesAsZeros = themeManager.getOptions('negativesAsZeros'); // misspelling case
    var familyOptions = {
      minBubbleSize: themeManager.getOptions('minBubbleSize'),
      maxBubbleSize: themeManager.getOptions('maxBubbleSize'),
      barGroupPadding: themeManager.getOptions('barGroupPadding'),
      barGroupWidth: themeManager.getOptions('barGroupWidth'),
      negativesAsZeroes: (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros
    };
    if ((_a = that.seriesFamilies) === null || _a === void 0 ? void 0 : _a.length) {
      (0, _iterator.each)(that.seriesFamilies, function (_, family) {
        family.updateOptions(familyOptions);
        family.adjustSeriesValues();
      });
      return;
    }
    (0, _iterator.each)(that.series, function (_, item) {
      if (!types.includes(item.type)) {
        types.push(item.type);
      }
    });
    (0, _iterator.each)(that._getLayoutTargets(), function (_, pane) {
      paneSeries = that._getSeriesForPane(pane.name);
      (0, _iterator.each)(types, function (_, type) {
        var family = new _series_family.SeriesFamily({
          type,
          pane: pane.name,
          minBubbleSize: familyOptions.minBubbleSize,
          maxBubbleSize: familyOptions.maxBubbleSize,
          barGroupPadding: familyOptions.barGroupPadding,
          barGroupWidth: familyOptions.barGroupWidth,
          negativesAsZeroes: familyOptions.negativesAsZeroes,
          rotated: that._isRotated()
        });
        family.add(paneSeries);
        family.adjustSeriesValues();
        families.push(family);
      });
    });
    that.seriesFamilies = families;
  },
  _updateSeriesDimensions() {
    var that = this;
    var i;
    var seriesFamilies = that.seriesFamilies || [];
    for (i = 0; i < seriesFamilies.length; i++) {
      var family = seriesFamilies[i];
      family.updateSeriesValues();
      family.adjustSeriesDimensions();
    }
  },
  _getLegendCallBack(series) {
    return this._legend && this._legend.getActionCallback(series);
  },
  _appendAxesGroups() {
    var that = this;
    that._stripsGroup.linkAppend();
    that._gridGroup.linkAppend();
    that._axesGroup.linkAppend();
    that._labelsAxesGroup.linkAppend();
    that._constantLinesGroup.linkAppend();
    that._stripLabelAxesGroup.linkAppend();
    that._scaleBreaksGroup.linkAppend();
  },
  _populateMarginOptions() {
    var that = this;
    var bubbleSize = estimateBubbleSize(that.getSize(), that.panes.length, that._themeManager.getOptions('maxBubbleSize'), that._isRotated());
    var argumentMarginOptions = {};
    that._valueAxes.forEach(function (valueAxis) {
      var groupSeries = that.series.filter(function (series) {
        return series.getValueAxis() === valueAxis;
      });
      var marginOptions = {};
      groupSeries.forEach(function (series) {
        if (series.isVisible()) {
          var seriesMarginOptions = processBubbleMargin(series.getMarginOptions(), bubbleSize);
          marginOptions = (0, _utils.mergeMarginOptions)(marginOptions, seriesMarginOptions);
          argumentMarginOptions = (0, _utils.mergeMarginOptions)(argumentMarginOptions, seriesMarginOptions);
        }
      });
      valueAxis.setMarginOptions(marginOptions);
    });
    that._argumentAxes.forEach(function (a) {
      return a.setMarginOptions(argumentMarginOptions);
    });
  },
  _populateBusinessRange(updatedAxis, keepRange) {
    var that = this;
    var rotated = that._isRotated();
    var series = that._getVisibleSeries();
    var argRanges = {};
    var commonArgRange = new _range.Range({
      rotated: !!rotated
    });
    var getPaneName = function getPaneName(axis) {
      return axis.pane || DEFAULT_PANE_NAME;
    };
    that.panes.forEach(function (p) {
      argRanges[p.name] = new _range.Range({
        rotated: !!rotated
      });
    });
    that._valueAxes.forEach(function (valueAxis) {
      var groupRange = new _range.Range({
        rotated: !!rotated,
        pane: valueAxis.pane,
        axis: valueAxis.name
      });
      var groupSeries = series.filter(function (series) {
        return series.getValueAxis() === valueAxis;
      });
      groupSeries.forEach(function (series) {
        var seriesRange = series.getRangeData();
        groupRange.addRange(seriesRange.val);
        argRanges[getPaneName(valueAxis)].addRange(seriesRange.arg);
      });
      if (!updatedAxis || updatedAxis && groupSeries.length && valueAxis === updatedAxis) {
        valueAxis.setGroupSeries(groupSeries);
        valueAxis.setBusinessRange(groupRange, that._axesReinitialized || keepRange, that._argumentAxes[0]._lastVisualRangeUpdateMode);
      }
    });
    if (!updatedAxis || updatedAxis && series.length) {
      Object.keys(argRanges).forEach(function (p) {
        return commonArgRange.addRange(argRanges[p]);
      });
      var commonInterval = commonArgRange.interval;
      that._argumentAxes.forEach(function (a) {
        var _a;
        var currentInterval = (_a = argRanges[getPaneName(a)].interval) !== null && _a !== void 0 ? _a : commonInterval; // T956425
        a.setBusinessRange(new _range.Range(_extends(_extends({}, commonArgRange), {
          interval: currentInterval
        })), that._axesReinitialized, undefined, that._groupsData.categories);
      });
    }
    that._populateMarginOptions();
  },
  getArgumentAxis() {
    return (this._argumentAxes || []).filter(function (a) {
      return !a.isVirtual;
    })[0];
  },
  getValueAxis(name) {
    var _this2 = this;
    return (this._valueAxes || []).filter((0, _type.isDefined)(name) ? function (a) {
      return a.name === name;
    } : function (a) {
      return a.pane === _this2.defaultPane;
    })[0];
  },
  _getGroupsData() {
    var _this3 = this;
    var groups = [];
    this._valueAxes.forEach(function (axis) {
      groups.push({
        series: _this3.series.filter(function (series) {
          return series.getValueAxis() === axis;
        }),
        valueAxis: axis,
        valueOptions: axis.getOptions()
      });
    });
    return {
      groups,
      argumentAxes: this._argumentAxes,
      argumentOptions: this._argumentAxes[0].getOptions()
    };
  },
  _groupSeries() {
    var that = this;
    that._correctValueAxes(false);
    that._groupsData = that._getGroupsData();
  },
  _processValueAxisFormat() {
    var axesWithFullStackedFormat = [];
    this.series.forEach(function (series) {
      var axis = series.getValueAxis();
      if (series.isFullStackedSeries()) {
        axis.setPercentLabelFormat();
        axesWithFullStackedFormat.push(axis);
      }
    });
    this._valueAxes.forEach(function (axis) {
      if (!axesWithFullStackedFormat.includes(axis)) {
        axis.resetAutoLabelFormat(); // B239299
      }
    });
  },

  _populateAxesOptions(typeSelector, userOptions, axisOptions, rotated, virtual) {
    var that = this;
    var preparedUserOptions = that._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);
    var options = (0, _extend2.extend)(true, {}, preparedUserOptions, axisOptions, that._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));
    if (virtual) {
      options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;
      options.title = {};
    }
    return options;
  },
  _getValFilter(series) {
    return _range_data_calculator.default.getViewPortFilter(series.getValueAxis().visualRange() || {});
  },
  _createAxis(isArgumentAxes, options, virtual) {
    var that = this;
    var typeSelector = isArgumentAxes ? 'argumentAxis' : 'valueAxis';
    var renderingSettings = (0, _extend2.extend)({
      renderer: that._renderer,
      incidentOccurred: that._incidentOccurred,
      eventTrigger: that._eventTrigger,
      axisClass: isArgumentAxes ? 'arg' : 'val',
      widgetClass: 'dxc',
      stripsGroup: that._stripsGroup,
      stripLabelAxesGroup: that._stripLabelAxesGroup,
      constantLinesGroup: that._constantLinesGroup,
      scaleBreaksGroup: that._scaleBreaksGroup,
      axesContainerGroup: that._axesGroup,
      labelsAxesGroup: that._labelsAxesGroup,
      gridGroup: that._gridGroup,
      isArgumentAxis: isArgumentAxes,
      getTemplate(template) {
        return that._getTemplate(template);
      }
    }, that._getAxisRenderingOptions(typeSelector));
    var axis = new _base_axis.Axis(renderingSettings);
    axis.updateOptions(options);
    axis.isVirtual = virtual;
    return axis;
  },
  _applyVisualRangeByVirtualAxes() {
    return false;
  },
  _applyCustomVisualRangeOption(axis, range) {
    var that = this;
    if (axis.getOptions().optionPath) {
      that._parseVisualRangeOption("".concat(axis.getOptions().optionPath, ".visualRange"), range);
    }
  },
  _getVisualRangeSetter() {
    var chart = this;
    return function (axis, _ref) {
      var skipEventRising = _ref.skipEventRising,
        range = _ref.range;
      chart._applyCustomVisualRangeOption(axis, range);
      axis.setCustomVisualRange(range);
      axis.skipEventRising = skipEventRising;
      if (!chart._applyVisualRangeByVirtualAxes(axis, range)) {
        if (chart._applyingChanges) {
          chart._change_VISUAL_RANGE();
        } else {
          chart._requestChange([VISUAL_RANGE]);
        }
      }
    };
  },
  _getTrackerSettings() {
    return (0, _extend2.extend)(this.callBase(), {
      argumentAxis: this.getArgumentAxis()
    });
  },
  _prepareStripsAndConstantLines(typeSelector, userOptions, rotated) {
    userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);
    if (userOptions.strips) {
      (0, _iterator.each)(userOptions.strips, function (i) {
        userOptions.strips[i] = (0, _extend2.extend)(true, {}, userOptions.stripStyle, userOptions.strips[i]);
      });
    }
    if (userOptions.constantLines) {
      (0, _iterator.each)(userOptions.constantLines, function (i, line) {
        userOptions.constantLines[i] = (0, _extend2.extend)(true, {}, userOptions.constantLineStyle, line);
      });
    }
    return userOptions;
  },
  refresh() {
    this._disposeAxes();
    this.callBase();
  },
  _layoutAxes(drawAxes) {
    var that = this;
    drawAxes();
    var needSpace = that.checkForMoreSpaceForPanesCanvas();
    if (needSpace) {
      var rect = this._rect.slice();
      var size = this._layout.backward(rect, rect, [needSpace.width, needSpace.height]);
      needSpace.width = Math.max(0, size[0]);
      needSpace.height = Math.max(0, size[1]);
      this._canvas = this._createCanvasFromRect(rect);
      drawAxes(needSpace);
    }
  },
  checkForMoreSpaceForPanesCanvas() {
    return this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), this._isRotated());
  },
  _parseVisualRangeOption(fullName, value) {
    var _a;
    var that = this;
    var name = fullName.split(/[.[]/)[0];
    var index = fullName.match(/\d+/g);
    index = (0, _type.isDefined)(index) ? parseInt(index[0], 10) : index;
    if (fullName.indexOf('visualRange') > 0) {
      if ((0, _type.type)(value) !== 'object') {
        value = (_a = wrapVisualRange(fullName, value)) !== null && _a !== void 0 ? _a : value;
      }
      that._setCustomVisualRange(name, index, value);
    } else if (((0, _type.type)(value) === 'object' || isArray(value)) && name.indexOf('Axis') > 0 && JSON.stringify(value).indexOf('visualRange') > 0) {
      if ((0, _type.isDefined)(value.visualRange)) {
        that._setCustomVisualRange(name, index, value.visualRange);
      } else if (isArray(value)) {
        value.forEach(function (a, i) {
          return (0, _type.isDefined)(a.visualRange) && that._setCustomVisualRange(name, i, a.visualRange);
        });
      }
    }
  },
  _setCustomVisualRange(axesName, index, value) {
    var that = this;
    var options = that._options.silent(axesName);
    if (!options) {
      return;
    }
    if (!(0, _type.isDefined)(index)) {
      options._customVisualRange = value;
    } else {
      options[index]._customVisualRange = value;
    }
    that._axesReinitialized = true;
  },
  _raiseZoomEndHandlers() {
    this._valueAxes.forEach(function (axis) {
      return axis.handleZoomEnd();
    });
  },
  _setOptionsByReference() {
    this.callBase();
    (0, _extend2.extend)(this._optionsByReference, {
      'valueAxis.visualRange': true
    });
  },
  _notifyOptionChanged(option, value) {
    this.callBase.apply(this, arguments);
    if (!this._optionChangedLocker) {
      this._parseVisualRangeOption(option, value);
    }
  },
  _notifyVisualRange() {
    var that = this;
    that._valueAxes.forEach(function (axis) {
      var axisPath = axis.getOptions().optionPath;
      if (axisPath) {
        var path = "".concat(axisPath, ".visualRange");
        var visualRange = (0, _utils.convertVisualRangeObject)(axis.visualRange(), !isArray(that.option(path)));
        if (!axis.skipEventRising || !(0, _utils.rangesAreEqual)(visualRange, that.option(path))) {
          if (!that.option(axisPath) && axisPath !== 'valueAxis') {
            that.option(axisPath, {
              name: axis.name,
              visualRange
            });
          } else {
            that.option(path, visualRange);
          }
        } else {
          axis.skipEventRising = null;
        }
      }
    });
  },
  _notify() {
    this.callBase();
    this._axesReinitialized = false;
    if (this.option('disableTwoWayBinding') !== true) {
      // for dashboards T732396
      this.skipOptionsRollBack = true; // T1037806
      this._notifyVisualRange();
      this.skipOptionsRollBack = false;
    }
  },
  _getAxesForScaling() {
    return this._valueAxes;
  },
  _getAxesByOptionPath(arg, isDirectOption, optionName) {
    var that = this;
    var sourceAxes = that._getAxesForScaling();
    var axes = [];
    if (isDirectOption) {
      var axisPath;
      if (arg.fullName) {
        axisPath = arg.fullName.slice(0, arg.fullName.indexOf('.'));
      }
      axes = sourceAxes.filter(function (a) {
        return a.getOptions().optionPath === axisPath;
      });
    } else if ((0, _type.type)(arg.value) === 'object') {
      axes = sourceAxes.filter(function (a) {
        return a.getOptions().optionPath === arg.name;
      });
    } else if (isArray(arg.value)) {
      arg.value.forEach(function (v, index) {
        var axis = sourceAxes.filter(function (a) {
          return a.getOptions().optionPath === "".concat(arg.name, "[").concat(index, "]");
        })[0];
        (0, _type.isDefined)(v[optionName]) && (0, _type.isDefined)(axis) && (axes[index] = axis);
      });
    }
    return axes;
  },
  _optionChanged(arg) {
    var that = this;
    if (!that._optionChangedLocker) {
      var optionName = 'visualRange';
      var axes;
      var isDirectOption = arg.fullName.indexOf(optionName) > 0 ? true : that.getPartialChangeOptionsName(arg).indexOf(optionName) > -1 ? false : undefined;
      if ((0, _type.isDefined)(isDirectOption)) {
        axes = that._getAxesByOptionPath(arg, isDirectOption, optionName);
        if (axes) {
          if (axes.length > 1 || isArray(arg.value)) {
            axes.forEach(function (a, index) {
              return setAxisVisualRangeByOption(arg, a, isDirectOption, index);
            });
          } else if (axes.length === 1) {
            setAxisVisualRangeByOption(arg, axes[0], isDirectOption);
          }
        }
      }
    }
    that.callBase(arg);
  },
  _change_VISUAL_RANGE() {
    var that = this;
    that._recreateSizeDependentObjects(false);
    if (!that._changes.has('FULL_RENDER')) {
      var resizePanesOnZoom = that.option('resizePanesOnZoom');
      that._doRender({
        force: true,
        drawTitle: false,
        drawLegend: false,
        adjustAxes: resizePanesOnZoom !== null && resizePanesOnZoom !== void 0 ? resizePanesOnZoom : that.option('adjustAxesOnZoom') || false,
        animate: false
      });
      that._raiseZoomEndHandlers();
    }
  },
  // API
  resetVisualRange() {
    var that = this;
    that._valueAxes.forEach(function (axis) {
      axis.resetVisualRange(false); // T602156
      that._applyCustomVisualRangeOption(axis);
    });
    that._requestChange([VISUAL_RANGE]);
  },
  _getCrosshairMargins() {
    return {
      x: 0,
      y: 0
    };
  },
  _legendDataField: 'series',
  _adjustSeriesLabels: _common.noop,
  _correctValueAxes: _common.noop
});
exports.AdvancedChart = AdvancedChart;

/***/ }),

/***/ 14107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.overlapping = exports.BaseChart = void 0;
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _layout_manager = __webpack_require__(21495);
var trackerModule = _interopRequireWildcard(__webpack_require__(19957));
var _chart_theme_manager = __webpack_require__(99327);
var _data_validator = __webpack_require__(45865);
var _legend = __webpack_require__(16342);
var _data_source = __webpack_require__(1539);
var _export = __webpack_require__(82454);
var _loading_indicator = __webpack_require__(64758);
var _title = __webpack_require__(17384);
var _tooltip = __webpack_require__(14371);
var _utils = __webpack_require__(19157);
var _base_series = __webpack_require__(54932);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

// PLUGINS_SECTION

var isArray = Array.isArray;
var REINIT_REFRESH_ACTION = '_reinit';
var REINIT_DATA_SOURCE_REFRESH_ACTION = '_updateDataSource';
var DATA_INIT_REFRESH_ACTION = '_dataInit';
var FORCE_RENDER_REFRESH_ACTION = '_forceRender';
var RESIZE_REFRESH_ACTION = '_resize';
var ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION];
var DEFAULT_OPACITY = 0.3;
var REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS = ['series', 'commonSeriesSettings', 'dataPrepareSettings', 'seriesSelectionMode', 'pointSelectionMode', 'synchronizeMultiAxes', 'resolveLabelsOverlapping'];
var REFRESH_SERIES_FAMILIES_ACTION_OPTIONS = ['minBubbleSize', 'maxBubbleSize', 'barGroupPadding', 'barGroupWidth', 'negativesAsZeroes', 'negativesAsZeros' // misspelling case
];

var FORCE_RENDER_REFRESH_ACTION_OPTIONS = ['adaptiveLayout', 'crosshair', 'resolveLabelOverlapping', 'adjustOnZoom', 'stickyHovering'];
var FONT = 'font';
function checkHeightRollingStock(rollingStocks, stubCanvas) {
  var canvasSize = stubCanvas.end - stubCanvas.start;
  var size = 0;
  rollingStocks.forEach(function (rollingStock) {
    size += rollingStock.getBoundingRect().width;
  });
  while (canvasSize < size) {
    size -= findAndKillSmallValue(rollingStocks);
  }
}
function findAndKillSmallValue(rollingStocks) {
  var smallestObject = rollingStocks.reduce(function (prev, rollingStock, index) {
    if (!rollingStock) return prev;
    var value = rollingStock.value();
    return value < prev.value ? {
      value,
      rollingStock,
      index
    } : prev;
  }, {
    rollingStock: undefined,
    value: Infinity,
    index: undefined
  });
  smallestObject.rollingStock.getLabels()[0].draw(false);
  var _smallestObject$rolli = smallestObject.rollingStock.getBoundingRect(),
    width = _smallestObject$rolli.width;
  rollingStocks[smallestObject.index] = null;
  return width;
}
function checkStackOverlap(rollingStocks) {
  var i;
  var j;
  var iLength;
  var jLength;
  var overlap = false;
  for (i = 0, iLength = rollingStocks.length - 1; i < iLength; i++) {
    for (j = i + 1, jLength = rollingStocks.length; j < jLength; j++) {
      if (i !== j && checkStacksOverlapping(rollingStocks[i], rollingStocks[j], true)) {
        overlap = true;
        break;
      }
    }
    if (overlap) break;
  }
  return overlap;
}
function resolveLabelOverlappingInOneDirection(points, canvas, isRotated, isInverted, shiftFunction) {
  var customSorting = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {
    return 0;
  };
  var rollingStocks = [];
  var stubCanvas = {
    start: isRotated ? canvas.left : canvas.top,
    end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom
  };
  var hasStackedSeries = false;
  var sortRollingStocks;
  points.forEach(function (p) {
    if (!p) return;
    hasStackedSeries = hasStackedSeries || p.series.isStackedSeries() || p.series.isFullStackedSeries();
    p.getLabels().forEach(function (l) {
      if (l.isVisible()) {
        rollingStocks.push(new RollingStock(l, isRotated, shiftFunction));
      }
    });
  });
  if (hasStackedSeries) {
    if (Number(!isRotated) ^ Number(isInverted)) {
      rollingStocks.reverse();
    }
    sortRollingStocks = !isInverted ? sortRollingStocksByValue(rollingStocks) : rollingStocks;
  } else {
    var rollingStocksTmp = rollingStocks.slice();
    sortRollingStocks = rollingStocks.sort(function (a, b) {
      return customSorting(a, b) || a.getInitialPosition() - b.getInitialPosition() || rollingStocksTmp.indexOf(a) - rollingStocksTmp.indexOf(b);
    });
  }
  if (!checkStackOverlap(sortRollingStocks)) return false;
  checkHeightRollingStock(sortRollingStocks, stubCanvas);
  prepareOverlapStacks(sortRollingStocks);
  sortRollingStocks.reverse();
  moveRollingStock(sortRollingStocks, stubCanvas);
  return true;
}
function checkStacksOverlapping(firstRolling, secondRolling, inTwoSides) {
  if (!firstRolling || !secondRolling) return;
  var firstRect = firstRolling.getBoundingRect();
  var secondRect = secondRolling.getBoundingRect();
  var oppositeOverlapping = inTwoSides ? firstRect.oppositeStart <= secondRect.oppositeStart && firstRect.oppositeEnd > secondRect.oppositeStart || secondRect.oppositeStart <= firstRect.oppositeStart && secondRect.oppositeEnd > firstRect.oppositeStart : true;
  return firstRect.end > secondRect.start && oppositeOverlapping;
}
function sortRollingStocksByValue(rollingStocks) {
  var positiveRollingStocks = [];
  var negativeRollingStocks = [];
  rollingStocks.forEach(function (stock) {
    if (stock.value() > 0) {
      positiveRollingStocks.push(stock);
    } else {
      negativeRollingStocks.unshift(stock);
    }
  });
  return positiveRollingStocks.concat(negativeRollingStocks);
}
function prepareOverlapStacks(rollingStocks) {
  var i;
  var currentRollingStock;
  var root;
  for (i = 0; i < rollingStocks.length - 1; i++) {
    currentRollingStock = root || rollingStocks[i];
    if (checkStacksOverlapping(currentRollingStock, rollingStocks[i + 1])) {
      currentRollingStock.toChain(rollingStocks[i + 1]);
      rollingStocks[i + 1] = null;
      root = currentRollingStock;
    } else {
      root = rollingStocks[i + 1] || currentRollingStock;
    }
  }
}
function moveRollingStock(rollingStocks, canvas) {
  var i;
  var j;
  var currentRollingStock;
  var nextRollingStock;
  var currentBBox;
  var nextBBox;
  for (i = 0; i < rollingStocks.length; i++) {
    currentRollingStock = rollingStocks[i];
    if (rollingStocksIsOut(currentRollingStock, canvas)) {
      currentBBox = currentRollingStock.getBoundingRect();
      for (j = i + 1; j < rollingStocks.length; j++) {
        nextRollingStock = rollingStocks[j];
        if (!nextRollingStock) {
          continue;
        }
        nextBBox = nextRollingStock.getBoundingRect();
        if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {
          nextRollingStock.toChain(currentRollingStock);
          rollingStocks[i] = currentRollingStock = null;
          break;
        }
      }
    }
    currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas);
  }
}
function rollingStocksIsOut(rollingStock, canvas) {
  return rollingStock && rollingStock.getBoundingRect().end > canvas.end;
}
function RollingStock(label, isRotated, shiftFunction) {
  var bBox = label.getBoundingRect();
  var x = bBox.x;
  var y = bBox.y;
  var endX = bBox.x + bBox.width;
  var endY = bBox.y + bBox.height;
  this.labels = [label];
  this.shiftFunction = shiftFunction;
  this._bBox = {
    start: isRotated ? x : y,
    width: isRotated ? bBox.width : bBox.height,
    end: isRotated ? endX : endY,
    oppositeStart: isRotated ? y : x,
    oppositeEnd: isRotated ? endY : endX
  };
  this._initialPosition = isRotated ? bBox.x : bBox.y;
}
RollingStock.prototype = {
  toChain(nextRollingStock) {
    var nextRollingStockBBox = nextRollingStock.getBoundingRect();
    nextRollingStock.shift(nextRollingStockBBox.start - this._bBox.end);
    this._changeBoxWidth(nextRollingStockBBox.width);
    this.labels = this.labels.concat(nextRollingStock.labels);
  },
  getBoundingRect() {
    return this._bBox;
  },
  shift(shiftLength) {
    var shiftFunction = this.shiftFunction;
    (0, _iterator.each)(this.labels, function (index, label) {
      var bBox = label.getBoundingRect();
      var coords = shiftFunction(bBox, shiftLength);
      if (!label.hideInsideLabel(coords)) {
        label.shift(coords.x, coords.y);
      }
    });
    this._bBox.end -= shiftLength;
    this._bBox.start -= shiftLength;
  },
  setRollingStockInCanvas(canvas) {
    if (this._bBox.end > canvas.end) {
      this.shift(this._bBox.end - canvas.end);
    }
  },
  getLabels() {
    return this.labels;
  },
  value() {
    return this.labels[0].getData().value;
  },
  getInitialPosition() {
    return this._initialPosition;
  },
  _changeBoxWidth(width) {
    this._bBox.end += width;
    this._bBox.width += width;
  }
};
function getLegendFields(name) {
  return {
    nameField: "".concat(name, "Name"),
    colorField: "".concat(name, "Color"),
    indexField: "".concat(name, "Index")
  };
}
function getLegendSettings(legendDataField) {
  var formatObjectFields = getLegendFields(legendDataField);
  return {
    getFormatObject(data) {
      var res = {};
      res[formatObjectFields.indexField] = data.id;
      res[formatObjectFields.colorField] = data.states.normal.fill;
      res[formatObjectFields.nameField] = data.text;
      return res;
    },
    textField: formatObjectFields.nameField
  };
}
function checkOverlapping(firstRect, secondRect) {
  return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height);
}
var overlapping = {
  resolveLabelOverlappingInOneDirection
};
exports.overlapping = overlapping;
var BaseChart = _m_base_widget.default.inherit({
  _eventsMap: {
    onSeriesClick: {
      name: 'seriesClick'
    },
    onPointClick: {
      name: 'pointClick'
    },
    onArgumentAxisClick: {
      name: 'argumentAxisClick'
    },
    onLegendClick: {
      name: 'legendClick'
    },
    onSeriesSelectionChanged: {
      name: 'seriesSelectionChanged'
    },
    onPointSelectionChanged: {
      name: 'pointSelectionChanged'
    },
    onSeriesHoverChanged: {
      name: 'seriesHoverChanged'
    },
    onPointHoverChanged: {
      name: 'pointHoverChanged'
    },
    onDone: {
      name: 'done',
      actionSettings: {
        excludeValidators: ['disabled']
      }
    },
    onZoomStart: {
      name: 'zoomStart'
    },
    onZoomEnd: {
      name: 'zoomEnd'
    }
  },
  _fontFields: ["legend.".concat(FONT), "legend.title.".concat(FONT), "legend.title.subtitle.".concat(FONT), "commonSeriesSettings.label.".concat(FONT)],
  _rootClassPrefix: 'dxc',
  _rootClass: 'dxc-chart',
  _initialChanges: ['INIT'],
  _themeDependentChanges: ['REFRESH_SERIES_REINIT'],
  _getThemeManagerOptions() {
    var themeOptions = this.callBase.apply(this, arguments);
    themeOptions.options = this.option();
    return themeOptions;
  },
  _createThemeManager() {
    var chartOption = this.option();
    var themeManager = new _chart_theme_manager.ThemeManager(this._getThemeManagerOptions());
    themeManager.setTheme(chartOption.theme, chartOption.rtlEnabled);
    return themeManager;
  },
  _initCore() {
    var that = this;
    that._canvasClipRect = that._renderer.clipRect();
    that._createHtmlStructure();
    that._createLegend();
    that._createTracker();
    that._needHandleRenderComplete = true;
    that.layoutManager = new _layout_manager.LayoutManager();
    that._createScrollBar();
    _events_engine.default.on(that._$element, 'contextmenu', function (event) {
      if ((0, _index.isTouchEvent)(event) || (0, _index.isPointerEvent)(event)) {
        event.preventDefault();
      }
    });
    _events_engine.default.on(that._$element, 'MSHoldVisual', function (event) {
      event.preventDefault();
    });
  },
  // Common functionality is overridden because Chart has its own layout logic. Nevertheless common logic should be used.
  _getLayoutItems: _common.noop,
  _layoutManagerOptions() {
    return this._themeManager.getOptions('adaptiveLayout');
  },
  _reinit() {
    var that = this;
    (0, _utils.setCanvasValues)(that._canvas);
    that._reinitAxes();
    that._requestChange(['DATA_SOURCE', 'DATA_INIT', 'CORRECT_AXIS', 'FULL_RENDER']);
  },
  _correctAxes: _common.noop,
  _createHtmlStructure() {
    var that = this;
    var renderer = that._renderer;
    var root = renderer.root;
    var createConstantLinesGroup = function createConstantLinesGroup() {
      // TODO: Must be created in the same place where used (advanced chart)
      return renderer.g().attr({
        class: 'dxc-constant-lines-group'
      }).linkOn(root, 'constant-lines');
    };
    that._constantLinesGroup = {
      dispose() {
        this.under.dispose();
        this.above.dispose();
      },
      linkOff() {
        this.under.linkOff();
        this.above.linkOff();
      },
      clear() {
        this.under.linkRemove().clear();
        this.above.linkRemove().clear();
      },
      linkAppend() {
        this.under.linkAppend();
        this.above.linkAppend();
      }
    };
    that._labelsAxesGroup = renderer.g().attr({
      class: 'dxc-elements-axes-group'
    });
    var appendLabelsAxesGroup = function appendLabelsAxesGroup() {
      that._labelsAxesGroup.linkOn(root, 'elements');
    };
    that._backgroundRect = renderer.rect().attr({
      fill: 'gray',
      opacity: 0.0001
    }).append(root);
    that._panesBackgroundGroup = renderer.g().attr({
      class: 'dxc-background'
    }).append(root);
    that._stripsGroup = renderer.g().attr({
      class: 'dxc-strips-group'
    }).linkOn(root, 'strips'); // TODO: Must be created in the same place where used (advanced chart)
    that._gridGroup = renderer.g().attr({
      class: 'dxc-grids-group'
    }).linkOn(root, 'grids'); // TODO: Must be created in the same place where used (advanced chart)
    that._panesBorderGroup = renderer.g().attr({
      class: 'dxc-border'
    }).linkOn(root, 'border'); // TODO: Must be created in the same place where used (chart)
    that._axesGroup = renderer.g().attr({
      class: 'dxc-axes-group'
    }).linkOn(root, 'axes'); // TODO: Must be created in the same place where used (advanced chart)
    that._executeAppendBeforeSeries(appendLabelsAxesGroup);
    that._stripLabelAxesGroup = renderer.g().attr({
      class: 'dxc-strips-labels-group'
    }).linkOn(root, 'strips-labels'); // TODO: Must be created in the same place where used (advanced chart)
    that._constantLinesGroup.under = createConstantLinesGroup();
    that._seriesGroup = renderer.g().attr({
      class: 'dxc-series-group'
    }).linkOn(root, 'series');
    that._executeAppendAfterSeries(appendLabelsAxesGroup);
    that._constantLinesGroup.above = createConstantLinesGroup();
    that._scaleBreaksGroup = renderer.g().attr({
      class: 'dxc-scale-breaks'
    }).linkOn(root, 'scale-breaks');
    that._labelsGroup = renderer.g().attr({
      class: 'dxc-labels-group'
    }).linkOn(root, 'labels');
    that._crosshairCursorGroup = renderer.g().attr({
      class: 'dxc-crosshair-cursor'
    }).linkOn(root, 'crosshair');
    that._legendGroup = renderer.g().attr({
      class: 'dxc-legend',
      'clip-path': that._getCanvasClipRectID()
    }).linkOn(root, 'legend').linkAppend(root).enableLinks();
    that._scrollBarGroup = renderer.g().attr({
      class: 'dxc-scroll-bar'
    }).linkOn(root, 'scroll-bar');
  },
  _executeAppendBeforeSeries() {},
  _executeAppendAfterSeries() {},
  _disposeObjectsInArray(propName, fieldNames) {
    (0, _iterator.each)(this[propName] || [], function (_, item) {
      if (fieldNames && item) {
        (0, _iterator.each)(fieldNames, function (_, field) {
          item[field] && item[field].dispose();
        });
      } else {
        item && item.dispose();
      }
    });
    this[propName] = null;
  },
  _disposeCore() {
    var that = this;
    var disposeObject = function disposeObject(propName) {
      // TODO: What is the purpose of the `if` check in a private function?
      if (that[propName]) {
        that[propName].dispose();
        that[propName] = null;
      }
    };
    var unlinkGroup = function unlinkGroup(name) {
      that[name].linkOff();
    };
    var disposeObjectsInArray = this._disposeObjectsInArray;
    that._renderer.stopAllAnimations();
    disposeObjectsInArray.call(that, 'series');
    disposeObject('_tracker');
    disposeObject('_crosshair');
    that.layoutManager = that._userOptions = that._canvas = that._groupsData = null;
    unlinkGroup('_stripsGroup');
    unlinkGroup('_gridGroup');
    unlinkGroup('_axesGroup');
    unlinkGroup('_constantLinesGroup');
    unlinkGroup('_stripLabelAxesGroup');
    unlinkGroup('_panesBorderGroup');
    unlinkGroup('_seriesGroup');
    unlinkGroup('_labelsGroup');
    unlinkGroup('_crosshairCursorGroup');
    unlinkGroup('_legendGroup');
    unlinkGroup('_scrollBarGroup');
    unlinkGroup('_scaleBreaksGroup');
    disposeObject('_canvasClipRect');
    disposeObject('_panesBackgroundGroup');
    disposeObject('_backgroundRect');
    disposeObject('_stripsGroup');
    disposeObject('_gridGroup');
    disposeObject('_axesGroup');
    disposeObject('_constantLinesGroup');
    disposeObject('_stripLabelAxesGroup');
    disposeObject('_panesBorderGroup');
    disposeObject('_seriesGroup');
    disposeObject('_labelsGroup');
    disposeObject('_crosshairCursorGroup');
    disposeObject('_legendGroup');
    disposeObject('_scrollBarGroup');
    disposeObject('_scaleBreaksGroup');
  },
  _getAnimationOptions() {
    return this._themeManager.getOptions('animation');
  },
  _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  // TODO: Theme manager should stop knowing about user options then this method can be removed
  _getOption(name) {
    return this._themeManager.getOptions(name);
  },
  _applySize(rect) {
    this._rect = rect.slice();
    if (!this._changes.has('FULL_RENDER')) {
      this._processRefreshData(RESIZE_REFRESH_ACTION);
    }
  },
  // _resize: function () {
  //    if (this._updateLockCount) {// T244164
  //        this._processRefreshData(RESIZE_REFRESH_ACTION);
  //    } else {
  //        this._render(this.__renderOptions || { animate: false, isResize: true });
  //    }
  // },
  _resize() {
    this._doRender(this.__renderOptions || {
      animate: false,
      isResize: true
    });
  },
  _trackerType: 'ChartTracker',
  _createTracker() {
    var that = this;
    // eslint-disable-next-line import/namespace
    that._tracker = new trackerModule[that._trackerType]({
      seriesGroup: that._seriesGroup,
      renderer: that._renderer,
      tooltip: that._tooltip,
      legend: that._legend,
      eventTrigger: that._eventTrigger
    });
  },
  _getTrackerSettings() {
    return (0, _extend.extend)({
      chart: this
    }, this._getSelectionModes());
  },
  _getSelectionModes() {
    var themeManager = this._themeManager;
    return {
      seriesSelectionMode: themeManager.getOptions('seriesSelectionMode'),
      pointSelectionMode: themeManager.getOptions('pointSelectionMode')
    };
  },
  _updateTracker(trackerCanvases) {
    var that = this;
    that._tracker.update(that._getTrackerSettings());
    that._tracker.setCanvases({
      left: 0,
      right: that._canvas.width,
      top: 0,
      bottom: that._canvas.height
    }, trackerCanvases);
  },
  _createCanvasFromRect(rect) {
    var currentCanvas = this._canvas;
    return (0, _utils.setCanvasValues)({
      left: rect[0],
      top: rect[1],
      right: currentCanvas.width - rect[2],
      bottom: currentCanvas.height - rect[3],
      width: currentCanvas.width,
      height: currentCanvas.height
    });
  },
  _doRender(_options) {
    var that = this;
    if (that._canvas.width === 0 && that._canvas.height === 0) return;
    that._resetIsReady(); // T207606
    var drawOptions = that._prepareDrawOptions(_options);
    var recreateCanvas = drawOptions.recreateCanvas;
    // T207665
    that._preserveOriginalCanvas();
    // T207665
    if (recreateCanvas) {
      that.__currentCanvas = that._canvas;
    } else {
      that._canvas = that.__currentCanvas;
    }
    recreateCanvas && that._updateCanvasClipRect(that._canvas);
    this._canvas = this._createCanvasFromRect(this._rect);
    that._renderer.stopAllAnimations(true);
    that._cleanGroups();
    var startTime = new Date();
    that._renderElements(drawOptions);
    that._lastRenderingTime = Number(new Date()) - Number(startTime);
  },
  _preserveOriginalCanvas() {
    this.__originalCanvas = this._canvas;
    this._canvas = (0, _extend.extend)({}, this._canvas); // NOTE: Instance of the original canvas must be preserved
  },

  _layoutAxes: _common.noop,
  _renderElements(drawOptions) {
    var that = this;
    var preparedOptions = that._prepareToRender(drawOptions);
    var isRotated = that._isRotated();
    var isLegendInside = that._isLegendInside();
    var trackerCanvases = [];
    var dirtyCanvas = (0, _extend.extend)({}, that._canvas);
    var argBusinessRange;
    var zoomMinArg;
    var zoomMaxArg;
    that._renderer.lock();
    if (drawOptions.drawLegend && that._legend) {
      that._legendGroup.linkAppend();
    }
    that.layoutManager.setOptions(that._layoutManagerOptions());
    var layoutTargets = that._getLayoutTargets();
    this._layoutAxes(function (needSpace) {
      var axisDrawOptions = needSpace ? (0, _extend.extend)({}, drawOptions, {
        animate: false,
        recreateCanvas: true
      }) : drawOptions;
      var canvas = that._renderAxes(axisDrawOptions, preparedOptions);
      that._shrinkAxes(needSpace, canvas);
    });
    that._applyClipRects(preparedOptions);
    that._appendSeriesGroups();
    that._createCrosshairCursor();
    layoutTargets.forEach(function (_ref) {
      var canvas = _ref.canvas;
      trackerCanvases.push({
        left: canvas.left,
        right: canvas.width - canvas.right,
        top: canvas.top,
        bottom: canvas.height - canvas.bottom
      });
    });
    if (that._scrollBar) {
      argBusinessRange = that._argumentAxes[0].getTranslator().getBusinessRange();
      if (argBusinessRange.axisType === 'discrete' && argBusinessRange.categories && argBusinessRange.categories.length <= 1 || argBusinessRange.axisType !== 'discrete' && argBusinessRange.min === argBusinessRange.max) {
        zoomMinArg = zoomMaxArg = undefined;
      } else {
        zoomMinArg = argBusinessRange.minVisible;
        zoomMaxArg = argBusinessRange.maxVisible;
      }
      that._scrollBar.init(argBusinessRange, !that._argumentAxes[0].getOptions().valueMarginsEnabled).setPosition(zoomMinArg, zoomMaxArg);
    }
    that._updateTracker(trackerCanvases);
    that._updateLegendPosition(drawOptions, isLegendInside);
    that._applyPointMarkersAutoHiding();
    that._renderSeries(drawOptions, isRotated, isLegendInside);
    that._renderGraphicObjects();
    that._renderer.unlock();
  },
  _updateLegendPosition: _common.noop,
  _createCrosshairCursor: _common.noop,
  _appendSeriesGroups() {
    this._seriesGroup.linkAppend();
    this._labelsGroup.linkAppend();
    this._appendAdditionalSeriesGroups();
  },
  _renderSeries(drawOptions, isRotated, isLegendInside) {
    this._calculateSeriesLayout(drawOptions, isRotated);
    this._renderSeriesElements(drawOptions, isLegendInside);
  },
  _calculateSeriesLayout(drawOptions, isRotated) {
    drawOptions.hideLayoutLabels = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), isRotated) && !this._themeManager.getOptions('adaptiveLayout').keepLabels;
    this._updateSeriesDimensions(drawOptions);
  },
  _getArgFilter() {
    return function () {
      return true;
    };
  },
  _getValFilter() {
    return function () {
      return true;
    };
  },
  _getPointsToAnimation(series) {
    var _this = this;
    var argViewPortFilter = this._getArgFilter();
    return series.map(function (s) {
      var valViewPortFilter = _this._getValFilter(s);
      return s.getPoints().filter(function (p) {
        return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)));
      }).length;
    });
  },
  _renderSeriesElements(drawOptions, isLegendInside) {
    var that = this;
    var series = that.series;
    var resolveLabelOverlapping = that._themeManager.getOptions('resolveLabelOverlapping');
    var pointsToAnimation = that._getPointsToAnimation(series);
    series.forEach(function (singleSeries, index) {
      that._applyExtraSettings(singleSeries, drawOptions);
      var animationEnabled = drawOptions.animate && pointsToAnimation[index] <= drawOptions.animationPointsLimit && that._renderer.animationEnabled();
      singleSeries.draw(animationEnabled, drawOptions.hideLayoutLabels, that._getLegendCallBack(singleSeries));
    });
    if (resolveLabelOverlapping === 'none') {
      that._adjustSeriesLabels(false);
    } else {
      that._locateLabels(resolveLabelOverlapping);
    }
    that._renderTrackers(isLegendInside);
    that._tracker.repairTooltip();
    that._renderExtraElements();
    that._clearCanvas();
    that._seriesElementsDrawn = true;
  },
  _changesApplied() {
    var that = this;
    if (that._seriesElementsDrawn) {
      that._seriesElementsDrawn = false;
      that._drawn();
      that._renderCompleteHandler();
    }
  },
  _locateLabels(resolveLabelOverlapping) {
    this._resolveLabelOverlapping(resolveLabelOverlapping);
  },
  _renderExtraElements() {},
  _clearCanvas() {
    // T207665, T336349, T503616
    this._canvas = this.__originalCanvas;
  },
  _resolveLabelOverlapping(resolveLabelOverlapping) {
    var func;
    switch (resolveLabelOverlapping) {
      case 'stack':
        func = this._resolveLabelOverlappingStack;
        break;
      case 'hide':
        func = this._resolveLabelOverlappingHide;
        break;
      case 'shift':
        func = this._resolveLabelOverlappingShift;
        break;
      default:
        break;
    }
    return (0, _type.isFunction)(func) && func.call(this);
  },
  _getVisibleSeries() {
    return (0, _common.grep)(this.getAllSeries(), function (series) {
      return series.isVisible();
    });
  },
  _resolveLabelOverlappingHide() {
    var labels = [];
    var currentLabel;
    var nextLabel;
    var currentLabelRect;
    var nextLabelRect;
    var i;
    var j;
    var points;
    var series = this._getVisibleSeries();
    for (i = 0; i < series.length; i++) {
      points = series[i].getVisiblePoints();
      for (j = 0; j < points.length; j++) {
        labels.push.apply(labels, points[j].getLabels());
      }
    }
    for (i = 0; i < labels.length; i++) {
      currentLabel = labels[i];
      if (!currentLabel.isVisible()) {
        continue;
      }
      currentLabelRect = currentLabel.getBoundingRect();
      for (j = i + 1; j < labels.length; j++) {
        nextLabel = labels[j];
        nextLabelRect = nextLabel.getBoundingRect();
        if (checkOverlapping(currentLabelRect, nextLabelRect)) {
          nextLabel.draw(false);
        }
      }
    }
  },
  _cleanGroups() {
    var that = this;
    that._stripsGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    that._gridGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    that._axesGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    that._constantLinesGroup.clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    that._stripLabelAxesGroup.linkRemove().clear(); // TODO: Must be removed in the same place where appended (advanced chart)
    // that._seriesGroup.linkRemove().clear();
    that._labelsGroup.linkRemove().clear();
    that._crosshairCursorGroup.linkRemove().clear();
    that._scaleBreaksGroup.linkRemove().clear();
  },
  _allowLegendInsidePosition() {
    return false;
  },
  _createLegend() {
    var that = this;
    var legendSettings = getLegendSettings(that._legendDataField);
    that._legend = new _legend.Legend({
      renderer: that._renderer,
      widget: that,
      group: that._legendGroup,
      backgroundClass: 'dxc-border',
      itemGroupClass: 'dxc-item',
      titleGroupClass: 'dxc-title',
      textField: legendSettings.textField,
      getFormatObject: legendSettings.getFormatObject,
      allowInsidePosition: that._allowLegendInsidePosition()
    });
    that._updateLegend();
    that._layout.add(that._legend);
  },
  _updateLegend() {
    var that = this;
    var themeManager = that._themeManager;
    var legendOptions = themeManager.getOptions('legend');
    var legendData = that._getLegendData();
    legendOptions.containerBackgroundColor = themeManager.getOptions('containerBackgroundColor');
    legendOptions._incidentOccurred = that._incidentOccurred; // TODO: Why is `_` used?
    that._legend.update(legendData, legendOptions, themeManager.theme('legend').title);
    this._change(['LAYOUT']);
  },
  _prepareDrawOptions(drawOptions) {
    var animationOptions = this._getAnimationOptions();
    var options = (0, _extend.extend)({}, {
      force: false,
      adjustAxes: true,
      drawLegend: true,
      drawTitle: true,
      animate: animationOptions.enabled,
      animationPointsLimit: animationOptions.maxPointCountSupported
    }, drawOptions, this.__renderOptions); // NOTE: This is to support `render` method options
    if (!(0, _type.isDefined)(options.recreateCanvas)) {
      options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle;
    }
    return options;
  },
  _processRefreshData(newRefreshAction) {
    var currentRefreshActionPosition = ACTIONS_BY_PRIORITY.indexOf(this._currentRefreshData);
    var newRefreshActionPosition = ACTIONS_BY_PRIORITY.indexOf(newRefreshAction);
    if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {
      this._currentRefreshData = newRefreshAction;
      // this._invalidate();
    }

    this._requestChange(['REFRESH']);
  },
  _getLegendData() {
    return (0, _utils.map)(this._getLegendTargets(), function (item) {
      var legendData = item.legendData;
      var style = item.getLegendStyles;
      var opacity = style.normal.opacity;
      if (!item.visible) {
        if (!(0, _type.isDefined)(opacity) || opacity > DEFAULT_OPACITY) {
          opacity = DEFAULT_OPACITY;
        }
        legendData.textOpacity = DEFAULT_OPACITY;
      }
      var opacityStyle = {
        opacity
      };
      legendData.states = {
        hover: (0, _extend.extend)({}, style.hover, opacityStyle),
        selection: (0, _extend.extend)({}, style.selection, opacityStyle),
        normal: (0, _extend.extend)({}, style.normal, opacityStyle)
      };
      return legendData;
    });
  },
  _getLegendOptions(item) {
    return {
      legendData: {
        text: item[this._legendItemTextField],
        id: item.index,
        visible: true
      },
      getLegendStyles: item.getLegendStyles(),
      visible: item.isVisible()
    };
  },
  _disposeSeries(seriesIndex) {
    var _a;
    var that = this;
    if (that.series) {
      if ((0, _type.isDefined)(seriesIndex)) {
        that.series[seriesIndex].dispose();
        that.series.splice(seriesIndex, 1);
      } else {
        (0, _iterator.each)(that.series, function (_, s) {
          return s.dispose();
        });
        that.series.length = 0;
      }
    }
    if (!((_a = that.series) === null || _a === void 0 ? void 0 : _a.length)) {
      that.series = [];
    }
  },
  _disposeSeriesFamilies() {
    var that = this;
    (0, _iterator.each)(that.seriesFamilies || [], function (_, family) {
      family.dispose();
    });
    that.seriesFamilies = null;
    that._needHandleRenderComplete = true;
  },
  _optionChanged(arg) {
    this._themeManager.resetOptions(arg.name);
    this.callBase.apply(this, arguments);
  },
  _applyChanges() {
    var that = this;
    that._themeManager.update(that._options.silent());
    that.callBase.apply(that, arguments);
  },
  _optionChangesMap: {
    animation: 'ANIMATION',
    dataSource: 'DATA_SOURCE',
    palette: 'PALETTE',
    paletteExtensionMode: 'PALETTE',
    legend: 'FORCE_DATA_INIT',
    seriesTemplate: 'FORCE_DATA_INIT',
    export: 'FORCE_RENDER',
    valueAxis: 'AXES_AND_PANES',
    argumentAxis: 'AXES_AND_PANES',
    commonAxisSettings: 'AXES_AND_PANES',
    panes: 'AXES_AND_PANES',
    commonPaneSettings: 'AXES_AND_PANES',
    defaultPane: 'AXES_AND_PANES',
    containerBackgroundColor: 'AXES_AND_PANES',
    rotated: 'ROTATED',
    autoHidePointMarkers: 'REFRESH_SERIES_REINIT',
    customizePoint: 'REFRESH_SERIES_REINIT',
    customizeLabel: 'REFRESH_SERIES_REINIT',
    scrollBar: 'SCROLL_BAR'
  },
  _optionChangesOrder: ['ROTATED', 'PALETTE', 'REFRESH_SERIES_REINIT', 'USE_SPIDER_WEB', 'AXES_AND_PANES', 'INIT', 'REINIT', 'DATA_SOURCE', 'REFRESH_SERIES_DATA_INIT', 'DATA_INIT', 'FORCE_DATA_INIT', 'REFRESH_AXES', 'CORRECT_AXIS'],
  _customChangesOrder: ['ANIMATION', 'REFRESH_SERIES_FAMILIES', 'FORCE_FIRST_DRAWING', 'FORCE_DRAWING', 'FORCE_RENDER', 'VISUAL_RANGE', 'SCROLL_BAR', 'REINIT', 'REFRESH', 'FULL_RENDER'],
  _change_ANIMATION() {
    this._renderer.updateAnimationOptions(this._getAnimationOptions());
  },
  _change_DATA_SOURCE() {
    this._needHandleRenderComplete = true;
    this._updateDataSource();
  },
  _change_PALETTE() {
    this._themeManager.updatePalette();
    this._refreshSeries('DATA_INIT');
  },
  _change_REFRESH_SERIES_DATA_INIT() {
    this._refreshSeries('DATA_INIT');
  },
  _change_DATA_INIT() {
    if ((!this.series || this.needToPopulateSeries) && !this._changes.has('FORCE_DATA_INIT')) {
      this._dataInit();
    }
  },
  _change_FORCE_DATA_INIT() {
    this._dataInit();
  },
  _change_REFRESH_SERIES_FAMILIES() {
    this._processSeriesFamilies();
    this._populateBusinessRange();
    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_FORCE_RENDER() {
    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_AXES_AND_PANES() {
    this._refreshSeries('INIT');
  },
  _change_ROTATED() {
    this._createScrollBar();
    this._refreshSeries('INIT');
  },
  _change_REFRESH_SERIES_REINIT() {
    this._refreshSeries('INIT');
  },
  _change_REFRESH_AXES() {
    var that = this;
    (0, _utils.setCanvasValues)(that._canvas);
    that._reinitAxes();
    that._requestChange(['CORRECT_AXIS', 'FULL_RENDER']);
  },
  _change_SCROLL_BAR() {
    this._createScrollBar();
    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);
  },
  _change_REINIT() {
    this._processRefreshData(REINIT_REFRESH_ACTION);
  },
  _change_FORCE_DRAWING() {
    this._resetComponentsAnimation();
  },
  _change_FORCE_FIRST_DRAWING() {
    this._resetComponentsAnimation(true);
  },
  _resetComponentsAnimation(isFirstDrawing) {
    this.series.forEach(function (s) {
      s.resetApplyingAnimation(isFirstDrawing);
    });
    this._resetAxesAnimation(isFirstDrawing);
  },
  _resetAxesAnimation: _common.noop,
  _refreshSeries(actionName) {
    this.needToPopulateSeries = true;
    this._requestChange([actionName]);
  },
  _change_CORRECT_AXIS() {
    this._correctAxes();
  },
  _doRefresh() {
    var methodName = this._currentRefreshData;
    if (methodName) {
      this._currentRefreshData = null;
      this._renderer.stopAllAnimations(true);
      this[methodName]();
    }
  },
  _updateCanvasClipRect(canvas) {
    var that = this;
    var width = Math.max(canvas.width - canvas.left - canvas.right, 0);
    var height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);
    that._canvasClipRect.attr({
      x: canvas.left,
      y: canvas.top,
      width,
      height
    });
    that._backgroundRect.attr({
      x: canvas.left,
      y: canvas.top,
      width,
      height
    });
  },
  _getCanvasClipRectID() {
    return this._canvasClipRect.id;
  },
  _dataSourceChangedHandler() {
    if (this._changes.has('INIT')) {
      this._requestChange(['DATA_INIT']);
    } else {
      this._requestChange(['FORCE_DATA_INIT']);
    }
  },
  _dataInit() {
    this._dataSpecificInit(true);
  },
  _processSingleSeries(singleSeries) {
    singleSeries.createPoints(false);
  },
  _handleSeriesDataUpdated() {
    var _this2 = this;
    if (this._getVisibleSeries().some(function (s) {
      return s.useAggregation();
    })) {
      this._populateMarginOptions();
    }
    this.series.forEach(function (s) {
      return _this2._processSingleSeries(s);
    }, this);
  },
  _dataSpecificInit(needRedraw) {
    var that = this;
    if (!that.series || that.needToPopulateSeries) {
      that.series = that._populateSeries();
    }
    that._repopulateSeries();
    that._seriesPopulatedHandlerCore();
    that._populateBusinessRange();
    that._tracker.updateSeries(that.series, this._changes.has('INIT'));
    that._updateLegend();
    if (needRedraw) {
      this._requestChange(['FULL_RENDER']);
    }
    // needRedraw && that._forceRender();
  },

  _forceRender() {
    this._doRender({
      force: true
    });
  },
  _repopulateSeries() {
    var that = this;
    var themeManager = that._themeManager;
    var data = that._dataSourceItems();
    var dataValidatorOptions = themeManager.getOptions('dataPrepareSettings');
    var seriesTemplate = themeManager.getOptions('seriesTemplate');
    if (seriesTemplate) {
      that._populateSeries(data);
    }
    that._groupSeries();
    var parsedData = (0, _data_validator.validateData)(data, that._groupsData, that._incidentOccurred, dataValidatorOptions);
    themeManager.resetPalette();
    that.series.forEach(function (singleSeries) {
      singleSeries.updateData(parsedData[singleSeries.getArgumentField()]);
    });
    that._handleSeriesDataUpdated();
  },
  _renderCompleteHandler() {
    var that = this;
    var allSeriesInited = true;
    if (that._needHandleRenderComplete) {
      (0, _iterator.each)(that.series, function (_, s) {
        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle();
      });
      if (allSeriesInited) {
        that._needHandleRenderComplete = false;
        that._eventTrigger('done', {
          target: that
        });
      }
    }
  },
  _dataIsReady() {
    // In order to support scenario when chart is created without "dataSource" and it is considered
    // as data is being loaded the check for state of "dataSource" option is added
    return (0, _type.isDefined)(this.option('dataSource')) && this._dataIsLoaded();
  },
  _populateSeriesOptions(data) {
    var that = this;
    var themeManager = that._themeManager;
    var seriesTemplate = themeManager.getOptions('seriesTemplate');
    var seriesOptions = seriesTemplate ? (0, _utils.processSeriesTemplate)(seriesTemplate, data || []) : that.option('series');
    var allSeriesOptions = isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [];
    var extraOptions = that._getExtraOptions();
    var particularSeriesOptions;
    var seriesTheme;
    var seriesThemes = [];
    var seriesVisibilityChanged = function seriesVisibilityChanged(target) {
      that._specialProcessSeries();
      that._populateBusinessRange(target && target.getValueAxis(), true);
      that._renderer.stopAllAnimations(true);
      that._updateLegend();
      that._requestChange(['FULL_RENDER']);
    };
    for (var i = 0; i < allSeriesOptions.length; i++) {
      particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i], extraOptions);
      if (!(0, _type.isDefined)(particularSeriesOptions.name) || particularSeriesOptions.name === '') {
        particularSeriesOptions.name = "Series ".concat((i + 1).toString());
      }
      particularSeriesOptions.rotated = that._isRotated();
      particularSeriesOptions.customizePoint = themeManager.getOptions('customizePoint');
      particularSeriesOptions.customizeLabel = themeManager.getOptions('customizeLabel');
      particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;
      particularSeriesOptions.incidentOccurred = that._incidentOccurred;
      seriesTheme = themeManager.getOptions('series', particularSeriesOptions, allSeriesOptions.length);
      if (that._checkPaneName(seriesTheme)) {
        seriesThemes.push(seriesTheme);
      }
    }
    return seriesThemes;
  },
  _populateSeries(data) {
    var _a;
    var that = this;
    var seriesBasis = [];
    var incidentOccurred = that._incidentOccurred;
    var seriesThemes = that._populateSeriesOptions(data);
    var particularSeries;
    var disposeSeriesFamilies = false;
    that.needToPopulateSeries = false;
    (0, _iterator.each)(seriesThemes, function (_, theme) {
      var curSeries = that.series && that.series.filter(function (s) {
        return s.name === theme.name && !seriesBasis.map(function (sb) {
          return sb.series;
        }).includes(s);
      })[0];
      if (curSeries && curSeries.type === theme.type) {
        seriesBasis.push({
          series: curSeries,
          options: theme
        });
      } else {
        seriesBasis.push({
          options: theme
        });
        disposeSeriesFamilies = true;
      }
    });
    ((_a = that.series) === null || _a === void 0 ? void 0 : _a.length) !== 0 && that._tracker.clearHover();
    (0, _iterator.reverseEach)(that.series, function (index, series) {
      if (!seriesBasis.some(function (s) {
        return series === s.series;
      })) {
        that._disposeSeries(index);
        disposeSeriesFamilies = true;
      }
    });
    !disposeSeriesFamilies && (disposeSeriesFamilies = seriesBasis.some(function (sb) {
      return sb.series.name !== seriesThemes[sb.series.index].name;
    }));
    that.series = [];
    disposeSeriesFamilies && that._disposeSeriesFamilies();
    that._themeManager.resetPalette();
    var eventPipe = function eventPipe(data) {
      that.series.forEach(function (currentSeries) {
        currentSeries.notify(data);
      });
    };
    (0, _iterator.each)(seriesBasis, function (_, basis) {
      var _a, _b;
      var seriesTheme = basis.options;
      var argumentAxis = (_b = (_a = that._argumentAxes) === null || _a === void 0 ? void 0 : _a.filter(function (a) {
        return a.pane === seriesTheme.pane;
      })[0]) !== null && _b !== void 0 ? _b : that.getArgumentAxis();
      var renderSettings = {
        commonSeriesModes: that._getSelectionModes(),
        argumentAxis,
        valueAxis: that._getValueAxis(seriesTheme.pane, seriesTheme.axis)
      };
      if (basis.series) {
        particularSeries = basis.series;
        particularSeries.updateOptions(seriesTheme, renderSettings);
      } else {
        particularSeries = new _base_series.Series((0, _extend.extend)({
          renderer: that._renderer,
          seriesGroup: that._seriesGroup,
          labelsGroup: that._labelsGroup,
          eventTrigger: that._eventTrigger,
          eventPipe,
          incidentOccurred
        }, renderSettings), seriesTheme);
      }
      if (!particularSeries.isUpdated) {
        incidentOccurred('E2101', [seriesTheme.type]);
      } else {
        particularSeries.index = that.series.length;
        that.series.push(particularSeries);
      }
    });
    return that.series;
  },
  getStackedPoints(point) {
    var stackName = point.series.getStackName();
    return this._getVisibleSeries().reduce(function (stackPoints, series) {
      if (!(0, _type.isDefined)(series.getStackName()) || !(0, _type.isDefined)(stackName) || stackName === series.getStackName()) {
        stackPoints = stackPoints.concat(series.getPointsByArg(point.argument));
      }
      return stackPoints;
    }, []);
  },
  // API
  getAllSeries: function getAllSeries() {
    return (this.series || []).slice();
  },
  getSeriesByName: function getSeriesByName(name) {
    var found = null;
    (0, _iterator.each)(this.series, function (i, singleSeries) {
      if (singleSeries.name === name) {
        found = singleSeries;
        return false;
      }
      return undefined;
    });
    return found;
  },
  getSeriesByPos: function getSeriesByPos(pos) {
    return (this.series || [])[pos];
  },
  clearSelection: function clearSelection() {
    this._tracker.clearSelection();
  },
  hideTooltip() {
    this._tracker._hideTooltip();
  },
  clearHover() {
    this._tracker.clearHover();
  },
  render(renderOptions) {
    var that = this;
    that.__renderOptions = renderOptions;
    that.__forceRender = renderOptions && renderOptions.force;
    that.callBase.apply(that, arguments);
    that.__renderOptions = that.__forceRender = null;
    return that;
  },
  refresh() {
    this._disposeSeries();
    this._disposeSeriesFamilies();
    this._requestChange(['CONTAINER_SIZE', 'REFRESH_SERIES_REINIT']);
  },
  _getMinSize() {
    var adaptiveLayout = this._layoutManagerOptions();
    return [adaptiveLayout.width, adaptiveLayout.height];
  },
  _change_REFRESH() {
    if (!this._changes.has('INIT')) {
      this._doRefresh();
    } else {
      this._currentRefreshData = null;
    }
  },
  _change_FULL_RENDER() {
    this._forceRender();
  },
  _change_INIT() {
    this._reinit();
  },
  _stopCurrentHandling() {
    this._tracker.stopCurrentHandling();
  }
});
exports.BaseChart = BaseChart;
REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS.forEach(function (name) {
  BaseChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_DATA_INIT';
});
FORCE_RENDER_REFRESH_ACTION_OPTIONS.forEach(function (name) {
  BaseChart.prototype._optionChangesMap[name] = 'FORCE_RENDER';
});
REFRESH_SERIES_FAMILIES_ACTION_OPTIONS.forEach(function (name) {
  BaseChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_FAMILIES';
});
BaseChart.addPlugin(_export.plugin);
BaseChart.addPlugin(_title.plugin);
BaseChart.addPlugin(_data_source.plugin);
BaseChart.addPlugin(_tooltip.plugin);
BaseChart.addPlugin(_loading_indicator.plugin);
// These are charts specifics on using title - they cannot be omitted because of charts custom layout.
// eslint-disable-next-line
var _change_TITLE = BaseChart.prototype._change_TITLE;
BaseChart.prototype._change_TITLE = function () {
  _change_TITLE.apply(this, arguments);
  this._change(['FORCE_RENDER']);
};

/***/ }),

/***/ 55845:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _size = __webpack_require__(58664);
var _type2 = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _base_theme_manager = __webpack_require__(43637);
var _base_widget = __webpack_require__(98469);
var _errors_warnings = _interopRequireDefault(__webpack_require__(80726));
var _helpers = __webpack_require__(3603);
var _layout = _interopRequireDefault(__webpack_require__(94551));
var _renderer2 = __webpack_require__(56453);
var _utils = __webpack_require__(19157);
var _m_charts = _interopRequireDefault(__webpack_require__(66798));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var floor = Math.floor;
var log = _errors_warnings.default.log;
var SIZE_CHANGING_THRESHOLD = 1;
var OPTION_RTL_ENABLED = 'rtlEnabled';
var SIZED_ELEMENT_CLASS = 'dx-sized-element';
var baseOptionMethod = _dom_component.default.prototype.option;
function getTrue() {
  return true;
}
function getFalse() {
  return false;
}
function areCanvasesDifferent(canvas1, canvas2) {
  return !(Math.abs(canvas1.width - canvas2.width) < SIZE_CHANGING_THRESHOLD && Math.abs(canvas1.height - canvas2.height) < SIZE_CHANGING_THRESHOLD && canvas1.left === canvas2.left && canvas1.top === canvas2.top && canvas1.right === canvas2.right && canvas1.bottom === canvas2.bottom);
}
function defaultOnIncidentOccurred(e) {
  if (!e.component._eventsStrategy.hasEvent('incidentOccurred')) {
    log.apply(null, [e.target.id].concat(e.target.args || []));
  }
}
function pickPositiveValue(values) {
  return values.reduce(function (result, value) {
    return value > 0 && !result ? value : result;
  }, 0);
}
// TODO - Changes handling
// * Provide more validation - something like
//     _changes: [{
//         code: "THEME",
//         options: ["theme"],
//         type: "option",
//         handler: function () {
//             this._setThemeAndRtl();
//         }
//     }, {
//         code: "CONTAINER_SIZE",
//         options: ["size", "option"],
//         type: "layout",
//         handler: function () {
//             this._updateSize();
//         }
//     }]
var getEmptyComponent = function getEmptyComponent() {
  var emptyComponentConfig = {
    _initTemplates() {},
    ctor(element, options) {
      this.callBase(element, options);
      var sizedElement = _dom_adapter.default.createElement('div');
      var width = options && (0, _type2.isNumeric)(options.width) ? "".concat(options.width, "px") : '100%';
      var height = options && (0, _type2.isNumeric)(options.height) ? "".concat(options.height, "px") : "".concat(this._getDefaultSize().height, "px");
      _dom_adapter.default.setStyle(sizedElement, 'width', width);
      _dom_adapter.default.setStyle(sizedElement, 'height', height);
      _dom_adapter.default.setClass(sizedElement, SIZED_ELEMENT_CLASS, false);
      _dom_adapter.default.insertElement(element, sizedElement);
    }
  };
  var EmptyComponent = _dom_component.default.inherit(emptyComponentConfig);
  var originalInherit = EmptyComponent.inherit;
  EmptyComponent.inherit = function (config) {
    Object.keys(config).forEach(function (field) {
      if ((0, _type2.isFunction)(config[field]) && field.substr(0, 1) !== '_' && field !== 'option' || field === '_dispose' || field === '_optionChanged') {
        config[field] = _common.noop;
      }
    });
    return originalInherit.call(this, config);
  };
  return EmptyComponent;
};
function callForEach(functions) {
  functions.forEach(function (c) {
    return c();
  });
}
function floorCanvasDimensions(canvas) {
  return _extends(_extends({}, canvas), {
    height: floor(canvas.height),
    width: floor(canvas.width)
  });
}
var isServerSide = !(0, _window.hasWindow)();
function sizeIsValid(value) {
  return (0, _type2.isDefined)(value) && value > 0;
}
var baseWidget = isServerSide ? getEmptyComponent() : _dom_component.default.inherit({
  _eventsMap: {
    onIncidentOccurred: {
      name: 'incidentOccurred',
      actionSettings: {
        excludeValidators: ['disabled']
      }
    },
    onDrawn: {
      name: 'drawn',
      actionSettings: {
        excludeValidators: ['disabled']
      }
    }
  },
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      onIncidentOccurred: defaultOnIncidentOccurred
    });
  },
  _useLinks: true,
  _init() {
    var that = this;
    that._$element.children(".".concat(SIZED_ELEMENT_CLASS)).remove();
    that._graphicObjects = {};
    that.callBase.apply(that, arguments);
    that._changesLocker = 0;
    that._optionChangedLocker = 0;
    that._asyncFirstDrawing = true;
    that._changes = (0, _helpers.changes)();
    that._suspendChanges();
    that._themeManager = that._createThemeManager();
    that._themeManager.setCallback(function () {
      that._requestChange(that._themeDependentChanges);
    });
    that._renderElementAttributes();
    that._initRenderer();
    // Shouldn't "_useLinks" be passed to the renderer instead of doing 3 checks here?
    var linkTarget = that._useLinks && that._renderer.root;
    // There is an implicit relation between `_useLinks` and `loading indicator` - it uses links
    // Though this relation is not ensured in code we will immediately know when it is broken - `loading indicator` will break on construction
    linkTarget && linkTarget.enableLinks().virtualLink('core').virtualLink('peripheral');
    that._renderVisibilityChange();
    that._attachVisibilityChangeHandlers();
    that._toggleParentsScrollSubscription(this._isVisible());
    that._initEventTrigger();
    that._incidentOccurred = (0, _base_widget.createIncidentOccurred)(that.NAME, that._eventTrigger);
    that._layout = new _layout.default();
    // Such solution is used only to avoid writing lots of "after" for all core elements in all widgets
    // May be later a proper solution would be found
    linkTarget && linkTarget.linkAfter('core');
    that._initPlugins();
    that._initCore();
    linkTarget && linkTarget.linkAfter();
    that._change(that._initialChanges);
  },
  _createThemeManager() {
    return new _base_theme_manager.BaseThemeManager(this._getThemeManagerOptions());
  },
  _getThemeManagerOptions() {
    return {
      themeSection: this._themeSection,
      fontFields: this._fontFields
    };
  },
  _initialChanges: ['LAYOUT', 'RESIZE_HANDLER', 'THEME', 'DISABLED'],
  _initPlugins() {
    var _this = this;
    (0, _iterator.each)(this._plugins, function (_, plugin) {
      plugin.init.call(_this);
    });
  },
  _disposePlugins() {
    var _this2 = this;
    (0, _iterator.each)(this._plugins.slice().reverse(), function (_, plugin) {
      plugin.dispose.call(_this2);
    });
  },
  _change(codes) {
    this._changes.add(codes);
  },
  _suspendChanges() {
    ++this._changesLocker;
  },
  _resumeChanges() {
    if (--this._changesLocker === 0 && this._changes.count() > 0 && !this._applyingChanges) {
      this._renderer.lock();
      this._applyingChanges = true;
      this._applyChanges();
      this._changes.reset();
      this._applyingChanges = false;
      this._changesApplied();
      this._renderer.unlock();
      if (this._optionsQueue) {
        this._applyQueuedOptions();
      }
      this.resolveItemsDeferred(this._legend ? [this._legend] : []);
      this._optionChangedLocker++;
      this._notify();
      this._optionChangedLocker--;
    }
  },
  resolveItemsDeferred(items) {
    this._resolveDeferred(this._getTemplatesItems(items));
  },
  _collectTemplatesFromItems(items) {
    return items.reduce(function (prev, i) {
      return {
        items: prev.items.concat(i.getTemplatesDef()),
        groups: prev.groups.concat(i.getTemplatesGroups())
      };
    }, {
      items: [],
      groups: []
    });
  },
  _getTemplatesItems(items) {
    var elements = this._collectTemplatesFromItems(items);
    var extraItems = this._getExtraTemplatesItems();
    return {
      items: extraItems.items.concat(elements.items),
      groups: extraItems.groups.concat(elements.groups),
      launchRequest: [extraItems.launchRequest],
      doneRequest: [extraItems.doneRequest]
    };
  },
  _getExtraTemplatesItems() {
    return {
      items: [],
      groups: [],
      launchRequest: function launchRequest() {},
      doneRequest: function doneRequest() {}
    };
  },
  _resolveDeferred(_ref) {
    var items = _ref.items,
      launchRequest = _ref.launchRequest,
      doneRequest = _ref.doneRequest,
      groups = _ref.groups;
    var that = this;
    that._setGroupsVisibility(groups, 'hidden');
    if (that._changesApplying) {
      that._changesApplying = false;
      callForEach(doneRequest);
      return;
    }
    var syncRendering = true;
    _deferred.when.apply(that, items).done(function () {
      if (syncRendering) {
        that._setGroupsVisibility(groups, 'visible');
        return;
      }
      callForEach(launchRequest);
      that._changesApplying = true;
      var changes = ['LAYOUT', 'FULL_RENDER'];
      if (that._asyncFirstDrawing) {
        changes.push('FORCE_FIRST_DRAWING');
        that._asyncFirstDrawing = false;
      } else {
        changes.push('FORCE_DRAWING');
      }
      that._requestChange(changes);
      that._setGroupsVisibility(groups, 'visible');
    });
    syncRendering = false;
  },
  _setGroupsVisibility(groups, visibility) {
    groups.forEach(function (g) {
      return g.attr({
        visibility
      });
    });
  },
  _applyQueuedOptions() {
    var queue = this._optionsQueue;
    this._optionsQueue = null;
    this.beginUpdate();
    (0, _iterator.each)(queue, function (_, action) {
      action();
    });
    this.endUpdate();
  },
  _requestChange(codes) {
    this._suspendChanges();
    this._change(codes);
    this._resumeChanges();
  },
  _applyChanges() {
    var that = this;
    var changes = that._changes;
    var order = that._totalChangesOrder;
    var i;
    var ii = order.length;
    for (i = 0; i < ii; ++i) {
      if (changes.has(order[i])) {
        that["_change_".concat(order[i])]();
      }
    }
  },
  _optionChangesOrder: ['EVENTS', 'THEME', 'RENDERER', 'RESIZE_HANDLER'],
  _layoutChangesOrder: ['ELEMENT_ATTR', 'CONTAINER_SIZE', 'LAYOUT'],
  _customChangesOrder: ['DISABLED'],
  _change_EVENTS() {
    this._eventTrigger.applyChanges();
  },
  _change_THEME() {
    this._setThemeAndRtl();
  },
  _change_RENDERER() {
    this._setRendererOptions();
  },
  _change_RESIZE_HANDLER() {
    this._setupResizeHandler();
  },
  _change_ELEMENT_ATTR() {
    this._renderElementAttributes();
    this._change(['CONTAINER_SIZE']);
  },
  _change_CONTAINER_SIZE() {
    this._updateSize();
  },
  _change_LAYOUT() {
    this._setContentSize();
  },
  _change_DISABLED() {
    var renderer = this._renderer;
    var root = renderer.root;
    if (this.option('disabled')) {
      this._initDisabledState = root.attr('pointer-events');
      root.attr({
        'pointer-events': 'none',
        filter: renderer.getGrayScaleFilter().id
      });
    } else if (root.attr('pointer-events') === 'none') {
      root.attr({
        'pointer-events': (0, _type2.isDefined)(this._initDisabledState) ? this._initDisabledState : null,
        filter: null
      });
    }
  },
  _themeDependentChanges: ['RENDERER'],
  _initRenderer() {
    var that = this;
    // Canvas is calculated before the renderer is created in order to capture actual size of the container
    var rawCanvas = that._calculateRawCanvas();
    that._canvas = floorCanvasDimensions(rawCanvas);
    that._renderer = new _renderer2.Renderer({
      cssClass: "".concat(that._rootClassPrefix, " ").concat(that._rootClass),
      pathModified: that.option('pathModified'),
      container: that._$element[0]
    });
    that._renderer.resize(that._canvas.width, that._canvas.height);
  },
  _disposeRenderer() {
    this._renderer.dispose();
  },
  _disposeGraphicObjects() {
    var _this3 = this;
    Object.keys(this._graphicObjects).forEach(function (id) {
      _this3._graphicObjects[id].dispose();
    });
    this._graphicObjects = null;
  },
  _getAnimationOptions: _common.noop,
  render() {
    this._requestChange(['CONTAINER_SIZE']);
    var visible = this._isVisible();
    this._toggleParentsScrollSubscription(visible);
    !visible && this._stopCurrentHandling();
  },
  _toggleParentsScrollSubscription(subscribe) {
    var $parents = (0, _renderer.default)(this._renderer.root.element).parents();
    var scrollEvents = 'scroll.viz_widgets';
    if (_devices.default.real().platform === 'generic') {
      $parents = $parents.add((0, _window.getWindow)());
    }
    this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function () {
      this._stopCurrentHandling();
    }.bind(this);
    _events_engine.default.off((0, _renderer.default)('').add(this._$prevRootParents), scrollEvents, this._proxiedTargetParentsScrollHandler);
    if (subscribe) {
      _events_engine.default.on($parents, scrollEvents, this._proxiedTargetParentsScrollHandler);
      this._$prevRootParents = $parents;
    }
  },
  _stopCurrentHandling: _common.noop,
  _dispose() {
    var that = this;
    if (this._disposed) {
      return;
    }
    that.callBase.apply(that, arguments);
    that._toggleParentsScrollSubscription(false);
    that._removeResizeHandler();
    that._layout.dispose();
    that._eventTrigger.dispose();
    that._disposeCore();
    that._disposePlugins();
    that._disposeGraphicObjects();
    that._disposeRenderer();
    that._themeManager.dispose();
    that._themeManager = that._renderer = that._eventTrigger = null;
  },
  _initEventTrigger() {
    var _this4 = this;
    this._eventTrigger = (0, _base_widget.createEventTrigger)(this._eventsMap, function (name, actionSettings) {
      return _this4._createActionByOption(name, actionSettings);
    });
  },
  _calculateRawCanvas() {
    var that = this;
    var size = that.option('size') || {};
    var margin = that.option('margin') || {};
    var defaultCanvas = that._getDefaultSize() || {};
    var getSizeOfSide = function getSizeOfSide(size, side, getter) {
      if (sizeIsValid(size[side]) || !(0, _window.hasWindow)()) {
        return 0;
      }
      var elementSize = getter(that._$element);
      return elementSize <= 1 ? 0 : elementSize;
    };
    var elementWidth = getSizeOfSide(size, 'width', function (x) {
      return (0, _size.getWidth)(x);
    });
    var elementHeight = getSizeOfSide(size, 'height', function (x) {
      return (0, _size.getHeight)(x);
    });
    var canvas = {
      width: size.width <= 0 ? 0 : pickPositiveValue([size.width, elementWidth, defaultCanvas.width]),
      height: size.height <= 0 ? 0 : pickPositiveValue([size.height, elementHeight, defaultCanvas.height]),
      left: pickPositiveValue([margin.left, defaultCanvas.left]),
      top: pickPositiveValue([margin.top, defaultCanvas.top]),
      right: pickPositiveValue([margin.right, defaultCanvas.right]),
      bottom: pickPositiveValue([margin.bottom, defaultCanvas.bottom])
    };
    // This for backward compatibility - widget was not rendered when canvas is empty.
    // Now it will be rendered but because of "width" and "height" of the root both set to 0 it will not be visible.
    if (canvas.width - canvas.left - canvas.right <= 0 || canvas.height - canvas.top - canvas.bottom <= 0) {
      canvas = {
        width: 0,
        height: 0
      };
    }
    return canvas;
  },
  _updateSize() {
    var rawCanvas = this._calculateRawCanvas();
    if (areCanvasesDifferent(this._canvas, rawCanvas) || this.__forceRender /* for charts */) {
      this._canvas = floorCanvasDimensions(rawCanvas);
      this._recreateSizeDependentObjects(true);
      this._renderer.resize(this._canvas.width, this._canvas.height);
      this._change(['LAYOUT']);
    }
  },
  _recreateSizeDependentObjects: _common.noop,
  _getMinSize() {
    return [0, 0];
  },
  _getAlignmentRect: _common.noop,
  _setContentSize() {
    var canvas = this._canvas;
    var layout = this._layout;
    var rect = canvas.width > 0 && canvas.height > 0 ? [canvas.left, canvas.top, canvas.width - canvas.right, canvas.height - canvas.bottom] : [0, 0, 0, 0];
    rect = layout.forward(rect, this._getMinSize());
    var nextRect = this._applySize(rect) || rect;
    layout.backward(nextRect, this._getAlignmentRect() || nextRect);
  },
  _getOption(name, isScalar) {
    var theme = this._themeManager.theme(name);
    var option = this.option(name);
    return isScalar ? option !== undefined ? option : theme : (0, _extend.extend)(true, {}, theme, option);
  },
  _setupResizeHandler() {
    var _this5 = this;
    var redrawOnResize = (0, _utils.parseScalar)(this._getOption('redrawOnResize', true), true);
    if (this._disposeResizeHandler) {
      this._removeResizeHandler();
    }
    this._disposeResizeHandler = (0, _base_widget.createResizeHandler)(this._$element[0], redrawOnResize, function () {
      return _this5._requestChange(['CONTAINER_SIZE']);
    });
  },
  _removeResizeHandler() {
    if (this._disposeResizeHandler) {
      this._disposeResizeHandler();
      this._disposeResizeHandler = null;
    }
  },
  // This is actually added only to make loading indicator pluggable. This is bad but much better than entire loading indicator in BaseWidget.
  _onBeginUpdate: _common.noop,
  beginUpdate() {
    // The "_initialized" flag is checked because first time "beginUpdate" is called in the constructor.
    if (this._initialized && this._isUpdateAllowed()) {
      this._onBeginUpdate();
      this._suspendChanges();
    }
    this.callBase.apply(this, arguments);
    return this;
  },
  endUpdate() {
    this.callBase();
    this._isUpdateAllowed() && this._resumeChanges();
    return this;
  },
  option(name) {
    // NOTE: `undefined` has to be returned because base option setter returns `undefined`.
    // `argument.length` and `isObject` checks are copypaste from Component.
    if (this._initialized && this._applyingChanges && (arguments.length > 1 || (0, _type2.isObject)(name))) {
      this._optionsQueue = this._optionsQueue || [];
      this._optionsQueue.push(this._getActionForUpdating(arguments));
    } else {
      return baseOptionMethod.apply(this, arguments);
    }
  },
  _getActionForUpdating(args) {
    var _this6 = this;
    return function () {
      baseOptionMethod.apply(_this6, args);
    };
  },
  // For quite a long time the following method were abstract (from the Component perspective).
  // Now they are not but that basic functionality is not required here.
  _clean: _common.noop,
  _render: _common.noop,
  _optionChanged(arg) {
    var that = this;
    if (that._optionChangedLocker) {
      return;
    }
    var partialChanges = that.getPartialChangeOptionsName(arg);
    var changes = [];
    if (partialChanges.length > 0) {
      partialChanges.forEach(function (pc) {
        return changes.push(that._partialOptionChangesMap[pc]);
      });
    } else {
      changes.push(that._optionChangesMap[arg.name]);
    }
    changes = changes.filter(function (c) {
      return !!c;
    });
    if (that._eventTrigger.change(arg.name)) {
      that._change(['EVENTS']);
    } else if (changes.length > 0) {
      that._change(changes);
    } else {
      that.callBase.apply(that, arguments);
    }
  },
  _notify: _common.noop,
  _changesApplied: _common.noop,
  _optionChangesMap: {
    size: 'CONTAINER_SIZE',
    margin: 'CONTAINER_SIZE',
    redrawOnResize: 'RESIZE_HANDLER',
    theme: 'THEME',
    rtlEnabled: 'THEME',
    encodeHtml: 'THEME',
    elementAttr: 'ELEMENT_ATTR',
    disabled: 'DISABLED'
  },
  _partialOptionChangesMap: {},
  _partialOptionChangesPath: {},
  getPartialChangeOptionsName(changedOption) {
    var _this7 = this;
    var fullName = changedOption.fullName;
    var sections = fullName.split(/[.]/);
    var name = changedOption.name;
    var value = changedOption.value;
    var options = this._partialOptionChangesPath[name];
    var partialChangeOptionsName = [];
    if (options) {
      if (options === true) {
        partialChangeOptionsName.push(name);
      } else {
        options.forEach(function (op) {
          fullName.indexOf(op) >= 0 && partialChangeOptionsName.push(op);
        });
        if (sections.length === 1) {
          if ((0, _type2.type)(value) === 'object') {
            this._addOptionsNameForPartialUpdate(value, options, partialChangeOptionsName);
          } else if ((0, _type2.type)(value) === 'array') {
            if (value.length > 0 && value.every(function (item) {
              return _this7._checkOptionsForPartialUpdate(item, options);
            })) {
              value.forEach(function (item) {
                return _this7._addOptionsNameForPartialUpdate(item, options, partialChangeOptionsName);
              });
            }
          }
        }
      }
    }
    return partialChangeOptionsName.filter(function (value, index, self) {
      return self.indexOf(value) === index;
    });
  },
  _checkOptionsForPartialUpdate(optionObject, options) {
    return !Object.keys(optionObject).some(function (key) {
      return options.indexOf(key) === -1;
    });
  },
  _addOptionsNameForPartialUpdate(optionObject, options, partialChangeOptionsName) {
    var optionKeys = Object.keys(optionObject);
    if (this._checkOptionsForPartialUpdate(optionObject, options)) {
      optionKeys.forEach(function (key) {
        return options.indexOf(key) > -1 && partialChangeOptionsName.push(key);
      });
    }
  },
  _visibilityChanged() {
    this.render();
  },
  _setThemeAndRtl() {
    this._themeManager.setTheme(this.option('theme'), this.option(OPTION_RTL_ENABLED));
  },
  _getRendererOptions() {
    return {
      rtl: this.option(OPTION_RTL_ENABLED),
      encodeHtml: this.option('encodeHtml'),
      animation: this._getAnimationOptions()
    };
  },
  _setRendererOptions() {
    this._renderer.setOptions(this._getRendererOptions());
  },
  svg() {
    return this._renderer.svg();
  },
  getSize() {
    var canvas = this._canvas || {};
    return {
      width: canvas.width,
      height: canvas.height
    };
  },
  isReady: getFalse,
  _dataIsReady: getTrue,
  _resetIsReady() {
    this.isReady = getFalse;
  },
  _renderGraphicObjects() {
    var _this8 = this;
    var renderer = this._renderer;
    var graphics = _m_charts.default.getGraphicObjects();
    Object.keys(graphics).forEach(function (id) {
      if (!_this8._graphicObjects[id]) {
        var _graphics$id = graphics[id],
          _type = _graphics$id.type,
          colors = _graphics$id.colors,
          rotationAngle = _graphics$id.rotationAngle,
          template = _graphics$id.template,
          width = _graphics$id.width,
          height = _graphics$id.height;
        switch (_type) {
          case 'linear':
            _this8._graphicObjects[id] = renderer.linearGradient(colors, id, rotationAngle);
            break;
          case 'radial':
            _this8._graphicObjects[id] = renderer.radialGradient(colors, id);
            break;
          case 'pattern':
            _this8._graphicObjects[id] = renderer.customPattern(id, _this8._getTemplate(template), width, height);
            break;
          default:
            break;
        }
      }
    });
  },
  _drawn() {
    var _this9 = this;
    this.isReady = getFalse;
    if (this._dataIsReady()) {
      this._renderer.onEndAnimation(function () {
        _this9.isReady = getTrue;
      });
    }
    this._eventTrigger('drawn', {});
  }
});
var _default = baseWidget;
exports["default"] = _default;
(0, _helpers.replaceInherit)(baseWidget);

/***/ }),

/***/ 4096:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _math = __webpack_require__(60810);
var _size = __webpack_require__(58664);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _crosshair = __webpack_require__(97574);
var _layout_manager = __webpack_require__(21495);
var _multi_axes_synchronizer = _interopRequireDefault(__webpack_require__(42597));
var _scroll_bar = __webpack_require__(97882);
var _shutter_zoom = _interopRequireDefault(__webpack_require__(70714));
var _zoom_and_pan = _interopRequireDefault(__webpack_require__(59345));
var _annotations = __webpack_require__(77129);
var _utils = __webpack_require__(19157);
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var _range = __webpack_require__(21177);
var _utils2 = __webpack_require__(34434);
var _m_advanced_chart = __webpack_require__(41690);
var _m_base_chart = __webpack_require__(14107);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-expect-error

var DEFAULT_PANE_NAME = 'default';
var VISUAL_RANGE = 'VISUAL_RANGE';
var DEFAULT_PANES = [{
  name: DEFAULT_PANE_NAME,
  border: {}
}];
var DISCRETE = 'discrete';
var isArray = Array.isArray;
function getFirstAxisNameForPane(axes, paneName, defaultPane) {
  var result;
  for (var i = 0; i < axes.length; i++) {
    if (axes[i].pane === paneName || axes[i].pane === undefined && paneName === defaultPane) {
      result = axes[i].name;
      break;
    }
  }
  if (!result) {
    result = axes[0].name;
  }
  return result;
}
function changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility) {
  var gridOpt = axis.getOptions().grid;
  var minorGridOpt = axis.getOptions().minorGrid;
  gridOpt.visible = gridVisibility;
  minorGridOpt && (minorGridOpt.visible = minorGridVisibility);
}
function hideGridsOnNonFirstValueAxisForPane(axesForPane) {
  var axisShown = false;
  var hiddenStubAxis = [];
  var minorGridVisibility = axesForPane.some(function (axis) {
    var minorGridOptions = axis.getOptions().minorGrid;
    return minorGridOptions && minorGridOptions.visible;
  });
  var gridVisibility = axesForPane.some(function (axis) {
    var gridOptions = axis.getOptions().grid;
    return gridOptions && gridOptions.visible;
  });
  if (axesForPane.length > 1) {
    axesForPane.forEach(function (axis) {
      var gridOpt = axis.getOptions().grid;
      if (axisShown) {
        changeVisibilityAxisGrids(axis, false, false);
      } else if (gridOpt && gridOpt.visible) {
        if (axis.getTranslator().getBusinessRange().isEmpty()) {
          changeVisibilityAxisGrids(axis, false, false);
          hiddenStubAxis.push(axis);
        } else {
          axisShown = true;
          changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility);
        }
      }
    });
    !axisShown && hiddenStubAxis.length && changeVisibilityAxisGrids(hiddenStubAxis[0], gridVisibility, minorGridVisibility);
  }
}
function findAxisOptions(valueAxes, valueAxesOptions, axisName) {
  var result;
  var axInd;
  for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {
    if (valueAxesOptions[axInd].name === axisName) {
      result = valueAxesOptions[axInd];
      result.priority = axInd;
      break;
    }
  }
  if (!result) {
    for (axInd = 0; axInd < valueAxes.length; axInd++) {
      if (valueAxes[axInd].name === axisName) {
        result = valueAxes[axInd].getOptions();
        result.priority = valueAxes[axInd].priority;
        break;
      }
    }
  }
  return result;
}
function findAxis(paneName, axisName, axes) {
  var axis;
  var i;
  for (i = 0; i < axes.length; i++) {
    axis = axes[i];
    if (axis.name === axisName && axis.pane === paneName) {
      return axis;
    }
  }
  if (paneName) {
    return findAxis(undefined, axisName, axes);
  }
}
function compareAxes(a, b) {
  return a.priority - b.priority;
}
// checks if pane with provided name exists in this panes array
function doesPaneExist(panes, paneName) {
  var found = false;
  (0, _iterator.each)(panes, function (_, pane) {
    if (pane.name === paneName) {
      found = true;
      return false;
    }
    return undefined;
  });
  return found;
}
// utilities used in axes rendering
function accumulate(field, src1, src2, auxSpacing) {
  var val1 = src1[field] || 0;
  var val2 = src2[field] || 0;
  return val1 + val2 + (val1 && val2 ? auxSpacing : 0);
}
function pickMax(field, src1, src2) {
  return pickMaxValue(src1[field], src2[field]);
}
function pickMaxValue(val1, val2) {
  return Math.max(val1 || 0, val2 || 0);
}
function getAxisMargins(axis) {
  return axis.getMargins();
}
function getHorizontalAxesMargins(axes, getMarginsFunc) {
  return axes.reduce(function (margins, axis) {
    var _a;
    var axisMargins = getMarginsFunc(axis);
    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
    var spacing = axis.getMultipleAxesSpacing();
    paneMargins.top = accumulate('top', paneMargins, axisMargins, spacing);
    paneMargins.bottom = accumulate('bottom', paneMargins, axisMargins, spacing);
    paneMargins.left = pickMax('left', paneMargins, axisMargins);
    paneMargins.right = pickMax('right', paneMargins, axisMargins);
    margins.top = pickMax('top', paneMargins, margins);
    margins.bottom = pickMax('bottom', paneMargins, margins);
    margins.left = pickMax('left', paneMargins, margins);
    margins.right = pickMax('right', paneMargins, margins);
    var orthogonalAxis = (_a = axis.getOrthogonalAxis) === null || _a === void 0 ? void 0 : _a.call(axis);
    if (orthogonalAxis && orthogonalAxis.customPositionIsAvailable() && (!axis.customPositionIsBoundaryOrthogonalAxis() || !orthogonalAxis.customPositionEqualsToPredefined())) {
      margins[orthogonalAxis.getResolvedBoundaryPosition()] = 0;
    }
    return margins;
  }, {
    panes: {}
  });
}
function getVerticalAxesMargins(axes) {
  return axes.reduce(function (margins, axis) {
    var axisMargins = axis.getMargins();
    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};
    var spacing = axis.getMultipleAxesSpacing();
    paneMargins.top = pickMax('top', paneMargins, axisMargins);
    paneMargins.bottom = pickMax('bottom', paneMargins, axisMargins);
    paneMargins.left = accumulate('left', paneMargins, axisMargins, spacing);
    paneMargins.right = accumulate('right', paneMargins, axisMargins, spacing);
    margins.top = pickMax('top', paneMargins, margins);
    margins.bottom = pickMax('bottom', paneMargins, margins);
    margins.left = pickMax('left', paneMargins, margins);
    margins.right = pickMax('right', paneMargins, margins);
    return margins;
  }, {
    panes: {}
  });
}
function performActionOnAxes(axes, action, actionArgument1, actionArgument2, actionArgument3) {
  axes.forEach(function (axis) {
    axis[action](actionArgument1 && actionArgument1[axis.pane], actionArgument2 && actionArgument2[axis.pane] || actionArgument2, actionArgument3);
  });
}
function shrinkCanvases(isRotated, canvases, sizes, verticalMargins, horizontalMargins) {
  function getMargin(side, margins, pane) {
    var m = !(isRotated ? ['left', 'right'] : ['top', 'bottom']).includes(side) ? margins : margins.panes[pane] || {};
    return m[side];
  }
  function getMaxMargin(side, margins1, margins2, pane) {
    return pickMaxValue(getMargin(side, margins1, pane), getMargin(side, margins2, pane));
  }
  var getOriginalField = function getOriginalField(field) {
    return "original".concat(field[0].toUpperCase()).concat(field.slice(1));
  };
  function shrink(canvases, paneNames, sizeField, startMargin, endMargin, oppositeMargins) {
    paneNames = paneNames.sort(function (p1, p2) {
      return canvases[p2][startMargin] - canvases[p1][startMargin];
    });
    paneNames.forEach(function (pane) {
      var canvas = canvases[pane];
      oppositeMargins.forEach(function (margin) {
        canvas[margin] = canvas[getOriginalField(margin)] + getMaxMargin(margin, verticalMargins, horizontalMargins, pane);
      });
    });
    var firstPane = canvases[paneNames[0]];
    var emptySpace = paneNames.reduce(function (space, paneName) {
      space -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, paneName) + getMaxMargin(endMargin, verticalMargins, horizontalMargins, paneName);
      return space;
    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - canvases[paneNames[paneNames.length - 1]][getOriginalField(startMargin)]) - _utils.PANE_PADDING * (paneNames.length - 1);
    emptySpace -= Object.keys(sizes).reduce(function (prev, key) {
      return prev + (!(0, _utils.isRelativeHeightPane)(sizes[key]) ? sizes[key].height : 0);
    }, 0);
    paneNames.reduce(function (offset, pane) {
      var canvas = canvases[pane];
      var paneSize = sizes[pane];
      offset -= getMaxMargin(endMargin, verticalMargins, horizontalMargins, pane);
      canvas[endMargin] = firstPane[sizeField] - offset;
      offset -= !(0, _utils.isRelativeHeightPane)(paneSize) ? paneSize.height : Math.floor(emptySpace * paneSize.height);
      canvas[startMargin] = offset;
      offset -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, pane) + _utils.PANE_PADDING;
      return offset;
    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - (emptySpace < 0 ? emptySpace : 0));
  }
  var paneNames = Object.keys(canvases);
  if (!isRotated) {
    shrink(canvases, paneNames, 'height', 'top', 'bottom', ['left', 'right']);
  } else {
    shrink(canvases, paneNames, 'width', 'left', 'right', ['top', 'bottom']);
  }
  return canvases;
}
function drawAxesWithTicks(axes, condition, canvases, panesBorderOptions) {
  if (condition) {
    performActionOnAxes(axes, 'createTicks', canvases);
    _multi_axes_synchronizer.default.synchronize(axes);
  }
  performActionOnAxes(axes, 'draw', !condition && canvases, panesBorderOptions);
}
function shiftAxis(side1, side2) {
  var shifts = {};
  return function (axis) {
    if (!axis.customPositionIsAvailable() || axis.customPositionEqualsToPredefined()) {
      var shift = shifts[axis.pane] = shifts[axis.pane] || {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      };
      var spacing = axis.getMultipleAxesSpacing();
      var margins = axis.getMargins();
      axis.shift(shift);
      shift[side1] = accumulate(side1, shift, margins, spacing);
      shift[side2] = accumulate(side2, shift, margins, spacing);
    } else {
      axis.shift({
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      });
    }
  };
}
function getCommonSize(side, margins) {
  var size = 0;
  var paneMargins;
  Object.keys(margins.panes).forEach(function (pane) {
    paneMargins = margins.panes[pane];
    size += side === 'height' ? paneMargins.top + paneMargins.bottom : paneMargins.left + paneMargins.right;
  });
  return size;
}
function checkUsedSpace(sizeShortage, side, axes, getMarginFunc) {
  var size = 0;
  if (sizeShortage[side] > 0) {
    size = getCommonSize(side, getMarginFunc(axes, getAxisMargins));
    performActionOnAxes(axes, 'hideTitle');
    sizeShortage[side] -= size - getCommonSize(side, getMarginFunc(axes, getAxisMargins));
  }
  if (sizeShortage[side] > 0) {
    performActionOnAxes(axes, 'hideOuterElements');
  }
}
function axisAnimationEnabled(drawOptions, pointsToAnimation) {
  var pointsCount = pointsToAnimation.reduce(function (sum, count) {
    return sum + count;
  }, 0) / pointsToAnimation.length;
  return drawOptions.animate && pointsCount <= drawOptions.animationPointsLimit;
}
function collectMarkersInfoBySeries(allSeries, filteredSeries, argAxis) {
  var series = [];
  var overloadedSeries = {};
  var argVisualRange = argAxis.visualRange();
  var argTranslator = argAxis.getTranslator();
  var argViewPortFilter = _range_data_calculator.default.getViewPortFilter(argVisualRange || {});
  filteredSeries.forEach(function (s) {
    var valAxis = s.getValueAxis();
    var valVisualRange = valAxis.getCanvasRange();
    var valTranslator = valAxis.getTranslator();
    var seriesIndex = allSeries.indexOf(s);
    var valViewPortFilter = _range_data_calculator.default.getViewPortFilter(valVisualRange || {});
    overloadedSeries[seriesIndex] = {};
    filteredSeries.forEach(function (sr) {
      overloadedSeries[seriesIndex][allSeries.indexOf(sr)] = 0;
    });
    var seriesPoints = [];
    s.getPoints().filter(function (p) {
      return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)));
    }).forEach(function (p) {
      var tp = {
        seriesIndex,
        argument: p.argument,
        value: p.getMaxValue(true),
        size: p.bubbleSize || p.getOptions().size,
        x: undefined,
        y: undefined
      };
      if (p.getMinValue(true) !== p.getMaxValue(true)) {
        var mp = (0, _extend2.extend)({}, tp);
        mp.value = p.getMinValue(true);
        mp.x = argTranslator.to(mp.argument, 1);
        mp.y = valTranslator.to(mp.value, 1);
        seriesPoints.push(mp);
      }
      tp.x = argTranslator.to(tp.argument, 1);
      tp.y = valTranslator.to(tp.value, 1);
      seriesPoints.push(tp);
    });
    overloadedSeries[seriesIndex].pointsCount = seriesPoints.length;
    overloadedSeries[seriesIndex].total = 0;
    overloadedSeries[seriesIndex].continuousSeries = 0;
    series.push({
      name: s.name,
      index: seriesIndex,
      points: seriesPoints
    });
  });
  return {
    series,
    overloadedSeries
  };
}
var isOverlay = function isOverlay(currentPoint, overlayPoint, pointRadius) {
  var pointHitsLeftBorder = overlayPoint.x - pointRadius <= currentPoint.x;
  var pointHitsRightBorder = overlayPoint.x + pointRadius >= currentPoint.x;
  var pointHitsTopBorder = overlayPoint.y - pointRadius <= currentPoint.y;
  var pointHitsBottomBorder = overlayPoint.y + pointRadius >= currentPoint.y;
  var isPointOverlappedHorizontally = pointHitsLeftBorder && pointHitsRightBorder;
  var isPointOverlappedVertically = pointHitsTopBorder && pointHitsBottomBorder;
  return isPointOverlappedHorizontally && isPointOverlappedVertically;
};
var isPointOverlapped = function isPointOverlapped(currentPoint, points, skipSamePointsComparing) {
  var radiusPoint = currentPoint.getOptions().size / 2;
  for (var i = 0; i < points.length; i++) {
    if (!skipSamePointsComparing) {
      var isXCoordinateSame = points[i].x === currentPoint.x;
      var isYCoordinateSame = points[i].y === currentPoint.y;
      if (isXCoordinateSame && isYCoordinateSame) {
        continue;
      }
    }
    if (isOverlay(currentPoint, points[i], radiusPoint)) {
      return true;
    }
  }
  return false;
};
function fastHidingPointMarkersByArea(canvas, markersInfo, series) {
  var area = canvas.width * canvas.height;
  var seriesPoints = markersInfo.series;
  var _loop = function _loop(i) {
    var currentSeries = series.filter(function (s) {
      return s.name === seriesPoints[i].name;
    })[0];
    var points = seriesPoints[i].points;
    var pointSize = points.length ? points[0].size : 0;
    var pointsArea = pointSize * pointSize * points.length;
    if (currentSeries.autoHidePointMarkersEnabled() && pointsArea >= area / seriesPoints.length) {
      var index = seriesPoints[i].index;
      currentSeries.autoHidePointMarkers = true;
      seriesPoints.splice(i, 1);
      series.splice(series.indexOf(currentSeries), 1);
      markersInfo.overloadedSeries[index] = null;
    }
  };
  for (var i = seriesPoints.length - 1; i >= 0; i--) {
    _loop(i);
  }
}
function updateMarkersInfo(points, overloadedSeries) {
  var isContinuousSeries = false;
  for (var i = 0; i < points.length - 1; i++) {
    var curPoint = points[i];
    var size = curPoint.size;
    if ((0, _type.isDefined)(curPoint.x) && (0, _type.isDefined)(curPoint.y)) {
      for (var j = i + 1; j < points.length; j++) {
        var nextPoint = points[j];
        var nextX = nextPoint === null || nextPoint === void 0 ? void 0 : nextPoint.x;
        var nextY = nextPoint === null || nextPoint === void 0 ? void 0 : nextPoint.y;
        if (!(0, _type.isDefined)(nextX) || Math.abs(curPoint.x - nextX) >= size) {
          isContinuousSeries = isContinuousSeries && j !== i + 1;
          break;
        } else {
          var distance = (0, _type.isDefined)(nextX) && (0, _type.isDefined)(nextY) && Math.sqrt(Math.pow(curPoint.x - nextX, 2) + Math.pow(curPoint.y - nextY, 2));
          if (distance && distance < size) {
            overloadedSeries[curPoint.seriesIndex][nextPoint.seriesIndex]++;
            overloadedSeries[curPoint.seriesIndex].total++;
            if (!isContinuousSeries) {
              overloadedSeries[curPoint.seriesIndex].continuousSeries++;
              isContinuousSeries = true;
            }
          }
        }
      }
    }
  }
}
// utilities used in axes rendering
var dxChart = _m_advanced_chart.AdvancedChart.inherit({
  _themeSection: 'chart',
  _fontFields: ['crosshair.label.font'],
  _initCore() {
    this.paneAxis = {};
    this.callBase();
  },
  _init() {
    this._containerInitialHeight = (0, _window.hasWindow)() ? (0, _size.getHeight)(this._$element) : 0;
    this.callBase();
  },
  _correctAxes() {
    this._correctValueAxes(true);
  },
  _setDeprecatedOptions() {
    this.callBase();
    (0, _extend2.extend)(this._deprecatedOptions, {
      'argumentAxis.aggregateByCategory': {
        since: '23.1',
        message: 'Use the aggregation.enabled property'
      }
    });
  },
  _getExtraOptions: _common.noop,
  _createPanes() {
    var that = this;
    var panes = that.option('panes');
    var panesNameCounter = 0;
    var defaultPane;
    if (!panes || isArray(panes) && !panes.length) {
      panes = DEFAULT_PANES;
    }
    that.callBase();
    defaultPane = that.option('defaultPane');
    panes = (0, _extend2.extend)(true, [], isArray(panes) ? panes : [panes]);
    (0, _iterator.each)(panes, function (_, pane) {
      pane.name = !(0, _type.isDefined)(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name;
    });
    if ((0, _type.isDefined)(defaultPane)) {
      if (!doesPaneExist(panes, defaultPane)) {
        that._incidentOccurred('W2101', [defaultPane]);
        defaultPane = panes[panes.length - 1].name;
      }
    } else {
      defaultPane = panes[panes.length - 1].name;
    }
    that.defaultPane = defaultPane;
    panes = that._isRotated() ? panes.reverse() : panes;
    return panes;
  },
  _getAxisRenderingOptions() {
    return {
      axisType: 'xyAxes',
      drawingType: 'linear'
    };
  },
  _prepareAxisOptions(typeSelector, userOptions, rotated) {
    return {
      isHorizontal: typeSelector === 'argumentAxis' !== rotated,
      containerColor: this._themeManager.getOptions('containerBackgroundColor')
    };
  },
  _checkPaneName(seriesTheme) {
    var paneList = (0, _utils.map)(this.panes, function (pane) {
      return pane.name;
    });
    seriesTheme.pane = seriesTheme.pane || this.defaultPane;
    return paneList.includes(seriesTheme.pane);
  },
  _initCustomPositioningAxes() {
    var that = this;
    var argumentAxis = that.getArgumentAxis();
    var valueAxisName = argumentAxis.getOptions().customPositionAxis;
    var valueAxis = that._valueAxes.filter(function (v) {
      return v.pane === argumentAxis.pane && (!valueAxisName || valueAxisName === v.name);
    })[0];
    that._valueAxes.forEach(function (v) {
      if (argumentAxis !== v.getOrthogonalAxis()) {
        v.getOrthogonalAxis = function () {
          return argumentAxis;
        };
        v.customPositionIsBoundaryOrthogonalAxis = function () {
          return argumentAxis.customPositionIsBoundary();
        };
      }
    });
    if ((0, _type.isDefined)(valueAxis) && valueAxis !== argumentAxis.getOrthogonalAxis()) {
      argumentAxis.getOrthogonalAxis = function () {
        return valueAxis;
      };
      argumentAxis.customPositionIsBoundaryOrthogonalAxis = function () {
        return that._valueAxes.some(function (v) {
          return v.customPositionIsBoundary();
        });
      };
    } else if ((0, _type.isDefined)(argumentAxis.getOrthogonalAxis()) && !(0, _type.isDefined)(valueAxis)) {
      argumentAxis.getOrthogonalAxis = _common.noop;
    }
  },
  _getAllAxes() {
    return this._argumentAxes.concat(this._valueAxes);
  },
  _resetAxesAnimation(isFirstDrawing, isHorizontal) {
    var axes = (0, _type.isDefined)(isHorizontal) ? isHorizontal ^ this._isRotated() ? this._argumentAxes : this._valueAxes : this._getAllAxes();
    axes.forEach(function (a) {
      a.resetApplyingAnimation(isFirstDrawing);
    });
  },
  _axesBoundaryPositioning() {
    var allAxes = this._getAllAxes();
    var boundaryStateChanged = false;
    allAxes.forEach(function (a) {
      if (!a.customPositionIsAvailable()) {
        return;
      }
      var prevBoundaryState = a.customPositionIsBoundary();
      a._customBoundaryPosition = a.getCustomBoundaryPosition();
      boundaryStateChanged = boundaryStateChanged || prevBoundaryState !== a.customPositionIsBoundary();
    });
    return boundaryStateChanged;
  },
  _getCrosshairMargins() {
    var crosshairOptions = this._getCrosshairOptions() || {};
    var crosshairEnabled = crosshairOptions.enabled;
    var margins = (0, _crosshair.getMargins)();
    var horizontalLabel = (0, _extend2.extend)(true, {}, crosshairOptions.label, crosshairOptions.horizontalLine.label);
    var verticalLabel = (0, _extend2.extend)(true, {}, crosshairOptions.label, crosshairOptions.verticalLine.label);
    return {
      x: crosshairEnabled && crosshairOptions.horizontalLine.visible && horizontalLabel.visible ? margins.x : 0,
      y: crosshairEnabled && crosshairOptions.verticalLine.visible && verticalLabel.visible ? margins.y : 0
    };
  },
  _getValueAxis(paneName, axisName) {
    var that = this;
    var valueAxes = that._valueAxes;
    var valueAxisOptions = that.option('valueAxis') || {};
    var valueAxesOptions = isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions];
    var rotated = that._isRotated();
    var crosshairMargins = that._getCrosshairMargins();
    var axisOptions;
    var axis;
    axisName = axisName || getFirstAxisNameForPane(valueAxes, paneName, that.defaultPane);
    axis = findAxis(paneName, axisName, valueAxes);
    if (!axis) {
      axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);
      if (!axisOptions) {
        that._incidentOccurred('W2102', [axisName]);
        axisOptions = {
          name: axisName,
          priority: valueAxes.length
        };
      }
      axis = that._createAxis(false, that._populateAxesOptions('valueAxis', axisOptions, {
        pane: paneName,
        name: axisName,
        optionPath: isArray(valueAxisOptions) ? "valueAxis[".concat(axisOptions.priority, "]") : 'valueAxis',
        crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x
      }, rotated));
      axis.applyVisualRangeSetter(that._getVisualRangeSetter());
      valueAxes.push(axis);
    }
    axis.setPane(paneName);
    return axis;
  },
  _correctValueAxes(needHideGrids) {
    var that = this;
    var synchronizeMultiAxes = that._themeManager.getOptions('synchronizeMultiAxes');
    var valueAxes = that._valueAxes;
    var paneWithAxis = {};
    that.series.forEach(function (series) {
      var axis = series.getValueAxis();
      paneWithAxis[axis.pane] = true;
    });
    that.panes.forEach(function (pane) {
      var paneName = pane.name;
      if (!paneWithAxis[paneName]) {
        that._getValueAxis(paneName); // creates an value axis if there is no one for pane
      }

      if (needHideGrids && synchronizeMultiAxes) {
        hideGridsOnNonFirstValueAxisForPane(valueAxes.filter(function (axis) {
          return axis.pane === paneName;
        }));
      }
    });
    that._valueAxes = valueAxes.filter(function (axis) {
      if (!axis.pane) {
        axis.setPane(that.defaultPane);
      }
      var paneExists = doesPaneExist(that.panes, axis.pane);
      if (!paneExists) {
        axis.dispose();
        axis = null;
      }
      return paneExists;
    }).sort(compareAxes);
    var defaultAxis = this.getValueAxis();
    that._valueAxes.forEach(function (axis) {
      var _axis$getOptions = axis.getOptions(),
        optionPath = _axis$getOptions.optionPath;
      if (optionPath) {
        var axesWithSamePath = that._valueAxes.filter(function (a) {
          return a.getOptions().optionPath === optionPath;
        });
        if (axesWithSamePath.length > 1) {
          if (axesWithSamePath.some(function (a) {
            return a === defaultAxis;
          })) {
            axesWithSamePath.forEach(function (a) {
              if (a !== defaultAxis) {
                a.getOptions().optionPath = null;
              }
            });
          } else {
            axesWithSamePath.forEach(function (a, i) {
              if (i !== 0) {
                a.getOptions().optionPath = null;
              }
            });
          }
        }
      }
    });
  },
  _getSeriesForPane(paneName) {
    var paneSeries = [];
    (0, _iterator.each)(this.series, function (_, oneSeries) {
      if (oneSeries.pane === paneName) {
        paneSeries.push(oneSeries);
      }
    });
    return paneSeries;
  },
  _createPanesBorderOptions() {
    var commonBorderOptions = this._themeManager.getOptions('commonPaneSettings').border;
    var panesBorderOptions = {};
    this.panes.forEach(function (pane) {
      panesBorderOptions[pane.name] = (0, _extend2.extend)(true, {}, commonBorderOptions, pane.border);
    });
    return panesBorderOptions;
  },
  _createScrollBar() {
    var that = this;
    var scrollBarOptions = that._themeManager.getOptions('scrollBar') || {};
    var scrollBarGroup = that._scrollBarGroup;
    if (scrollBarOptions.visible) {
      scrollBarOptions.rotated = that._isRotated();
      that._scrollBar = (that._scrollBar || new _scroll_bar.ScrollBar(that._renderer, scrollBarGroup)).update(scrollBarOptions);
    } else {
      scrollBarGroup.linkRemove();
      that._scrollBar && that._scrollBar.dispose();
      that._scrollBar = null;
    }
  },
  _executeAppendAfterSeries(append) {
    append();
  },
  _prepareToRender() {
    var panesBorderOptions = this._createPanesBorderOptions();
    this._createPanesBackground();
    this._appendAxesGroups();
    this._adjustViewport();
    return panesBorderOptions;
  },
  _adjustViewport() {
    var adjustOnZoom = this._themeManager.getOptions('adjustOnZoom');
    if (!adjustOnZoom) {
      return;
    }
    this._valueAxes.forEach(function (axis) {
      return axis.adjust();
    });
  },
  _recreateSizeDependentObjects(isCanvasChanged) {
    var that = this;
    var series = that._getVisibleSeries();
    var useAggregation = series.some(function (s) {
      return s.useAggregation();
    });
    var zoomChanged = that._isZooming();
    if (!useAggregation) {
      return;
    }
    that._argumentAxes.forEach(function (axis) {
      axis.updateCanvas(that._canvas, true);
    });
    series.forEach(function (series) {
      if (series.useAggregation() && (isCanvasChanged || zoomChanged || !series._useAllAggregatedPoints)) {
        series.createPoints();
      }
    });
    that._processSeriesFamilies();
  },
  _isZooming() {
    var that = this;
    var argumentAxis = that.getArgumentAxis();
    if (!argumentAxis || !argumentAxis.getTranslator()) {
      return false;
    }
    var businessRange = argumentAxis.getTranslator().getBusinessRange();
    var zoomRange = argumentAxis.getViewport();
    var min = zoomRange ? zoomRange.min : 0;
    var max = zoomRange ? zoomRange.max : 0;
    if (businessRange.axisType === 'logarithmic') {
      min = (0, _utils.getLog)(min, businessRange.base);
      max = (0, _utils.getLog)(max, businessRange.base);
    }
    var viewportDistance = businessRange.axisType === DISCRETE ? (0, _utils.getCategoriesInfo)(businessRange.categories, min, max).categories.length : Math.abs(max - min);
    var precision = (0, _math.getPrecision)(viewportDistance);
    precision = precision > 1 ? Math.pow(10, precision - 2) : 1;
    var zoomChanged = Math.round((that._zoomLength - viewportDistance) * precision) / precision !== 0;
    that._zoomLength = viewportDistance;
    return zoomChanged;
  },
  _handleSeriesDataUpdated() {
    var that = this;
    var viewport = new _range.Range();
    that.series.forEach(function (s) {
      viewport.addRange(s.getArgumentRange());
    });
    that._argumentAxes.forEach(function (axis) {
      axis.updateCanvas(that._canvas, true);
      axis.setBusinessRange(viewport, that._axesReinitialized);
    });
    that.callBase();
  },
  _isLegendInside() {
    return this._legend && this._legend.getPosition() === 'inside';
  },
  _isRotated() {
    return this._themeManager.getOptions('rotated');
  },
  _getLayoutTargets() {
    return this.panes;
  },
  _applyClipRects(panesBorderOptions) {
    var that = this;
    that._drawPanesBorders(panesBorderOptions);
    that._createClipRectsForPanes();
    that._applyClipRectsForAxes();
    that._fillPanesBackground();
  },
  _updateLegendPosition(drawOptions, legendHasInsidePosition) {
    var that = this;
    if (drawOptions.drawLegend && that._legend && legendHasInsidePosition) {
      var panes = that.panes;
      var newCanvas = (0, _extend2.extend)({}, panes[0].canvas);
      var layoutManager = new _layout_manager.LayoutManager();
      newCanvas.right = panes[panes.length - 1].canvas.right;
      newCanvas.bottom = panes[panes.length - 1].canvas.bottom;
      layoutManager.layoutInsideLegend(that._legend, newCanvas);
    }
  },
  _allowLegendInsidePosition() {
    return true;
  },
  _applyExtraSettings(series) {
    var that = this;
    var paneIndex = that._getPaneIndex(series.pane);
    var panesClipRects = that._panesClipRects;
    var wideClipRect = panesClipRects.wide[paneIndex];
    series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, that._getPaneBorderVisibility(paneIndex));
  },
  _updatePanesCanvases(drawOptions) {
    if (!drawOptions.recreateCanvas) {
      return;
    }
    (0, _utils.updatePanesCanvases)(this.panes, this._canvas, this._isRotated());
  },
  _normalizePanesHeight() {
    (0, _utils.normalizePanesHeight)(this.panes);
  },
  _renderScaleBreaks() {
    this._valueAxes.concat(this._argumentAxes).forEach(function (axis) {
      axis.drawScaleBreaks();
    });
  },
  _getArgFilter() {
    return _range_data_calculator.default.getViewPortFilter(this.getArgumentAxis().visualRange() || {});
  },
  _hidePointsForSingleSeriesIfNeeded(series) {
    var seriesPoints = series.getPoints();
    var overlappedPointsCount = 0;
    for (var i = 0; i < seriesPoints.length; i++) {
      var currentPoint = seriesPoints[i];
      var overlappingPoints = seriesPoints.slice(i + 1);
      overlappedPointsCount += Number(isPointOverlapped(currentPoint, overlappingPoints));
      if (overlappedPointsCount > seriesPoints.length / 2) {
        series.autoHidePointMarkers = true;
        break;
      }
    }
  },
  _applyAutoHidePointMarkers(filteredSeries) {
    var overlappingPoints = [];
    var reducerFunc = function reducerFunc(pointsCount, currentPoint) {
      return pointsCount + isPointOverlapped(currentPoint, overlappingPoints, true);
    };
    for (var i = filteredSeries.length - 1; i >= 0; i--) {
      var currentSeries = filteredSeries[i];
      if (!currentSeries.autoHidePointMarkersEnabled()) {
        continue;
      }
      currentSeries.autoHidePointMarkers = false;
      this._hidePointsForSingleSeriesIfNeeded(currentSeries);
      if (!currentSeries.autoHidePointMarkers) {
        var seriesPoints = currentSeries.getPoints();
        var overlappingPointsCount = seriesPoints.reduce(reducerFunc, 0);
        if (overlappingPointsCount < seriesPoints.length) {
          overlappingPoints = overlappingPoints.concat(seriesPoints);
        } else {
          currentSeries.autoHidePointMarkers = true;
        }
      }
    }
  },
  _applyPointMarkersAutoHiding() {
    var that = this;
    var allSeries = that.series;
    if (!that._themeManager.getOptions('autoHidePointMarkers')) {
      allSeries.forEach(function (s) {
        s.autoHidePointMarkers = false;
      });
      return;
    }
    that.panes.forEach(function (_ref) {
      var borderCoords = _ref.borderCoords,
        name = _ref.name;
      var series = allSeries.filter(function (s) {
        return s.pane === name && s.usePointsToDefineAutoHiding();
      });
      series.forEach(function (singleSeries) {
        singleSeries.prepareCoordinatesForPoints();
      });
      var argAxis = that.getArgumentAxis();
      var markersInfo = collectMarkersInfoBySeries(allSeries, series, argAxis);
      fastHidingPointMarkersByArea(borderCoords, markersInfo, series);
      if (markersInfo.series.length) {
        var argVisualRange = argAxis.visualRange();
        var argAxisIsDiscrete = argAxis.getOptions().type === DISCRETE;
        var sortingCallback = argAxisIsDiscrete ? function (p1, p2) {
          return argVisualRange.categories.indexOf(p1.argument) - argVisualRange.categories.indexOf(p2.argument);
        } : function (p1, p2) {
          return p1.argument - p2.argument;
        };
        var points = [];
        markersInfo.series.forEach(function (s) {
          points = points.concat(s.points);
        });
        points.sort(sortingCallback);
        updateMarkersInfo(points, markersInfo.overloadedSeries);
        that._applyAutoHidePointMarkers(series);
      }
    });
  },
  _renderAxes(drawOptions, panesBorderOptions) {
    function calculateTitlesWidth(axes) {
      return axes.map(function (axis) {
        if (!axis.getTitle) return 0;
        var title = axis.getTitle();
        return title ? title.bBox.width : 0;
      });
    }
    var that = this;
    var rotated = that._isRotated();
    var synchronizeMultiAxes = that._themeManager.getOptions('synchronizeMultiAxes');
    var scrollBar = that._scrollBar ? [that._scrollBar] : [];
    var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);
    var verticalAxes = rotated ? that._argumentAxes : that._valueAxes;
    var verticalElements = rotated ? extendedArgAxes : that._valueAxes;
    var horizontalAxes = rotated ? that._valueAxes : that._argumentAxes;
    var horizontalElements = rotated ? that._valueAxes : extendedArgAxes;
    var allAxes = verticalAxes.concat(horizontalAxes);
    var allElements = allAxes.concat(scrollBar);
    var verticalAxesFirstDrawing = verticalAxes.some(function (v) {
      return v.isFirstDrawing();
    });
    that._normalizePanesHeight();
    that._updatePanesCanvases(drawOptions);
    var panesCanvases = that.panes.reduce(function (canvases, pane) {
      canvases[pane.name] = (0, _extend2.extend)({}, pane.canvas);
      return canvases;
    }, {});
    var paneSizes = that.panes.reduce(function (sizes, pane) {
      sizes[pane.name] = {
        height: pane.height,
        unit: pane.unit
      };
      return sizes;
    }, {});
    var cleanPanesCanvases = (0, _extend2.extend)(true, {}, panesCanvases);
    that._initCustomPositioningAxes();
    var needCustomAdjustAxes = that._axesBoundaryPositioning();
    if (!drawOptions.adjustAxes && !needCustomAdjustAxes) {
      drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
      drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);
      performActionOnAxes(allAxes, 'prepareAnimation');
      that._renderScaleBreaks();
      horizontalAxes.forEach(function (a) {
        return a.resolveOverlappingForCustomPositioning(verticalAxes);
      });
      verticalAxes.forEach(function (a) {
        return a.resolveOverlappingForCustomPositioning(horizontalAxes);
      });
      return false;
    }
    if (needCustomAdjustAxes) {
      allAxes.forEach(function (a) {
        return a.customPositionIsAvailable() && a.shift({
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
        });
      });
    }
    if (that._scrollBar) {
      that._scrollBar.setPane(that.panes);
    }
    var vAxesMargins = {
      panes: {},
      left: 0,
      right: 0
    };
    var hAxesMargins = getHorizontalAxesMargins(horizontalElements, function (axis) {
      return axis.estimateMargins(panesCanvases[axis.pane]);
    });
    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
    var drawAxesAndSetCanvases = function drawAxesAndSetCanvases(isHorizontal) {
      var axes = isHorizontal ? horizontalAxes : verticalAxes;
      var condition = (isHorizontal ? rotated : !rotated) && synchronizeMultiAxes;
      drawAxesWithTicks(axes, condition, panesCanvases, panesBorderOptions);
      if (isHorizontal) {
        hAxesMargins = getHorizontalAxesMargins(horizontalElements, getAxisMargins);
      } else {
        vAxesMargins = getVerticalAxesMargins(verticalElements);
      }
      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
    };
    drawAxesAndSetCanvases(false);
    drawAxesAndSetCanvases(true);
    if (!that._changesApplying && that._estimateTickIntervals(verticalAxes, panesCanvases)) {
      drawAxesAndSetCanvases(false);
    }
    var oldTitlesWidth = calculateTitlesWidth(verticalAxes);
    var visibleSeries = that._getVisibleSeries();
    var pointsToAnimation = that._getPointsToAnimation(visibleSeries);
    var axesIsAnimated = axisAnimationEnabled(drawOptions, pointsToAnimation);
    performActionOnAxes(allElements, 'updateSize', panesCanvases, axesIsAnimated);
    horizontalElements.forEach(shiftAxis('top', 'bottom'));
    verticalElements.forEach(shiftAxis('left', 'right'));
    that._renderScaleBreaks();
    that.panes.forEach(function (pane) {
      (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]);
    });
    that._valueAxes.forEach(function (axis) {
      axis.setInitRange();
    });
    verticalAxes.forEach(function (axis, i) {
      var _a;
      if ((_a = axis.hasWrap) === null || _a === void 0 ? void 0 : _a.call(axis)) {
        var title = axis.getTitle();
        var newTitleWidth = title ? title.bBox.width : 0;
        var offset = newTitleWidth - oldTitlesWidth[i];
        if (axis.getOptions().position === 'right') {
          vAxesMargins.right += offset;
        } else {
          vAxesMargins.left += offset;
          that.panes.forEach(function (_ref2) {
            var name = _ref2.name;
            vAxesMargins.panes[name].left += offset;
          });
        }
        panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);
        performActionOnAxes(allElements, 'updateSize', panesCanvases, false, false);
        oldTitlesWidth = calculateTitlesWidth(verticalAxes);
      }
    });
    if (verticalAxes.some(function (v) {
      return v.customPositionIsAvailable() && v.getCustomPosition() !== v._axisPosition;
    })) {
      axesIsAnimated && that._resetAxesAnimation(verticalAxesFirstDrawing, false);
      performActionOnAxes(verticalAxes, 'updateSize', panesCanvases, axesIsAnimated);
    }
    horizontalAxes.forEach(function (a) {
      return a.resolveOverlappingForCustomPositioning(verticalAxes);
    });
    verticalAxes.forEach(function (a) {
      return a.resolveOverlappingForCustomPositioning(horizontalAxes);
    });
    return cleanPanesCanvases;
  },
  _getExtraTemplatesItems() {
    var that = this;
    var allAxes = (that._argumentAxes || []).concat(that._valueAxes || []);
    var elements = that._collectTemplatesFromItems(allAxes);
    return {
      items: elements.items,
      groups: elements.groups,
      launchRequest() {
        allAxes.forEach(function (a) {
          a.setRenderedState(true);
        });
      },
      doneRequest() {
        allAxes.forEach(function (a) {
          a.setRenderedState(false);
        });
      }
    };
  },
  _estimateTickIntervals(axes, canvases) {
    return axes.some(function (axis) {
      return axis.estimateTickInterval(canvases[axis.pane]);
    });
  },
  checkForMoreSpaceForPanesCanvas() {
    var that = this;
    var rotated = that._isRotated();
    var panesAreCustomSized = that.panes.filter(function (p) {
      return p.unit;
    }).length === that.panes.length;
    var needSpace = false;
    if (panesAreCustomSized) {
      var needHorizontalSpace = 0;
      var needVerticalSpace = 0;
      if (rotated) {
        var argAxisRightMargin = that.getArgumentAxis().getMargins().right;
        var rightPanesIndent = Math.min.apply(Math, that.panes.map(function (p) {
          return p.canvas.right;
        }));
        needHorizontalSpace = that._canvas.right + argAxisRightMargin - rightPanesIndent;
      } else {
        var argAxisBottomMargin = that.getArgumentAxis().getMargins().bottom;
        var bottomPanesIndent = Math.min.apply(Math, that.panes.map(function (p) {
          return p.canvas.bottom;
        }));
        needVerticalSpace = that._canvas.bottom + argAxisBottomMargin - bottomPanesIndent;
      }
      needSpace = needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
        width: needHorizontalSpace,
        height: needVerticalSpace
      } : false;
      if (needVerticalSpace !== 0) {
        var realSize = that.getSize();
        var customSize = that.option('size');
        var container = that._$element[0];
        var containerHasStyledHeight = !!parseInt(container.style.height, 10) || that._containerInitialHeight !== 0;
        if (!rotated && !(customSize && customSize.height) && !containerHasStyledHeight) {
          that._forceResize(realSize.width, realSize.height + needVerticalSpace);
          needSpace = false;
        }
      }
    } else {
      needSpace = that.layoutManager.needMoreSpaceForPanesCanvas(that._getLayoutTargets(), rotated, function (pane) {
        return {
          width: rotated && !!pane.unit,
          height: !rotated && !!pane.unit
        };
      });
    }
    return needSpace;
  },
  _forceResize(width, height) {
    this._renderer.resize(width, height);
    this._updateSize();
    this._setContentSize();
    this._preserveOriginalCanvas();
    this._updateCanvasClipRect(this._canvas);
  },
  _shrinkAxes(sizeShortage, panesCanvases) {
    if (!sizeShortage || !panesCanvases) {
      return;
    }
    this._renderer.stopAllAnimations(true);
    var that = this;
    var rotated = that._isRotated();
    var scrollBar = that._scrollBar ? [that._scrollBar] : [];
    var extendedArgAxes = that._isArgumentAxisBeforeScrollBar() ? that._argumentAxes.concat(scrollBar) : scrollBar.concat(that._argumentAxes);
    var verticalAxes = rotated ? extendedArgAxes : that._valueAxes;
    var horizontalAxes = rotated ? that._valueAxes : extendedArgAxes;
    var allAxes = verticalAxes.concat(horizontalAxes);
    if (sizeShortage.width || sizeShortage.height) {
      checkUsedSpace(sizeShortage, 'height', horizontalAxes, getHorizontalAxesMargins);
      checkUsedSpace(sizeShortage, 'width', verticalAxes, getVerticalAxesMargins);
      performActionOnAxes(allAxes, 'updateSize', panesCanvases);
      var paneSizes = that.panes.reduce(function (sizes, pane) {
        sizes[pane.name] = {
          height: pane.height,
          unit: pane.unit
        };
        return sizes;
      }, {});
      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, getVerticalAxesMargins(verticalAxes), getHorizontalAxesMargins(horizontalAxes, getAxisMargins));
      performActionOnAxes(allAxes, 'updateSize', panesCanvases);
      horizontalAxes.forEach(shiftAxis('top', 'bottom'));
      verticalAxes.forEach(shiftAxis('left', 'right'));
      that.panes.forEach(function (pane) {
        return (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]);
      });
    }
  },
  _isArgumentAxisBeforeScrollBar() {
    var _a;
    var that = this;
    var argumentAxis = that.getArgumentAxis();
    if (that._scrollBar) {
      var argAxisPosition = argumentAxis.getResolvedBoundaryPosition();
      var argAxisLabelPosition = (_a = argumentAxis.getOptions().label) === null || _a === void 0 ? void 0 : _a.position;
      var scrollBarPosition = that._scrollBar.getOptions().position;
      return argumentAxis.hasNonBoundaryPosition() || scrollBarPosition === argAxisPosition && argAxisLabelPosition !== scrollBarPosition;
    }
    return false;
  },
  _getPanesParameters() {
    var that = this;
    var panes = that.panes;
    var i;
    var params = [];
    for (i = 0; i < panes.length; i++) {
      if (that._getPaneBorderVisibility(i)) {
        params.push({
          coords: panes[i].borderCoords,
          clipRect: that._panesClipRects.fixed[i]
        });
      }
    }
    return params;
  },
  _createCrosshairCursor() {
    var that = this;
    var options = that._themeManager.getOptions('crosshair') || {};
    var argumentAxis = that.getArgumentAxis();
    var axes = !that._isRotated() ? [[argumentAxis], that._valueAxes] : [that._valueAxes, [argumentAxis]];
    var parameters = {
      canvas: that._getCommonCanvas(),
      panes: that._getPanesParameters(),
      axes
    };
    if (!options || !options.enabled) {
      return;
    }
    if (!that._crosshair) {
      that._crosshair = new _crosshair.Crosshair(that._renderer, options, parameters, that._crosshairCursorGroup);
    } else {
      that._crosshair.update(options, parameters);
    }
    that._crosshair.render();
  },
  _getCommonCanvas() {
    var i;
    var canvas;
    var commonCanvas;
    var panes = this.panes;
    for (i = 0; i < panes.length; i++) {
      canvas = panes[i].canvas;
      if (!commonCanvas) {
        // TODO
        commonCanvas = (0, _extend2.extend)({}, canvas);
      } else {
        commonCanvas.right = canvas.right;
        commonCanvas.bottom = canvas.bottom;
      }
    }
    return commonCanvas;
  },
  _createPanesBackground() {
    var that = this;
    var defaultBackgroundColor = that._themeManager.getOptions('commonPaneSettings').backgroundColor;
    var backgroundColor;
    var renderer = that._renderer;
    var rect;
    var i;
    var rects = [];
    that._panesBackgroundGroup.clear();
    for (i = 0; i < that.panes.length; i++) {
      backgroundColor = that.panes[i].backgroundColor || defaultBackgroundColor;
      if (!backgroundColor || backgroundColor === 'none') {
        rects.push(null);
        continue;
      }
      rect = renderer.rect(0, 0, 0, 0).attr({
        fill: (0, _utils.extractColor)(backgroundColor),
        'stroke-width': 0
      }).append(that._panesBackgroundGroup);
      rects.push(rect);
    }
    that.panesBackground = rects;
  },
  _fillPanesBackground() {
    var that = this;
    var bc;
    (0, _iterator.each)(that.panes, function (i, pane) {
      bc = pane.borderCoords;
      if (that.panesBackground[i] !== null) {
        that.panesBackground[i].attr({
          x: bc.left,
          y: bc.top,
          width: bc.width,
          height: bc.height
        });
      }
    });
  },
  _calcPaneBorderCoords(pane) {
    var canvas = pane.canvas;
    var bc = pane.borderCoords = pane.borderCoords || {};
    bc.left = canvas.left;
    bc.top = canvas.top;
    bc.right = canvas.width - canvas.right;
    bc.bottom = canvas.height - canvas.bottom;
    bc.width = Math.max(bc.right - bc.left, 0);
    bc.height = Math.max(bc.bottom - bc.top, 0);
  },
  _drawPanesBorders(panesBorderOptions) {
    var that = this;
    var rotated = that._isRotated();
    that._panesBorderGroup.linkRemove().clear();
    (0, _iterator.each)(that.panes, function (i, pane) {
      var borderOptions = panesBorderOptions[pane.name];
      var attr = {
        fill: 'none',
        stroke: borderOptions.color,
        'stroke-opacity': borderOptions.opacity,
        'stroke-width': borderOptions.width,
        dashStyle: borderOptions.dashStyle,
        'stroke-linecap': 'square'
      };
      that._calcPaneBorderCoords(pane, rotated);
      if (!borderOptions.visible) {
        return;
      }
      var bc = pane.borderCoords;
      var segmentRectParams = (0, _utils2.prepareSegmentRectPoints)(bc.left, bc.top, bc.width, bc.height, borderOptions);
      that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup);
    });
    that._panesBorderGroup.linkAppend();
  },
  _createClipRect(clipArray, index, left, top, width, height) {
    var that = this;
    var clipRect = clipArray[index];
    if (!clipRect) {
      clipRect = that._renderer.clipRect(left, top, width, height);
      clipArray[index] = clipRect;
    } else {
      clipRect.attr({
        x: left,
        y: top,
        width,
        height
      });
    }
  },
  _createClipRectsForPanes() {
    var that = this;
    var canvas = that._canvas;
    (0, _iterator.each)(that.panes, function (i, pane) {
      var needWideClipRect = false;
      var bc = pane.borderCoords;
      var left = bc.left;
      var top = bc.top;
      var width = bc.width;
      var height = bc.height;
      var panesClipRects = that._panesClipRects;
      that._createClipRect(panesClipRects.fixed, i, left, top, width, height);
      that._createClipRect(panesClipRects.base, i, left, top, width, height);
      (0, _iterator.each)(that.series, function (_, series) {
        if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {
          needWideClipRect = true;
        }
      });
      if (needWideClipRect) {
        if (that._isRotated()) {
          top = 0;
          height = canvas.height;
        } else {
          left = 0;
          width = canvas.width;
        }
        that._createClipRect(panesClipRects.wide, i, left, top, width, height);
      } else {
        panesClipRects.wide[i] = null;
      }
    });
  },
  _applyClipRectsForAxes() {
    var that = this;
    var axes = that._getAllAxes();
    var chartCanvasClipRectID = that._getCanvasClipRectID();
    for (var i = 0; i < axes.length; i++) {
      var elementsClipRectID = that._getElementsClipRectID(axes[i].pane);
      axes[i].applyClipRects(elementsClipRectID, chartCanvasClipRectID);
    }
  },
  _getPaneBorderVisibility(paneIndex) {
    var commonPaneBorderVisible = this._themeManager.getOptions('commonPaneSettings').border.visible;
    var pane = this.panes[paneIndex] || {};
    var paneBorder = pane.border || {};
    return 'visible' in paneBorder ? paneBorder.visible : commonPaneBorderVisible;
  },
  _getCanvasForPane(paneName) {
    var panes = this.panes;
    var panesNumber = panes.length;
    var i;
    for (i = 0; i < panesNumber; i++) {
      if (panes[i].name === paneName) {
        return panes[i].canvas;
      }
    }
  },
  _getTrackerSettings() {
    var that = this;
    var themeManager = that._themeManager;
    return (0, _extend2.extend)(this.callBase(), {
      chart: that,
      rotated: that._isRotated(),
      crosshair: that._getCrosshairOptions().enabled ? that._crosshair : null,
      stickyHovering: themeManager.getOptions('stickyHovering')
    });
  },
  _resolveLabelOverlappingStack() {
    var that = this;
    var isRotated = that._isRotated();
    var shiftDirection = isRotated ? function (box, length) {
      return {
        x: box.x - length,
        y: box.y
      };
    } : function (box, length) {
      return {
        x: box.x,
        y: box.y - length
      };
    };
    (0, _iterator.each)(that._getStackPoints(), function (_, stacks) {
      (0, _iterator.each)(stacks, function (_, points) {
        var isInverted = points[0].series.getValueAxis().getOptions().inverted;
        _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, isInverted, shiftDirection, function (a, b) {
          var coordPosition = isRotated ? 1 : 0;
          var figureCenter1 = a.labels[0].getFigureCenter()[coordPosition];
          var figureCenter12 = b.labels[0].getFigureCenter()[coordPosition];
          if (figureCenter1 - figureCenter12 === 0) {
            return (a.value() - b.value()) * (a.labels[0].getPoint().series.getValueAxis().getTranslator().isInverted() ? -1 : 1);
          }
          return 0;
        });
      });
    });
  },
  _getStackPoints() {
    var stackPoints = {};
    var visibleSeries = this._getVisibleSeries();
    (0, _iterator.each)(visibleSeries, function (_, singleSeries) {
      var points = singleSeries.getPoints();
      var stackName = singleSeries.getStackName() || null;
      (0, _iterator.each)(points, function (_, point) {
        var argument = point.argument;
        if (!stackPoints[argument]) {
          stackPoints[argument] = {};
        }
        if (!stackPoints[argument][stackName]) {
          stackPoints[argument][stackName] = [];
        }
        stackPoints[argument][stackName].push(point);
      });
    });
    return stackPoints;
  },
  _getCrosshairOptions() {
    return this._getOption('crosshair');
  },
  // API
  zoomArgument(min, max) {
    var that = this;
    if (!that._initialized || !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
      return;
    }
    that.getArgumentAxis().visualRange([min, max]);
  },
  resetVisualRange() {
    var that = this;
    var axes = that._argumentAxes;
    var nonVirtualArgumentAxis = that.getArgumentAxis();
    axes.forEach(function (axis) {
      axis.resetVisualRange(nonVirtualArgumentAxis !== axis);
      that._applyCustomVisualRangeOption(axis);
    });
    that.callBase();
  },
  // T218011 for dashboards
  getVisibleArgumentBounds() {
    var translator = this._argumentAxes[0].getTranslator();
    var range = translator.getBusinessRange();
    var isDiscrete = range.axisType === DISCRETE;
    var categories = range.categories;
    return {
      minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,
      maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible
    };
  },
  _change_FULL_RENDER() {
    this.callBase();
    if (this._changes.has(VISUAL_RANGE)) {
      this._raiseZoomEndHandlers();
    }
  },
  _getAxesForScaling() {
    return [this.getArgumentAxis()].concat(this._valueAxes);
  },
  _applyVisualRangeByVirtualAxes(axis, range) {
    var that = this;
    if (axis.isArgumentAxis) {
      if (axis !== that.getArgumentAxis()) {
        return true;
      }
      that._argumentAxes.filter(function (a) {
        return a !== axis;
      }).forEach(function (a) {
        return a.visualRange(range, {
          start: true,
          end: true
        });
      });
    }
    return false;
  },
  _raiseZoomEndHandlers() {
    this._argumentAxes.forEach(function (axis) {
      return axis.handleZoomEnd();
    });
    this.callBase();
  },
  _setOptionsByReference() {
    this.callBase();
    (0, _extend2.extend)(this._optionsByReference, {
      'argumentAxis.visualRange': true
    });
  },
  option() {
    var option = this.callBase.apply(this, arguments);
    var valueAxis = this._options.silent('valueAxis');
    if ((0, _type.type)(valueAxis) === 'array') {
      for (var i = 0; i < valueAxis.length; i++) {
        var optionPath = "valueAxis[".concat(i, "].visualRange");
        this._optionsByReference[optionPath] = true;
      }
    }
    return option;
  },
  _notifyVisualRange() {
    var that = this;
    var argAxis = that._argumentAxes[0];
    var argumentVisualRange = (0, _utils.convertVisualRangeObject)(argAxis.visualRange(), !isArray(that.option('argumentAxis.visualRange')));
    if (!argAxis.skipEventRising || !(0, _utils.rangesAreEqual)(argumentVisualRange, that.option('argumentAxis.visualRange'))) {
      that.option('argumentAxis.visualRange', argumentVisualRange);
    } else {
      argAxis.skipEventRising = null;
    }
    that.callBase();
  }
});
dxChart.addPlugin(_shutter_zoom.default);
dxChart.addPlugin(_zoom_and_pan.default);
dxChart.addPlugin(_annotations.plugins.core);
dxChart.addPlugin(_annotations.plugins.chart);
(0, _component_registrator.default)('dxChart', dxChart);
var _default = dxChart;
exports["default"] = _default;

/***/ }),

/***/ 88647:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _annotations = __webpack_require__(77129);
var _center_template = __webpack_require__(56672);
var _utils = __webpack_require__(19157);
var _range = __webpack_require__(21177);
var _translator1d = __webpack_require__(17953);
var _m_base_chart = __webpack_require__(14107);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var states = _consts.default.states;
var seriesSpacing = _consts.default.pieSeriesSpacing;
var OPTIONS_FOR_REFRESH_SERIES = ['startAngle', 'innerRadius', 'segmentsDirection', 'type'];
var NORMAL_STATE = states.normalMark;
var HOVER_STATE = states.hoverMark;
var SELECTED_STATE = states.selectedMark;
var MAX_RESOLVE_ITERATION_COUNT = 5;
var LEGEND_ACTIONS = [states.resetItem, states.applyHover, states.applySelected, states.applySelected];
function getLegendItemAction(points) {
  var state = NORMAL_STATE;
  points.forEach(function (point) {
    var _a;
    var seriesOptions = (_a = point.series) === null || _a === void 0 ? void 0 : _a.getOptions();
    var pointState = point.fullState;
    if ((seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.hoverMode) === 'none') {
      pointState &= ~HOVER_STATE;
    }
    if ((seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.selectionMode) === 'none') {
      pointState &= ~SELECTED_STATE;
    }
    state |= pointState;
  });
  return LEGEND_ACTIONS[state];
}
function correctPercentValue(value) {
  if ((0, _type.isNumeric)(value)) {
    if (value > 1) {
      value = 1;
    } else if (value < 0) {
      value = 0;
    }
  } else {
    value = undefined;
  }
  return value;
}
var pieSizeEqualizer = function () {
  function equalize(group, allPies) {
    var pies = allPies.filter(function (p) {
      return p._isVisible() && p.getSizeGroup() === group;
    });
    var minRadius = Math.min.apply(null, pies.map(function (p) {
      return p.getSizeGroupLayout().radius;
    }));
    var minPie = pies.filter(function (p) {
      return p.getSizeGroupLayout().radius === minRadius;
    });
    pies.forEach(function (p) {
      return p.render({
        force: true,
        sizeGroupLayout: minPie.length ? minPie[0].getSizeGroupLayout() : {}
      });
    });
  }
  function removeFromList(list, item) {
    return list.filter(function (li) {
      return li !== item;
    });
  }
  function addToList(list, item) {
    return removeFromList(list, item).concat(item);
  }
  var pies = [];
  var timers = {};
  return {
    queue(pie) {
      var group = pie.getSizeGroup();
      pies = addToList(pies, pie);
      clearTimeout(timers[group]);
      timers[group] = setTimeout(function () {
        equalize(group, pies);
      });
    },
    remove(pie) {
      pies = removeFromList(pies, pie);
      if (!pies.length) {
        timers = {};
      }
    }
  };
}();
var dxPieChart = _m_base_chart.BaseChart.inherit({
  _themeSection: 'pie',
  _layoutManagerOptions() {
    return (0, _extend2.extend)(true, {}, this.callBase(), {
      piePercentage: correctPercentValue(this._themeManager.getOptions('diameter')),
      minPiePercentage: correctPercentValue(this._themeManager.getOptions('minDiameter'))
    });
  },
  _optionChangesMap: {
    diameter: 'REINIT',
    minDiameter: 'REINIT',
    sizeGroup: 'REINIT'
  },
  _disposeCore() {
    pieSizeEqualizer.remove(this);
    this.callBase();
  },
  _groupSeries() {
    var series = this.series;
    this._groupsData = {
      groups: [{
        series,
        valueOptions: {
          valueType: 'numeric'
        }
      }],
      argumentOptions: series[0] && series[0].getOptions()
    };
  },
  getArgumentAxis() {
    return null;
  },
  _getValueAxis() {
    var translator = new _translator1d.Translator1D().setCodomain(360, 0);
    return {
      getTranslator() {
        return translator;
      },
      setBusinessRange(range) {
        translator.setDomain(range.min, range.max);
      }
    };
  },
  _populateBusinessRange() {
    this.series.map(function (series) {
      var range = new _range.Range();
      range.addRange(series.getRangeData().val);
      series.getValueAxis().setBusinessRange(range);
      return range;
    });
  },
  _specialProcessSeries() {
    (0, _iterator.each)(this.series, function (_, singleSeries) {
      singleSeries.arrangePoints();
    });
  },
  _checkPaneName() {
    return true;
  },
  _processSingleSeries(singleSeries) {
    this.callBase(singleSeries);
    singleSeries.arrangePoints();
  },
  _handleSeriesDataUpdated() {
    var maxPointCount = 0;
    this.series.forEach(function (s) {
      maxPointCount = Math.max(s.getPointsCount(), maxPointCount);
    });
    this.series.forEach(function (s) {
      s.setMaxPointsCount(maxPointCount);
    });
    this.callBase();
  },
  _getLegendOptions(item) {
    var legendItem = this.callBase(item);
    var legendData = legendItem.legendData;
    legendData.argument = item.argument;
    legendData.argumentIndex = item.argumentIndex;
    legendData.points = [item];
    return legendItem;
  },
  _getLegendTargets() {
    var that = this;
    var itemsByArgument = {};
    (that.series || []).forEach(function (series) {
      series.getPoints().forEach(function (point) {
        var argument = point.argument.valueOf();
        var index = series.getPointsByArg(argument).indexOf(point);
        var key = argument.valueOf().toString() + index;
        itemsByArgument[key] = itemsByArgument[key] || [];
        var argumentCount = itemsByArgument[key].push(point);
        point.index = itemsByArgument[key][argumentCount - 2] ? itemsByArgument[key][argumentCount - 2].index : Object.keys(itemsByArgument).length - 1;
        point.argumentIndex = index;
      });
    });
    var items = [];
    (0, _iterator.each)(itemsByArgument, function (_, points) {
      points.forEach(function (point, index) {
        if (index === 0) {
          items.push(that._getLegendOptions(point));
          return;
        }
        var item = items[items.length - 1];
        item.legendData.points.push(point);
        if (!item.visible) {
          item.visible = point.isVisible();
        }
      });
    });
    return items;
  },
  _getLayoutTargets() {
    return [{
      canvas: this._canvas
    }];
  },
  _getLayoutSeries(series, drawOptions) {
    var that = this;
    var layout;
    var canvas = that._canvas;
    var drawnLabels = false;
    layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, true);
    series.forEach(function (singleSeries) {
      singleSeries.correctPosition(layout, canvas);
      drawnLabels = singleSeries.drawLabelsWOPoints() || drawnLabels;
    });
    if (drawnLabels) {
      layout = that.layoutManager.applyPieChartSeriesLayout(canvas, series, drawOptions.hideLayoutLabels);
    }
    series.forEach(function (singleSeries) {
      singleSeries.hideLabels();
    });
    that._sizeGroupLayout = {
      x: layout.centerX,
      y: layout.centerY,
      radius: layout.radiusOuter,
      drawOptions
    };
    return layout;
  },
  _getLayoutSeriesForEqualPies(series, sizeGroupLayout) {
    var canvas = this._canvas;
    var layout = this.layoutManager.applyEqualPieChartLayout(series, sizeGroupLayout);
    series.forEach(function (s) {
      s.correctPosition(layout, canvas);
      s.drawLabelsWOPoints();
    });
    this.layoutManager.correctPieLabelRadius(series, layout, canvas);
    return layout;
  },
  _updateSeriesDimensions(drawOptions) {
    var that = this;
    var visibleSeries = that._getVisibleSeries();
    var lengthVisibleSeries = visibleSeries.length;
    var innerRad;
    var delta;
    var layout;
    var sizeGroupLayout = drawOptions.sizeGroupLayout;
    if (lengthVisibleSeries) {
      layout = sizeGroupLayout ? that._getLayoutSeriesForEqualPies(visibleSeries, sizeGroupLayout) : that._getLayoutSeries(visibleSeries, drawOptions);
      delta = (layout.radiusOuter - layout.radiusInner - seriesSpacing * (lengthVisibleSeries - 1)) / lengthVisibleSeries;
      innerRad = layout.radiusInner;
      that._setGeometry(layout);
      visibleSeries.forEach(function (singleSeries) {
        singleSeries.correctRadius({
          radiusInner: innerRad,
          radiusOuter: innerRad + delta
        });
        innerRad += delta + seriesSpacing;
      });
    }
  },
  _renderSeries(drawOptions, isRotated, isLegendInside) {
    this._calculateSeriesLayout(drawOptions, isRotated);
    if (!drawOptions.sizeGroupLayout && this.getSizeGroup()) {
      pieSizeEqualizer.queue(this);
      this._clearCanvas();
      return;
    }
    this._renderSeriesElements(drawOptions, isLegendInside);
  },
  _getCenter() {
    return this._center;
  },
  getInnerRadius() {
    return this._innerRadius;
  },
  _getLegendCallBack() {
    var that = this;
    var legend = this._legend;
    var items = this._getLegendTargets().map(function (i) {
      return i.legendData;
    });
    return function (target) {
      items.forEach(function (data) {
        var points = [];
        var callback = legend.getActionCallback({
          index: data.id
        });
        that.series.forEach(function (series) {
          var seriesPoints = series.getPointsByKeys(data.argument, data.argumentIndex);
          points.push.apply(points, seriesPoints);
        });
        if (target && target.argument === data.argument && target.argumentIndex === data.argumentIndex) {
          points.push(target);
        }
        callback(getLegendItemAction(points));
      });
    };
  },
  _locateLabels(resolveLabelOverlapping) {
    var iterationCount = 0;
    var labelsWereOverlapped;
    var wordWrapApplied;
    do {
      wordWrapApplied = this._adjustSeriesLabels(resolveLabelOverlapping === 'shift');
      labelsWereOverlapped = this._resolveLabelOverlapping(resolveLabelOverlapping);
    } while ((labelsWereOverlapped || wordWrapApplied) && ++iterationCount < MAX_RESOLVE_ITERATION_COUNT);
  },
  _adjustSeriesLabels(moveLabelsFromCenter) {
    return this.series.reduce(function (r, s) {
      return s.adjustLabels(moveLabelsFromCenter) || r;
    }, false);
  },
  _applyExtraSettings: _common.noop,
  _resolveLabelOverlappingShift() {
    var that = this;
    var inverseDirection = that.option('segmentsDirection') === 'anticlockwise';
    var seriesByPosition = that.series.reduce(function (r, s) {
      (r[s.getOptions().label.position] || r.outside).push(s);
      return r;
    }, {
      inside: [],
      columns: [],
      outside: []
    });
    var labelsOverlapped = false;
    if (seriesByPosition.inside.length > 0) {
      labelsOverlapped = resolve(seriesByPosition.inside.reduce(function (r, singleSeries) {
        return singleSeries.getVisiblePoints().reduce(function (r, point) {
          r.left.push(point);
          return r;
        }, r);
      }, {
        left: [],
        right: []
      }), shiftInColumnFunction) || labelsOverlapped;
    }
    labelsOverlapped = seriesByPosition.columns.reduce(function (r, singleSeries) {
      return resolve(dividePoints(singleSeries), shiftInColumnFunction) || r;
    }, labelsOverlapped);
    if (seriesByPosition.outside.length > 0) {
      labelsOverlapped = resolve(seriesByPosition.outside.reduce(function (r, singleSeries) {
        return dividePoints(singleSeries, r);
      }, null), shiftFunction) || labelsOverlapped;
    }
    return labelsOverlapped;
    function dividePoints(series, points) {
      return series.getVisiblePoints().reduce(function (r, point) {
        var angle = (0, _utils.normalizeAngle)(point.middleAngle);
        (angle <= 90 || angle >= 270 ? r.right : r.left).push(point);
        return r;
      }, points || {
        left: [],
        right: []
      });
    }
    function resolve(points, shiftCallback) {
      var overlapped = false;
      if (inverseDirection) {
        points.left.reverse();
        points.right.reverse();
      }
      overlapped = _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.left, that._canvas, false, false, shiftCallback);
      return _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(points.right, that._canvas, false, false, shiftCallback) || overlapped;
    }
    function shiftFunction(box, length) {
      return (0, _utils.getVerticallyShiftedAngularCoords)(box, -length, that._center);
    }
    function shiftInColumnFunction(box, length) {
      return {
        x: box.x,
        y: box.y - length
      };
    }
  },
  _setGeometry(_ref) {
    var x = _ref.centerX,
      y = _ref.centerY,
      radiusInner = _ref.radiusInner;
    this._center = {
      x,
      y
    };
    this._innerRadius = radiusInner;
  },
  _disposeSeries() {
    this.callBase.apply(this, arguments);
    this._abstractSeries = null;
  },
  _legendDataField: 'point',
  _legendItemTextField: 'argument',
  _applyPointMarkersAutoHiding: _common.noop,
  _renderTrackers: _common.noop,
  _trackerType: 'PieTracker',
  _createScrollBar: _common.noop,
  _updateAxesLayout: _common.noop,
  _applyClipRects: _common.noop,
  _appendAdditionalSeriesGroups: _common.noop,
  _prepareToRender: _common.noop,
  _isLegendInside: _common.noop,
  _renderAxes: _common.noop,
  _shrinkAxes: _common.noop,
  _isRotated: _common.noop,
  _seriesPopulatedHandlerCore: _common.noop,
  _reinitAxes: _common.noop,
  _correctAxes: _common.noop,
  _getExtraOptions() {
    var that = this;
    return {
      startAngle: that.option('startAngle'),
      innerRadius: that.option('innerRadius'),
      segmentsDirection: that.option('segmentsDirection'),
      type: that.option('type')
    };
  },
  getSizeGroup() {
    return this._themeManager.getOptions('sizeGroup');
  },
  getSizeGroupLayout() {
    return this._sizeGroupLayout || {};
  }
});
(0, _iterator.each)(OPTIONS_FOR_REFRESH_SERIES, function (_, name) {
  dxPieChart.prototype._optionChangesMap[name] = 'REFRESH_SERIES_DATA_INIT';
});
dxPieChart.addPlugin(_center_template.plugins.pieChart);
dxPieChart.addPlugin(_annotations.plugins.core);
dxPieChart.addPlugin(_annotations.plugins.pieChart);
(0, _component_registrator.default)('dxPieChart', dxPieChart);
var _default = dxPieChart;
exports["default"] = _default;

/***/ }),

/***/ 86139:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _annotations = __webpack_require__(77129);
var _utils = __webpack_require__(19157);
var _m_advanced_chart = __webpack_require__(41690);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DEFAULT_PANE_NAME = 'default';
var DOUBLE_PI_ANGLE = 360;
var dxPolarChart = _m_advanced_chart.AdvancedChart.inherit({
  _themeSection: 'polar',
  _createPanes() {
    this.callBase();
    return [{
      name: DEFAULT_PANE_NAME
    }];
  },
  _checkPaneName() {
    return true;
  },
  _getAxisRenderingOptions(typeSelector) {
    var isArgumentAxis = typeSelector === 'argumentAxis';
    var type = isArgumentAxis ? 'circular' : 'linear';
    var useSpiderWeb = this.option('useSpiderWeb');
    if (useSpiderWeb) {
      type += 'Spider';
    }
    return {
      axisType: 'polarAxes',
      drawingType: type
    };
  },
  _executeAppendBeforeSeries(append) {
    append();
  },
  _prepareAxisOptions(typeSelector, axisOptions) {
    var isArgumentAxis = typeSelector === 'argumentAxis';
    var themeManager = this._themeManager;
    var axisUserOptions = this.option('argumentAxis');
    var argumentAxisOptions = themeManager.getOptions('argumentAxis', axisUserOptions) || {};
    var startAngle = isFinite(argumentAxisOptions.startAngle) ? (0, _utils.normalizeAngle)(argumentAxisOptions.startAngle) : 0;
    return {
      type: this.option('useSpiderWeb') && isArgumentAxis ? 'discrete' : axisOptions.type,
      isHorizontal: true,
      showCustomBoundaryTicks: isArgumentAxis,
      startAngle,
      endAngle: startAngle + 360
    };
  },
  _optionChangesMap: {
    useSpiderWeb: 'USE_SPIDER_WEB'
  },
  _change_USE_SPIDER_WEB() {
    this._disposeAxes();
    this._requestChange(['AXES_AND_PANES']);
  },
  _getExtraOptions() {
    return {
      spiderWidget: this.option('useSpiderWeb')
    };
  },
  _prepareToRender() {
    this._appendAxesGroups();
    return {};
  },
  _calcCanvas() {
    var canvas = (0, _extend.extend)({}, this._canvas);
    var argumentAxis = this.getArgumentAxis();
    var margins = argumentAxis.getMargins();
    Object.keys(margins).forEach(function (margin) {
      canvas[margin] = canvas["original".concat(margin[0].toUpperCase()).concat(margin.slice(1))] + margins[margin];
    });
    return canvas;
  },
  _renderAxes() {
    var valueAxis = this._getValueAxis();
    var argumentAxis = this.getArgumentAxis();
    argumentAxis.draw(this._canvas);
    valueAxis.setSpiderTicks(argumentAxis.getSpiderTicks());
    var canvas = this._calcCanvas();
    argumentAxis.updateSize(canvas);
    valueAxis.draw(canvas);
    return canvas;
  },
  _getValueAxis() {
    return this._valueAxes[0];
  },
  _shrinkAxes(sizeStorage) {
    var valueAxis = this._getValueAxis();
    var argumentAxis = this.getArgumentAxis();
    if (sizeStorage && (sizeStorage.width || sizeStorage.height)) {
      argumentAxis.hideOuterElements();
      var canvas = this._calcCanvas();
      argumentAxis.updateSize(canvas);
      valueAxis.updateSize(canvas);
    }
  },
  checkForMoreSpaceForPanesCanvas() {
    return this.layoutManager.needMoreSpaceForPanesCanvas([{
      canvas: this.getArgumentAxis().getCanvas()
    }], this._isRotated());
  },
  _getLayoutTargets() {
    return [{
      canvas: this._canvas
    }];
  },
  _getSeriesForPane() {
    return this.series;
  },
  _applyClipRects() {
    var canvasClipRectID = this._getCanvasClipRectID();
    this._createClipPathForPane();
    this.getArgumentAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID);
    this._getValueAxis().applyClipRects(this._getElementsClipRectID(), canvasClipRectID);
  },
  _createClipPathForPane() {
    var that = this;
    var valueAxis = that._getValueAxis();
    var center = valueAxis.getCenter();
    var radius = valueAxis.getRadius();
    var panesClipRects = that._panesClipRects;
    center = {
      x: Math.round(center.x),
      y: Math.round(center.y)
    };
    that._createClipCircle(panesClipRects.fixed, center.x, center.y, radius);
    that._createClipCircle(panesClipRects.base, center.x, center.y, radius);
    if (that.series.some(function (s) {
      return s.areErrorBarsVisible();
    })) {
      that._createClipCircle(panesClipRects.wide, center.x, center.y, radius);
    } else {
      panesClipRects.wide[0] = null;
    }
  },
  _createClipCircle(clipArray, left, top, radius) {
    var that = this;
    var clipCircle = clipArray[0];
    if (!clipCircle) {
      clipCircle = that._renderer.clipCircle(left, top, radius);
      clipArray[0] = clipCircle;
    } else {
      clipCircle.attr({
        cx: left,
        cy: top,
        r: radius
      });
    }
  },
  _applyExtraSettings(series) {
    var wideClipRect = this._panesClipRects.wide[0];
    series.setClippingParams(this._panesClipRects.base[0].id, wideClipRect && wideClipRect.id, false, false);
  },
  getActualAngle(angle) {
    return this.getArgumentAxis().getOptions().inverted ? DOUBLE_PI_ANGLE - angle : angle;
  },
  getXYFromPolar(angle, radius, argument, value) {
    var layoutInfo = {
      angle: undefined,
      radius: undefined,
      x: undefined,
      y: undefined
    };
    if (!(0, _type.isDefined)(angle) && !(0, _type.isDefined)(radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(value)) {
      return layoutInfo;
    }
    var argAxis = this.getArgumentAxis();
    var startAngle = argAxis.getAngles()[0];
    var argAngle;
    var translatedRadius;
    if ((0, _type.isDefined)(argument)) {
      argAngle = argAxis.getTranslator().translate(argument);
    } else if (isFinite(angle)) {
      argAngle = this.getActualAngle(angle);
    } else if (!(0, _type.isDefined)(angle)) {
      argAngle = 0;
    }
    if ((0, _type.isDefined)(value)) {
      translatedRadius = this.getValueAxis().getTranslator().translate(value);
    } else if (isFinite(radius)) {
      translatedRadius = radius;
    } else if (!(0, _type.isDefined)(radius)) {
      translatedRadius = argAxis.getRadius();
    }
    if ((0, _type.isDefined)(argAngle) && (0, _type.isDefined)(translatedRadius)) {
      var coords = (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, argAngle, translatedRadius);
      (0, _extend.extend)(layoutInfo, coords, {
        angle: argAxis.getTranslatedAngle(argAngle),
        radius: translatedRadius
      });
    }
    return layoutInfo;
  },
  _applyPointMarkersAutoHiding: _common.noop,
  _createScrollBar: _common.noop,
  _isRotated: _common.noop,
  _getCrosshairOptions: _common.noop,
  _isLegendInside: _common.noop
});
dxPolarChart.addPlugin(_annotations.plugins.core);
dxPolarChart.addPlugin(_annotations.plugins.polarChart);
(0, _component_registrator.default)('dxPolarChart', dxPolarChart);
var _default = dxPolarChart;
exports["default"] = _default;

/***/ }),

/***/ 23908:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.convertTransitionTimingFuncToEasing = void 0;
exports.getEasing = getEasing;
exports.setEasing = setEasing;
var _type = __webpack_require__(35922);
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
  'linear': 'cubic-bezier(0, 0, 1, 1)',
  'swing': 'cubic-bezier(0.445, 0.05, 0.55, 0.95)',
  'ease': 'cubic-bezier(0.25, 0.1, 0.25, 1)',
  'ease-in': 'cubic-bezier(0.42, 0, 1, 1)',
  'ease-out': 'cubic-bezier(0, 0, 0.58, 1)',
  'ease-in-out': 'cubic-bezier(0.42, 0, 0.58, 1)'
};
var polynomBezier = function polynomBezier(x1, y1, x2, y2) {
  var Cx = 3 * x1;
  var Bx = 3 * (x2 - x1) - Cx;
  var Ax = 1 - Cx - Bx;
  var Cy = 3 * y1;
  var By = 3 * (y2 - y1) - Cy;
  var Ay = 1 - Cy - By;
  var bezierX = function bezierX(t) {
    return t * (Cx + t * (Bx + t * Ax));
  };
  var bezierY = function bezierY(t) {
    return t * (Cy + t * (By + t * Ay));
  };
  var derivativeX = function derivativeX(t) {
    return Cx + t * (2 * Bx + t * 3 * Ax);
  };
  var findXFor = function findXFor(t) {
    var x = t;
    var i = 0;
    var z;
    while (i < 14) {
      z = bezierX(x) - t;
      if (Math.abs(z) < 1e-3) {
        break;
      }
      x = x - z / derivativeX(x);
      i++;
    }
    return x;
  };
  return function (t) {
    return bezierY(findXFor(t));
  };
};
var easing = {};
var convertTransitionTimingFuncToEasing = function convertTransitionTimingFuncToEasing(cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  var forceName;
  if (!coeffs) {
    forceName = 'linear';
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }
  coeffs = coeffs.slice(1, 5);
  for (var i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }
  var easingName = forceName || 'cubicbezier_' + coeffs.join('_').replace(/\./g, 'p');
  if (!(0, _type.isFunction)(easing[easingName])) {
    easing[easingName] = function (x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }
  return easingName;
};
exports.convertTransitionTimingFuncToEasing = convertTransitionTimingFuncToEasing;
function setEasing(value) {
  easing = value;
}
function getEasing(name) {
  return easing[name];
}

/***/ }),

/***/ 90057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.cancelAnimationFrame = cancelAnimationFrame;
exports.requestAnimationFrame = requestAnimationFrame;
var _window = __webpack_require__(58201);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.hasWindow)() ? (0, _window.getWindow)() : {};
var FRAME_ANIMATION_STEP_TIME = 1000 / 60;
var request = function request(callback) {
  return setTimeout(callback, FRAME_ANIMATION_STEP_TIME);
};
var cancel = function cancel(requestID) {
  clearTimeout(requestID);
};
var setAnimationFrameMethods = (0, _call_once.default)(function () {
  var nativeRequest = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
  var nativeCancel = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }
});
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window, arguments);
}

/***/ }),

/***/ 87209:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _element = __webpack_require__(6415);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _translator = __webpack_require__(31648);
var _easing = __webpack_require__(23908);
var _frame = __webpack_require__(90057);
var _support = __webpack_require__(60137);
var _position = _interopRequireDefault(__webpack_require__(49387));
var _remove = __webpack_require__(29007);
var _index = __webpack_require__(39611);
var _deferred = __webpack_require__(62754);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var removeEventName = (0, _index.addNamespace)(_remove.removeEvent, 'dxFX');
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var ANIM_DATA_KEY = 'dxAnimData';
var ANIM_QUEUE_KEY = 'dxAnimQueue';
var TRANSFORM_PROP = 'transform';
var TransitionAnimationStrategy = {
  initAnimation: function initAnimation($element, config) {
    $element.css({
      'transitionProperty': 'none'
    });
    if (typeof config.from === 'string') {
      $element.addClass(config.from);
    } else {
      setProps($element, config.from);
    }
    var that = this;
    var deferred = new _deferred.Deferred();
    var cleanupWhen = config.cleanupWhen;
    config.transitionAnimation = {
      deferred: deferred,
      finish: function finish() {
        that._finishTransition($element);
        if (cleanupWhen) {
          (0, _deferred.when)(deferred, cleanupWhen).always(function () {
            that._cleanup($element, config);
          });
        } else {
          that._cleanup($element, config);
        }
        deferred.resolveWith($element, [config, $element]);
      }
    };
    this._completeAnimationCallback($element, config).done(function () {
      config.transitionAnimation.finish();
    }).fail(function () {
      deferred.rejectWith($element, [config, $element]);
    });
    if (!config.duration) {
      config.transitionAnimation.finish();
    }

    // NOTE: Hack for setting 'from' css by browser before run animation
    //       Do not move this hack to initAnimation since some css props can be changed in the 'start' callback (T231434)
    //       Unfortunately this can't be unit tested
    // TODO: find better way if possible
    $element.css('transform');
  },
  animate: function animate($element, config) {
    this._startAnimation($element, config);
    return config.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function _completeAnimationCallback($element, config) {
    var that = this;
    var startTime = Date.now() + config.delay;
    var deferred = new _deferred.Deferred();
    var transitionEndFired = new _deferred.Deferred();
    var simulatedTransitionEndFired = new _deferred.Deferred();
    var simulatedEndEventTimer;
    var transitionEndEventFullName = (0, _support.transitionEndEventName)() + '.dxFX';
    config.transitionAnimation.cleanup = function () {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);
      _events_engine.default.off($element, transitionEndEventFullName);
      _events_engine.default.off($element, removeEventName);
    };
    _events_engine.default.one($element, transitionEndEventFullName, function () {
      // NOTE: prevent native transitionEnd event from previous animation in queue (Chrome)
      if (Date.now() - startTime >= config.duration) {
        transitionEndFired.reject();
      }
    });
    _events_engine.default.off($element, removeEventName);
    _events_engine.default.on($element, removeEventName, function () {
      that.stop($element, config);
      deferred.reject();
    });
    var waitForJSCompleteTimer = setTimeout(function () {
      // Fix for a visual bug (T244514): do not setup the timer until all js code has finished working
      simulatedEndEventTimer = setTimeout(function () {
        simulatedTransitionEndFired.reject();
      }, config.duration + config.delay + fx._simulatedTransitionEndDelay /* T255863 */);

      (0, _deferred.when)(transitionEndFired, simulatedTransitionEndFired).fail(function () {
        deferred.resolve();
      }.bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function _startAnimation($element, config) {
    $element.css({
      'transitionProperty': 'all',
      'transitionDelay': config.delay + 'ms',
      'transitionDuration': config.duration + 'ms',
      'transitionTimingFunction': config.easing
    });
    if (typeof config.to === 'string') {
      $element[0].className += ' ' + config.to;
      // Do not uncomment: performance critical
      // $element.addClass(config.to);
    } else if (config.to) {
      setProps($element, config.to);
    }
  },
  _finishTransition: function _finishTransition($element) {
    $element.css('transition', 'none');
  },
  _cleanup: function _cleanup($element, config) {
    config.transitionAnimation.cleanup();
    if (typeof config.from === 'string') {
      $element.removeClass(config.from);
      $element.removeClass(config.to);
    }
  },
  stop: function stop($element, config, jumpToEnd) {
    if (!config) {
      return;
    }
    if (jumpToEnd) {
      config.transitionAnimation.finish();
    } else {
      if ((0, _type.isPlainObject)(config.to)) {
        (0, _iterator.each)(config.to, function (key) {
          $element.css(key, $element.css(key));
        });
      }
      this._finishTransition($element);
      this._cleanup($element, config);
    }
  }
};
var FrameAnimationStrategy = {
  initAnimation: function initAnimation($element, config) {
    setProps($element, config.from);
  },
  animate: function animate($element, config) {
    var deferred = new _deferred.Deferred();
    var that = this;
    if (!config) {
      return deferred.reject().promise();
    }
    (0, _iterator.each)(config.to, function (prop) {
      if (config.from[prop] === undefined) {
        config.from[prop] = that._normalizeValue($element.css(prop));
      }
    });
    if (config.to[TRANSFORM_PROP]) {
      config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
      config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP]);
    }
    config.frameAnimation = {
      to: config.to,
      from: config.from,
      currentValue: config.from,
      easing: (0, _easing.convertTransitionTimingFuncToEasing)(config.easing),
      duration: config.duration,
      startTime: new Date().valueOf(),
      finish: function finish() {
        this.currentValue = this.to;
        this.draw();
        (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function draw() {
        if (config.draw) {
          config.draw(this.currentValue);
          return;
        }
        var currentValue = (0, _extend.extend)({}, this.currentValue);
        if (currentValue[TRANSFORM_PROP]) {
          currentValue[TRANSFORM_PROP] = (0, _iterator.map)(currentValue[TRANSFORM_PROP], function (value, prop) {
            if (prop === 'translate') {
              return (0, _translator.getTranslateCss)(value);
            } else if (prop === 'scale') {
              return 'scale(' + value + ')';
            } else if (prop.substr(0, prop.length - 1) === 'rotate') {
              return prop + '(' + value + 'deg)';
            }
          }).join(' ');
        }
        $element.css(currentValue);
      }
    };
    if (config.delay) {
      config.frameAnimation.startTime += config.delay;
      config.frameAnimation.delayTimeout = setTimeout(function () {
        that._startAnimation($element, config);
      }, config.delay);
    } else {
      that._startAnimation($element, config);
    }
    return deferred.promise();
  },
  _startAnimation: function _startAnimation($element, config) {
    _events_engine.default.off($element, removeEventName);
    _events_engine.default.on($element, removeEventName, function () {
      if (config.frameAnimation) {
        (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId);
      }
    });
    this._animationStep($element, config);
  },
  _parseTransform: function _parseTransform(transformString) {
    var result = {};
    (0, _iterator.each)(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function (i, part) {
      var translateData = (0, _translator.parseTranslate)(part);
      var scaleData = part.match(/scale\((.+?)\)/);
      var rotateData = part.match(/(rotate.)\((.+)deg\)/);
      if (translateData) {
        result.translate = translateData;
      }
      if (scaleData && scaleData[1]) {
        result.scale = parseFloat(scaleData[1]);
      }
      if (rotateData && rotateData[1]) {
        result[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result;
  },
  stop: function stop($element, config, jumpToEnd) {
    var frameAnimation = config && config.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    (0, _frame.cancelAnimationFrame)(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);
    if (jumpToEnd) {
      frameAnimation.finish();
    }
    delete config.frameAnimation;
  },
  _animationStep: function _animationStep($element, config) {
    var frameAnimation = config && config.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    var now = new Date().valueOf();
    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }
    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    var that = this;
    frameAnimation.animationFrameId = (0, _frame.requestAnimationFrame)(function () {
      that._animationStep($element, config);
    });
  },
  _calcStepValue: function _calcStepValue(frameAnimation, currentDuration) {
    var calcValueRecursively = function calcValueRecursively(from, to) {
      var result = Array.isArray(to) ? [] : {};
      var calcEasedValue = function calcEasedValue(propName) {
        var x = currentDuration / frameAnimation.duration;
        var t = currentDuration;
        var b = 1 * from[propName];
        var c = to[propName] - from[propName];
        var d = frameAnimation.duration;
        return (0, _easing.getEasing)(frameAnimation.easing)(x, t, b, c, d);
      };
      (0, _iterator.each)(to, function (propName, endPropValue) {
        if (typeof endPropValue === 'string' && parseFloat(endPropValue) === false) {
          return true;
        }
        result[propName] = typeof endPropValue === 'object' ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName);
      });
      return result;
    };
    return calcValueRecursively(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function _normalizeValue(value) {
    var numericValue = parseFloat(value);
    if (numericValue === false) {
      return value;
    }
    return numericValue;
  }
};
var FallbackToNoAnimationStrategy = {
  initAnimation: function initAnimation() {},
  animate: function animate() {
    return new _deferred.Deferred().resolve().promise();
  },
  stop: _common.noop,
  isSynchronous: true
};
var getAnimationStrategy = function getAnimationStrategy(config) {
  config = config || {};
  var animationStrategies = {
    'transition': (0, _support.transition)() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    'frame': FrameAnimationStrategy,
    'noAnimation': FallbackToNoAnimationStrategy
  };
  var strategy = config.strategy || 'transition';
  if (config.type === 'css' && !(0, _support.transition)()) {
    strategy = 'noAnimation';
  }
  return animationStrategies[strategy];
};
var baseConfigValidator = function baseConfigValidator(config, animationType, validate, typeMessage) {
  (0, _iterator.each)(['from', 'to'], function () {
    if (!validate(config[this])) {
      throw _errors.default.Error('E0010', animationType, this, typeMessage);
    }
  });
};
var isObjectConfigValidator = function isObjectConfigValidator(config, animationType) {
  return baseConfigValidator(config, animationType, function (target) {
    return (0, _type.isPlainObject)(target);
  }, 'a plain object');
};
var isStringConfigValidator = function isStringConfigValidator(config, animationType) {
  return baseConfigValidator(config, animationType, function (target) {
    return typeof target === 'string';
  }, 'a string');
};
var CustomAnimationConfigurator = {
  setup: function setup() {}
};
var CssAnimationConfigurator = {
  validateConfig: function validateConfig(config) {
    isStringConfigValidator(config, 'css');
  },
  setup: function setup() {}
};
var positionAliases = {
  'top': {
    my: 'bottom center',
    at: 'top center'
  },
  'bottom': {
    my: 'top center',
    at: 'bottom center'
  },
  'right': {
    my: 'left center',
    at: 'right center'
  },
  'left': {
    my: 'right center',
    at: 'left center'
  }
};
var SlideAnimationConfigurator = {
  validateConfig: function validateConfig(config) {
    isObjectConfigValidator(config, 'slide');
  },
  setup: function setup($element, config) {
    var location = (0, _translator.locate)($element);
    if (config.type !== 'slide') {
      var positioningConfig = config.type === 'slideIn' ? config.from : config.to;
      positioningConfig.position = (0, _extend.extend)({
        of: window
      }, positionAliases[config.direction]);
      setupPosition($element, positioningConfig);
    }
    this._setUpConfig(location, config.from);
    this._setUpConfig(location, config.to);
    (0, _translator.clearCache)($element);
  },
  _setUpConfig: function _setUpConfig(location, config) {
    config.left = 'left' in config ? config.left : '+=0';
    config.top = 'top' in config ? config.top : '+=0';
    this._initNewPosition(location, config);
  },
  _initNewPosition: function _initNewPosition(location, config) {
    var position = {
      left: config.left,
      top: config.top
    };
    delete config.left;
    delete config.top;
    var relativeValue = this._getRelativeValue(position.left);
    if (relativeValue !== undefined) {
      position.left = relativeValue + location.left;
    } else {
      config.left = 0;
    }
    relativeValue = this._getRelativeValue(position.top);
    if (relativeValue !== undefined) {
      position.top = relativeValue + location.top;
    } else {
      config.top = 0;
    }
    config[TRANSFORM_PROP] = (0, _translator.getTranslateCss)({
      x: position.left,
      y: position.top
    });
  },
  _getRelativeValue: function _getRelativeValue(value) {
    var relativeValue;
    if (typeof value === 'string' && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
      return parseInt(relativeValue[1] + '1') * relativeValue[2];
    }
  }
};
var FadeAnimationConfigurator = {
  setup: function setup($element, config) {
    var _from$opacity, _to$opacity;
    var from = config.from;
    var to = config.to;
    var defaultFromOpacity = config.type === 'fadeOut' ? 1 : 0;
    var defaultToOpacity = config.type === 'fadeOut' ? 0 : 1;
    var fromOpacity = (0, _type.isPlainObject)(from) ? String((_from$opacity = from.opacity) !== null && _from$opacity !== void 0 ? _from$opacity : defaultFromOpacity) : String(from);
    var toOpacity = (0, _type.isPlainObject)(to) ? String((_to$opacity = to.opacity) !== null && _to$opacity !== void 0 ? _to$opacity : defaultToOpacity) : String(to);
    if (!config.skipElementInitialStyles) {
      fromOpacity = $element.css('opacity');
    }
    switch (config.type) {
      case 'fadeIn':
        toOpacity = 1;
        break;
      case 'fadeOut':
        toOpacity = 0;
        break;
    }
    config.from = {
      visibility: 'visible',
      opacity: fromOpacity
    };
    config.to = {
      opacity: toOpacity
    };
  }
};
var PopAnimationConfigurator = {
  validateConfig: function validateConfig(config) {
    isObjectConfigValidator(config, 'pop');
  },
  setup: function setup($element, config) {
    var from = config.from;
    var to = config.to;
    var fromOpacity = 'opacity' in from ? from.opacity : $element.css('opacity');
    var toOpacity = 'opacity' in to ? to.opacity : 1;
    var fromScale = 'scale' in from ? from.scale : 0;
    var toScale = 'scale' in to ? to.scale : 1;
    config.from = {
      opacity: fromOpacity
    };
    var translate = (0, _translator.getTranslate)($element);
    config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
    config.to = {
      opacity: toOpacity
    };
    config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function _getCssTransform(translate, scale) {
    return (0, _translator.getTranslateCss)(translate) + 'scale(' + scale + ')';
  }
};
var animationConfigurators = {
  'custom': CustomAnimationConfigurator,
  'slide': SlideAnimationConfigurator,
  'slideIn': SlideAnimationConfigurator,
  'slideOut': SlideAnimationConfigurator,
  'fade': FadeAnimationConfigurator,
  'fadeIn': FadeAnimationConfigurator,
  'fadeOut': FadeAnimationConfigurator,
  'pop': PopAnimationConfigurator,
  'css': CssAnimationConfigurator
};
var getAnimationConfigurator = function getAnimationConfigurator(config) {
  var result = animationConfigurators[config.type];
  if (!result) {
    throw _errors.default.Error('E0011', config.type);
  }
  return result;
};
var defaultJSConfig = {
  type: 'custom',
  from: {},
  to: {},
  duration: 400,
  start: _common.noop,
  complete: _common.noop,
  easing: 'ease',
  delay: 0
};
var defaultCssConfig = {
  duration: 400,
  easing: 'ease',
  delay: 0
};
function setupAnimationOnElement() {
  var animation = this;
  var $element = animation.element;
  var config = animation.config;
  setupPosition($element, config.from);
  setupPosition($element, config.to);
  animation.configurator.setup($element, config);
  $element.data(ANIM_DATA_KEY, animation);
  if (fx.off) {
    config.duration = 0;
    config.delay = 0;
  }
  animation.strategy.initAnimation($element, config);
  if (config.start) {
    var element = (0, _element.getPublicElement)($element);
    config.start.apply(this, [element, config]);
  }
}
var onElementAnimationComplete = function onElementAnimationComplete(animation) {
  var $element = animation.element;
  var config = animation.config;
  $element.removeData(ANIM_DATA_KEY);
  if (config.complete) {
    var element = (0, _element.getPublicElement)($element);
    config.complete.apply(this, [element, config]);
  }
  animation.deferred.resolveWith(this, [$element, config]);
};
var startAnimationOnElement = function startAnimationOnElement() {
  var animation = this;
  var $element = animation.element;
  var config = animation.config;
  animation.isStarted = true;
  return animation.strategy.animate($element, config).done(function () {
    onElementAnimationComplete(animation);
  }).fail(function () {
    animation.deferred.rejectWith(this, [$element, config]);
  });
};
var stopAnimationOnElement = function stopAnimationOnElement(jumpToEnd) {
  var animation = this;
  var $element = animation.element;
  var config = animation.config;
  clearTimeout(animation.startTimeout);
  if (!animation.isStarted) {
    animation.start();
  }
  animation.strategy.stop($element, config, jumpToEnd);
};
var scopedRemoveEvent = (0, _index.addNamespace)(_remove.removeEvent, 'dxFXStartAnimation');
var subscribeToRemoveEvent = function subscribeToRemoveEvent(animation) {
  _events_engine.default.off(animation.element, scopedRemoveEvent);
  _events_engine.default.on(animation.element, scopedRemoveEvent, function () {
    fx.stop(animation.element);
  });
  animation.deferred.always(function () {
    _events_engine.default.off(animation.element, scopedRemoveEvent);
  });
};
var createAnimation = function createAnimation(element, initialConfig) {
  var defaultConfig = initialConfig.type === 'css' ? defaultCssConfig : defaultJSConfig;
  var config = (0, _extend.extend)(true, {}, defaultConfig, initialConfig);
  var configurator = getAnimationConfigurator(config);
  var strategy = getAnimationStrategy(config);
  var animation = {
    element: (0, _renderer.default)(element),
    config: config,
    configurator: configurator,
    strategy: strategy,
    isSynchronous: strategy.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new _deferred.Deferred()
  };
  if ((0, _type.isFunction)(configurator.validateConfig)) {
    configurator.validateConfig(config);
  }
  subscribeToRemoveEvent(animation);
  return animation;
};
var animate = function animate(element, config) {
  var $element = (0, _renderer.default)(element);
  if (!$element.length) {
    return new _deferred.Deferred().resolve().promise();
  }
  var animation = createAnimation($element, config);
  pushInAnimationQueue($element, animation);
  return animation.deferred.promise();
};
function pushInAnimationQueue($element, animation) {
  var queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data(ANIM_QUEUE_KEY) || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data(ANIM_QUEUE_KEY, queueData);
}
var destroyAnimQueueData = function destroyAnimQueueData($element) {
  $element.removeData(ANIM_QUEUE_KEY);
};
function isAnimating($element) {
  return !!$element.data(ANIM_DATA_KEY);
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  var animation = queueData.shift();
  if (queueData.length === 0) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation).done(function () {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation) {
  animation.setup();
  if (fx.off || animation.isSynchronous) {
    animation.start();
  } else {
    animation.startTimeout = setTimeout(function () {
      animation.start();
    });
  }
  return animation.deferred.promise();
}
function setupPosition($element, config) {
  if (!config || !config.position) {
    return;
  }
  var win = (0, _renderer.default)(window);
  var left = 0;
  var top = 0;
  var position = _position.default.calculate($element, config.position);
  var offset = $element.offset();
  var currentPosition = $element.position();
  if (currentPosition.top > offset.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset.left) {
    left = win.scrollLeft();
  }
  (0, _extend.extend)(config, {
    left: position.h.location - offset.left + currentPosition.left - left,
    top: position.v.location - offset.top + currentPosition.top - top
  });
  delete config.position;
}
function setProps($element, props) {
  (0, _iterator.each)(props, function (key, value) {
    try {
      $element.css(key, (0, _type.isFunction)(value) ? value() : value);
    } catch (e) {}
  });
}
var stop = function stop(element, jumpToEnd) {
  var $element = (0, _renderer.default)(element);
  var queueData = getAnimQueueData($element);

  // TODO: think about complete all animation in queue
  (0, _iterator.each)(queueData, function (_, animation) {
    animation.config.delay = 0;
    animation.config.duration = 0;
    animation.isSynchronous = true;
  });
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
  var animation = $element.data(ANIM_DATA_KEY);
  if (animation) {
    animation.stop(jumpToEnd);
  }
  $element.removeData(ANIM_DATA_KEY);
  destroyAnimQueueData($element);
};
var fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate: animate,
  createAnimation: createAnimation,
  isAnimating: isAnimating,
  stop: stop,
  _simulatedTransitionEndDelay: 100
};
var _default = fx;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49387:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _position = __webpack_require__(37518);
var _browser = _interopRequireDefault(__webpack_require__(47810));
var _translator = __webpack_require__(31648);
var _support = __webpack_require__(60137);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _style = __webpack_require__(80968);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale\(.+?\)/;
var IS_SAFARI = _browser.default.safari;
var normalizeAlign = function normalizeAlign(raw) {
  var result = {
    h: 'center',
    v: 'center'
  };
  var pair = (0, _common.splitPair)(raw);
  if (pair) {
    (0, _iterator.each)(pair, function () {
      var w = String(this).toLowerCase();
      if (horzRe.test(w)) {
        result.h = w;
      } else if (vertRe.test(w)) {
        result.v = w;
      }
    });
  }
  return result;
};
var normalizeOffset = function normalizeOffset(raw, preventRound) {
  return (0, _common.pairToObject)(raw, preventRound);
};
var normalizeCollision = function normalizeCollision(raw) {
  var pair = (0, _common.splitPair)(raw);
  var h = String(pair && pair[0]).toLowerCase();
  var v = String(pair && pair[1]).toLowerCase();
  if (!collisionRe.test(h)) {
    h = 'none';
  }
  if (!collisionRe.test(v)) {
    v = h;
  }
  return {
    h: h,
    v: v
  };
};
var getAlignFactor = function getAlignFactor(align) {
  switch (align) {
    case 'center':
      return 0.5;
    case 'right':
    case 'bottom':
      return 1;
    default:
      return 0;
  }
};
var inverseAlign = function inverseAlign(align) {
  switch (align) {
    case 'left':
      return 'right';
    case 'right':
      return 'left';
    case 'top':
      return 'bottom';
    case 'bottom':
      return 'top';
    default:
      return align;
  }
};
var calculateOversize = function calculateOversize(data, bounds) {
  var oversize = 0;
  if (data.myLocation < bounds.min) {
    oversize += bounds.min - data.myLocation;
  }
  if (data.myLocation > bounds.max) {
    oversize += data.myLocation - bounds.max;
  }
  return oversize;
};
var collisionSide = function collisionSide(direction, data, bounds) {
  if (data.myLocation < bounds.min) {
    return direction === 'h' ? 'left' : 'top';
  }
  if (data.myLocation > bounds.max) {
    return direction === 'h' ? 'right' : 'bottom';
  }
  return 'none';
};

// TODO: rename?
var initMyLocation = function initMyLocation(data) {
  data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset;
};
var collisionResolvers = {
  'fit': function fit(data, bounds) {
    var result = false;
    if (data.myLocation > bounds.max) {
      data.myLocation = bounds.max;
      result = true;
    }
    if (data.myLocation < bounds.min) {
      data.myLocation = bounds.min;
      result = true;
    }
    data.fit = result;
  },
  'flip': function flip(data, bounds) {
    data.flip = false;
    if (data.myAlign === 'center' && data.atAlign === 'center') {
      return;
    }
    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
      var inverseData = (0, _extend.extend)({}, data, {
        myAlign: inverseAlign(data.myAlign),
        atAlign: inverseAlign(data.atAlign),
        offset: -data.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);
      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
        data.myLocation = inverseData.myLocation;
        data.oversize = inverseData.oversize;
        data.flip = true;
      }
    }
  },
  'flipfit': function flipfit(data, bounds) {
    this.flip(data, bounds);
    this.fit(data, bounds);
  },
  'none': function none(data) {
    data.oversize = 0;
  }
};
var scrollbarWidth;
var calculateScrollbarWidth = function calculateScrollbarWidth() {
  var $scrollDiv = (0, _renderer.default)('<div>').css({
    width: 100,
    height: 100,
    overflow: 'scroll',
    position: 'absolute',
    top: -9999
  }).appendTo((0, _renderer.default)('body'));
  var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result;
};
var defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};
var calculatePosition = function calculatePosition(what, options) {
  var $what = (0, _renderer.default)(what);
  var currentOffset = $what.offset();
  var result = (0, _extend.extend)(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });
  if (!options) {
    return result;
  }
  var my = normalizeAlign(options.my);
  var at = normalizeAlign(options.at);
  var of = (0, _renderer.default)(options.of).length && options.of || window;
  var offset = normalizeOffset(options.offset, options.precise);
  var collision = normalizeCollision(options.collision);
  var boundary = options.boundary;
  var boundaryOffset = normalizeOffset(options.boundaryOffset, options.precise);
  var h = {
    mySize: (0, _size.getOuterWidth)($what),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  var v = {
    mySize: (0, _size.getOuterHeight)($what),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };
  if (of.preventDefault) {
    h.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h.atSize = 0;
    v.atSize = 0;
  } else {
    of = (0, _renderer.default)(of);
    if ((0, _type.isWindow)(of[0])) {
      h.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();
      if (_devices.default.real().deviceType === 'phone' && of[0].visualViewport) {
        h.atLocation = Math.max(h.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : (0, _size.getWidth)(of);
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : (0, _size.getHeight)(of);
      }
    } else if (of[0].nodeType === 9) {
      h.atLocation = 0;
      v.atLocation = 0;
      h.atSize = (0, _size.getWidth)(of);
      v.atSize = (0, _size.getHeight)(of);
    } else {
      var ofRect = (0, _position.getBoundingRect)(of.get(0));
      var o = getOffsetWithoutScale(of);
      h.atLocation = o.left;
      v.atLocation = o.top;
      h.atSize = Math.max(ofRect.width, (0, _size.getOuterWidth)(of));
      v.atSize = Math.max(ofRect.height, (0, _size.getOuterHeight)(of));
    }
  }
  initMyLocation(h);
  initMyLocation(v);
  var bounds = function () {
    var win = (0, _renderer.default)(window);
    var windowWidth = (0, _size.getWidth)(win);
    var windowHeight = (0, _size.getHeight)(win);
    var left = win.scrollLeft();
    var top = win.scrollTop();
    var documentElement = _dom_adapter.default.getDocumentElement();
    var hZoomLevel = _support.touch ? documentElement.clientWidth / windowWidth : 1;
    var vZoomLevel = _support.touch ? documentElement.clientHeight / windowHeight : 1;
    if (scrollbarWidth === undefined) {
      calculateScrollbarWidth();
    }
    var boundaryWidth = windowWidth;
    var boundaryHeight = windowHeight;
    if (boundary && !(0, _type.isWindow)(boundary)) {
      var $boundary = (0, _renderer.default)(boundary);
      var boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = (0, _size.getWidth)($boundary);
      boundaryHeight = (0, _size.getHeight)($boundary);
    }
    return {
      h: {
        min: left + h.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();
  h.oversize = calculateOversize(h, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h.collisionSide = collisionSide('h', h, bounds.h);
  v.collisionSide = collisionSide('v', v, bounds.v);
  if (collisionResolvers[h.collision]) {
    collisionResolvers[h.collision](h, bounds.h);
  }
  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }
  var preciser = function preciser(number) {
    return options.precise ? number : Math.round(number);
  };
  (0, _extend.extend)(true, result, {
    h: {
      location: preciser(h.myLocation),
      oversize: preciser(h.oversize),
      fit: h.fit,
      flip: h.flip,
      collisionSide: h.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options.precise
  });
  return result;
};
// NOTE: Setting the 'element.style' requires creating attributeNode when both of the conditions met:
//       - a form contains an input with the name property set to "style";
//       - a form contains a dx-validator (or other popup widget).
//       T941581
var setScaleProperty = function setScaleProperty(element, scale, styleAttr, isEmpty) {
  var stylePropIsValid = (0, _type.isDefined)(element.style) && !_dom_adapter.default.isNode(element.style);
  var newStyleValue = isEmpty ? styleAttr.replace(scale, '') : styleAttr;
  if (stylePropIsValid) {
    (0, _style.setStyle)(element, newStyleValue, false);
  } else {
    var styleAttributeNode = _dom_adapter.default.createAttribute('style');
    styleAttributeNode.value = newStyleValue;
    element.setAttributeNode(styleAttributeNode);
  }
};
var getOffsetWithoutScale = function getOffsetWithoutScale($startElement) {
  var _currentElement$getAt, _style$match;
  var $currentElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $startElement;
  var currentElement = $currentElement.get(0);
  if (!currentElement) {
    return $startElement.offset();
  }
  var style = ((_currentElement$getAt = currentElement.getAttribute) === null || _currentElement$getAt === void 0 ? void 0 : _currentElement$getAt.call(currentElement, 'style')) || '';
  var scale = (_style$match = style.match(scaleRe)) === null || _style$match === void 0 ? void 0 : _style$match[0];
  var offset;
  if (scale) {
    setScaleProperty(currentElement, scale, style, true);
    offset = getOffsetWithoutScale($startElement, $currentElement.parent());
    setScaleProperty(currentElement, scale, style, false);
  } else {
    offset = getOffsetWithoutScale($startElement, $currentElement.parent());
  }
  return offset;
};
var position = function position(what, options) {
  var $what = (0, _renderer.default)(what);
  if (!options) {
    return $what.offset();
  }
  (0, _translator.resetPosition)($what, true);
  var offset = getOffsetWithoutScale($what);
  var targetPosition = options.h && options.v ? options : calculatePosition($what, options);
  var preciser = function preciser(number) {
    return options.precise ? number : Math.round(number);
  };
  (0, _translator.move)($what, {
    left: targetPosition.h.location - preciser(offset.left),
    top: targetPosition.v.location - preciser(offset.top)
  });
  return targetPosition;
};
var offset = function offset(element) {
  element = (0, _renderer.default)(element).get(0);
  if ((0, _type.isWindow)(element)) {
    return null;
  } else if (element && 'pageY' in element && 'pageX' in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }
  return (0, _renderer.default)(element).offset();
};
if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}
if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}
var _default = {
  calculateScrollbarWidth: calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset: offset
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 42814:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.presets = exports.PresetCollection = void 0;
var _size = __webpack_require__(58664);
var _component = __webpack_require__(44297);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _fx = _interopRequireDefault(__webpack_require__(87209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var directionPostfixes = {
  forward: ' dx-forward',
  backward: ' dx-backward',
  none: ' dx-no-direction',
  undefined: ' dx-no-direction'
};
var optionPrefix = 'preset_';
var AnimationPresetCollection = _component.Component.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    this._registeredPresets = [];
    this.resetToDefaults();
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      defaultAnimationDuration: 400,
      defaultAnimationDelay: 0,
      defaultStaggerAnimationDuration: 300,
      defaultStaggerAnimationDelay: 40,
      defaultStaggerAnimationStartDelay: 500 // hack for better animations on ipad mini
    });
  },

  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat([{
      device: function device(_device) {
        return _device.phone;
      },
      options: {
        defaultStaggerAnimationDuration: 350,
        defaultStaggerAnimationDelay: 50,
        defaultStaggerAnimationStartDelay: 0
      }
    }, {
      // T254756
      device: function device() {
        return _devices.default.current().android || _devices.default.real.android;
      },
      options: {
        defaultAnimationDelay: 100
      }
    }]);
  },
  _getPresetOptionName: function _getPresetOptionName(animationName) {
    return optionPrefix + animationName;
  },
  // T257755
  _createAndroidSlideAnimationConfig: function _createAndroidSlideAnimationConfig(throughOpacity, widthMultiplier) {
    var that = this;
    var createBaseConfig = function createBaseConfig(configModifier) {
      return {
        type: 'slide',
        delay: configModifier.delay === undefined ? that.option('defaultAnimationDelay') : configModifier.delay,
        duration: configModifier.duration === undefined ? that.option('defaultAnimationDuration') : configModifier.duration
      };
    };
    return {
      enter: function enter($element, configModifier) {
        var width = (0, _size.getWidth)($element.parent()) * widthMultiplier;
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.to = {
          left: 0,
          opacity: 1
        };
        if (direction === 'forward') {
          config.from = {
            left: width,
            opacity: throughOpacity
          };
        } else if (direction === 'backward') {
          config.from = {
            left: -width,
            opacity: throughOpacity
          };
        } else {
          config.from = {
            left: 0,
            opacity: 0
          };
        }
        return _fx.default.createAnimation($element, config);
      },
      leave: function leave($element, configModifier) {
        var width = (0, _size.getWidth)($element.parent()) * widthMultiplier;
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.from = {
          left: 0,
          opacity: 1
        };
        if (direction === 'forward') {
          config.to = {
            left: -width,
            opacity: throughOpacity
          };
        } else if (direction === 'backward') {
          config.to = {
            left: width,
            opacity: throughOpacity
          };
        } else {
          config.to = {
            left: 0,
            opacity: 0
          };
        }
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  _createOpenDoorConfig: function _createOpenDoorConfig() {
    var that = this;
    var createBaseConfig = function createBaseConfig(configModifier) {
      return {
        type: 'css',
        extraCssClasses: 'dx-opendoor-animation',
        delay: configModifier.delay === undefined ? that.option('defaultAnimationDelay') : configModifier.delay,
        duration: configModifier.duration === undefined ? that.option('defaultAnimationDuration') : configModifier.duration
      };
    };
    return {
      enter: function enter($element, configModifier) {
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.delay = direction === 'none' ? config.delay : config.duration;
        config.from = 'dx-enter dx-opendoor-animation' + directionPostfixes[direction];
        config.to = 'dx-enter-active';
        return _fx.default.createAnimation($element, config);
      },
      leave: function leave($element, configModifier) {
        var direction = configModifier.direction;
        var config = createBaseConfig(configModifier);
        config.from = 'dx-leave dx-opendoor-animation' + directionPostfixes[direction];
        config.to = 'dx-leave-active';
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  _createWinPopConfig: function _createWinPopConfig() {
    var that = this;
    var baseConfig = {
      type: 'css',
      extraCssClasses: 'dx-win-pop-animation',
      duration: that.option('defaultAnimationDuration')
    };
    return {
      enter: function enter($element, configModifier) {
        var config = baseConfig;
        var direction = configModifier.direction;
        config.delay = direction === 'none' ? that.option('defaultAnimationDelay') : that.option('defaultAnimationDuration') / 2;
        config.from = 'dx-enter dx-win-pop-animation' + directionPostfixes[direction];
        config.to = 'dx-enter-active';
        return _fx.default.createAnimation($element, config);
      },
      leave: function leave($element, configModifier) {
        var config = baseConfig;
        var direction = configModifier.direction;
        config.delay = that.option('defaultAnimationDelay');
        config.from = 'dx-leave dx-win-pop-animation' + directionPostfixes[direction];
        config.to = 'dx-leave-active';
        return _fx.default.createAnimation($element, config);
      }
    };
  },
  resetToDefaults: function resetToDefaults() {
    this.clear();
    this.registerDefaultPresets();
    this.applyChanges();
  },
  clear: function clear(name) {
    var that = this;
    var newRegisteredPresets = [];
    (0, _iterator.each)(this._registeredPresets, function (index, preset) {
      if (!name || name === preset.name) {
        that.option(that._getPresetOptionName(preset.name), undefined);
      } else {
        newRegisteredPresets.push(preset);
      }
    });
    this._registeredPresets = newRegisteredPresets;
    this.applyChanges();
  },
  registerPreset: function registerPreset(name, config) {
    this._registeredPresets.push({
      name: name,
      config: config
    });
  },
  applyChanges: function applyChanges() {
    var that = this;
    var customRules = [];
    (0, _iterator.each)(this._registeredPresets, function (index, preset) {
      var rule = {
        device: preset.config.device,
        options: {}
      };
      rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
      customRules.push(rule);
    });
    this._setOptionsByDevice(customRules);
  },
  getPreset: function getPreset(name) {
    var result = name;
    while (typeof result === 'string') {
      result = this.option(this._getPresetOptionName(result));
    }
    return result;
  },
  registerDefaultPresets: function registerDefaultPresets() {
    this.registerPreset('pop', {
      animation: {
        extraCssClasses: 'dx-android-pop-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('openDoor', {
      animation: this._createOpenDoorConfig()
    });
    this.registerPreset('win-pop', {
      animation: this._createWinPopConfig()
    });
    this.registerPreset('fade', {
      animation: {
        extraCssClasses: 'dx-fade-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('slide', {
      device: function device() {
        return _devices.default.current().android || _devices.default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(1, 1)
    });
    this.registerPreset('slide', {
      device: function device() {
        return !_devices.default.current().android && !_devices.default.real.android;
      },
      animation: {
        extraCssClasses: 'dx-slide-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-slide', {
      animation: {
        extraCssClasses: 'dx-ios7-slide-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('overflow', {
      animation: {
        extraCssClasses: 'dx-overflow-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-toolbar', {
      device: function device() {
        return !_devices.default.current().android && !_devices.default.real.android;
      },
      animation: {
        extraCssClasses: 'dx-ios7-toolbar-animation',
        delay: this.option('defaultAnimationDelay'),
        duration: this.option('defaultAnimationDuration')
      }
    });
    this.registerPreset('ios7-toolbar', {
      device: function device() {
        return _devices.default.current().android || _devices.default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(0, 0.4)
    });
    this.registerPreset('stagger-fade', {
      animation: {
        extraCssClasses: 'dx-fade-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-slide', {
      animation: {
        extraCssClasses: 'dx-slide-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-slide', {
      animation: {
        extraCssClasses: 'dx-fade-slide-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-drop', {
      animation: {
        extraCssClasses: 'dx-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-drop', {
      animation: {
        extraCssClasses: 'dx-fade-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-rise', {
      animation: {
        extraCssClasses: 'dx-fade-rise-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-3d-drop', {
      animation: {
        extraCssClasses: 'dx-3d-drop-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
    this.registerPreset('stagger-fade-zoom', {
      animation: {
        extraCssClasses: 'dx-fade-zoom-animation',
        staggerDelay: this.option('defaultStaggerAnimationDelay'),
        duration: this.option('defaultStaggerAnimationDuration'),
        delay: this.option('defaultStaggerAnimationStartDelay')
      }
    });
  }
});
exports.PresetCollection = AnimationPresetCollection;
var animationPresets = new AnimationPresetCollection();
exports.presets = animationPresets;

/***/ }),

/***/ 52431:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.TransitionExecutor = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend = __webpack_require__(13306);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _fx = _interopRequireDefault(__webpack_require__(87209));
var _presets = __webpack_require__(42814);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var directionPostfixes = {
  forward: ' dx-forward',
  backward: ' dx-backward',
  none: ' dx-no-direction',
  undefined: ' dx-no-direction'
};
var DX_ANIMATING_CLASS = 'dx-animating';
var TransitionExecutor = _class.default.inherit({
  ctor: function ctor() {
    this._accumulatedDelays = {
      enter: 0,
      leave: 0
    };
    this._animations = [];
    this.reset();
  },
  _createAnimations: function _createAnimations($elements, initialConfig, configModifier, type) {
    $elements = (0, _renderer.default)($elements);
    var that = this;
    var result = [];
    configModifier = configModifier || {};
    var animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);
    if (animationConfig) {
      $elements.each(function () {
        var animation = that._createAnimation((0, _renderer.default)(this), animationConfig, configModifier);
        if (animation) {
          animation.element.addClass(DX_ANIMATING_CLASS);
          animation.setup();
          result.push(animation);
        }
      });
    }
    return result;
  },
  _prepareElementAnimationConfig: function _prepareElementAnimationConfig(config, configModifier, type) {
    var result;
    if (typeof config === 'string') {
      var presetName = config;
      config = _presets.presets.getPreset(presetName);
    }
    if (!config) {
      result = undefined;
    } else if ((0, _type.isFunction)(config[type])) {
      result = config[type];
    } else {
      result = (0, _extend.extend)({
        skipElementInitialStyles: true,
        cleanupWhen: this._completePromise
      }, config, configModifier);
      if (!result.type || result.type === 'css') {
        var cssClass = 'dx-' + type;
        var extraCssClasses = (result.extraCssClasses ? ' ' + result.extraCssClasses : '') + directionPostfixes[result.direction];
        result.type = 'css';
        result.from = (result.from || cssClass) + extraCssClasses;
        result.to = result.to || cssClass + '-active';
      }
      result.staggerDelay = result.staggerDelay || 0;
      result.delay = result.delay || 0;
      if (result.staggerDelay) {
        result.delay += this._accumulatedDelays[type];
        this._accumulatedDelays[type] += result.staggerDelay;
      }
    }
    return result;
  },
  _createAnimation: function _createAnimation($element, animationConfig, configModifier) {
    var result;
    if ((0, _type.isPlainObject)(animationConfig)) {
      result = _fx.default.createAnimation($element, animationConfig);
    } else if ((0, _type.isFunction)(animationConfig)) {
      result = animationConfig($element, configModifier);
    }
    return result;
  },
  _startAnimations: function _startAnimations() {
    var animations = this._animations;
    for (var i = 0; i < animations.length; i++) {
      animations[i].start();
    }
  },
  _stopAnimations: function _stopAnimations(jumpToEnd) {
    var animations = this._animations;
    for (var i = 0; i < animations.length; i++) {
      animations[i].stop(jumpToEnd);
    }
  },
  _clearAnimations: function _clearAnimations() {
    var animations = this._animations;
    for (var i = 0; i < animations.length; i++) {
      animations[i].element.removeClass(DX_ANIMATING_CLASS);
    }
    this._animations.length = 0;
  },
  reset: function reset() {
    this._accumulatedDelays.enter = 0;
    this._accumulatedDelays.leave = 0;
    this._clearAnimations();
    this._completeDeferred = new _deferred.Deferred();
    this._completePromise = this._completeDeferred.promise();
  },
  enter: function enter($elements, animationConfig, configModifier) {
    var animations = this._createAnimations($elements, animationConfig, configModifier, 'enter');
    this._animations.push.apply(this._animations, animations);
  },
  leave: function leave($elements, animationConfig, configModifier) {
    var animations = this._createAnimations($elements, animationConfig, configModifier, 'leave');
    this._animations.push.apply(this._animations, animations);
  },
  start: function start() {
    var that = this;
    var result;
    if (!this._animations.length) {
      that.reset();
      result = new _deferred.Deferred().resolve().promise();
    } else {
      var animationDeferreds = (0, _iterator.map)(this._animations, function (animation) {
        var result = new _deferred.Deferred();
        animation.deferred.always(function () {
          result.resolve();
        });
        return result.promise();
      });
      result = _deferred.when.apply(_renderer.default, animationDeferreds).always(function () {
        that._completeDeferred.resolve();
        that.reset();
      });
      (0, _common.executeAsync)(function () {
        that._startAnimations();
      });
    }
    return result;
  },
  stop: function stop(jumpToEnd) {
    this._stopAnimations(jumpToEnd);
  }
});
exports.TransitionExecutor = TransitionExecutor;

/***/ }),

/***/ 31648:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.resetPosition = exports.parseTranslate = exports.move = exports.locate = exports.getTranslateCss = exports.getTranslate = exports.clearCache = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _element_data = __webpack_require__(97906);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var TRANSLATOR_DATA_KEY = 'dxTranslator';
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function locate($element) {
  $element = (0, _renderer.default)($element);
  var translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};
exports.locate = locate;
function isPercentValue(value) {
  return (0, _type.type)(value) === 'string' && value[value.length - 1] === '%';
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY, translate);
  }
}
var clearCache = function clearCache($element) {
  if ($element.length) {
    (0, _element_data.removeData)($element.get(0), TRANSLATOR_DATA_KEY);
  }
};
exports.clearCache = clearCache;
var getTranslateCss = function getTranslateCss(translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + 'px';
  var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + 'px';
  return 'translate(' + xValueString + ', ' + yValueString + ')';
};
exports.getTranslateCss = getTranslateCss;
var getTranslate = function getTranslate($element) {
  var result = $element.length ? (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY) : null;
  if (!result) {
    var transformValue = $element.css('transform') || getTranslateCss({
      x: 0,
      y: 0
    });
    var matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    var is3D = matrix && matrix[1];
    if (matrix) {
      matrix = matrix[2].split(',');
      if (is3D === '3d') {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }
    result = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result);
  }
  return result;
};
exports.getTranslate = getTranslate;
var move = function move($element, position) {
  $element = (0, _renderer.default)($element);
  var left = position.left;
  var top = position.top;
  var translate;
  if (left === undefined) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (top === undefined) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }
  $element.css({
    transform: getTranslateCss(translate)
  });
  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};
exports.move = move;
var resetPosition = function resetPosition($element, finishTransition) {
  $element = (0, _renderer.default)($element);
  var originalTransition;
  var stylesConfig = {
    left: 0,
    top: 0,
    transform: 'none'
  };
  if (finishTransition) {
    originalTransition = $element.css('transition');
    stylesConfig.transition = 'none';
  }
  $element.css(stylesConfig);
  clearCache($element);
  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css('transition', originalTransition);
  }
};
exports.resetPosition = resetPosition;
var parseTranslate = function parseTranslate(translateString) {
  var result = translateString.match(TRANSLATE_REGEX);
  if (!result || !result[1]) {
    return;
  }
  result = result[1].split(',');
  result = {
    x: parseFloat(result[0]),
    y: parseFloat(result[1]),
    z: parseFloat(result[2])
  };
  return result;
};
exports.parseTranslate = parseTranslate;

/***/ }),

/***/ 72505:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(36991);
DevExpress.common = DevExpress.common || {};
DevExpress.common.charts = __webpack_require__(29932);
module.exports = DevExpress.common.charts;

/***/ }),

/***/ 36991:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
var windowUtils = __webpack_require__(58201);
var window = windowUtils.getWindow();
var DevExpress = window.DevExpress = window.DevExpress || {};
var errors = DevExpress.errors = __webpack_require__(17381);
if (DevExpress._DEVEXTREME_BUNDLE_INITIALIZED) {
  throw errors.Error('E0024');
}
DevExpress._DEVEXTREME_BUNDLE_INITIALIZED = true;
DevExpress.clientExporter = __webpack_require__(78292);
DevExpress.excelExporter = __webpack_require__(2994);
DevExpress.pdfExporter = __webpack_require__(44194);
DevExpress.VERSION = (__webpack_require__(36739).version);
DevExpress.Class = __webpack_require__(38377);
DevExpress.DOMComponent = __webpack_require__(13046);
DevExpress.Component = (__webpack_require__(44297).Component);
DevExpress.registerComponent = __webpack_require__(99393);
DevExpress.devices = __webpack_require__(20530);
DevExpress.Color = __webpack_require__(52752);
var animationFrame = __webpack_require__(90057);

/**
 * @name utils
 * @namespace DevExpress
 */
DevExpress.utils = {};
DevExpress.utils.requestAnimationFrame = animationFrame.requestAnimationFrame;
DevExpress.utils.cancelAnimationFrame = animationFrame.cancelAnimationFrame;
DevExpress.utils.initMobileViewport = (__webpack_require__(88185)/* .initMobileViewport */ .p);
DevExpress.utils.getTimeZones = (__webpack_require__(88673)/* .getTimeZones */ .Z);

// TODO: MODULARITY: Remove this
DevExpress.utils.extendFromObject = (__webpack_require__(13306).extendFromObject);
DevExpress.utils.triggerShownEvent = (__webpack_require__(80506).triggerShownEvent);
DevExpress.utils.triggerHidingEvent = (__webpack_require__(80506).triggerHidingEvent);
DevExpress.utils.resetActiveElement = (__webpack_require__(3532).resetActiveElement);
DevExpress.utils.findBestMatches = (__webpack_require__(20576).findBestMatches);
DevExpress.createQueue = (__webpack_require__(59504).create);
DevExpress.utils.dom = __webpack_require__(3532);
DevExpress.utils.common = __webpack_require__(20576);
DevExpress.utils.date = __webpack_require__(91198);
DevExpress.utils.browser = __webpack_require__(47810);
DevExpress.utils.inflector = __webpack_require__(78008);
DevExpress.utils.iterator = __webpack_require__(95479);
DevExpress.utils.readyCallbacks = __webpack_require__(24311);
DevExpress.utils.resizeCallbacks = __webpack_require__(55814);
DevExpress.utils.console = __webpack_require__(30869);
DevExpress.utils.string = __webpack_require__(68752);
DevExpress.utils.support = __webpack_require__(60137);
DevExpress.utils.ajax = __webpack_require__(37208);
DevExpress.viewPort = (__webpack_require__(77695).value);
DevExpress.hideTopOverlay = __webpack_require__(60628);
DevExpress.formatHelper = __webpack_require__(30343);
DevExpress.config = __webpack_require__(80209);
DevExpress.animationPresets = (__webpack_require__(42814).presets);
DevExpress.fx = __webpack_require__(87209);
DevExpress.TransitionExecutor = (__webpack_require__(52431).TransitionExecutor);
DevExpress.AnimationPresetCollection = (__webpack_require__(42814).PresetCollection);
DevExpress.events = __webpack_require__(66365);
DevExpress.events.click = __webpack_require__(95429);
DevExpress.events.utils = __webpack_require__(39611);
DevExpress.events.GestureEmitter = __webpack_require__(98621);
DevExpress.localization = __webpack_require__(94484);
DevExpress.templateRendered = (__webpack_require__(81033).renderedCallbacks);
DevExpress.setTemplateEngine = (__webpack_require__(72987).setTemplateEngine);
module.exports = DevExpress;

/***/ }),

/***/ 86635:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(36991);
var errors = __webpack_require__(17381);
module.exports = DevExpress.data = DevExpress.data || {};
Object.defineProperty(DevExpress.data, 'errorHandler', {
  get: function get() {
    return (__webpack_require__(18438).errorHandler);
  },
  set: function set(value) {
    errors.log('W0003', 'DevExpress.data', 'errorHandler', '21.1', 'Use the \'setErrorHandler\' method instead');
    (__webpack_require__(18438).setErrorHandler)(value);
  }
});

// TODO: try remove (plugins failed without this)
Object.defineProperty(DevExpress.data, '_errorHandler', {
  get: function get() {
    return (__webpack_require__(18438).handleError);
  },
  set: function set(value) {
    errors.log('W0003', 'DevExpress.data', '_errorHandler', '21.1', 'Use the \'setErrorHandler\' method instead');
    (__webpack_require__(18438).setErrorHandler)(value);
  }
});
DevExpress.data.setErrorHandler = (__webpack_require__(18438).setErrorHandler);
DevExpress.data.DataSource = __webpack_require__(33546);
DevExpress.data.query = __webpack_require__(96687);
DevExpress.data.Store = __webpack_require__(67403);
DevExpress.data.ArrayStore = __webpack_require__(26562);
DevExpress.data.CustomStore = __webpack_require__(88036);
DevExpress.data.LocalStore = __webpack_require__(82837);
DevExpress.data.base64_encode = (__webpack_require__(16454).base64_encode);
DevExpress.data.applyChanges = __webpack_require__(36893);
DevExpress.data.Guid = __webpack_require__(73176);
DevExpress.data.utils = {};
DevExpress.data.utils.compileGetter = (__webpack_require__(47617).compileGetter);
DevExpress.data.utils.compileSetter = (__webpack_require__(47617).compileSetter);
DevExpress.EndpointSelector = __webpack_require__(8162);
DevExpress.data.queryImpl = (__webpack_require__(77549).queryImpl);
DevExpress.data.queryAdapters = __webpack_require__(16135);
var dataUtils = __webpack_require__(16454);
DevExpress.data.utils.normalizeBinaryCriterion = dataUtils.normalizeBinaryCriterion;
DevExpress.data.utils.normalizeSortingInfo = dataUtils.normalizeSortingInfo;
DevExpress.data.utils.errorMessageFromXhr = dataUtils.errorMessageFromXhr;
DevExpress.data.utils.aggregators = dataUtils.aggregators;
DevExpress.data.utils.keysEqual = dataUtils.keysEqual;
DevExpress.data.utils.isDisjunctiveOperator = dataUtils.isDisjunctiveOperator;
DevExpress.data.utils.isConjunctiveOperator = dataUtils.isConjunctiveOperator;
DevExpress.data.utils.processRequestResultLock = dataUtils.processRequestResultLock;
DevExpress.data.utils.toComparable = (__webpack_require__(47617).toComparable);
DevExpress.data.utils.multiLevelGroup = (__webpack_require__(99236).multiLevelGroup);
DevExpress.data.utils.arrangeSortingInfo = (__webpack_require__(99236).arrangeSortingInfo);
DevExpress.data.utils.normalizeDataSourceOptions = (__webpack_require__(9234).normalizeDataSourceOptions);

/***/ }),

/***/ 72343:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



/* global DevExpress */
/* eslint-disable import/no-commonjs */
__webpack_require__(86635);
DevExpress.data.ODataStore = __webpack_require__(341);
DevExpress.data.ODataContext = __webpack_require__(47256);
DevExpress.data.utils = DevExpress.data.utils || {};
DevExpress.data.utils.odata = {};
DevExpress.data.utils.odata.keyConverters = (__webpack_require__(77869).keyConverters);
DevExpress.data.EdmLiteral = (__webpack_require__(77869).EdmLiteral);
var ODataUtilsModule = __webpack_require__(77869);
DevExpress.data.utils.odata.serializePropName = ODataUtilsModule.serializePropName;
DevExpress.data.utils.odata.serializeValue = ODataUtilsModule.serializeValue;
DevExpress.data.utils.odata.serializeKey = ODataUtilsModule.serializeKey;
DevExpress.data.utils.odata.sendRequest = ODataUtilsModule.sendRequest;
DevExpress.data.queryAdapters = DevExpress.data.queryAdapters || {};
DevExpress.data.queryAdapters.odata = (__webpack_require__(54263).odata);

/***/ }),

/***/ 85357:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/// BUNDLER_PARTS

/* Core (dx.module-core.js) */
/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(36991);

/* Integrations (dx.module-core.js) */

__webpack_require__(78475);
__webpack_require__(71582);
__webpack_require__(49281);
__webpack_require__(74872);
__webpack_require__(46949);
__webpack_require__(908);
__webpack_require__(60316);
__webpack_require__(7239);

/* Events (dx.module-core.js) */

__webpack_require__(95429);
__webpack_require__(49166);
__webpack_require__(85272);
__webpack_require__(23174);
__webpack_require__(11699);
__webpack_require__(24028);
__webpack_require__(93786);
__webpack_require__(34309);
__webpack_require__(91093);
/// BUNDLER_PARTS_END

module.exports = DevExpress;

/***/ }),

/***/ 94620:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(85357);

/// BUNDLER_PARTS
/* Data (dx.module-core.js) */

var data = DevExpress.data = __webpack_require__(86635);
data.odata = __webpack_require__(72343);
/// BUNDLER_PARTS_END

module.exports = data;

/***/ }),

/***/ 66312:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



/* eslint-disable import/no-commonjs */
var DevExpress = __webpack_require__(85357);
__webpack_require__(94620);
__webpack_require__(72505);

/// BUNDLER_PARTS
/* Viz core (dx.module-viz-core.js) */

var viz = DevExpress.viz = __webpack_require__(20802);
viz.currentTheme = (__webpack_require__(86231).currentTheme);
viz.registerTheme = (__webpack_require__(86231).registerTheme);
viz.exportFromMarkup = (__webpack_require__(5259).exportFromMarkup);
viz.getMarkup = (__webpack_require__(5259).getMarkup);
viz.exportWidgets = (__webpack_require__(5259).exportWidgets);
viz.currentPalette = (__webpack_require__(23696).currentPalette);
viz.getPalette = (__webpack_require__(23696).getPalette);
viz.generateColors = (__webpack_require__(23696).generateColors);
viz.registerPalette = (__webpack_require__(23696).registerPalette);
viz.refreshTheme = (__webpack_require__(86231).refreshTheme);

/* Charts (dx.module-viz-charts.js) */
viz.dxChart = __webpack_require__(99511);
viz.dxPieChart = __webpack_require__(72111);
viz.dxPolarChart = __webpack_require__(80919);

/* Gauges (dx.module-viz-gauges.js) */
viz.dxLinearGauge = __webpack_require__(99630);
viz.dxCircularGauge = __webpack_require__(39847);
viz.dxBarGauge = __webpack_require__(45888);

/* Range selector (dx.module-viz-rangeselector.js) */
viz.dxRangeSelector = __webpack_require__(82879);

/* Vector map (dx.module-viz-vectormap.js) */
viz.dxVectorMap = __webpack_require__(81849);
viz.map = {};
viz.map.sources = {};
viz.map.projection = (__webpack_require__(102).projection);

/* Sparklines (dx.module-viz-sparklines.js) */
viz.dxSparkline = __webpack_require__(43759);
viz.dxBullet = __webpack_require__(88950);

/* Treemap */
viz.dxTreeMap = __webpack_require__(15584);

/* Funnel */
viz.dxFunnel = __webpack_require__(30187);

/* Sankey */
viz.dxSankey = __webpack_require__(34377);

/// BUNDLER_PARTS_END

viz.getTheme = (__webpack_require__(86231).getTheme);
// Keep it for backward compatibility after renaming findTheme to getTheme
viz.findTheme = (__webpack_require__(86231).getTheme);
// We need to keep this method as we suggested it to users
viz.refreshAll = (__webpack_require__(86231).refreshTheme);
viz.refreshPaths = (__webpack_require__(34434).refreshPaths);
viz.gauges = {
  __internals: {}
};
viz._dashboard = {};
viz._dashboard.Renderer = (__webpack_require__(56453).Renderer);
viz._dashboard.SvgElement = (__webpack_require__(56453).SvgElement);
viz._dashboard.patchFontOptions = (__webpack_require__(19157).patchFontOptions);
module.exports = viz;

/***/ }),

/***/ 20802:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(36991);
/* global DevExpress */
/* eslint-disable import/no-commonjs */

module.exports = DevExpress.viz = DevExpress.viz || {};

/***/ }),

/***/ 52752:
/***/ (function(module, exports) {



exports["default"] = void 0;
var standardColorNames = {
  'aliceblue': 'f0f8ff',
  'antiquewhite': 'faebd7',
  'aqua': '00ffff',
  'aquamarine': '7fffd4',
  'azure': 'f0ffff',
  'beige': 'f5f5dc',
  'bisque': 'ffe4c4',
  'black': '000000',
  'blanchedalmond': 'ffebcd',
  'blue': '0000ff',
  'blueviolet': '8a2be2',
  'brown': 'a52a2a',
  'burlywood': 'deb887',
  'cadetblue': '5f9ea0',
  'chartreuse': '7fff00',
  'chocolate': 'd2691e',
  'coral': 'ff7f50',
  'cornflowerblue': '6495ed',
  'cornsilk': 'fff8dc',
  'crimson': 'dc143c',
  'cyan': '00ffff',
  'darkblue': '00008b',
  'darkcyan': '008b8b',
  'darkgoldenrod': 'b8860b',
  'darkgray': 'a9a9a9',
  'darkgreen': '006400',
  'darkgrey': 'a9a9a9',
  'darkkhaki': 'bdb76b',
  'darkmagenta': '8b008b',
  'darkolivegreen': '556b2f',
  'darkorange': 'ff8c00',
  'darkorchid': '9932cc',
  'darkred': '8b0000',
  'darksalmon': 'e9967a',
  'darkseagreen': '8fbc8f',
  'darkslateblue': '483d8b',
  'darkslategray': '2f4f4f',
  'darkslategrey': '2f4f4f',
  'darkturquoise': '00ced1',
  'darkviolet': '9400d3',
  'deeppink': 'ff1493',
  'deepskyblue': '00bfff',
  'dimgray': '696969',
  'dimgrey': '696969',
  'dodgerblue': '1e90ff',
  'feldspar': 'd19275',
  'firebrick': 'b22222',
  'floralwhite': 'fffaf0',
  'forestgreen': '228b22',
  'fuchsia': 'ff00ff',
  'gainsboro': 'dcdcdc',
  'ghostwhite': 'f8f8ff',
  'gold': 'ffd700',
  'goldenrod': 'daa520',
  'gray': '808080',
  'green': '008000',
  'greenyellow': 'adff2f',
  'grey': '808080',
  'honeydew': 'f0fff0',
  'hotpink': 'ff69b4',
  'indianred': 'cd5c5c',
  'indigo': '4b0082',
  'ivory': 'fffff0',
  'khaki': 'f0e68c',
  'lavender': 'e6e6fa',
  'lavenderblush': 'fff0f5',
  'lawngreen': '7cfc00',
  'lemonchiffon': 'fffacd',
  'lightblue': 'add8e6',
  'lightcoral': 'f08080',
  'lightcyan': 'e0ffff',
  'lightgoldenrodyellow': 'fafad2',
  'lightgray': 'd3d3d3',
  'lightgreen': '90ee90',
  'lightgrey': 'd3d3d3',
  'lightpink': 'ffb6c1',
  'lightsalmon': 'ffa07a',
  'lightseagreen': '20b2aa',
  'lightskyblue': '87cefa',
  'lightslateblue': '8470ff',
  'lightslategray': '778899',
  'lightslategrey': '778899',
  'lightsteelblue': 'b0c4de',
  'lightyellow': 'ffffe0',
  'lime': '00ff00',
  'limegreen': '32cd32',
  'linen': 'faf0e6',
  'magenta': 'ff00ff',
  'maroon': '800000',
  'mediumaquamarine': '66cdaa',
  'mediumblue': '0000cd',
  'mediumorchid': 'ba55d3',
  'mediumpurple': '9370d8',
  'mediumseagreen': '3cb371',
  'mediumslateblue': '7b68ee',
  'mediumspringgreen': '00fa9a',
  'mediumturquoise': '48d1cc',
  'mediumvioletred': 'c71585',
  'midnightblue': '191970',
  'mintcream': 'f5fffa',
  'mistyrose': 'ffe4e1',
  'moccasin': 'ffe4b5',
  'navajowhite': 'ffdead',
  'navy': '000080',
  'oldlace': 'fdf5e6',
  'olive': '808000',
  'olivedrab': '6b8e23',
  'orange': 'ffa500',
  'orangered': 'ff4500',
  'orchid': 'da70d6',
  'palegoldenrod': 'eee8aa',
  'palegreen': '98fb98',
  'paleturquoise': 'afeeee',
  'palevioletred': 'd87093',
  'papayawhip': 'ffefd5',
  'peachpuff': 'ffdab9',
  'peru': 'cd853f',
  'pink': 'ffc0cb',
  'plum': 'dda0dd',
  'powderblue': 'b0e0e6',
  'purple': '800080',
  'rebeccapurple': '663399',
  'red': 'ff0000',
  'rosybrown': 'bc8f8f',
  'royalblue': '4169e1',
  'saddlebrown': '8b4513',
  'salmon': 'fa8072',
  'sandybrown': 'f4a460',
  'seagreen': '2e8b57',
  'seashell': 'fff5ee',
  'sienna': 'a0522d',
  'silver': 'c0c0c0',
  'skyblue': '87ceeb',
  'slateblue': '6a5acd',
  'slategray': '708090',
  'slategrey': '708090',
  'snow': 'fffafa',
  'springgreen': '00ff7f',
  'steelblue': '4682b4',
  'tan': 'd2b48c',
  'teal': '008080',
  'thistle': 'd8bfd8',
  'tomato': 'ff6347',
  'turquoise': '40e0d0',
  'violet': 'ee82ee',
  'violetred': 'd02090',
  'wheat': 'f5deb3',
  'white': 'ffffff',
  'whitesmoke': 'f5f5f5',
  'yellow': 'ffff00',
  'yellowgreen': '9acd32'
};

// array of color definition objects
var standardColorTypes = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function process(colorString) {
    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10)];
  }
}, {
  re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*\.*\d+)\)$/,
  process: function process(colorString) {
    return [parseInt(colorString[1], 10), parseInt(colorString[2], 10), parseInt(colorString[3], 10), parseFloat(colorString[4])];
  }
}, {
  re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
  process: function process(colorString) {
    return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16)];
  }
}, {
  re: /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/,
  process: function process(colorString) {
    return [parseInt(colorString[1], 16), parseInt(colorString[2], 16), parseInt(colorString[3], 16), Number((parseInt(colorString[4], 16) / 255).toFixed(2))];
  }
}, {
  re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
  process: function process(colorString) {
    return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16), Number((parseInt(colorString[4] + colorString[4], 16) / 255).toFixed(2))];
  }
}, {
  re: /^#([a-f0-9]{1})([a-f0-9]{1})([a-f0-9]{1})$/,
  process: function process(colorString) {
    return [parseInt(colorString[1] + colorString[1], 16), parseInt(colorString[2] + colorString[2], 16), parseInt(colorString[3] + colorString[3], 16)];
  }
}, {
  re: /^hsv\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function process(colorString) {
    var h = parseInt(colorString[1], 10);
    var s = parseInt(colorString[2], 10);
    var v = parseInt(colorString[3], 10);
    var rgb = hsvToRgb(h, s, v);
    return [rgb[0], rgb[1], rgb[2], 1, [h, s, v]];
  }
}, {
  re: /^hsl\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function process(colorString) {
    var h = parseInt(colorString[1], 10);
    var s = parseInt(colorString[2], 10);
    var l = parseInt(colorString[3], 10);
    var rgb = hslToRgb(h, s, l);
    return [rgb[0], rgb[1], rgb[2], 1, null, [h, s, l]];
  }
}];
var _round = Math.round;
function Color(value) {
  this.baseColor = value;
  var color;
  if (value) {
    color = String(value).toLowerCase().replace(/ /g, '');
    color = standardColorNames[color] ? '#' + standardColorNames[color] : color;
    color = parseColor(color);
  }
  if (!color) {
    this.colorIsInvalid = true;
  }
  color = color || {};
  this.r = normalize(color[0]);
  this.g = normalize(color[1]);
  this.b = normalize(color[2]);
  this.a = normalize(color[3], 1, 1);
  if (color[4]) {
    this.hsv = {
      h: color[4][0],
      s: color[4][1],
      v: color[4][2]
    };
  } else {
    this.hsv = toHsvFromRgb(this.r, this.g, this.b);
  }
  if (color[5]) {
    this.hsl = {
      h: color[5][0],
      s: color[5][1],
      l: color[5][2]
    };
  } else {
    this.hsl = toHslFromRgb(this.r, this.g, this.b);
  }
}
function parseColor(color) {
  if (color === 'transparent') {
    return [0, 0, 0, 0];
  }
  var i = 0;
  var ii = standardColorTypes.length;
  var str;
  for (; i < ii; ++i) {
    str = standardColorTypes[i].re.exec(color);
    if (str) {
      return standardColorTypes[i].process(str);
    }
  }
  return null;
}
function normalize(colorComponent, def, max) {
  def = def || 0;
  max = max || 255;
  return colorComponent < 0 || isNaN(colorComponent) ? def : colorComponent > max ? max : colorComponent;
}
function toHexFromRgb(r, g, b) {
  return '#' + (0X01000000 | r << 16 | g << 8 | b).toString(16).slice(1);
}
function toHsvFromRgb(r, g, b) {
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var delta = max - min;
  var H;
  var S;
  var V = max;
  S = max === 0 ? 0 : 1 - min / max;
  if (max === min) {
    H = 0;
  } else {
    switch (max) {
      case r:
        H = 60 * ((g - b) / delta);
        if (g < b) {
          H = H + 360;
        }
        break;
      case g:
        H = 60 * ((b - r) / delta) + 120;
        break;
      case b:
        H = 60 * ((r - g) / delta) + 240;
        break;
    }
  }
  S *= 100;
  V *= 100 / 255;
  return {
    h: Math.round(H),
    s: Math.round(S),
    v: Math.round(V)
  };
}
function hsvToRgb(h, s, v) {
  var index = Math.floor(h % 360 / 60);
  var vMin = (100 - s) * v / 100;
  var a = (v - vMin) * (h % 60 / 60);
  var vInc = vMin + a;
  var vDec = v - a;
  var r;
  var g;
  var b;
  switch (index) {
    /* eslint-disable no-multi-spaces */
    case 0:
      r = v;
      g = vInc;
      b = vMin;
      break;
    case 1:
      r = vDec;
      g = v;
      b = vMin;
      break;
    case 2:
      r = vMin;
      g = v;
      b = vInc;
      break;
    case 3:
      r = vMin;
      g = vDec;
      b = v;
      break;
    case 4:
      r = vInc;
      g = vMin;
      b = v;
      break;
    case 5:
      r = v;
      g = vMin;
      b = vDec;
      break;
    /* eslint-enable no-multi-spaces */
  }

  return [Math.round(r * 2.55), Math.round(g * 2.55), Math.round(b * 2.55)];
}
function calculateHue(r, g, b, delta) {
  var max = Math.max(r, g, b);
  switch (max) {
    case r:
      return (g - b) / delta + (g < b ? 6 : 0);
    case g:
      return (b - r) / delta + 2;
    case b:
      return (r - g) / delta + 4;
  }
}
function toHslFromRgb(r, g, b) {
  r = convertTo01Bounds(r, 255);
  g = convertTo01Bounds(g, 255);
  b = convertTo01Bounds(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var maxMinSum = max + min;
  var h;
  var s;
  var l = maxMinSum / 2;
  if (max === min) {
    h = s = 0;
  } else {
    var delta = max - min;
    if (l > 0.5) {
      s = delta / (2 - maxMinSum);
    } else {
      s = delta / maxMinSum;
    }
    h = calculateHue(r, g, b, delta);
    h /= 6;
  }
  return {
    h: _round(h * 360),
    s: _round(s * 100),
    l: _round(l * 100)
  };
}
function makeColorTint(colorPart, h) {
  var colorTint = h;
  if (colorPart === 'r') {
    colorTint = h + 1 / 3;
  }
  if (colorPart === 'b') {
    colorTint = h - 1 / 3;
  }
  return colorTint;
}
function modifyColorTint(colorTint) {
  if (colorTint < 0) {
    colorTint += 1;
  }
  if (colorTint > 1) {
    colorTint -= 1;
  }
  return colorTint;
}
function hueToRgb(p, q, colorTint) {
  colorTint = modifyColorTint(colorTint);
  if (colorTint < 1 / 6) {
    return p + (q - p) * 6 * colorTint;
  }
  if (colorTint < 1 / 2) {
    return q;
  }
  if (colorTint < 2 / 3) {
    return p + (q - p) * (2 / 3 - colorTint) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  var r;
  var g;
  var b;
  h = convertTo01Bounds(h, 360);
  s = convertTo01Bounds(s, 100);
  l = convertTo01Bounds(l, 100);
  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hueToRgb(p, q, makeColorTint('r', h));
    g = hueToRgb(p, q, makeColorTint('g', h));
    b = hueToRgb(p, q, makeColorTint('b', h));
  }
  return [_round(r * 255), _round(g * 255), _round(b * 255)];
}
function convertTo01Bounds(n, max) {
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (Math.abs(n - max) < 0.000001) {
    return 1;
  }
  return n % max / parseFloat(max);
}
function isIntegerBetweenMinAndMax(number, min, max) {
  min = min || 0;
  max = max || 255;
  if (number % 1 !== 0 || number < min || number > max || typeof number !== 'number' || isNaN(number)) {
    return false;
  }
  return true;
}
Color.prototype = {
  constructor: Color,
  highlight: function highlight(step) {
    step = step || 10;
    return this.alter(step).toHex();
  },
  darken: function darken(step) {
    step = step || 10;
    return this.alter(-step).toHex();
  },
  alter: function alter(step) {
    var result = new Color();
    result.r = normalize(this.r + step);
    result.g = normalize(this.g + step);
    result.b = normalize(this.b + step);
    return result;
  },
  blend: function blend(blendColor, opacity) {
    var other = blendColor instanceof Color ? blendColor : new Color(blendColor);
    var result = new Color();
    result.r = normalize(_round(this.r * (1 - opacity) + other.r * opacity));
    result.g = normalize(_round(this.g * (1 - opacity) + other.g * opacity));
    result.b = normalize(_round(this.b * (1 - opacity) + other.b * opacity));
    return result;
  },
  toHex: function toHex() {
    return toHexFromRgb(this.r, this.g, this.b);
  },
  getPureColor: function getPureColor() {
    var rgb = hsvToRgb(this.hsv.h, 100, 100);
    return new Color('rgb(' + rgb.join(',') + ')');
  },
  isValidHex: function isValidHex(hex) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);
  },
  isValidRGB: function isValidRGB(r, g, b) {
    if (!isIntegerBetweenMinAndMax(r) || !isIntegerBetweenMinAndMax(g) || !isIntegerBetweenMinAndMax(b)) {
      return false;
    }
    return true;
  },
  isValidAlpha: function isValidAlpha(a) {
    if (isNaN(a) || a < 0 || a > 1 || typeof a !== 'number') {
      return false;
    }
    return true;
  },
  colorIsInvalid: false,
  fromHSL: function fromHSL(hsl) {
    var color = new Color();
    var rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
    color.r = rgb[0];
    color.g = rgb[1];
    color.b = rgb[2];
    return color;
  }
};
var _default = Color;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 29932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "registerGradient", ({
  enumerable: true,
  get: function get() {
    return _m_charts.registerGradient;
  }
}));
Object.defineProperty(exports, "registerPattern", ({
  enumerable: true,
  get: function get() {
    return _m_charts.registerPattern;
  }
}));
var _m_charts = __webpack_require__(66798);

/***/ }),

/***/ 62414:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _window = __webpack_require__(58201);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var Action = /*#__PURE__*/function () {
  function Action(action, config) {
    config = config || {};
    this._action = action;
    this._context = config.context || (0, _window.getWindow)();
    this._beforeExecute = config.beforeExecute;
    this._afterExecute = config.afterExecute;
    this._component = config.component;
    this._validatingTargetName = config.validatingTargetName;
    var excludeValidators = this._excludeValidators = {};
    if (config.excludeValidators) {
      for (var i = 0; i < config.excludeValidators.length; i++) {
        excludeValidators[config.excludeValidators[i]] = true;
      }
    }
  }
  var _proto = Action.prototype;
  _proto.execute = function execute() {
    var e = {
      action: this._action,
      args: Array.prototype.slice.call(arguments),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    var beforeExecute = this._beforeExecute;
    var afterExecute = this._afterExecute;
    var argsBag = e.args[0] || {};
    if (!this._validateAction(e)) {
      return;
    }
    beforeExecute === null || beforeExecute === void 0 ? void 0 : beforeExecute.call(this._context, e);
    if (e.cancel) {
      return;
    }
    var result = this._executeAction(e);
    if (argsBag.cancel) {
      return;
    }
    afterExecute === null || afterExecute === void 0 ? void 0 : afterExecute.call(this._context, e);
    return result;
  };
  _proto._validateAction = function _validateAction(e) {
    var excludeValidators = this._excludeValidators;
    var executors = Action.executors;
    for (var name in executors) {
      if (!excludeValidators[name]) {
        var _executor$validate;
        var executor = executors[name];
        (_executor$validate = executor.validate) === null || _executor$validate === void 0 ? void 0 : _executor$validate.call(executor, e);
        if (e.cancel) {
          return false;
        }
      }
    }
    return true;
  };
  _proto._executeAction = function _executeAction(e) {
    var result;
    var executors = Action.executors;
    for (var name in executors) {
      var _executor$execute;
      var executor = executors[name];
      (_executor$execute = executor.execute) === null || _executor$execute === void 0 ? void 0 : _executor$execute.call(executor, e);
      if (e.handled) {
        result = e.result;
        break;
      }
    }
    return result;
  };
  Action.registerExecutor = function registerExecutor(name, executor) {
    if ((0, _type.isPlainObject)(name)) {
      (0, _iterator.each)(name, Action.registerExecutor);
      return;
    }
    Action.executors[name] = executor;
  };
  Action.unregisterExecutor = function unregisterExecutor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    (0, _iterator.each)(args, function () {
      delete Action.executors[this];
    });
  };
  return Action;
}();
exports["default"] = Action;
Action.executors = {};
var createValidatorByTargetElement = function createValidatorByTargetElement(condition) {
  return function (e) {
    if (!e.args.length) {
      return;
    }
    var args = e.args[0];
    var element = args[e.validatingTargetName] || args.element;
    if (element && condition((0, _renderer.default)(element))) {
      e.cancel = true;
    }
  };
};
Action.registerExecutor({
  'disabled': {
    validate: createValidatorByTargetElement(function ($target) {
      return $target.is('.dx-state-disabled, .dx-state-disabled *');
    })
  },
  'readOnly': {
    validate: createValidatorByTargetElement(function ($target) {
      return $target.is('.dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)');
    })
  },
  'undefined': {
    execute: function execute(e) {
      if (!e.action) {
        e.result = undefined;
        e.handled = true;
      }
    }
  },
  'func': {
    execute: function execute(e) {
      if ((0, _type.isFunction)(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38377:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var wrapOverridden = function wrapOverridden(baseProto, methodName, method) {
  return function () {
    var prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];
    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};
var clonePrototype = function clonePrototype(obj) {
  var func = function func() {};
  func.prototype = obj.prototype;
  return new func();
};
var redefine = function redefine(members) {
  var that = this;
  var overridden;
  var memberName;
  var member;
  if (!members) {
    return that;
  }
  for (memberName in members) {
    member = members[memberName];
    overridden = typeof that.prototype[memberName] === 'function' && typeof member === 'function';
    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member;
  }
  return that;
};
var include = function include() {
  var classObj = this;
  var argument;
  var name;
  var i;

  // NOTE: For ES6 classes. They don't have _includedCtors/_includedPostCtors
  // properties and get them from the ancestor class.
  var hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  var isES6Class = !hasClassObjOwnProperty('_includedCtors') && !hasClassObjOwnProperty('_includedPostCtors');
  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }
  for (i = 0; i < arguments.length; i++) {
    argument = arguments[i];
    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }
    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }
    for (name in argument) {
      if (name === 'ctor' || name === 'postCtor' || name === 'default') {
        continue;
      }
      classObj.prototype[name] = argument[name];
    }
  }
  return classObj;
};
var subclassOf = function subclassOf(parentClass) {
  var hasParentProperty = Object.prototype.hasOwnProperty.bind(this)('parent');
  var isES6Class = !hasParentProperty && this.parent;
  if (isES6Class) {
    var baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  } else {
    if (this.parent === parentClass) {
      return true;
    }
    if (!this.parent || !this.parent.subclassOf) {
      return false;
    }
    return this.parent.subclassOf(parentClass);
  }
};
var abstract = function abstract() {
  throw _errors.default.Error('E0001');
};
var copyStatic = function () {
  var hasOwn = Object.prototype.hasOwnProperty;
  return function (source, destination) {
    for (var key in source) {
      if (!hasOwn.call(source, key)) {
        return;
      }
      destination[key] = source[key];
    }
  };
}();
var classImpl = function classImpl() {};
classImpl.inherit = function (members) {
  var inheritor = function inheritor() {
    if (!this || (0, _type.isWindow)(this) || typeof this.constructor !== 'function') {
      throw _errors.default.Error('E0003');
    }
    var instance = this;
    var ctor = instance.ctor;
    var includedCtors = instance.constructor._includedCtors;
    var includedPostCtors = instance.constructor._includedPostCtors;
    var i;
    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }
    if (ctor) {
      ctor.apply(instance, arguments);
    }
    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };
  inheritor.prototype = clonePrototype(this);
  copyStatic(this, inheritor);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};
classImpl.abstract = abstract;
var _default = classImpl;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44297:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Component = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _extend = __webpack_require__(13306);
var _index = __webpack_require__(95683);
var _utils = __webpack_require__(45434);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _action = _interopRequireDefault(__webpack_require__(62414));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _events_strategy = __webpack_require__(80566);
var _public_component = __webpack_require__(9321);
var _postponed_operations = __webpack_require__(90889);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _data = __webpack_require__(47617);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var getEventName = function getEventName(actionName) {
  return actionName.charAt(2).toLowerCase() + actionName.substr(3);
};
var isInnerOption = function isInnerOption(optionName) {
  return optionName.indexOf('_', 0) === 0;
};
var Component = _class.default.inherit({
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  },
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  },
  _getDefaultOptions() {
    return {
      onInitialized: null,
      onOptionChanged: null,
      onDisposing: null,
      defaultOptionsRules: null
    };
  },
  _defaultOptionsRules() {
    return [];
  },
  _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  },
  _convertRulesToOptions(rules) {
    return (0, _utils.convertRulesToOptions)(rules);
  },
  _isInitialOptionValue(name) {
    return this._options.isInitial(name);
  },
  _setOptionsByReference() {
    this._optionsByReference = {};
  },
  _getOptionsByReference() {
    return this._optionsByReference;
  },
  /**
  * @name Component.ctor
  * @publicName ctor(options)
  * @param1 options:ComponentOptions|undefined
  * @hidden
  */
  ctor() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _optionChangedCallbacks = options._optionChangedCallbacks,
      _disposingCallbacks = options._disposingCallbacks;
    this.NAME = (0, _public_component.name)(this.constructor);
    this._eventsStrategy = _events_strategy.EventsStrategy.create(this, options.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || (0, _callbacks.default)();
    this._disposingCallbacks = _disposingCallbacks || (0, _callbacks.default)();
    this.postponedOperations = new _postponed_operations.PostponedOperations();
    this._createOptions(options);
  },
  _createOptions(options) {
    var _this = this;
    this.beginUpdate();
    try {
      this._setOptionsByReference();
      this._setDeprecatedOptions();
      this._options = new _index.Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
      this._options.onChanging(function (name, previousValue, value) {
        return _this._initialized && _this._optionChanging(name, previousValue, value);
      });
      this._options.onDeprecated(function (option, info) {
        return _this._logDeprecatedOptionWarning(option, info);
      });
      this._options.onChanged(function (name, value, previousValue) {
        return _this._notifyOptionChanged(name, value, previousValue);
      });
      this._options.onStartChange(function () {
        return _this.beginUpdate();
      });
      this._options.onEndChange(function () {
        return _this.endUpdate();
      });
      this._options.addRules(this._defaultOptionsRules());
      if (options && options.onInitializing) {
        options.onInitializing.apply(this, [options]);
      }
      this._setOptionsByDevice(options.defaultOptionsRules);
      this._initOptions(options);
    } finally {
      this.endUpdate();
    }
  },
  _initOptions(options) {
    this.option(options);
  },
  _init() {
    var _this2 = this;
    this._createOptionChangedAction();
    this.on('disposing', function (args) {
      _this2._disposingCallbacks.fireWith(_this2, [args]);
    });
  },
  _logDeprecatedOptionWarning(option, info) {
    var message = info.message || "Use the '".concat(info.alias, "' option instead");
    _errors.default.log('W0001', this.NAME, option, info.since, message);
  },
  _logDeprecatedComponentWarning(since, alias) {
    _errors.default.log('W0000', this.NAME, since, "Use the '".concat(alias, "' widget instead"));
  },
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption('onOptionChanged', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption('onDisposing', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case 'onDisposing':
      case 'onInitialized':
        break;
      case 'onOptionChanged':
        this._createOptionChangedAction();
        break;
      case 'defaultOptionsRules':
        break;
    }
  },
  _dispose() {
    this._optionChangedCallbacks.empty();
    this._createDisposingAction();
    this._disposingAction();
    this._eventsStrategy.dispose();
    this._options.dispose();
    this._disposed = true;
  },
  _lockUpdate() {
    this._updateLockCount++;
  },
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  },
  // TODO: remake as getter after ES6 refactor
  _isUpdateAllowed() {
    return this._updateLockCount === 0;
  },
  // TODO: remake as getter after ES6 refactor
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  },
  isInitialized() {
    return this._initialized;
  },
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  },
  _initializeComponent() {
    this._initializing = true;
    try {
      this._init();
    } finally {
      this._initializing = false;
      this._lockUpdate();
      this._createActionByOption('onInitialized', {
        excludeValidators: ['disabled', 'readOnly']
      })();
      this._unlockUpdate();
      this._initialized = true;
    }
  },
  instance() {
    return this;
  },
  beginUpdate: function beginUpdate() {
    this._lockUpdate();
  },
  endUpdate: function endUpdate() {
    this._unlockUpdate();
    this._isUpdateAllowed() && this._commitUpdate();
  },
  _optionChanging: _common.noop,
  _notifyOptionChanged(option, value, previousValue) {
    if (this._initialized) {
      var optionNames = [option].concat(this._options.getAliasesByName(option));
      for (var i = 0; i < optionNames.length; i++) {
        var name = optionNames[i];
        var args = {
          name: (0, _data.getPathParts)(name)[0],
          fullName: name,
          value: value,
          previousValue: previousValue
        };
        if (!isInnerOption(name)) {
          this._optionChangedCallbacks.fireWith(this, [(0, _extend.extend)(this._defaultActionArgs(), args)]);
          this._optionChangedAction((0, _extend.extend)({}, args));
        }
        if (!this._disposed && this._cancelOptionChange !== name) {
          this._optionChanged(args);
        }
      }
    }
  },
  initialOption(name) {
    return this._options.initial(name);
  },
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  },
  _defaultActionArgs() {
    return {
      component: this
    };
  },
  _createAction(actionSource, config) {
    var _this3 = this;
    var action;
    return function (e) {
      if (!(0, _type.isDefined)(e)) {
        e = {};
      }
      if (!(0, _type.isPlainObject)(e)) {
        e = {
          actionValue: e
        };
      }
      action = action || new _action.default(actionSource, (0, _extend.extend)(config, _this3._defaultActionConfig()));
      return action.execute.call(action, (0, _extend.extend)(e, _this3._defaultActionArgs()));
    };
  },
  _createActionByOption(optionName, config) {
    var _this4 = this;
    var action;
    var eventName;
    var actionFunc;
    var result = function result() {
      if (!eventName) {
        config = config || {};
        if (typeof optionName !== 'string') {
          throw _errors.default.Error('E0008');
        }
        if (optionName.indexOf('on') === 0) {
          eventName = getEventName(optionName);
        }
        actionFunc = _this4.option(optionName);
      }
      if (!action && !actionFunc && !config.beforeExecute && !config.afterExecute && !_this4._eventsStrategy.hasEvent(eventName)) {
        return;
      }
      if (!action) {
        var beforeExecute = config.beforeExecute;
        config.beforeExecute = function () {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }
          beforeExecute && beforeExecute.apply(_this4, props);
          _this4._eventsStrategy.fireEvent(eventName, props[0].args);
        };
        action = _this4._createAction(actionFunc, config);
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if ((0, _config.default)().wrapActionsBeforeExecute) {
        var beforeActionExecute = _this4.option('beforeActionExecute') || _common.noop;
        var wrappedAction = beforeActionExecute(_this4, action, config) || action;
        return wrappedAction.apply(_this4, args);
      }
      return action.apply(_this4, args);
    };
    if ((0, _config.default)().wrapActionsBeforeExecute) {
      return result;
    }
    var onActionCreated = this.option('onActionCreated') || _common.noop;
    return onActionCreated(this, result, config) || result;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  },
  hasActionSubscription: function hasActionSubscription(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
  },
  isOptionDeprecated(name) {
    return this._options.isDeprecated(name);
  },
  _setOptionWithoutOptionChange(name, value) {
    this._cancelOptionChange = name;
    this.option(name, value);
    this._cancelOptionChange = false;
  },
  _getOptionValue(name, context) {
    var value = this.option(name);
    if ((0, _type.isFunction)(value)) {
      return value.bind(context)();
    }
    return value;
  },
  option() {
    var _this$_options;
    return (_this$_options = this._options).option.apply(_this$_options, arguments);
  },
  resetOption(name) {
    this.beginUpdate();
    this._options.reset(name);
    this.endUpdate();
  }
});
exports.Component = Component;

/***/ }),

/***/ 99393:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(5554));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _public_component = __webpack_require__(9321);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var registerComponent = function registerComponent(name, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name] = componentClass;
  }
  (0, _public_component.name)(componentClass, name);
  _component_registrator_callbacks.default.fire(name, componentClass);
};
var registerRendererComponent = function registerRendererComponent(name, componentClass) {
  _renderer.default.fn[name] = function (options) {
    var isMemberInvoke = typeof options === 'string';
    var result;
    if (isMemberInvoke) {
      var memberName = options;
      var memberArgs = [].slice.call(arguments).slice(1);
      this.each(function () {
        var instance = componentClass.getInstance(this);
        if (!instance) {
          throw _errors.default.Error('E0009', name);
        }
        var member = instance[memberName];
        var memberValue = member.apply(instance, memberArgs);
        if (result === undefined) {
          result = memberValue;
        }
      });
    } else {
      this.each(function () {
        var instance = componentClass.getInstance(this);
        if (instance) {
          instance.option(options);
        } else {
          new componentClass(this, options);
        }
      });
      result = this;
    }
    return result;
  };
};
_component_registrator_callbacks.default.add(registerRendererComponent);
var _default = registerComponent;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 5554:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _memorized_callbacks = _interopRequireDefault(__webpack_require__(83358));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = new _memorized_callbacks.default();
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 80209:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global DevExpress */

var config = {
  rtlEnabled: false,
  defaultCurrency: 'USD',
  defaultUseCurrencyAccountingStyle: true,
  oDataFilterToLower: true,
  serverDecimalSeparator: '.',
  decimalSeparator: '.',
  thousandsSeparator: ',',
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,
  /**
  * @name GlobalConfig.useJQuery
  * @type boolean
  * @hidden
  */
  useJQuery: undefined,
  editorStylingMode: undefined,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: 'add',
    closeIcon: 'close',
    label: '',
    position: {
      at: 'right bottom',
      my: 'right bottom',
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: 'auto'
  },
  optionsParser: function optionsParser(optionsString) {
    if (optionsString.trim().charAt(0) !== '{') {
      optionsString = '{' + optionsString + '}';
    }
    try {
      return JSON.parse(optionsString);
    } catch (ex) {
      try {
        return JSON.parse(normalizeToJSONString(optionsString));
      } catch (exNormalize) {
        throw _errors.default.Error('E3018', ex, optionsString);
      }
    }
  }
};
var normalizeToJSONString = function normalizeToJSONString(optionsString) {
  return optionsString.replace(/'/g, '"') // replace all ' to "
  .replace(/,\s*([\]}])/g, '$1') // remove trailing commas
  .replace(/([{,])\s*([^":\s]+)\s*:/g, '$1"$2":'); // add quotes for unquoted keys
};

var deprecatedFields = ['decimalSeparator', 'thousandsSeparator'];
var configMethod = function configMethod() {
  if (!arguments.length) {
    return config;
  }
  var newConfig = arguments.length <= 0 ? undefined : arguments[0];
  deprecatedFields.forEach(function (deprecatedField) {
    if (newConfig[deprecatedField]) {
      var message = "Now, the ".concat(deprecatedField, " is selected based on the specified locale.");
      _errors.default.log('W0003', 'config', deprecatedField, '19.2', message);
    }
  });
  (0, _extend.extend)(config, newConfig);
};
if (typeof DevExpress !== 'undefined' && DevExpress.config) {
  configMethod(DevExpress.config);
}
var _default = configMethod;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 20530:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _window = __webpack_require__(58201);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _events_strategy = __webpack_require__(80566);
var _storage = __webpack_require__(36613);
var _view_port = __webpack_require__(77695);
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var KNOWN_UA_TABLE = {
  'iPhone': 'iPhone',
  'iPhone5': 'iPhone',
  'iPhone6': 'iPhone',
  'iPhone6plus': 'iPhone',
  'iPad': 'iPad',
  'iPadMini': 'iPad Mini',
  'androidPhone': 'Android Mobile',
  'androidTablet': 'Android',
  'msSurface': 'Windows ARM Tablet PC',
  'desktop': 'desktop'
};
var DEFAULT_DEVICE = {
  deviceType: 'desktop',
  platform: 'generic',
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: 'A',
  // TODO: For internal use (draft, do not document these options!)
  mac: false
};
var UA_PARSERS = {
  generic(userAgent) {
    var isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    var isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    var isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    var isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return null;
    }
    return {
      deviceType: isPhone ? 'phone' : isTablet ? 'tablet' : 'desktop',
      platform: 'generic',
      version: [],
      grade: 'A',
      mac: isMac
    };
  },
  appleTouchDevice(userAgent) {
    var navigator = (0, _window.getNavigator)();
    var isIpadOs = /Macintosh/i.test(userAgent) && (navigator === null || navigator === void 0 ? void 0 : navigator.maxTouchPoints) > 2;
    var isAppleDevice = /ip(hone|od|ad)/i.test(userAgent);
    if (!isAppleDevice && !isIpadOs) {
      return null;
    }
    var isPhone = /ip(hone|od)/i.test(userAgent);
    var matches = userAgent.match(/os\s{0,}X? (\d+)_(\d+)_?(\d+)?/i);
    var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    var isIPhone4 = window.screen.height === 960 / 2;
    var grade = isIPhone4 ? 'B' : 'A';
    return {
      deviceType: isPhone ? 'phone' : 'tablet',
      platform: 'ios',
      version,
      grade
    };
  },
  android(userAgent) {
    // TODO: Check this RegExp.
    //  It looks like there may be missing android user agents.
    var isAndroid = /android|htc_|silk/i.test(userAgent);
    var isWinPhone = /windows phone/i.test(userAgent);
    if (!isAndroid || isWinPhone) {
      return null;
    }
    var isPhone = /mobile/i.test(userAgent);
    var matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    var version = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    var worseThan4_4 = version.length > 1 && (version[0] < 4 || version[0] === 4 && version[1] < 4);
    var grade = worseThan4_4 ? 'B' : 'A';
    return {
      deviceType: isPhone ? 'phone' : 'tablet',
      platform: 'android',
      version,
      grade
    };
  }
};
var UA_PARSERS_ARRAY = [UA_PARSERS.appleTouchDevice, UA_PARSERS.android, UA_PARSERS.generic];
var Devices = /*#__PURE__*/function () {
  /**
  * @name DevicesObject.ctor
  * @publicName ctor(options)
  * @param1 options:object
  * @param1_field1 window:Window
  * @hidden
  */
  function Devices(options) {
    this._window = (options === null || options === void 0 ? void 0 : options.window) || window;
    this._realDevice = this._getDevice();
    this._currentDevice = undefined;
    this._currentOrientation = undefined;
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
    this.changed = (0, _callbacks.default)();
    if ((0, _window.hasWindow)()) {
      _ready_callbacks.default.add(this._recalculateOrientation.bind(this));
      _resize_callbacks.default.add(this._recalculateOrientation.bind(this));
    }
  }
  var _proto = Devices.prototype;
  _proto.current = function current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      deviceOrName = undefined;
      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }
        if (deviceOrName) {
          this._forced = true;
        }
      }
      this._currentDevice = this._getDevice(deviceOrName);
    }
    return this._currentDevice;
  };
  _proto.real = function real(forceDevice) {
    return (0, _extend.extend)({}, this._realDevice);
  };
  _proto.orientation = function orientation() {
    return this._currentOrientation;
  };
  _proto.isForced = function isForced() {
    return this._forced;
  };
  _proto.isRippleEmulator = function isRippleEmulator() {
    return !!this._window.tinyHippos;
  };
  _proto._getCssClasses = function _getCssClasses(device) {
    var result = [];
    var realDevice = this._realDevice;
    device = device || this.current();

    // TODO: use real device here?
    if (device.deviceType) {
      result.push("dx-device-".concat(device.deviceType));
      if (device.deviceType !== 'desktop') {
        result.push('dx-device-mobile');
      }
    }
    result.push("dx-device-".concat(realDevice.platform));
    if (realDevice.version && realDevice.version.length) {
      result.push("dx-device-".concat(realDevice.platform, "-").concat(realDevice.version[0]));
    }
    if (this.isSimulator()) {
      result.push('dx-simulator');
    }
    if ((0, _config.default)().rtlEnabled) {
      result.push('dx-rtl');
    }
    return result;
  };
  _proto.attachCssClasses = function attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(' ');
    (0, _renderer.default)(element).addClass(this._deviceClasses);
  };
  _proto.detachCssClasses = function detachCssClasses(element) {
    (0, _renderer.default)(element).removeClass(this._deviceClasses);
  };
  _proto.isSimulator = function isSimulator() {
    // NOTE: error may happen due to same-origin policy
    try {
      return this._isSimulator || (0, _window.hasWindow)() && this._window.top !== this._window.self && this._window.top['dx-force-device'] || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  };
  _proto.forceSimulator = function forceSimulator() {
    this._isSimulator = true;
  };
  _proto._getDevice = function _getDevice(deviceName) {
    if (deviceName === 'genericPhone') {
      deviceName = {
        deviceType: 'phone',
        platform: 'generic',
        generic: true
      };
    }
    if ((0, _type.isPlainObject)(deviceName)) {
      return this._fromConfig(deviceName);
    } else {
      var ua;
      if (deviceName) {
        ua = KNOWN_UA_TABLE[deviceName];
        if (!ua) {
          throw _errors.default.Error('E0005');
        }
      } else {
        var navigator = (0, _window.getNavigator)();
        ua = navigator.userAgent;
      }
      return this._fromUA(ua);
    }
  };
  _proto._getDeviceOrNameFromWindowScope = function _getDeviceOrNameFromWindowScope() {
    var result;
    if ((0, _window.hasWindow)() && (this._window.top['dx-force-device-object'] || this._window.top['dx-force-device'])) {
      result = this._window.top['dx-force-device-object'] || this._window.top['dx-force-device'];
    }
    return result;
  };
  _proto._getDeviceNameFromSessionStorage = function _getDeviceNameFromSessionStorage() {
    var sessionStorage = (0, _storage.sessionStorage)();
    if (!sessionStorage) {
      return;
    }
    var deviceOrName = sessionStorage.getItem('dx-force-device');
    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  };
  _proto._fromConfig = function _fromConfig(config) {
    var result = (0, _extend.extend)({}, DEFAULT_DEVICE, this._currentDevice, config);
    var shortcuts = {
      phone: result.deviceType === 'phone',
      tablet: result.deviceType === 'tablet',
      android: result.platform === 'android',
      ios: result.platform === 'ios',
      generic: result.platform === 'generic'
    };
    return (0, _extend.extend)(result, shortcuts);
  };
  _proto._fromUA = function _fromUA(ua) {
    for (var idx = 0; idx < UA_PARSERS_ARRAY.length; idx += 1) {
      var parser = UA_PARSERS_ARRAY[idx];
      var config = parser(ua);
      if (config) {
        return this._fromConfig(config);
      }
    }
    return DEFAULT_DEVICE;
  };
  _proto._changeOrientation = function _changeOrientation() {
    var $window = (0, _renderer.default)(this._window);
    var orientation = (0, _size.getHeight)($window) > (0, _size.getWidth)($window) ? 'portrait' : 'landscape';
    if (this._currentOrientation === orientation) {
      return;
    }
    this._currentOrientation = orientation;
    this._eventsStrategy.fireEvent('orientationChanged', [{
      orientation: orientation
    }]);
  };
  _proto._recalculateOrientation = function _recalculateOrientation() {
    var windowWidth = (0, _size.getWidth)(this._window);
    if (this._currentWidth === windowWidth) {
      return;
    }
    this._currentWidth = windowWidth;
    this._changeOrientation();
  };
  _proto.on = function on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  };
  _proto.off = function off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  };
  return Devices;
}();
var devices = new Devices();
var viewPortElement = (0, _view_port.value)();
if (viewPortElement) {
  devices.attachCssClasses(viewPortElement);
}
_view_port.changeCallback.add(function (viewPort, prevViewport) {
  devices.detachCssClasses(prevViewport);
  devices.attachCssClasses(viewPort);
});
var _default = devices;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 73349:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _common = __webpack_require__(20576);
var _shadow_dom = __webpack_require__(90330);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global document */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var nativeDOMAdapterStrategy = {
  querySelectorAll(element, selector) {
    return element.querySelectorAll(selector);
  },
  elementMatches(element, selector) {
    var _this = this;
    var matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || function (selector) {
      var doc = element.document || element.ownerDocument;
      if (!doc) {
        return false;
      }
      var items = _this.querySelectorAll(doc, selector);
      for (var i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    };
    return matches.call(element, selector);
  },
  createElement(tagName, context) {
    context = context || this._document;
    return context.createElement(tagName);
  },
  createElementNS(ns, tagName, context) {
    context = context || this._document;
    return context.createElementNS(ns, tagName);
  },
  createTextNode(text, context) {
    context = context || this._document;
    return context.createTextNode(text);
  },
  createAttribute(text, context) {
    context = context || this._document;
    return context.createAttribute(text);
  },
  isNode(element) {
    return element && typeof element === 'object' && 'nodeType' in element && 'nodeName' in element;
  },
  isElementNode(element) {
    return element && element.nodeType === ELEMENT_NODE;
  },
  isTextNode(element) {
    return element && element.nodeType === TEXT_NODE;
  },
  isDocument(element) {
    return element && element.nodeType === DOCUMENT_NODE;
  },
  isDocumentFragment(element) {
    return element && element.nodeType === DOCUMENT_FRAGMENT_NODE;
  },
  removeElement(element) {
    var parentNode = element && element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute(element, name) {
    return element.getAttribute(name);
  },
  setAttribute(element, name, value) {
    if (name === 'style') {
      element.style.cssText = value;
    } else {
      element.setAttribute(name, value);
    }
  },
  removeAttribute(element, name) {
    element.removeAttribute(name);
  },
  setProperty(element, name, value) {
    element[name] = value;
  },
  setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass(element, className, isAdd) {
    if (element.nodeType === 1 && className) {
      isAdd ? element.classList.add(className) : element.classList.remove(className);
    }
  },
  setStyle(element, name, value) {
    element.style[name] = value || '';
  },
  _document: typeof document === 'undefined' ? undefined : document,
  getDocument() {
    return this._document;
  },
  getActiveElement(element) {
    var activeElementHolder = this.getRootNode(element);
    return activeElementHolder.activeElement;
  },
  getRootNode(element) {
    var _element$getRootNode, _element$getRootNode2;
    return (_element$getRootNode = element === null || element === void 0 ? void 0 : (_element$getRootNode2 = element.getRootNode) === null || _element$getRootNode2 === void 0 ? void 0 : _element$getRootNode2.call(element)) !== null && _element$getRootNode !== void 0 ? _element$getRootNode : this._document;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(property) {
    return property in this._document;
  },
  listen(element, event, callback, options) {
    if (!element || !('addEventListener' in element)) {
      return _common.noop;
    }
    element.addEventListener(event, callback, options);
    return function () {
      element.removeEventListener(event, callback);
    };
  },
  elementsFromPoint(x, y, element) {
    var activeElementHolder = this.getRootNode(element);
    if (activeElementHolder.host) {
      return (0, _shadow_dom.getShadowElementsFromPoint)(x, y, activeElementHolder);
    }
    return activeElementHolder.elementsFromPoint(x, y);
  }
};
var _default = (0, _dependency_injector.default)(nativeDOMAdapterStrategy);
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 13046:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _config = _interopRequireDefault(__webpack_require__(80209));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _component = __webpack_require__(44297);
var _template_manager = __webpack_require__(14192);
var _public_component = __webpack_require__(9321);
var _shadow_dom = __webpack_require__(90330);
var _element_data = __webpack_require__(97906);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _element = __webpack_require__(6415);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
var _short = __webpack_require__(72918);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var abstract = _component.Component.abstract;
var DOMComponent = _component.Component.inherit({
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      width: undefined,
      height: undefined,
      rtlEnabled: (0, _config.default)().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
    }, this._useTemplates() ? _template_manager.TemplateManager.createDefaultOptions() : {});
  },
  /**
  * @name DOMComponent.ctor
  * @publicName ctor(element,options)
  * @param1 element:Element|JQuery
  * @param2 options:DOMComponentOptions|undefined
  * @hidden
  */
  ctor(element, options) {
    this._customClass = null;
    this._createElement(element);
    (0, _public_component.attachInstanceToElement)(this._$element, this, this._dispose);
    this.callBase(options);
  },
  _createElement(element) {
    this._$element = (0, _renderer.default)(element);
  },
  _getSynchronizableOptionsForCreateComponent() {
    return ['rtlEnabled', 'disabled', 'templatesRenderAsynchronously'];
  },
  _checkFunctionValueDeprecation: function _checkFunctionValueDeprecation(optionNames) {
    var _this = this;
    if (!this.option('_ignoreFunctionValueDeprecation')) {
      optionNames.forEach(function (optionName) {
        if ((0, _type.isFunction)(_this.option(optionName))) {
          _errors.default.log('W0017', optionName);
        }
      });
    }
  },
  _visibilityChanged: abstract,
  _dimensionChanged: abstract,
  _init() {
    this.callBase();
    this._checkFunctionValueDeprecation(['width', 'height', 'maxHeight', 'maxWidth', 'minHeight', 'minWidth', 'popupHeight', 'popupWidth']);
    this._attachWindowResizeCallback();
    this._initTemplateManager();
  },
  _setOptionsByDevice(instanceCustomRules) {
    this.callBase([].concat(this.constructor._classCustomRules || [], instanceCustomRules || []));
  },
  _isInitialOptionValue(name) {
    var isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name);
    return !isCustomOption && this.callBase(name);
  },
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      var windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      _resize_callbacks.default.add(windowResizeCallBack);
    }
  },
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== abstract;
  },
  _renderComponent() {
    this._initMarkup();
    (0, _window.hasWindow)() && this._render();
  },
  _initMarkup() {
    var _ref = this.option() || {},
      rtlEnabled = _ref.rtlEnabled;
    this._renderElementAttributes();
    this._toggleRTLDirection(rtlEnabled);
    this._renderVisibilityChange();
    this._renderDimensions();
  },
  _render() {
    this._attachVisibilityChangeHandlers();
    (0, _shadow_dom.addShadowDomStyles)(this.$element());
  },
  _renderElementAttributes() {
    var _ref2 = this.option() || {},
      elementAttr = _ref2.elementAttr;
    var attributes = (0, _extend.extend)({}, elementAttr);
    var classNames = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames);
    this._customClass = classNames;
  },
  _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }
    if (this._isVisibilityChangeSupported()) {
      var $element = this.$element();
      $element.addClass('dx-visibility-change-handler');
    }
  },
  _renderDimensions() {
    var $element = this.$element();
    var element = $element.get(0);
    var width = this._getOptionValue('width', element);
    var height = this._getOptionValue('height', element);
    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: width === null ? '' : width,
        height: height === null ? '' : height
      });
    }
  },
  _isCssUpdateRequired(element, height, width) {
    return !!((0, _type.isDefined)(width) || (0, _type.isDefined)(height) || element.style.width || element.style.height);
  },
  _attachDimensionChangeHandlers() {
    var _this2 = this;
    var $el = this.$element();
    var namespace = "".concat(this.NAME, "VisibilityChange");
    _short.resize.off($el, {
      namespace
    });
    _short.resize.on($el, function () {
      return _this2._dimensionChanged();
    }, {
      namespace
    });
  },
  _attachVisibilityChangeHandlers() {
    var _this3 = this;
    if (this._isVisibilityChangeSupported()) {
      var $el = this.$element();
      var namespace = "".concat(this.NAME, "VisibilityChange");
      this._isHidden = !this._isVisible();
      _short.visibility.off($el, {
        namespace
      });
      _short.visibility.on($el, function () {
        return _this3._checkVisibilityChanged('shown');
      }, function () {
        return _this3._checkVisibilityChanged('hiding');
      }, {
        namespace
      });
    }
  },
  _isVisible() {
    var $element = this.$element();
    return $element.is(':visible');
  },
  _checkVisibilityChanged(action) {
    var isVisible = this._isVisible();
    if (isVisible) {
      if (action === 'hiding' && !this._isHidden) {
        this._visibilityChanged(false);
        this._isHidden = true;
      } else if (action === 'shown' && this._isHidden) {
        this._isHidden = false;
        this._visibilityChanged(true);
      }
    }
  },
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== abstract && (0, _window.hasWindow)();
  },
  _clean: _common.noop,
  _modelByElement() {
    var _this$option = this.option(),
      modelByElement = _this$option.modelByElement;
    var $element = this.$element();
    return modelByElement ? modelByElement($element) : undefined;
  },
  _invalidate() {
    if (this._isUpdateAllowed()) {
      throw _errors.default.Error('E0007');
    }
    this._requireRefresh = true;
  },
  _refresh() {
    this._clean();
    this._renderComponent();
  },
  _dispose() {
    this._templateManager && this._templateManager.dispose();
    this.callBase();
    this._clean();
    this._detachWindowResizeCallback();
  },
  _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      _resize_callbacks.default.remove(this._windowResizeCallBack);
    }
  },
  _toggleRTLDirection(rtl) {
    var $element = this.$element();
    $element.toggleClass('dx-rtl', rtl);
  },
  _createComponent(element, component) {
    var _this4 = this;
    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var synchronizableOptions = (0, _common.grep)(this._getSynchronizableOptionsForCreateComponent(), function (value) {
      return !(value in config);
    });
    var _this$option2 = this.option(),
      integrationOptions = _this$option2.integrationOptions;
    var _this$option3 = this.option(),
      nestedComponentOptions = _this$option3.nestedComponentOptions;
    nestedComponentOptions = nestedComponentOptions || _common.noop;
    var nestedComponentConfig = (0, _extend.extend)({
      integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach(function (optionName) {
      return nestedComponentConfig[optionName] = _this4.option(optionName);
    });
    this._extendConfig(config, nestedComponentConfig);
    var instance = void 0;
    if ((0, _type.isString)(component)) {
      var $element = (0, _renderer.default)(element)[component](config);
      instance = $element[component]('instance');
    } else if (element) {
      instance = component.getInstance(element);
      if (instance) {
        instance.option(config);
      } else {
        instance = new component(element, config);
      }
    }
    if (instance) {
      var optionChangedHandler = function optionChangedHandler(_ref3) {
        var name = _ref3.name,
          value = _ref3.value;
        if (synchronizableOptions.includes(name)) {
          instance.option(name, value);
        }
      };
      this.on('optionChanged', optionChangedHandler);
      instance.on('disposing', function () {
        return _this4.off('optionChanged', optionChangedHandler);
      });
    }
    return instance;
  },
  _extendConfig(config, extendConfig) {
    (0, _iterator.each)(extendConfig, function (key, value) {
      !Object.prototype.hasOwnProperty.call(config, key) && (config[key] = value);
    });
  },
  _defaultActionConfig() {
    var $element = this.$element();
    var context = this._modelByElement($element);
    return (0, _extend.extend)(this.callBase(), {
      context
    });
  },
  _defaultActionArgs() {
    var $element = this.$element();
    var model = this._modelByElement($element);
    var element = this.element();
    return (0, _extend.extend)(this.callBase(), {
      element,
      model
    });
  },
  _optionChanged(args) {
    switch (args.name) {
      case 'width':
      case 'height':
        this._renderDimensions();
        break;
      case 'rtlEnabled':
        this._invalidate();
        break;
      case 'elementAttr':
        this._renderElementAttributes();
        break;
      case 'disabled':
      case 'integrationOptions':
        break;
      default:
        this.callBase(args);
        break;
    }
  },
  _removeAttributes(element) {
    var attrs = element.attributes;
    for (var i = attrs.length - 1; i >= 0; i--) {
      var attr = attrs[i];
      if (attr) {
        var name = attr.name;
        if (!name.indexOf('aria-') || name.indexOf('dx-') !== -1 || name === 'role' || name === 'style' || name === 'tabindex') {
          element.removeAttribute(name);
        }
      }
    }
  },
  _removeClasses(element) {
    element.className = element.className.split(' ').filter(function (cssClass) {
      return cssClass.lastIndexOf('dx-', 0) !== 0;
    }).join(' ');
  },
  _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;
      this._refresh();
    }
  },
  endUpdate() {
    var renderRequired = this._isInitializingRequired();
    this.callBase();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  },
  $element() {
    return this._$element;
  },
  element() {
    var $element = this.$element();
    return (0, _element.getPublicElement)($element);
  },
  dispose() {
    var element = this.$element().get(0);
    (0, _element_data.cleanDataRecursive)(element, true);
    element.textContent = '';
    this._removeAttributes(element);
    this._removeClasses(element);
  },
  resetOption(optionName) {
    this.callBase(optionName);
    if (optionName === 'width' || optionName === 'height') {
      var initialOption = this.initialOption(optionName);
      !(0, _type.isDefined)(initialOption) && this.$element().css(optionName, '');
    }
  },
  _getAnonymousTemplateName() {
    return void 0;
  },
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) return void 0;
    var _this$option4 = this.option(),
      _this$option4$integra = _this$option4.integrationOptions,
      integrationOptions = _this$option4$integra === void 0 ? {} : _this$option4$integra;
    var createTemplate = integrationOptions.createTemplate;
    this._templateManager = new _template_manager.TemplateManager(createTemplate, this._getAnonymousTemplateName());
    this._initTemplates();
  },
  _initTemplates() {
    var _this5 = this;
    var _this$_templateManage = this._templateManager.extractTemplates(this.$element()),
      templates = _this$_templateManage.templates,
      anonymousTemplateMeta = _this$_templateManage.anonymousTemplateMeta;
    var anonymousTemplate = this.option("integrationOptions.templates.".concat(anonymousTemplateMeta.name));
    templates.forEach(function (_ref4) {
      var name = _ref4.name,
        template = _ref4.template;
      _this5._options.silent("integrationOptions.templates.".concat(name), template);
    });
    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent("integrationOptions.templates.".concat(anonymousTemplateMeta.name), anonymousTemplateMeta.template);
      this._options.silent('_hasAnonymousTemplateContent', true);
    }
  },
  _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  },
  _getTemplate(templateSource) {
    var templates = this.option('integrationOptions.templates');
    var isAsyncTemplate = this.option('templatesRenderAsynchronously');
    var skipTemplates = this.option('integrationOptions.skipTemplates');
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate,
      skipTemplates
    }, this);
  },
  _saveTemplate(name, template) {
    this._setOptionWithoutOptionChange('integrationOptions.templates.' + name, this._templateManager._createTemplate(template));
  },
  _useTemplates() {
    return true;
  }
});
DOMComponent.getInstance = function (element) {
  return (0, _public_component.getInstanceByElement)((0, _renderer.default)(element), this);
};
DOMComponent.defaultOptions = function (rule) {
  this._classCustomRules = this._classCustomRules || [];
  this._classCustomRules.push(rule);
};
var _default = DOMComponent;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 6415:
/***/ (function(__unused_webpack_module, exports) {



exports.getPublicElement = getPublicElement;
exports.setPublicElementWrapper = setPublicElementWrapper;
var strategy = function strategy(element) {
  return element && element.get(0);
};
function getPublicElement(element) {
  return strategy(element);
}
function setPublicElementWrapper(newStrategy) {
  strategy = newStrategy;
}

/***/ }),

/***/ 97906:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.afterCleanData = afterCleanData;
exports.beforeCleanData = beforeCleanData;
exports.cleanData = cleanData;
exports.cleanDataRecursive = cleanDataRecursive;
exports.data = data;
exports.getDataStrategy = getDataStrategy;
exports.removeData = removeData;
exports.strategyChanging = exports.setDataStrategy = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _memorized_callbacks = _interopRequireDefault(__webpack_require__(83358));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var dataMap = new WeakMap();
var strategy;
var strategyChanging = new _memorized_callbacks.default();
exports.strategyChanging = strategyChanging;
var beforeCleanDataFunc = function beforeCleanDataFunc() {};
var afterCleanDataFunc = function afterCleanDataFunc() {};
var setDataStrategy = function setDataStrategy(value) {
  strategyChanging.fire(value);
  strategy = value;
  var cleanData = strategy.cleanData;
  strategy.cleanData = function (nodes) {
    beforeCleanDataFunc(nodes);
    var result = cleanData.call(this, nodes);
    afterCleanDataFunc(nodes);
    return result;
  };
};
exports.setDataStrategy = setDataStrategy;
setDataStrategy({
  data: function data() {
    var element = arguments[0];
    var key = arguments[1];
    var value = arguments[2];
    if (!element) return;
    var elementData = dataMap.get(element);
    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }
    if (key === undefined) {
      return elementData;
    }
    if (arguments.length === 2) {
      return elementData[key];
    }
    elementData[key] = value;
    return value;
  },
  removeData: function removeData(element, key) {
    if (!element) return;
    if (key === undefined) {
      dataMap.delete(element);
    } else {
      var elementData = dataMap.get(element);
      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function cleanData(elements) {
    for (var i = 0; i < elements.length; i++) {
      _events_engine.default.off(elements[i]);
      dataMap.delete(elements[i]);
    }
  }
});
function getDataStrategy() {
  return strategy;
}
function data() {
  return strategy.data.apply(this, arguments);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function afterCleanData(callback) {
  afterCleanDataFunc = callback;
}
function cleanData(nodes) {
  return strategy.cleanData.call(this, nodes);
}
function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!_dom_adapter.default.isElementNode(element)) {
    return;
  }
  var childElements = element.getElementsByTagName('*');
  strategy.cleanData(childElements);
  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}

/***/ }),

/***/ 17381:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _error = _interopRequireDefault(__webpack_require__(95640));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
* @docid
* @name ErrorsCore
*/
var _default = (0, _error.default)({
  /**
  * @name ErrorsCore.E0001
  */
  E0001: 'Method is not implemented',
  /**
  * @name ErrorsCore.E0002
  */
  E0002: 'Member name collision: {0}',
  /**
  * @name ErrorsCore.E0003
  */
  E0003: 'A class must be instantiated using the \'new\' keyword',
  /**
  * @name ErrorsCore.E0004
  */
  E0004: 'The NAME property of the component is not specified',
  /**
  * @name ErrorsCore.E0005
  */
  E0005: 'Unknown device',
  /**
  * @name ErrorsCore.E0006
  */
  E0006: 'Unknown endpoint key is requested',
  /**
  * @name ErrorsCore.E0007
  */
  E0007: '\'Invalidate\' method is called outside the update transaction',
  /**
  * @name ErrorsCore.E0008
  */
  E0008: 'Type of the option name is not appropriate to create an action',
  /**
  * @name ErrorsCore.E0009
  */
  E0009: 'Component \'{0}\' has not been initialized for an element',
  /**
  * @name ErrorsCore.E0010
  */
  E0010: 'Animation configuration with the \'{0}\' type requires \'{1}\' configuration as {2}',
  /**
  * @name ErrorsCore.E0011
  */
  E0011: 'Unknown animation type \'{0}\'',
  /**
  * @name ErrorsCore.E0012
  */
  E0012: 'jQuery version is too old. Please upgrade jQuery to 1.10.0 or later',
  /**
  * @name ErrorsCore.E0013
  */
  E0013: 'KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later',
  /**
  * @name ErrorsCore.E0014
  */
  E0014: 'The \'release\' method shouldn\'t be called for an unlocked Lock object',
  /**
  * @name ErrorsCore.E0015
  */
  E0015: 'Queued task returned an unexpected result',
  /**
  * @name ErrorsCore.E0017
  */
  E0017: 'Event namespace is not defined',
  /**
  * @name ErrorsCore.E0018
  */
  E0018: 'DevExpress.ui.DevExpressPopup widget is required',
  /**
  * @name ErrorsCore.E0020
  */
  E0020: 'Template engine \'{0}\' is not supported',
  /**
  * @name ErrorsCore.E0021
  */
  E0021: 'Unknown theme is set: {0}',
  /**
  * @name ErrorsCore.E0022
  */
  E0022: 'LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts',
  /**
  * @name ErrorsCore.E0023
  */
  E0023: 'Template name is not specified',
  /**
  * @name ErrorsCore.E0024
  */
  E0024: 'DevExtreme bundle already included',
  /**
  * @name ErrorsCore.E0025
  */
  E0025: 'Unexpected argument type',
  /**
  * @name ErrorsCore.E0100
  */
  E0100: 'Unknown validation type is detected',
  /**
  * @name ErrorsCore.E0101
  */
  E0101: 'Misconfigured range validation rule is detected',
  /**
  * @name ErrorsCore.E0102
  */
  E0102: 'Misconfigured comparison validation rule is detected',
  /**
  * @name ErrorsCore.E0103
  */
  E0103: 'validationCallback of an asynchronous rule should return a jQuery or a native promise',
  /**
  * @name ErrorsCore.E0110
  */
  E0110: 'Unknown validation group is detected',
  /**
  * @name ErrorsCore.E0120
  */
  E0120: 'Adapter for a DevExpressValidator component cannot be configured',
  /**
  * @name ErrorsCore.E0121
  */
  E0121: 'The \'customItem\' parameter of the \'onCustomItemCreating\' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.',
  /**
  * @name ErrorsCore.W0000
  */
  W0000: '\'{0}\' is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0001
  */
  W0001: '{0} - \'{1}\' option is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0002
  */
  W0002: '{0} - \'{1}\' method is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0003
  */
  W0003: '{0} - \'{1}\' property is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0004
  */
  W0004: 'Timeout for theme loading is over: {0}',
  /**
  * @name ErrorsCore.W0005
  */
  W0005: '\'{0}\' event is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0006
  */
  W0006: 'Invalid recurrence rule: \'{0}\'',
  /**
  * @name ErrorsCore.W0007
  */
  W0007: '\'{0}\' Globalize culture is not defined',
  /**
  * @name ErrorsCore.W0008
  */
  W0008: 'Invalid view name: \'{0}\'',
  /**
  * @name ErrorsCore.W0009
  */
  W0009: 'Invalid time zone name: \'{0}\'',
  /**
  * @name ErrorsCore.W0010
  */
  W0010: '{0} is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0011
  */
  W0011: 'Number parsing is invoked while the parser is not defined',
  /**
  * @name ErrorsCore.W0012
  */
  W0012: 'Date parsing is invoked while the parser is not defined',
  /**
  * @name ErrorsCore.W0013
  */
  W0013: '\'{0}\' file is deprecated in {1}. {2}',
  /**
  * @name ErrorsCore.W0014
  */
  W0014: '{0} - \'{1}\' type is deprecated in {2}. {3}',
  /**
  * @name ErrorsCore.W0015
  */
  W0015: 'Instead of returning a value from the \'{0}\' function, write it into the \'{1}\' field of the function\'s parameter.',
  /**
  * @name ErrorsCore.W0016
  */
  W0016: 'The "{0}" option does not accept the "{1}" value since v{2}. {3}.',
  /**
  * @name ErrorsCore.W0017
  */
  W0017: 'Setting the "{0}" property with a function is deprecated since v21.2',
  /**
  * @name ErrorsCore.W0018
  */
  W0018: 'Setting the "position" property with a function is deprecated since v21.2'
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 80566:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.EventsStrategy = void 0;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var EventsStrategy = /*#__PURE__*/function () {
  function EventsStrategy(owner) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options;
  }
  EventsStrategy.create = function create(owner, strategy) {
    if (strategy) {
      return (0, _type.isFunction)(strategy) ? strategy(owner) : strategy;
    } else {
      return new EventsStrategy(owner);
    }
  };
  var _proto = EventsStrategy.prototype;
  _proto.hasEvent = function hasEvent(eventName) {
    var callbacks = this._events[eventName];
    return callbacks ? callbacks.has() : false;
  };
  _proto.fireEvent = function fireEvent(eventName, eventArgs) {
    var callbacks = this._events[eventName];
    if (callbacks) {
      callbacks.fireWith(this._owner, eventArgs);
    }
    return this._owner;
  };
  _proto.on = function on(eventName, eventHandler) {
    var _this = this;
    if ((0, _type.isPlainObject)(eventName)) {
      (0, _iterator.each)(eventName, function (e, h) {
        _this.on(e, h);
      });
    } else {
      var callbacks = this._events[eventName];
      if (!callbacks) {
        callbacks = (0, _callbacks.default)({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks;
      }
      var addFn = callbacks.originalAdd || callbacks.add;
      addFn.call(callbacks, eventHandler);
    }
  };
  _proto.off = function off(eventName, eventHandler) {
    var callbacks = this._events[eventName];
    if (callbacks) {
      if ((0, _type.isFunction)(eventHandler)) {
        callbacks.remove(eventHandler);
      } else {
        callbacks.empty();
      }
    }
  };
  _proto.dispose = function dispose() {
    (0, _iterator.each)(this._events, function (eventName, event) {
      event.empty();
    });
  };
  return EventsStrategy;
}();
exports.EventsStrategy = EventsStrategy;

/***/ }),

/***/ 73176:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var Guid = _class.default.inherit({
  /**
  * @name Guid.ctor
  * @publicName ctor()
  */
  /**
  * @name Guid.ctor
  * @publicName ctor(value)
  * @param1 value:string
  */
  ctor: function ctor(value) {
    if (value) {
      value = String(value);
    }
    this._value = this._normalize(value || this._generate());
  },
  _normalize: function _normalize(value) {
    value = value.replace(/[^a-f0-9]/ig, '').toLowerCase();
    while (value.length < 32) {
      value += '0';
    }
    return [value.substr(0, 8), value.substr(8, 4), value.substr(12, 4), value.substr(16, 4), value.substr(20, 12)].join('-');
  },
  _generate: function _generate() {
    var value = '';
    for (var i = 0; i < 32; i++) {
      value += Math.round(Math.random() * 15).toString(16);
    }
    return value;
  },
  toString: function toString() {
    return this._value;
  },
  valueOf: function valueOf() {
    return this._value;
  },
  toJSON: function toJSON() {
    return this._value;
  }
});
var _default = Guid;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 83448:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _window = __webpack_require__(58201);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var nativeXMLHttpRequest = {
  getXhr: function getXhr() {
    return new window.XMLHttpRequest();
  }
};
var _default = (0, _dependency_injector.default)(nativeXMLHttpRequest);
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 15334:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _inferno = __webpack_require__(65414);
var _inferno2 = __webpack_require__(74219);
var _infernoCreateElement = __webpack_require__(99038);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _element_data = __webpack_require__(97906);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var remove = function remove(element) {
  var parentNode = element.parentNode;
  if (parentNode) {
    var nextSibling = element.nextSibling;
    (0, _element_data.cleanDataRecursive)(element);
    parentNode.$V = element.$V;
    (0, _inferno.render)(null, parentNode);
    parentNode.insertBefore(element, nextSibling);
    element.innerHTML = '';
    delete parentNode.$V;
  }
  delete element.$V;
};
var _default = (0, _dependency_injector.default)({
  createElement: function createElement(component, props) {
    return (0, _infernoCreateElement.createElement)(component, props);
  },
  remove,
  onAfterRender: function onAfterRender() {
    _inferno2.InfernoEffectHost.callEffects();
  },
  onPreRender: function onPreRender() {
    _inferno2.InfernoEffectHost.lock();
  },
  render: function render(component, props, container, replace) {
    if (!replace) {
      var parentNode = container.parentNode;
      var nextNode = container === null || container === void 0 ? void 0 : container.nextSibling;
      var rootNode = _dom_adapter.default.createElement('div');
      rootNode.appendChild(container);
      var mountNode = _dom_adapter.default.createDocumentFragment().appendChild(rootNode);
      var vNodeAlreadyExists = !!container.$V;
      vNodeAlreadyExists && remove(container);
      (0, _inferno2.hydrate)((0, _infernoCreateElement.createElement)(component, props), mountNode);
      container.$V = mountNode.$V;
      if (parentNode) {
        parentNode.insertBefore(container, nextNode);
      }
    } else {
      (0, _inferno.render)((0, _infernoCreateElement.createElement)(component, props), container);
    }
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 83358:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var MemorizedCallbacks = /*#__PURE__*/function () {
  function MemorizedCallbacks() {
    this.memory = [];
    this.callbacks = (0, _callbacks.default)();
  }
  var _proto = MemorizedCallbacks.prototype;
  _proto.add = function add(fn) {
    (0, _iterator.each)(this.memory, function (_, item) {
      return fn.apply(fn, item);
    });
    this.callbacks.add(fn);
  };
  _proto.remove = function remove(fn) {
    this.callbacks.remove(fn);
  };
  _proto.fire = function fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  };
  return MemorizedCallbacks;
}();
exports["default"] = MemorizedCallbacks;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 95683:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Options = void 0;
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _option_manager = __webpack_require__(9030);
var _data = __webpack_require__(47617);
var _utils = __webpack_require__(45434);
var _extend = __webpack_require__(13306);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var Options = /*#__PURE__*/function () {
  function Options(options, defaultOptions, optionsByReference, deprecatedOptions) {
    var _this = this;
    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._default = defaultOptions;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];
    this._initDeprecatedNames();
    this._optionManager = new _option_manager.OptionManager(options, optionsByReference);
    this._optionManager.onRelevantNamesPrepared(function (options, name, value, silent) {
      return _this._setRelevantNames(options, name, value, silent);
    });
    this._cachedOptions = {};
    this._rules = [];
  }
  var _proto = Options.prototype;
  _proto._initDeprecatedNames = function _initDeprecatedNames() {
    for (var optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  };
  _proto._getByRules = function _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return (0, _utils.convertRulesToOptions)(rules);
  };
  _proto._notifyDeprecated = function _notifyDeprecated(option) {
    var info = this._deprecated[option];
    if (info) {
      this._deprecatedCallback(option, info);
    }
  };
  _proto._setRelevantNames = function _setRelevantNames(options, name, value, silent) {
    if (name) {
      var normalizedName = this._normalizeName(name, silent);
      if (normalizedName && normalizedName !== name) {
        this._setField(options, normalizedName, value);
        this._clearField(options, name);
      }
    }
  };
  _proto._setField = function _setField(options, fullName, value) {
    var fieldName = '';
    var fieldObject = null;
    do {
      fieldName = fieldName ? ".".concat(fieldName) : '';
      fieldName = (0, _utils.getFieldName)(fullName) + fieldName;
      fullName = (0, _utils.getParentName)(fullName);
      fieldObject = fullName ? this._optionManager.get(options, fullName, false) : options;
    } while (!fieldObject);
    fieldObject[fieldName] = value;
  };
  _proto._clearField = function _clearField(options, name) {
    delete options[name];
    var previousFieldName = (0, _utils.getParentName)(name);
    var fieldObject = previousFieldName ? this._optionManager.get(options, previousFieldName, false) : options;
    if (fieldObject) {
      delete fieldObject[(0, _utils.getFieldName)(name)];
    }
  };
  _proto._normalizeName = function _normalizeName(name, silent) {
    if (this._deprecatedNames.length && name) {
      for (var i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name) {
          var deprecate = this._deprecated[name];
          if (deprecate) {
            !silent && this._notifyDeprecated(name);
            return deprecate.alias || name;
          }
        }
      }
    }
    return name;
  };
  _proto.addRules = function addRules(rules) {
    this._rules = rules.concat(this._rules);
  };
  _proto.applyRules = function applyRules(rules) {
    var options = this._getByRules(rules);
    this.silent(options);
  };
  _proto.dispose = function dispose() {
    this._deprecatedCallback = _common.noop;
    this._startChangeCallback = _common.noop;
    this._endChangeCallback = _common.noop;
    this._optionManager.dispose();
  };
  _proto.onChanging = function onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  };
  _proto.onChanged = function onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  };
  _proto.onDeprecated = function onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  };
  _proto.onStartChange = function onStartChange(callBack) {
    this._startChangeCallback = callBack;
  };
  _proto.onEndChange = function onEndChange(callBack) {
    this._endChangeCallback = callBack;
  };
  _proto.isInitial = function isInitial(name) {
    var value = this.silent(name);
    var initialValue = this.initial(name);
    var areFunctions = (0, _type.isFunction)(value) && (0, _type.isFunction)(initialValue);
    return areFunctions ? value.toString() === initialValue.toString() : (0, _common.equalByValue)(value, initialValue);
  };
  _proto.initial = function initial(name) {
    return (0, _utils.getNestedOptionValue)(this._initial, name);
  };
  _proto.option = function option(options, value) {
    var isGetter = arguments.length < 2 && (0, _type.type)(options) !== 'object';
    if (isGetter) {
      return this._optionManager.get(undefined, this._normalizeName(options));
    } else {
      this._startChangeCallback();
      try {
        this._optionManager.set(options, value);
      } finally {
        this._endChangeCallback();
      }
    }
  };
  _proto.silent = function silent(options, value) {
    var isGetter = arguments.length < 2 && (0, _type.type)(options) !== 'object';
    if (isGetter) {
      return this._optionManager.get(undefined, options, undefined, true);
    } else {
      this._optionManager.set(options, value, undefined, true);
    }
  };
  _proto.reset = function reset(name) {
    var _this2 = this;
    if (name) {
      var fullPath = (0, _data.getPathParts)(name);
      var value = fullPath.reduce(function (value, field) {
        return value ? value[field] : _this2.initial(field);
      }, null);
      var defaultValue = (0, _type.isObject)(value) ? _extends({}, value) : value;
      this._optionManager.set(name, defaultValue, false);
    }
  };
  _proto.getAliasesByName = function getAliasesByName(name) {
    var _this3 = this;
    return Object.keys(this._deprecated).filter(function (aliasName) {
      return name === _this3._deprecated[aliasName].alias;
    });
  };
  _proto.isDeprecated = function isDeprecated(name) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name);
  };
  _proto.cache = function cache(name, options) {
    var isGetter = arguments.length < 2;
    if (isGetter) {
      return this._cachedOptions[name];
    } else {
      this._cachedOptions[name] = (0, _extend.extend)(this._cachedOptions[name], options);
    }
  };
  _createClass(Options, [{
    key: "_initial",
    get: function get() {
      if (!this._initialOptions) {
        var rulesOptions = this._getByRules(this.silent('defaultOptionsRules'));
        this._initialOptions = this._default;
        this._optionManager._setByReference(this._initialOptions, rulesOptions);
      }
      return this._initialOptions;
    },
    set: function set(value) {
      this._initialOptions = value;
    }
  }]);
  return Options;
}();
exports.Options = Options;

/***/ }),

/***/ 9030:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.OptionManager = void 0;
var _data = __webpack_require__(47617);
var _common = __webpack_require__(20576);
var _comparator = __webpack_require__(49036);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(45434);
var cachedGetters = {};
var cachedSetters = {};
var OptionManager = /*#__PURE__*/function () {
  function OptionManager(options, optionsByReference) {
    this._options = options;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
  }
  var _proto = OptionManager.prototype;
  _proto._setByReference = function _setByReference(options, rulesOptions) {
    (0, _extend.extend)(true, options, rulesOptions);
    for (var fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options[fieldName] = rulesOptions[fieldName];
      }
    }
  };
  _proto._setPreparedValue = function _setPreparedValue(name, value, merge, silent) {
    var previousValue = this.get(this._options, name, false);
    if (!(0, _comparator.equals)(previousValue, value)) {
      var path = (0, _data.getPathParts)(name);
      !silent && this._changingCallback(name, previousValue, value);
      cachedSetters[name] = cachedSetters[name] || (0, _data.compileSetter)(name);
      cachedSetters[name](this._options, value, {
        functionsAsIs: true,
        merge: (0, _type.isDefined)(merge) ? merge : !this._optionsByReference[name],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name, value, previousValue);
    }
  };
  _proto._prepareRelevantNames = function _prepareRelevantNames(options, name, value, silent) {
    if ((0, _type.isPlainObject)(value)) {
      for (var valueName in value) {
        this._prepareRelevantNames(options, "".concat(name, ".").concat(valueName), value[valueName]);
      }
    }
    this._namePreparedCallbacks(options, name, value, silent);
  };
  _proto.get = function get() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options;
    var name = arguments.length > 1 ? arguments[1] : undefined;
    var unwrapObservables = arguments.length > 2 ? arguments[2] : undefined;
    cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
    return cachedGetters[name](options, {
      functionsAsIs: true,
      unwrapObservables
    });
  };
  _proto.set = function set(options, value, merge, silent) {
    options = (0, _utils.normalizeOptions)(options, value);
    for (var name in options) {
      this._prepareRelevantNames(options, name, options[name], silent);
    }
    for (var _name in options) {
      this._setPreparedValue(_name, options[_name], merge, silent);
    }
  };
  _proto.onRelevantNamesPrepared = function onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  };
  _proto.onChanging = function onChanging(callBack) {
    this._changingCallback = callBack;
  };
  _proto.onChanged = function onChanged(callBack) {
    this._changedCallback = callBack;
  };
  _proto.dispose = function dispose() {
    this._changingCallback = _common.noop;
    this._changedCallback = _common.noop;
  };
  return OptionManager;
}();
exports.OptionManager = OptionManager;

/***/ }),

/***/ 45434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.normalizeOptions = exports.getParentName = exports.getNestedOptionValue = exports.getFieldName = exports.deviceMatch = exports.createDefaultOptionRules = exports.convertRulesToOptions = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _data = __webpack_require__(47617);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var cachedGetters = {};
var convertRulesToOptions = function convertRulesToOptions(rules) {
  var currentDevice = _devices.default.current();
  return rules.reduce(function (options, _ref) {
    var device = _ref.device,
      ruleOptions = _ref.options;
    var deviceFilter = device || {};
    var match = (0, _type.isFunction)(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
    if (match) {
      (0, _extend.extend)(true, options, ruleOptions);
    }
    return options;
  }, {});
};
exports.convertRulesToOptions = convertRulesToOptions;
var normalizeOptions = function normalizeOptions(options, value) {
  return typeof options !== 'string' ? options : {
    [options]: value
  };
};
exports.normalizeOptions = normalizeOptions;
var deviceMatch = function deviceMatch(device, filter) {
  return (0, _type.isEmptyObject)(filter) || (0, _common.findBestMatches)(device, [filter]).length > 0;
};
exports.deviceMatch = deviceMatch;
var getFieldName = function getFieldName(fullName) {
  return fullName.substr(fullName.lastIndexOf('.') + 1);
};
exports.getFieldName = getFieldName;
var getParentName = function getParentName(fullName) {
  return fullName.substr(0, fullName.lastIndexOf('.'));
};
exports.getParentName = getParentName;
var getNestedOptionValue = function getNestedOptionValue(optionsObject, name) {
  cachedGetters[name] = cachedGetters[name] || (0, _data.compileGetter)(name);
  return cachedGetters[name](optionsObject, {
    functionsAsIs: true
  });
};
exports.getNestedOptionValue = getNestedOptionValue;
var createDefaultOptionRules = function createDefaultOptionRules() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return options;
};
exports.createDefaultOptionRules = createDefaultOptionRules;

/***/ }),

/***/ 90889:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.PostponedOperations = void 0;
var _deferred = __webpack_require__(62754);
var _type = __webpack_require__(35922);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var PostponedOperations = /*#__PURE__*/function () {
  function PostponedOperations() {
    this._postponedOperations = {};
  }
  var _proto = PostponedOperations.prototype;
  _proto.add = function add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      var completePromise = new _deferred.Deferred();
      this._postponedOperations[key] = {
        fn: fn,
        completePromise: completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }
    return this._postponedOperations[key].completePromise.promise();
  };
  _proto.callPostponedOperations = function callPostponedOperations() {
    for (var key in this._postponedOperations) {
      var operation = this._postponedOperations[key];
      if ((0, _type.isDefined)(operation)) {
        if (operation.promises && operation.promises.length) {
          _deferred.when.apply(void 0, _toConsumableArray(operation.promises)).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }
    this._postponedOperations = {};
  };
  return PostponedOperations;
}();
exports.PostponedOperations = PostponedOperations;

/***/ }),

/***/ 68374:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer_base = _interopRequireDefault(__webpack_require__(82981));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _renderer_base.default.get();
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82981:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _element_data = __webpack_require__(97906);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _type = __webpack_require__(35922);
var _style = __webpack_require__(80968);
var _size = __webpack_require__(58664);
var _html_parser = __webpack_require__(61371);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var renderer;
var initRender = function initRender(selector, context) {
  if (!selector) {
    this.length = 0;
    return this;
  }
  if (typeof selector === 'string') {
    if (selector === 'body') {
      this[0] = context ? context.body : _dom_adapter.default.getBody();
      this.length = 1;
      return this;
    }
    context = context || _dom_adapter.default.getDocument();
    if (selector[0] === '<') {
      this[0] = _dom_adapter.default.createElement(selector.slice(1, -1), context);
      this.length = 1;
      return this;
    }
    [].push.apply(this, _dom_adapter.default.querySelectorAll(context, selector));
    return this;
  } else if (_dom_adapter.default.isNode(selector) || (0, _type.isWindow)(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  } else if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }
  return renderer(selector.toArray ? selector.toArray() : [selector]);
};
renderer = function renderer(selector, context) {
  return new initRender(selector, context);
};
renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;
var repeatMethod = function repeatMethod(methodName, args) {
  for (var i = 0; i < this.length; i++) {
    var item = renderer(this[i]);
    item[methodName].apply(item, args);
  }
  return this;
};
var setAttributeValue = function setAttributeValue(element, attrName, value) {
  if (value !== undefined && value !== null && value !== false) {
    _dom_adapter.default.setAttribute(element, attrName, value);
  } else {
    _dom_adapter.default.removeAttribute(element, attrName);
  }
};
initRender.prototype.show = function () {
  return this.toggle(true);
};
initRender.prototype.hide = function () {
  return this.toggle(false);
};
initRender.prototype.toggle = function (value) {
  if (this[0]) {
    this.toggleClass('dx-state-invisible', !value);
  }
  return this;
};
initRender.prototype.attr = function (attrName, value) {
  if (this.length > 1 && arguments.length > 1) return repeatMethod.call(this, 'attr', arguments);
  if (!this[0]) {
    if ((0, _type.isObject)(attrName) || value !== undefined) {
      return this;
    } else {
      return undefined;
    }
  }
  if (!this[0].getAttribute) {
    return this.prop(attrName, value);
  }
  if (typeof attrName === 'string' && arguments.length === 1) {
    var result = this[0].getAttribute(attrName);
    return result == null ? undefined : result;
  } else if ((0, _type.isPlainObject)(attrName)) {
    for (var key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value);
  }
  return this;
};
initRender.prototype.removeAttr = function (attrName) {
  this[0] && _dom_adapter.default.removeAttribute(this[0], attrName);
  return this;
};
initRender.prototype.prop = function (propName, value) {
  if (!this[0]) return this;
  if (typeof propName === 'string' && arguments.length === 1) {
    return this[0][propName];
  } else if ((0, _type.isPlainObject)(propName)) {
    for (var key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    _dom_adapter.default.setProperty(this[0], propName, value);
  }
  return this;
};
initRender.prototype.addClass = function (className) {
  return this.toggleClass(className, true);
};
initRender.prototype.removeClass = function (className) {
  return this.toggleClass(className, false);
};
initRender.prototype.hasClass = function (className) {
  if (!this[0] || this[0].className === undefined) return false;
  var classNames = className.split(' ');
  for (var i = 0; i < classNames.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames[i])) return true;
    } else {
      // IE9
      var _className = (0, _type.isString)(this[0].className) ? this[0].className : _dom_adapter.default.getAttribute(this[0], 'class');
      if ((_className || '').split(' ').indexOf(classNames[i]) >= 0) return true;
    }
  }
  return false;
};
initRender.prototype.toggleClass = function (className, value) {
  if (this.length > 1) {
    return repeatMethod.call(this, 'toggleClass', arguments);
  }
  if (!this[0] || !className) return this;
  value = value === undefined ? !this.hasClass(className) : value;
  var classNames = className.split(' ');
  for (var i = 0; i < classNames.length; i++) {
    _dom_adapter.default.setClass(this[0], classNames[i], value);
  }
  return this;
};
initRender.prototype.html = function (value) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }
  this.empty();
  if (typeof value === 'string' && !(0, _html_parser.isTablePart)(value) || typeof value === 'number') {
    this[0].innerHTML = value;
    return this;
  }
  return this.append((0, _html_parser.parseHTML)(value));
};
var appendElements = function appendElements(element, nextSibling) {
  if (!this[0] || !element) return;
  if (typeof element === 'string') {
    element = (0, _html_parser.parseHTML)(element);
  } else if (element.nodeType) {
    element = [element];
  } else if ((0, _type.isNumeric)(element)) {
    element = [_dom_adapter.default.createTextNode(element)];
  }
  for (var i = 0; i < element.length; i++) {
    var item = element[i];
    var container = this[0];
    var wrapTR = container.tagName === 'TABLE' && item.tagName === 'TR';
    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }
    _dom_adapter.default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};
var setCss = function setCss(name, value) {
  if (!this[0] || !this[0].style) return;
  if (value === null || typeof value === 'number' && isNaN(value)) {
    return;
  }
  name = (0, _style.styleProp)(name);
  for (var i = 0; i < this.length; i++) {
    this[i].style[name] = (0, _style.normalizeStyleProp)(name, value);
  }
};
initRender.prototype.css = function (name, value) {
  if ((0, _type.isString)(name)) {
    if (arguments.length === 2) {
      setCss.call(this, name, value);
    } else {
      if (!this[0]) return;
      name = (0, _style.styleProp)(name);
      var result = window.getComputedStyle(this[0])[name] || this[0].style[name];
      return (0, _type.isNumeric)(result) ? result.toString() : result;
    }
  } else if ((0, _type.isPlainObject)(name)) {
    for (var key in name) {
      setCss.call(this, key, name[key]);
    }
  }
  return this;
};
initRender.prototype.prepend = function (element) {
  if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};
initRender.prototype.append = function (element) {
  if (arguments.length > 1) {
    for (var i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element]);
  return this;
};
initRender.prototype.prependTo = function (element) {
  if (this.length > 1) {
    for (var i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }
    return this;
  }
  element = renderer(element);
  if (element[0]) {
    _dom_adapter.default.insertElement(element[0], this[0], element[0].firstChild);
  }
  return this;
};
initRender.prototype.appendTo = function (element) {
  if (this.length > 1) {
    return repeatMethod.call(this, 'appendTo', arguments);
  }
  _dom_adapter.default.insertElement(renderer(element)[0], this[0]);
  return this;
};
initRender.prototype.insertBefore = function (element) {
  if (element && element[0]) {
    _dom_adapter.default.insertElement(element[0].parentNode, this[0], element[0]);
  }
  return this;
};
initRender.prototype.insertAfter = function (element) {
  if (element && element[0]) {
    _dom_adapter.default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }
  return this;
};
initRender.prototype.before = function (element) {
  if (this[0]) {
    _dom_adapter.default.insertElement(this[0].parentNode, element[0], this[0]);
  }
  return this;
};
initRender.prototype.after = function (element) {
  if (this[0]) {
    _dom_adapter.default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }
  return this;
};
initRender.prototype.wrap = function (wrapper) {
  if (this[0]) {
    var wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }
  return this;
};
initRender.prototype.wrapInner = function (wrapper) {
  var contents = this.contents();
  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }
  return this;
};
initRender.prototype.replaceWith = function (element) {
  if (!(element && element[0])) return;
  if (element.is(this)) return this;
  element.insertBefore(this);
  this.remove();
  return element;
};
initRender.prototype.remove = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'remove', arguments);
  }
  (0, _element_data.cleanDataRecursive)(this[0], true);
  _dom_adapter.default.removeElement(this[0]);
  return this;
};
initRender.prototype.detach = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'detach', arguments);
  }
  _dom_adapter.default.removeElement(this[0]);
  return this;
};
initRender.prototype.empty = function () {
  if (this.length > 1) {
    return repeatMethod.call(this, 'empty', arguments);
  }
  (0, _element_data.cleanDataRecursive)(this[0]);
  _dom_adapter.default.setText(this[0], '');
  return this;
};
initRender.prototype.clone = function () {
  var result = [];
  for (var i = 0; i < this.length; i++) {
    result.push(this[i].cloneNode(true));
  }
  return renderer(result);
};
initRender.prototype.text = function (value) {
  if (!arguments.length) {
    var result = '';
    for (var i = 0; i < this.length; i++) {
      result += this[i] && this[i].textContent || '';
    }
    return result;
  }
  var text = (0, _type.isFunction)(value) ? value() : value;
  (0, _element_data.cleanDataRecursive)(this[0], false);
  _dom_adapter.default.setText(this[0], (0, _type.isDefined)(text) ? text : '');
  return this;
};
initRender.prototype.val = function (value) {
  if (arguments.length === 1) {
    return this.prop('value', (0, _type.isDefined)(value) ? value : '');
  }
  return this.prop('value');
};
initRender.prototype.contents = function () {
  if (!this[0]) return renderer();
  var result = [];
  result.push.apply(result, this[0].childNodes);
  return renderer(result);
};
initRender.prototype.find = function (selector) {
  var result = renderer();
  if (!selector) {
    return result;
  }
  var nodes = [];
  var i;
  if (typeof selector === 'string') {
    selector = selector.trim();
    for (i = 0; i < this.length; i++) {
      var element = this[i];
      if (_dom_adapter.default.isElementNode(element)) {
        var elementId = element.getAttribute('id');
        var queryId = elementId || 'dx-query-children';
        if (!elementId) {
          setAttributeValue(element, 'id', queryId);
        }
        queryId = '[id=\'' + queryId + '\'] ';
        var querySelector = queryId + selector.replace(/([^\\])(,)/g, '$1, ' + queryId);
        nodes.push.apply(nodes, _dom_adapter.default.querySelectorAll(element, querySelector));
        setAttributeValue(element, 'id', elementId);
      } else if (_dom_adapter.default.isDocument(element) || _dom_adapter.default.isDocumentFragment(element)) {
        nodes.push.apply(nodes, _dom_adapter.default.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = _dom_adapter.default.isNode(selector) ? selector : selector[0];
      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }
  return result.add(nodes);
};
var isVisible = function isVisible(_, element) {
  var _element$host;
  element = (_element$host = element.host) !== null && _element$host !== void 0 ? _element$host : element;
  if (!element.nodeType) return true;
  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
};
initRender.prototype.filter = function (selector) {
  if (!selector) return renderer();
  if (selector === ':visible') {
    return this.filter(isVisible);
  } else if (selector === ':hidden') {
    return this.filter(function (_, element) {
      return !isVisible(_, element);
    });
  }
  var result = [];
  for (var i = 0; i < this.length; i++) {
    var item = this[i];
    if (_dom_adapter.default.isElementNode(item) && (0, _type.type)(selector) === 'string') {
      _dom_adapter.default.elementMatches(item, selector) && result.push(item);
    } else if (_dom_adapter.default.isNode(selector) || (0, _type.isWindow)(selector)) {
      selector === item && result.push(item);
    } else if ((0, _type.isFunction)(selector)) {
      selector.call(item, i, item) && result.push(item);
    } else {
      for (var j = 0; j < selector.length; j++) {
        selector[j] === item && result.push(item);
      }
    }
  }
  return renderer(result);
};
initRender.prototype.not = function (selector) {
  var result = [];
  var nodes = this.filter(selector).toArray();
  for (var i = 0; i < this.length; i++) {
    if (nodes.indexOf(this[i]) === -1) {
      result.push(this[i]);
    }
  }
  return renderer(result);
};
initRender.prototype.is = function (selector) {
  return !!this.filter(selector).length;
};
initRender.prototype.children = function (selector) {
  var result = [];
  for (var i = 0; i < this.length; i++) {
    var nodes = this[i] ? this[i].childNodes : [];
    for (var j = 0; j < nodes.length; j++) {
      if (_dom_adapter.default.isElementNode(nodes[j])) {
        result.push(nodes[j]);
      }
    }
  }
  result = renderer(result);
  return selector ? result.filter(selector) : result;
};
initRender.prototype.siblings = function () {
  var element = this[0];
  if (!element || !element.parentNode) {
    return renderer();
  }
  var result = [];
  var parentChildNodes = element.parentNode.childNodes || [];
  for (var i = 0; i < parentChildNodes.length; i++) {
    var node = parentChildNodes[i];
    if (_dom_adapter.default.isElementNode(node) && node !== element) {
      result.push(node);
    }
  }
  return renderer(result);
};
initRender.prototype.each = function (callback) {
  for (var i = 0; i < this.length; i++) {
    if (callback.call(this[i], i, this[i]) === false) {
      break;
    }
  }
};
initRender.prototype.index = function (element) {
  if (!element) {
    return this.parent().children().index(this);
  }
  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};
initRender.prototype.get = function (index) {
  return this[index < 0 ? this.length + index : index];
};
initRender.prototype.eq = function (index) {
  index = index < 0 ? this.length + index : index;
  return renderer(this[index]);
};
initRender.prototype.first = function () {
  return this.eq(0);
};
initRender.prototype.last = function () {
  return this.eq(-1);
};
initRender.prototype.select = function () {
  for (var i = 0; i < this.length; i += 1) {
    this[i].select && this[i].select();
  }
  return this;
};
initRender.prototype.parent = function (selector) {
  if (!this[0]) return renderer();
  var result = renderer(this[0].parentNode);
  return !selector || result.is(selector) ? result : renderer();
};
initRender.prototype.parents = function (selector) {
  var result = [];
  var parent = this.parent();
  while (parent && parent[0] && !_dom_adapter.default.isDocument(parent[0])) {
    if (_dom_adapter.default.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result.push(parent.get(0));
      }
    }
    parent = parent.parent();
  }
  return renderer(result);
};
initRender.prototype.closest = function (selector) {
  if (this.is(selector)) {
    return this;
  }
  var parent = this.parent();
  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }
    parent = parent.parent();
  }
  return renderer();
};
initRender.prototype.next = function (selector) {
  if (!this[0]) return renderer();
  var next = renderer(this[0].nextSibling);
  if (!arguments.length) {
    return next;
  }
  while (next && next.length) {
    if (next.is(selector)) return next;
    next = next.next();
  }
  return renderer();
};
initRender.prototype.prev = function () {
  if (!this[0]) return renderer();
  return renderer(this[0].previousSibling);
};
initRender.prototype.add = function (selector) {
  var targets = renderer(selector);
  var result = this.toArray();
  for (var i = 0; i < targets.length; i++) {
    var target = targets[i];
    if (result.indexOf(target) === -1) {
      result.push(target);
    }
  }
  return renderer(result);
};
var emptyArray = [];
initRender.prototype.splice = function () {
  return renderer(emptyArray.splice.apply(this, arguments));
};
initRender.prototype.slice = function () {
  return renderer(emptyArray.slice.apply(this, arguments));
};
initRender.prototype.toArray = function () {
  return emptyArray.slice.call(this);
};
initRender.prototype.offset = function () {
  if (!this[0]) return;
  return (0, _size.getOffset)(this[0]);
};
initRender.prototype.offsetParent = function () {
  if (!this[0]) return renderer();
  var offsetParent = renderer(this[0].offsetParent);
  while (offsetParent[0] && offsetParent.css('position') === 'static') {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }
  offsetParent = offsetParent[0] ? offsetParent : renderer(_dom_adapter.default.getDocumentElement());
  return offsetParent;
};
initRender.prototype.position = function () {
  if (!this[0]) return;
  var offset;
  var marginTop = parseFloat(this.css('marginTop'));
  var marginLeft = parseFloat(this.css('marginLeft'));
  if (this.css('position') === 'fixed') {
    offset = this[0].getBoundingClientRect();
    return {
      top: offset.top - marginTop,
      left: offset.left - marginLeft
    };
  }
  offset = this.offset();
  var offsetParent = this.offsetParent();
  var parentOffset = {
    top: 0,
    left: 0
  };
  if (offsetParent[0].nodeName !== 'HTML') {
    parentOffset = offsetParent.offset();
  }
  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css('borderTopWidth')),
    left: parentOffset.left + parseFloat(offsetParent.css('borderLeftWidth'))
  };
  return {
    top: offset.top - parentOffset.top - marginTop,
    left: offset.left - parentOffset.left - marginLeft
  };
};
[{
  name: 'scrollLeft',
  offsetProp: 'pageXOffset',
  scrollWindow: function scrollWindow(win, value) {
    win.scrollTo(value, win.pageYOffset);
  }
}, {
  name: 'scrollTop',
  offsetProp: 'pageYOffset',
  scrollWindow: function scrollWindow(win, value) {
    win.scrollTo(win.pageXOffset, value);
  }
}].forEach(function (directionStrategy) {
  var propName = directionStrategy.name;
  initRender.prototype[propName] = function (value) {
    if (!this[0]) {
      return;
    }
    var window = (0, _size.getWindowByElement)(this[0]);
    if (value === undefined) {
      return window ? window[directionStrategy.offsetProp] : this[0][propName];
    }
    if (window) {
      directionStrategy.scrollWindow(window, value);
    } else {
      this[0][propName] = value;
    }
    return this;
  };
});
initRender.prototype.data = function (key, value) {
  if (!this[0]) return;
  if (arguments.length < 2) {
    return _element_data.data.call(renderer, this[0], key);
  }
  _element_data.data.call(renderer, this[0], key, value);
  return this;
};
initRender.prototype.removeData = function (key) {
  this[0] && (0, _element_data.removeData)(this[0], key);
  return this;
};
var rendererWrapper = function rendererWrapper() {
  return renderer.apply(this, arguments);
};
Object.defineProperty(rendererWrapper, 'fn', {
  enumerable: true,
  configurable: true,
  get: function get() {
    return renderer.fn;
  },
  set: function set(value) {
    renderer.fn = value;
  }
});
var _default = {
  set: function set(strategy) {
    renderer = strategy;
  },
  get: function get() {
    return rendererWrapper;
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 91784:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _window = __webpack_require__(58201);
var window = (0, _window.getWindow)();
var ResizeObserverMock = {
  observe: _common.noop,
  unobserve: _common.noop,
  disconnect: _common.noop
};
var ResizeObserverSingleton = /*#__PURE__*/function () {
  function ResizeObserverSingleton() {
    var _this = this;
    if (!(0, _window.hasWindow)() || !window.ResizeObserver) {
      return ResizeObserverMock;
    }
    this._callbacksMap = new Map();
    this._observer = new window.ResizeObserver(function (entries) {
      entries.forEach(function (entry) {
        var _this$_callbacksMap$g;
        (_this$_callbacksMap$g = _this._callbacksMap.get(entry.target)) === null || _this$_callbacksMap$g === void 0 ? void 0 : _this$_callbacksMap$g(entry);
      });
    });
  }
  var _proto = ResizeObserverSingleton.prototype;
  _proto.observe = function observe(element, callback) {
    this._callbacksMap.set(element, callback);
    this._observer.observe(element);
  };
  _proto.unobserve = function unobserve(element) {
    this._callbacksMap.delete(element);
    this._observer.unobserve(element);
  };
  _proto.disconnect = function disconnect() {
    this._callbacksMap.clear();
    this._observer.disconnect();
  };
  return ResizeObserverSingleton;
}();
var resizeObserverSingleton = new ResizeObserverSingleton();
var _default = resizeObserverSingleton;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 14192:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.TemplateManager = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _function_template = __webpack_require__(68494);
var _empty_template = __webpack_require__(10688);
var _template_manager = __webpack_require__(69697);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var TEXT_NODE = 3;
var ANONYMOUS_TEMPLATE_NAME = 'template';
var TEMPLATE_OPTIONS_NAME = 'dxTemplate';
var TEMPLATE_WRAPPER_CLASS = 'dx-template-wrapper';
var DX_POLYMORPH_WIDGET_TEMPLATE = new _function_template.FunctionTemplate(function (_ref) {
  var model = _ref.model,
    parent = _ref.parent;
  var widgetName = model.widget;
  if (!widgetName) return (0, _renderer.default)();
  var widgetElement = (0, _renderer.default)('<div>');
  var widgetOptions = model.options || {};
  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }
  return widgetElement;
});
var TemplateManager = /*#__PURE__*/function () {
  function TemplateManager(createElement, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || ANONYMOUS_TEMPLATE_NAME;
    this._createElement = createElement || _template_manager.defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  TemplateManager.createDefaultOptions = function createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function watchMethod(fn, callback) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          if (!options.skipImmediate) {
            callback(fn());
          }
          return _common.noop;
        },
        templates: {
          'dx-polymorph-widget': DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  };
  var _proto = TemplateManager.prototype;
  _proto.addDefaultTemplates = function addDefaultTemplates(templates) {
    this._defaultTemplates = (0, _extend.extend)({}, this._defaultTemplates, templates);
  };
  _proto.dispose = function dispose() {
    this._tempTemplates.forEach(function (tempTemplate) {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });
    this._tempTemplates = [];
  };
  _proto.extractTemplates = function extractTemplates($el) {
    var templates = this._extractTemplates($el);
    var anonymousTemplateMeta = this._extractAnonymousTemplate($el);
    return {
      templates,
      anonymousTemplateMeta
    };
  };
  _proto._extractTemplates = function _extractTemplates($el) {
    var _this = this;
    var templates = (0, _template_manager.findTemplates)($el, TEMPLATE_OPTIONS_NAME);
    var suitableTemplates = (0, _template_manager.suitableTemplatesByName)(templates);
    templates.forEach(function (_ref2) {
      var element = _ref2.element,
        name = _ref2.options.name;
      if (element === suitableTemplates[name]) {
        (0, _renderer.default)(element).addClass(TEMPLATE_WRAPPER_CLASS).detach();
      } else {
        (0, _renderer.default)(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map(function (name) {
      return {
        name,
        template: _this._createTemplate(suitableTemplates[name])
      };
    });
  };
  _proto._extractAnonymousTemplate = function _extractAnonymousTemplate($el) {
    var $anonymousTemplate = $el.contents().detach();
    var $notJunkTemplateContent = $anonymousTemplate.filter(function (_, element) {
      var isTextNode = element.nodeType === TEXT_NODE;
      var isEmptyText = (0, _renderer.default)(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  };
  _proto._createTemplateIfNeeded = function _createTemplateIfNeeded(templateSource) {
    var cachedTemplate = this._tempTemplates.filter(function (tempTemplate) {
      return tempTemplate.source === (0, _template_manager.templateKey)(templateSource);
    })[0];
    if (cachedTemplate) return cachedTemplate.template;
    var template = this._createTemplate(templateSource);
    this._tempTemplates.push({
      template,
      source: (0, _template_manager.templateKey)(templateSource)
    });
    return template;
  };
  _proto._createTemplate = function _createTemplate(templateSource) {
    return this._createElement((0, _template_manager.validateTemplateSource)(templateSource));
  };
  _proto.getTemplate = function getTemplate(templateSource, templates, _ref3, context) {
    var _this2 = this;
    var isAsyncTemplate = _ref3.isAsyncTemplate,
      skipTemplates = _ref3.skipTemplates;
    if (!(0, _type.isFunction)(templateSource)) {
      return (0, _template_manager.acquireTemplate)(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }
    return new _function_template.FunctionTemplate(function (options) {
      var templateSourceResult = templateSource.apply(context, (0, _template_manager.getNormalizedTemplateArgs)(options));
      if (!(0, _type.isDefined)(templateSourceResult)) {
        return new _empty_template.EmptyTemplate();
      }
      var dispose = false;
      var template = (0, _template_manager.acquireTemplate)(templateSourceResult, function (templateSource) {
        if (templateSource.nodeType || (0, _type.isRenderer)(templateSource) && !(0, _renderer.default)(templateSource).is('script')) {
          return new _function_template.FunctionTemplate(function () {
            return templateSource;
          });
        }
        dispose = true;
        return _this2._createTemplate(templateSource);
      }, templates, isAsyncTemplate, skipTemplates, _this2._defaultTemplates);
      var result = template.render(options);
      dispose && template.dispose && template.dispose();
      return result;
    });
  };
  _createClass(TemplateManager, [{
    key: "anonymousTemplateName",
    get: function get() {
      return this._anonymousTemplateName;
    }
  }]);
  return TemplateManager;
}();
exports.TemplateManager = TemplateManager;

/***/ }),

/***/ 93280:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.BindableTemplate = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _template_base = __webpack_require__(81033);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _remove = __webpack_require__(29007);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var watchChanges = function () {
  var globalWatch = function globalWatch(data, watchMethod, callback) {
    return watchMethod(function () {
      return data;
    }, callback);
  };
  var fieldsWatch = function fieldsWatch(data, watchMethod, fields, fieldsMap, callback) {
    var resolvedData = {};
    var missedFields = fields.slice();
    var watchHandlers = fields.map(function (name) {
      var fieldGetter = fieldsMap[name];
      return watchMethod(fieldGetter ? function () {
        return fieldGetter(data);
      } : function () {
        return data[name];
      }, function (value) {
        resolvedData[name] = value;
        if (missedFields.length) {
          var index = missedFields.indexOf(name);
          if (index >= 0) {
            missedFields.splice(index, 1);
          }
        }
        if (!missedFields.length) {
          callback(resolvedData);
        }
      });
    });
    return function () {
      watchHandlers.forEach(function (dispose) {
        return dispose();
      });
    };
  };
  return function (rawData, watchMethod, fields, fieldsMap, callback) {
    var fieldsDispose;
    var globalDispose = globalWatch(rawData, watchMethod, function (dataWithRawFields) {
      fieldsDispose && fieldsDispose();
      if ((0, _type.isPrimitive)(dataWithRawFields)) {
        callback(dataWithRawFields);
        return;
      }
      fieldsDispose = fieldsWatch(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
    });
    return function () {
      fieldsDispose && fieldsDispose();
      globalDispose && globalDispose();
    };
  };
}();
var BindableTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(BindableTemplate, _TemplateBase);
  function BindableTemplate(render, fields, watchMethod, fieldsMap) {
    var _this;
    _this = _TemplateBase.call(this) || this;
    _this._render = render;
    _this._fields = fields;
    _this._fieldsMap = fieldsMap || {};
    _this._watchMethod = watchMethod;
    return _this;
  }
  var _proto = BindableTemplate.prototype;
  _proto._renderCore = function _renderCore(options) {
    var _this2 = this;
    var $container = (0, _renderer.default)(options.container);
    var dispose = watchChanges(options.model, this._watchMethod, this._fields, this._fieldsMap, function (data) {
      $container.empty();
      _this2._render($container, data, options.model);
    });
    _events_engine.default.on($container, _remove.removeEvent, dispose);
    return $container.contents();
  };
  return BindableTemplate;
}(_template_base.TemplateBase);
exports.BindableTemplate = BindableTemplate;

/***/ }),

/***/ 91627:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ChildDefaultTemplate = void 0;
var _template_base = __webpack_require__(81033);
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var ChildDefaultTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(ChildDefaultTemplate, _TemplateBase);
  function ChildDefaultTemplate(name) {
    var _this;
    _this = _TemplateBase.call(this) || this;
    _this.name = name;
    return _this;
  }
  return ChildDefaultTemplate;
}(_template_base.TemplateBase);
exports.ChildDefaultTemplate = ChildDefaultTemplate;

/***/ }),

/***/ 10688:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.EmptyTemplate = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _template_base = __webpack_require__(81033);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var EmptyTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(EmptyTemplate, _TemplateBase);
  function EmptyTemplate() {
    return _TemplateBase.apply(this, arguments) || this;
  }
  var _proto = EmptyTemplate.prototype;
  _proto._renderCore = function _renderCore() {
    return (0, _renderer.default)();
  };
  return EmptyTemplate;
}(_template_base.TemplateBase);
exports.EmptyTemplate = EmptyTemplate;

/***/ }),

/***/ 68494:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.FunctionTemplate = void 0;
var _template_base = __webpack_require__(81033);
var _dom = __webpack_require__(3532);
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var FunctionTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(FunctionTemplate, _TemplateBase);
  function FunctionTemplate(render) {
    var _this;
    _this = _TemplateBase.call(this) || this;
    _this._render = render;
    return _this;
  }
  var _proto = FunctionTemplate.prototype;
  _proto._renderCore = function _renderCore(options) {
    return (0, _dom.normalizeTemplateElement)(this._render(options));
  };
  return FunctionTemplate;
}(_template_base.TemplateBase);
exports.FunctionTemplate = FunctionTemplate;

/***/ }),

/***/ 9545:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Template = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _template_base = __webpack_require__(81033);
var _dom = __webpack_require__(3532);
var _template_engine_registry = __webpack_require__(72987);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
(0, _template_engine_registry.registerTemplateEngine)('default', {
  compile: function compile(element) {
    return (0, _dom.normalizeTemplateElement)(element);
  },
  render: function render(template, model, index) {
    return template.clone();
  }
});
(0, _template_engine_registry.setTemplateEngine)('default');
var Template = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(Template, _TemplateBase);
  function Template(element) {
    var _this;
    _this = _TemplateBase.call(this) || this;
    _this._element = element;
    return _this;
  }
  var _proto = Template.prototype;
  _proto._renderCore = function _renderCore(options) {
    var transclude = options.transclude;
    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = (0, _template_engine_registry.getCurrentTemplateEngine)().compile(this._element);
    }
    return (0, _renderer.default)('<div>').append(transclude ? this._element : (0, _template_engine_registry.getCurrentTemplateEngine)().render(this._compiledTemplate, options.model, options.index)).contents();
  };
  _proto.source = function source() {
    return (0, _renderer.default)(this._element).clone();
  };
  return Template;
}(_template_base.TemplateBase);
exports.Template = Template;

/***/ }),

/***/ 81033:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.renderedCallbacks = exports.TemplateBase = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _dom = __webpack_require__(3532);
var _visibility_change = __webpack_require__(80506);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var renderedCallbacks = (0, _callbacks.default)({
  syncStrategy: true
});
exports.renderedCallbacks = renderedCallbacks;
var TemplateBase = /*#__PURE__*/function () {
  function TemplateBase() {}
  var _proto = TemplateBase.prototype;
  _proto.render = function render(options) {
    options = options || {};
    var onRendered = options.onRendered;
    delete options.onRendered;
    var $result;
    if (options.renovated && options.transclude && this._element) {
      $result = (0, _renderer.default)('<div>').append(this._element).contents();
    } else {
      $result = this._renderCore(options);
    }
    this._ensureResultInContainer($result, options.container);
    renderedCallbacks.fire($result, options.container);
    onRendered && onRendered();
    return $result;
  };
  _proto._ensureResultInContainer = function _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }
    var $container = (0, _renderer.default)(container);
    var resultInContainer = (0, _dom.contains)($container.get(0), $result.get(0));
    $container.append($result);
    if (resultInContainer) {
      return;
    }
    var resultInBody = _dom_adapter.default.getBody().contains($container.get(0));
    if (!resultInBody) {
      return;
    }
    (0, _visibility_change.triggerShownEvent)($result);
  };
  _proto._renderCore = function _renderCore() {
    throw _errors.default.Error('E0001');
  };
  return TemplateBase;
}();
exports.TemplateBase = TemplateBase;

/***/ }),

/***/ 72987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getCurrentTemplateEngine = getCurrentTemplateEngine;
exports.registerTemplateEngine = registerTemplateEngine;
exports.setTemplateEngine = setTemplateEngine;
var _type = __webpack_require__(35922);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var templateEngines = {};
var currentTemplateEngine;
function registerTemplateEngine(name, templateEngine) {
  templateEngines[name] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if ((0, _type.isString)(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw _errors.default.Error('E0020', templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}

/***/ }),

/***/ 37208:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _deferred = __webpack_require__(62754);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _http_request = _interopRequireDefault(__webpack_require__(83448));
var _window = __webpack_require__(58201);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var SUCCESS = 'success';
var ERROR = 'error';
var TIMEOUT = 'timeout';
var NO_CONTENT = 'nocontent';
var PARSER_ERROR = 'parsererror';
var isStatusSuccess = function isStatusSuccess(status) {
  return 200 <= status && status < 300;
};
var hasContent = function hasContent(status) {
  return status !== 204;
};
var paramsConvert = function paramsConvert(params) {
  var result = [];
  for (var name in params) {
    var value = params[name];
    if (value === undefined) {
      continue;
    }
    if (value === null) {
      value = '';
    }
    if (typeof value === 'function') {
      value = value();
    }
    result.push(encodeURIComponent(name) + '=' + encodeURIComponent(value));
  }
  return result.join('&');
};
var createScript = function createScript(options) {
  var script = _dom_adapter.default.createElement('script');
  for (var name in options) {
    script[name] = options[name];
  }
  return script;
};
var removeScript = function removeScript(scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};
var appendToHead = function appendToHead(element) {
  return _dom_adapter.default.getHead().appendChild(element);
};
var evalScript = function evalScript(code) {
  var script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};
var evalCrossDomainScript = function evalCrossDomainScript(url) {
  var script = createScript({
    src: url
  });
  return new Promise(function (resolve, reject) {
    var events = {
      'load': resolve,
      'error': reject
    };
    var loadHandler = function loadHandler(e) {
      events[e.type]();
      removeScript(script);
    };
    for (var event in events) {
      _dom_adapter.default.listen(script, event, loadHandler);
    }
    appendToHead(script);
  });
};
var getAcceptHeader = function getAcceptHeader(options) {
  var dataType = options.dataType || '*';
  var scriptAccept = 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript';
  var accepts = {
    '*': '*/*',
    text: 'text/plain',
    html: 'text/html',
    xml: 'application/xml, text/xml',
    json: 'application/json, text/javascript',
    jsonp: scriptAccept,
    script: scriptAccept
  };
  (0, _extend.extendFromObject)(accepts, options.accepts, true);
  return accepts[dataType] ? accepts[dataType] + (dataType !== '*' ? ', */*; q=0.01' : '') : accepts['*'];
};
var getContentTypeHeader = function getContentTypeHeader(options) {
  var defaultContentType;
  if (options.data && !options.upload && getMethod(options) !== 'GET') {
    defaultContentType = 'application/x-www-form-urlencoded;charset=utf-8';
  }
  return options.contentType || defaultContentType;
};
var getDataFromResponse = function getDataFromResponse(xhr) {
  return xhr.responseType && xhr.responseType !== 'text' || typeof xhr.responseText !== 'string' ? xhr.response : xhr.responseText;
};
var postProcess = function postProcess(deferred, xhr, dataType) {
  var data = getDataFromResponse(xhr);
  switch (dataType) {
    case 'jsonp':
      evalScript(data);
      break;
    case 'script':
      evalScript(data);
      deferred.resolve(data, SUCCESS, xhr);
      break;
    case 'json':
      try {
        deferred.resolve(JSON.parse(data), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }
      break;
    default:
      deferred.resolve(data, SUCCESS, xhr);
  }
};
var isCrossDomain = function isCrossDomain(url) {
  if (!(0, _window.hasWindow)()) {
    return true;
  }
  var crossDomain = false;
  var originAnchor = _dom_adapter.default.createElement('a');
  var urlAnchor = _dom_adapter.default.createElement('a');
  originAnchor.href = window.location.href;
  try {
    urlAnchor.href = url;

    // NOTE: IE11
    // eslint-disable-next-line no-self-assign
    urlAnchor.href = urlAnchor.href;
    crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
  } catch (e) {
    crossDomain = true;
  }
  return crossDomain;
};
var setHttpTimeout = function setHttpTimeout(timeout, xhr) {
  return timeout && setTimeout(function () {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};
var getJsonpOptions = function getJsonpOptions(options) {
  if (options.dataType === 'jsonp') {
    var random = Math.random().toString().replace(/\D/g, '');
    var callbackName = options.jsonpCallback || 'dxCallback' + Date.now() + '_' + random;
    var callbackParameter = options.jsonp || 'callback';
    options.data = options.data || {};
    options.data[callbackParameter] = callbackName;
    return callbackName;
  }
};
var getRequestOptions = function getRequestOptions(options, headers) {
  var params = options.data;
  var paramsAlreadyString = typeof params === 'string';
  var url = options.url || window.location.href;
  if (!paramsAlreadyString && !options.cache) {
    params = params || {};
    params['_'] = Date.now();
  }
  if (params && !options.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }
    if (getMethod(options) === 'GET') {
      if (params !== '') {
        url += (url.indexOf('?') > -1 ? '&' : '?') + params;
      }
      params = null;
    } else if (headers['Content-Type'] && headers['Content-Type'].indexOf('application/x-www-form-urlencoded') > -1) {
      params = params.replace(/%20/g, '+');
    }
  }
  return {
    url: url,
    parameters: params
  };
};
function getMethod(options) {
  return (options.method || 'GET').toUpperCase();
}
var getRequestHeaders = function getRequestHeaders(options) {
  var headers = options.headers || {};
  headers['Content-Type'] = headers['Content-Type'] || getContentTypeHeader(options);
  headers['Accept'] = headers['Accept'] || getAcceptHeader(options);
  if (!options.crossDomain && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = 'XMLHttpRequest';
  }
  return headers;
};
var sendRequest = function sendRequest(options) {
  var xhr = _http_request.default.getXhr();
  var d = new _deferred.Deferred();
  var result = d.promise();
  var async = (0, _type.isDefined)(options.async) ? options.async : true;
  var dataType = options.dataType;
  var timeout = options.timeout || 0;
  var timeoutId;
  options.crossDomain = isCrossDomain(options.url);
  var needScriptEvaluation = dataType === 'jsonp' || dataType === 'script';
  if (options.cache === undefined) {
    options.cache = !needScriptEvaluation;
  }
  var callbackName = getJsonpOptions(options);
  var headers = getRequestHeaders(options);
  var requestOptions = getRequestOptions(options, headers);
  var url = requestOptions.url;
  var parameters = requestOptions.parameters;
  if (callbackName) {
    window[callbackName] = function (data) {
      d.resolve(data, SUCCESS, xhr);
    };
  }
  if (options.crossDomain && needScriptEvaluation) {
    var reject = function reject() {
      d.reject(xhr, ERROR);
    };
    var resolve = function resolve() {
      if (dataType === 'jsonp') return;
      d.resolve(null, SUCCESS, xhr);
    };
    evalCrossDomainScript(url).then(resolve, reject);
    return result;
  }
  if (options.crossDomain && !('withCredentials' in xhr)) {
    d.reject(xhr, ERROR);
    return result;
  }
  xhr.open(getMethod(options), url, async, options.username, options.password);
  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr);
  }
  xhr['onreadystatechange'] = function (e) {
    if (xhr.readyState === 4) {
      clearTimeout(timeoutId);
      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };
  if (options.upload) {
    xhr.upload['onprogress'] = options.upload['onprogress'];
    xhr.upload['onloadstart'] = options.upload['onloadstart'];
    xhr.upload['onabort'] = options.upload['onabort'];
  }
  if (options.xhrFields) {
    for (var field in options.xhrFields) {
      xhr[field] = options.xhrFields[field];
    }
  }
  if (options.responseType === 'arraybuffer') {
    xhr.responseType = options.responseType;
  }
  for (var name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name) && (0, _type.isDefined)(headers[name])) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }
  if (options.beforeSend) {
    options.beforeSend(xhr);
  }
  xhr.send(parameters);
  result.abort = function () {
    xhr.abort();
  };
  return result;
};
var _default = (0, _dependency_injector.default)({
  sendRequest: sendRequest
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 89386:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.wrapToArray = exports.removeDuplicates = exports.normalizeIndexes = exports.groupBy = exports.getUniqueValues = exports.getIntersection = void 0;
var _type = __webpack_require__(35922);
var _object = __webpack_require__(48013);
var _config2 = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function createOccurrenceMap(array) {
  return array.reduce(function (map, value) {
    var _map$get;
    var count = ((_map$get = map.get(value)) !== null && _map$get !== void 0 ? _map$get : 0) + 1;
    map.set(value, count);
    return map;
  }, new Map());
}
var wrapToArray = function wrapToArray(item) {
  return Array.isArray(item) ? item : [item];
};
exports.wrapToArray = wrapToArray;
var getUniqueValues = function getUniqueValues(values) {
  return _toConsumableArray(new Set(values));
};
exports.getUniqueValues = getUniqueValues;
var getIntersection = function getIntersection(firstArray, secondArray) {
  var toRemoveMap = createOccurrenceMap(secondArray);
  return firstArray.filter(function (value) {
    var occurrencesCount = toRemoveMap.get(value);
    occurrencesCount && toRemoveMap.set(value, occurrencesCount - 1);
    return occurrencesCount;
  });
};
exports.getIntersection = getIntersection;
var removeDuplicates = function removeDuplicates() {
  var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var toRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var toRemoveMap = createOccurrenceMap(toRemove);
  return from.filter(function (value) {
    var occurrencesCount = toRemoveMap.get(value);
    occurrencesCount && toRemoveMap.set(value, occurrencesCount - 1);
    return !occurrencesCount;
  });
};
exports.removeDuplicates = removeDuplicates;
var normalizeIndexes = function normalizeIndexes(items, indexPropName, currentItem, needIndexCallback) {
  var indexedItems = {};
  var _config = (0, _config2.default)(),
    useLegacyVisibleIndex = _config.useLegacyVisibleIndex;
  var currentIndex = 0;
  var shouldUpdateIndex = function shouldUpdateIndex(item) {
    return !(0, _type.isDefined)(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));
  };
  items.forEach(function (item) {
    var index = item[indexPropName];
    if (index >= 0) {
      indexedItems[index] = indexedItems[index] || [];
      if (item === currentItem) {
        indexedItems[index].unshift(item);
      } else {
        indexedItems[index].push(item);
      }
    } else {
      item[indexPropName] = undefined;
    }
  });
  if (!useLegacyVisibleIndex) {
    items.forEach(function (item) {
      if (shouldUpdateIndex(item)) {
        while (indexedItems[currentIndex]) {
          currentIndex++;
        }
        indexedItems[currentIndex] = [item];
        currentIndex++;
      }
    });
  }
  currentIndex = 0;
  (0, _object.orderEach)(indexedItems, function (index, items) {
    items.forEach(function (item) {
      if (index >= 0) {
        item[indexPropName] = currentIndex++;
      }
    });
  });
  if (useLegacyVisibleIndex) {
    items.forEach(function (item) {
      if (shouldUpdateIndex(item)) {
        item[indexPropName] = currentIndex++;
      }
    });
  }
};
exports.normalizeIndexes = normalizeIndexes;
var groupBy = function groupBy(array, getGroupName) {
  return array.reduce(function (groupedResult, item) {
    var _groupedResult$groupN;
    var groupName = getGroupName(item);
    groupedResult[groupName] = (_groupedResult$groupN = groupedResult[groupName]) !== null && _groupedResult$groupN !== void 0 ? _groupedResult$groupN : [];
    groupedResult[groupName].push(item);
    return groupedResult;
  }, {});
};
exports.groupBy = groupBy;

/***/ }),

/***/ 34671:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.isKeysEqual = exports.findChanges = void 0;
var _type = __webpack_require__(35922);
var getKeyWrapper = function getKeyWrapper(item, getKey) {
  var key = getKey(item);
  if ((0, _type.isObject)(key)) {
    try {
      return JSON.stringify(key);
    } catch (e) {
      return key;
    }
  }
  return key;
};
var getSameNewByOld = function getSameNewByOld(oldItem, newItems, newIndexByKey, getKey) {
  var key = getKeyWrapper(oldItem, getKey);
  return newItems[newIndexByKey[key]];
};
var isKeysEqual = function isKeysEqual(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }
  for (var i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }
  return true;
};
exports.isKeysEqual = isKeysEqual;
var findChanges = function findChanges(oldItems, newItems, getKey, isItemEquals) {
  var oldIndexByKey = {};
  var newIndexByKey = {};
  var addedCount = 0;
  var removeCount = 0;
  var result = [];
  oldItems.forEach(function (item, index) {
    var key = getKeyWrapper(item, getKey);
    oldIndexByKey[key] = index;
  });
  newItems.forEach(function (item, index) {
    var key = getKeyWrapper(item, getKey);
    newIndexByKey[key] = index;
  });
  var itemCount = Math.max(oldItems.length, newItems.length);
  for (var index = 0; index < itemCount + addedCount; index++) {
    var newItem = newItems[index];
    var oldNextIndex = index - addedCount + removeCount;
    var nextOldItem = oldItems[oldNextIndex];
    var isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
    if (isRemoved) {
      if (nextOldItem) {
        result.push({
          type: 'remove',
          key: getKey(nextOldItem),
          index: index,
          oldItem: nextOldItem
        });
        removeCount++;
        index--;
      }
    } else {
      var key = getKeyWrapper(newItem, getKey);
      var oldIndex = oldIndexByKey[key];
      var oldItem = oldItems[oldIndex];
      if (!oldItem) {
        addedCount++;
        result.push({
          type: 'insert',
          data: newItem,
          index: index
        });
      } else if (oldIndex === oldNextIndex) {
        if (!isItemEquals(oldItem, newItem)) {
          result.push({
            type: 'update',
            data: newItem,
            key: getKey(newItem),
            index: index,
            oldItem: oldItem
          });
        }
      } else {
        return;
      }
    }
  }
  return result;
};
exports.findChanges = findChanges;

/***/ }),

/***/ 47810:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var navigator = (0, _window.getNavigator)();
var webkitRegExp = /(webkit)[ /]([\w.]+)/;
var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
var browserFromUA = function browserFromUA(ua) {
  ua = ua.toLowerCase();
  var result = {};
  var matches = webkitRegExp.exec(ua) || ua.indexOf('compatible') < 0 && mozillaRegExp.exec(ua) || [];
  var browserName = matches[1];
  var browserVersion = matches[2];
  if (browserName === 'webkit') {
    result['webkit'] = true;
    if (ua.indexOf('chrome') >= 0 || ua.indexOf('crios') >= 0) {
      browserName = 'chrome';
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf('fxios') >= 0) {
      browserName = 'mozilla';
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf('safari') >= 0 && /version|phantomjs/.test(ua)) {
      browserName = 'safari';
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = 'unknown';
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    }
  }
  if (browserName) {
    result[browserName] = true;
    result.version = browserVersion;
  }
  return result;
};
var _default = (0, _extend.extend)({
  _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 39618:
/***/ (function(module, exports) {



exports["default"] = void 0;
var callOnce = function callOnce(handler) {
  var result;
  var _wrappedHandler = function wrappedHandler() {
    result = handler.apply(this, arguments);
    _wrappedHandler = function wrappedHandler() {
      return result;
    };
    return result;
  };
  return function () {
    return _wrappedHandler.apply(this, arguments);
  };
};
var _default = callOnce;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44504:
/***/ (function(module, exports) {



exports["default"] = void 0;
var Callback = function Callback(options) {
  this._options = options || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};
Callback.prototype._fireCore = function (context, args) {
  var firingIndexes = this._firingIndexes;
  var list = this._list;
  var stopOnFalse = this._options.stopOnFalse;
  var step = firingIndexes.length;
  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    var result = list[firingIndexes[step]].apply(context, args);
    if (result === false && stopOnFalse) {
      break;
    }
  }
  firingIndexes.pop();
};
Callback.prototype.add = function (fn) {
  if (typeof fn === 'function' && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }
  return this;
};
Callback.prototype.remove = function (fn) {
  var list = this._list;
  var firingIndexes = this._firingIndexes;
  var index = list.indexOf(fn);
  if (index > -1) {
    list.splice(index, 1);
    if (this._firing && firingIndexes.length) {
      for (var step = 0; step < firingIndexes.length; step++) {
        if (index <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }
  return this;
};
Callback.prototype.has = function (fn) {
  var list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};
Callback.prototype.empty = function (fn) {
  this._list = [];
  return this;
};
Callback.prototype.fireWith = function (context, args) {
  var queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;
  if (this._options.syncStrategy) {
    this._firing = true;
    this._fireCore(context, args);
  } else {
    queue.push([context, args]);
    if (this._firing) {
      return;
    }
    this._firing = true;
    while (queue.length) {
      var memory = queue.shift();
      this._fireCore(memory[0], memory[1]);
    }
  }
  this._firing = false;
  this._fired = true;
  return this;
};
Callback.prototype.fire = function () {
  this.fireWith(this, arguments);
};
Callback.prototype.fired = function () {
  return this._fired;
};
var Callbacks = function Callbacks(options) {
  return new Callback(options);
};
var _default = Callbacks;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 20576:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.splitPair = exports.pairToObject = exports.normalizeKey = exports.noop = exports.grep = exports.getKeyHash = exports.findBestMatches = exports.executeAsync = exports.escapeRegExp = exports.equalByValue = exports.ensureDefined = exports.denormalizeKey = exports.deferUpdater = exports.deferUpdate = exports.deferRenderer = exports.deferRender = exports.asyncNoop = exports.applyServerDecimalSeparator = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _deferred = __webpack_require__(62754);
var _data = __webpack_require__(47617);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var ensureDefined = function ensureDefined(value, defaultValue) {
  return (0, _type.isDefined)(value) ? value : defaultValue;
};
exports.ensureDefined = ensureDefined;
var executeAsync = function executeAsync(action, context /* , internal */) {
  var deferred = new _deferred.Deferred();
  var normalizedContext = context || this;
  var task = {
    promise: deferred.promise(),
    abort: function abort() {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };
  var callback = function callback() {
    var result = action.call(normalizedContext);
    if (result && result.done && (0, _type.isFunction)(result.done)) {
      result.done(function () {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  };
  var timerId = (arguments[2] || setTimeout)(callback, typeof context === 'number' ? context : 0);
  return task;
};
exports.executeAsync = executeAsync;
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;
var deferExecute = function deferExecute(name, func, deferred) {
  if (executingName && executingName !== name) {
    delayedFuncs.push(func);
    delayedNames.push(name);
    deferred = deferred || new _deferred.Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  } else {
    var oldExecutingName = executingName;
    var currentDelayedCount = delayedDeferreds.length;
    executingName = name;
    var result = func();
    if (!result) {
      if (delayedDeferreds.length > currentDelayedCount) {
        result = _deferred.when.apply(this, delayedDeferreds.slice(currentDelayedCount));
      } else if (deferred) {
        deferred.resolve();
      }
    }
    executingName = oldExecutingName;
    if (deferred && result && result.done) {
      result.done(deferred.resolve).fail(deferred.reject);
    }
    if (!executingName && delayedFuncs.length) {
      (delayedNames.shift() === 'render' ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
    }
    return result || (0, _deferred.when)();
  }
};
var deferRender = function deferRender(func, deferred) {
  return deferExecute('render', func, deferred);
};
exports.deferRender = deferRender;
var deferUpdate = function deferUpdate(func, deferred) {
  return deferExecute('update', func, deferred);
};
exports.deferUpdate = deferUpdate;
var deferRenderer = function deferRenderer(func) {
  return function () {
    var that = this;
    return deferExecute('render', function () {
      return func.call(that);
    });
  };
};
exports.deferRenderer = deferRenderer;
var deferUpdater = function deferUpdater(func) {
  return function () {
    var that = this;
    return deferExecute('update', function () {
      return func.call(that);
    });
  };
};
exports.deferUpdater = deferUpdater;
var findBestMatches = function findBestMatches(targetFilter, items, mapFn) {
  var bestMatches = [];
  var maxMatchCount = 0;
  (0, _iterator.each)(items, function (index, itemSrc) {
    var matchCount = 0;
    var item = mapFn ? mapFn(itemSrc) : itemSrc;
    (0, _iterator.each)(targetFilter, function (paramName, targetValue) {
      var value = item[paramName];
      if (value === undefined) {
        return;
      }
      if (match(value, targetValue)) {
        matchCount++;
        return;
      }
      matchCount = -1;
      return false;
    });
    if (matchCount < maxMatchCount) {
      return;
    }
    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }
    bestMatches.push(itemSrc);
  });
  return bestMatches;
};
exports.findBestMatches = findBestMatches;
var match = function match(value, targetValue) {
  if (Array.isArray(value) && Array.isArray(targetValue)) {
    var mismatch = false;
    (0, _iterator.each)(value, function (index, valueItem) {
      if (valueItem !== targetValue[index]) {
        mismatch = true;
        return false;
      }
    });
    if (mismatch) {
      return false;
    }
    return true;
  }
  if (value === targetValue) {
    return true;
  }
  return false;
};
var splitPair = function splitPair(raw) {
  var _raw$x, _raw$y;
  switch ((0, _type.type)(raw)) {
    case 'string':
      return raw.split(/\s+/, 2);
    case 'object':
      return [(_raw$x = raw.x) !== null && _raw$x !== void 0 ? _raw$x : raw.h, (_raw$y = raw.y) !== null && _raw$y !== void 0 ? _raw$y : raw.v];
    case 'number':
      return [raw];
    case 'array':
      return raw;
    default:
      return null;
  }
};
exports.splitPair = splitPair;
var normalizeKey = function normalizeKey(id) {
  var key = (0, _type.isString)(id) ? id : id.toString();
  var arr = key.match(/[^a-zA-Z0-9_]/g);
  arr && (0, _iterator.each)(arr, function (_, sign) {
    key = key.replace(sign, '__' + sign.charCodeAt() + '__');
  });
  return key;
};
exports.normalizeKey = normalizeKey;
var denormalizeKey = function denormalizeKey(key) {
  var arr = key.match(/__\d+__/g);
  arr && arr.forEach(function (char) {
    var charCode = parseInt(char.replace('__', ''));
    key = key.replace(char, String.fromCharCode(charCode));
  });
  return key;
};
exports.denormalizeKey = denormalizeKey;
var pairToObject = function pairToObject(raw, preventRound) {
  var pair = splitPair(raw);
  var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
  if (!isFinite(h)) {
    h = 0;
  }
  if (!isFinite(v)) {
    v = h;
  }
  return {
    h,
    v
  };
};
exports.pairToObject = pairToObject;
var getKeyHash = function getKeyHash(key) {
  if (key instanceof _guid.default) {
    return key.toString();
  } else if ((0, _type.isObject)(key) || Array.isArray(key)) {
    try {
      var keyHash = JSON.stringify(key);
      return keyHash === '{}' ? key : keyHash;
    } catch (e) {
      return key;
    }
  }
  return key;
};
exports.getKeyHash = getKeyHash;
var escapeRegExp = function escapeRegExp(string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, '\\$&');
};
exports.escapeRegExp = escapeRegExp;
var applyServerDecimalSeparator = function applyServerDecimalSeparator(value) {
  var separator = (0, _config.default)().serverDecimalSeparator;
  if ((0, _type.isDefined)(value)) {
    value = value.toString().replace('.', separator);
  }
  return value;
};
exports.applyServerDecimalSeparator = applyServerDecimalSeparator;
var noop = function noop() {};
exports.noop = noop;
var asyncNoop = function asyncNoop() {
  return new _deferred.Deferred().resolve().promise();
};
exports.asyncNoop = asyncNoop;
var grep = function grep(elements, checkFunction, invert) {
  var result = [];
  var check;
  var expectedCheck = !invert;
  for (var i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);
    if (check === expectedCheck) {
      result.push(elements[i]);
    }
  }
  return result;
};
exports.grep = grep;
var compareArrays = function compareArrays(array1, array2, depth, options) {
  if (array1.length !== array2.length) {
    return false;
  }
  return !array1.some(function (item, idx) {
    return !compareByValue(item, array2[idx], depth + 1, _extends({}, options, {
      strict: true
    }));
  });
};
var compareObjects = function compareObjects(object1, object2, depth, options) {
  var keys1 = Object.keys(object1);
  var keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  var keys2Set = new Set(keys2);
  return !keys1.some(function (key) {
    return !keys2Set.has(key) || !compareByValue(object1[key], object2[key], depth + 1, options);
  });
};
var DEFAULT_EQUAL_BY_VALUE_OPTS = {
  maxDepth: 3,
  strict: true
};
var compareByValue = function compareByValue(value1, value2, depth, options) {
  var strict = options.strict,
    maxDepth = options.maxDepth;
  var comparable1 = (0, _data.toComparable)(value1, true);
  var comparable2 = (0, _data.toComparable)(value2, true);
  var comparisonResult = strict ? comparable1 === comparable2
  // eslint-disable-next-line eqeqeq
  : comparable1 == comparable2;
  switch (true) {
    case comparisonResult:
    case depth >= maxDepth:
      return true;
    case (0, _type.isObject)(comparable1) && (0, _type.isObject)(comparable2):
      return compareObjects(comparable1, comparable2, depth, options);
    case Array.isArray(comparable1) && Array.isArray(comparable2):
      return compareArrays(comparable1, comparable2, depth, options);
    default:
      return false;
  }
};
var equalByValue = function equalByValue(value1, value2) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_EQUAL_BY_VALUE_OPTS;
  var compareOptions = _extends({}, DEFAULT_EQUAL_BY_VALUE_OPTS, options);
  return compareByValue(value1, value2, 0, compareOptions);
};
exports.equalByValue = equalByValue;

/***/ }),

/***/ 49036:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.equals = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _data = __webpack_require__(47617);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var hasNegation = function hasNegation(oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};
var equals = function equals(oldValue, newValue) {
  oldValue = (0, _data.toComparable)(oldValue, true);
  newValue = (0, _data.toComparable)(newValue, true);
  if (oldValue && newValue && (0, _type.isRenderer)(oldValue) && (0, _type.isRenderer)(newValue)) {
    return newValue.is(oldValue);
  }
  var oldValueIsNaN = oldValue !== oldValue;
  var newValueIsNaN = newValue !== newValue;
  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }
  if (oldValue === 0 && newValue === 0) {
    return hasNegation(oldValue, newValue);
  }
  if (oldValue === null || typeof oldValue !== 'object' || _dom_adapter.default.isElementNode(oldValue)) {
    return oldValue === newValue;
  }
  return false;
};
exports.equals = equals;

/***/ }),

/***/ 30869:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.logger = exports.debug = void 0;
var _type = __webpack_require__(35922);
/* global console */
/* eslint no-console: off */

var noop = function noop() {};
var getConsoleMethod = function getConsoleMethod(method) {
  if (typeof console === 'undefined' || !(0, _type.isFunction)(console[method])) {
    return noop;
  }
  return console[method].bind(console);
};
var logger = {
  log: getConsoleMethod('log'),
  info: getConsoleMethod('info'),
  warn: getConsoleMethod('warn'),
  error: getConsoleMethod('error')
};
exports.logger = logger;
var debug = function () {
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  function assertParam(parameter, message) {
    assert(parameter !== null && parameter !== undefined, message);
  }
  return {
    assert: assert,
    assertParam: assertParam
  };
}();
exports.debug = debug;

/***/ }),

/***/ 47617:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.toComparable = exports.getPathParts = exports.compileSetter = exports.compileGetter = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _object = __webpack_require__(48013);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var unwrapVariable = _variable_wrapper.default.unwrap;
var isWrapped = _variable_wrapper.default.isWrapped;
var assign = _variable_wrapper.default.assign;
var bracketsToDots = function bracketsToDots(expr) {
  return expr.replace(/\[/g, '.').replace(/\]/g, '');
};
var getPathParts = function getPathParts(name) {
  return bracketsToDots(name).split('.');
};
exports.getPathParts = getPathParts;
var readPropValue = function readPropValue(obj, propName, options) {
  options = options || {};
  if (propName === 'this') {
    return unwrap(obj, options);
  }
  return unwrap(obj[propName], options);
};
var assignPropValue = function assignPropValue(obj, propName, value, options) {
  if (propName === 'this') {
    throw new _errors.default.Error('E4016');
  }
  var propValue = obj[propName];
  if (options.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value);
  } else {
    obj[propName] = value;
  }
};
var prepareOptions = function prepareOptions(options) {
  options = options || {};
  options.unwrapObservables = options.unwrapObservables !== undefined ? options.unwrapObservables : true;
  return options;
};
function unwrap(value, options) {
  return options.unwrapObservables ? unwrapVariable(value) : value;
}
var compileGetter = function compileGetter(expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }
  if (!expr || expr === 'this') {
    return function (obj) {
      return obj;
    };
  }
  if (typeof expr === 'string') {
    var path = getPathParts(expr);
    return function (obj, options) {
      options = prepareOptions(options);
      var functionAsIs = options.functionsAsIs;
      var hasDefaultValue = ('defaultValue' in options);
      var current = unwrap(obj, options);
      for (var i = 0; i < path.length; i++) {
        if (!current) {
          if (current == null && hasDefaultValue) {
            return options.defaultValue;
          }
          break;
        }
        var pathPart = path[i];
        if (hasDefaultValue && (0, _type.isObject)(current) && !(pathPart in current)) {
          return options.defaultValue;
        }
        var next = unwrap(current[pathPart], options);
        if (!functionAsIs && (0, _type.isFunction)(next)) {
          next = next.call(current);
        }
        current = next;
      }
      return current;
    };
  }
  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }
  if ((0, _type.isFunction)(expr)) {
    return expr;
  }
};
exports.compileGetter = compileGetter;
function combineGetters(getters) {
  var compiledGetters = {};
  for (var i = 0, l = getters.length; i < l; i++) {
    var getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function (obj, options) {
    var result;
    (0, _iterator.each)(compiledGetters, function (name) {
      var value = this(obj, options);
      if (value === undefined) {
        return;
      }
      var current = result || (result = {});
      var path = name.split('.');
      var last = path.length - 1;
      for (var _i = 0; _i < last; _i++) {
        var pathItem = path[_i];
        if (!(pathItem in current)) {
          current[pathItem] = {};
        }
        current = current[pathItem];
      }
      current[path[last]] = value;
    });
    return result;
  };
}
var ensurePropValueDefined = function ensurePropValueDefined(obj, propName, value, options) {
  if ((0, _type.isDefined)(value)) {
    return value;
  }
  var newValue = {};
  assignPropValue(obj, propName, newValue, options);
  return newValue;
};
var compileSetter = function compileSetter(expr) {
  expr = getPathParts(expr || 'this');
  var lastLevelIndex = expr.length - 1;
  return function (obj, value, options) {
    options = prepareOptions(options);
    var currentValue = unwrap(obj, options);
    expr.forEach(function (propertyName, levelIndex) {
      var propertyValue = readPropValue(currentValue, propertyName, options);
      var isPropertyFunc = !options.functionsAsIs && (0, _type.isFunction)(propertyValue) && !isWrapped(propertyValue);
      if (levelIndex === lastLevelIndex) {
        if (options.merge && (0, _type.isPlainObject)(value) && (!(0, _type.isDefined)(propertyValue) || (0, _type.isPlainObject)(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
          (0, _object.deepExtendArraySafe)(propertyValue, value, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value);
        } else {
          assignPropValue(currentValue, propertyName, value, options);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);
        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }
        currentValue = propertyValue;
      }
    });
  };
};
exports.compileSetter = compileSetter;
var toComparable = function toComparable(value, caseSensitive) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (value instanceof Date) {
    return value.getTime();
  }
  if (value && value instanceof _class.default && value.valueOf) {
    return value.valueOf();
  }
  if (!caseSensitive && typeof value === 'string') {
    var _options$collatorOpti;
    if ((options === null || options === void 0 ? void 0 : (_options$collatorOpti = options.collatorOptions) === null || _options$collatorOpti === void 0 ? void 0 : _options$collatorOpti.sensitivity) === 'base') {
      var REMOVE_DIACRITICAL_MARKS_REGEXP = /[\u0300-\u036f]/g;
      value = value.normalize('NFD').replace(REMOVE_DIACRITICAL_MARKS_REGEXP, '');
    }
    return options !== null && options !== void 0 && options.locale ? value.toLocaleLowerCase(options.locale) : value.toLowerCase();
  }
  return value;
};
exports.toComparable = toComparable;

/***/ }),

/***/ 91198:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
var _iterator = __webpack_require__(95479);
var _inflector = __webpack_require__(78008);
var _index = __webpack_require__(25050);
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var DAYS_IN_WEEK = 7;
var THURSDAY_WEEK_NUMBER = 4;
var SUNDAY_WEEK_NUMBER = 7;
var USUAL_WEEK_COUNT_IN_YEAR = 52;
var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'];
var getDatesInterval = function getDatesInterval(startDate, endDate, intervalUnit) {
  var delta = endDate.getTime() - startDate.getTime();
  var millisecondCount = (0, _index.toMilliseconds)(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};
var getNextDateUnit = function getNextDateUnit(unit, withWeeks) {
  var interval = getDateUnitInterval(unit);
  switch (interval) {
    case 'millisecond':
      return 'second';
    case 'second':
      return 'minute';
    case 'minute':
      return 'hour';
    case 'hour':
      return 'day';
    case 'day':
      return withWeeks ? 'week' : 'month';
    case 'week':
      return 'month';
    case 'month':
      return 'quarter';
    case 'quarter':
      return 'year';
    case 'year':
      return 'year';
    default:
      return 0;
  }
};
var convertMillisecondsToDateUnits = function convertMillisecondsToDateUnits(value) {
  var i;
  var dateUnitCount;
  var dateUnitInterval;
  var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];
  var result = {};
  for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals[i];
    dateUnitCount = Math.floor(value / (0, _index.toMilliseconds)(dateUnitInterval));
    if (dateUnitCount > 0) {
      result[dateUnitInterval + 's'] = dateUnitCount;
      value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }
  return result;
};
var dateToMilliseconds = function dateToMilliseconds(tickInterval) {
  var milliseconds = 0;
  if ((0, _type.isObject)(tickInterval)) {
    (0, _iterator.each)(tickInterval, function (key, value) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value);
    });
  }
  if ((0, _type.isString)(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }
  return milliseconds;
};
function convertDateUnitToMilliseconds(dateUnit, count) {
  return (0, _index.toMilliseconds)(dateUnit) * count;
}

// refactor for performance
function getDateUnitInterval(tickInterval) {
  var maxInterval = -1;
  var i;
  if ((0, _type.isString)(tickInterval)) {
    return tickInterval;
  }
  if ((0, _type.isObject)(tickInterval)) {
    (0, _iterator.each)(tickInterval, function (key, value) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value && (key === dateUnitIntervals[i] + 's' || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return '';
}

// T375972
var tickIntervalToFormatMap = {
  millisecond: 'millisecond',
  second: 'longtime',
  minute: 'shorttime',
  hour: 'shorttime',
  day: 'day',
  week: 'day',
  month: 'month',
  quarter: 'quarter',
  year: 'year'
};

// Because of changes in formatting (Globalize has been updated) common date formatting has been changed.
// The purpose of the following method is to preserve original dates formatting in axes and range selector slider markers.
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || '';
}
var getQuarter = function getQuarter(month) {
  return Math.floor(month / 3);
};
var getFirstQuarterMonth = function getFirstQuarterMonth(month) {
  return getQuarter(month) * 3;
};
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  var oldDate = new Date(date.getTime());
  var firstQuarterMonth;
  var month;
  var dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case 'second':
      date = new Date(Math.floor(oldDate.getTime() / 1000) * 1000);
      break;
    case 'minute':
      date = new Date(Math.floor(oldDate.getTime() / 60000) * 60000);
      break;
    case 'hour':
      date = new Date(Math.floor(oldDate.getTime() / 3600000) * 3600000);
      break;
    case 'year':
      date.setMonth(0);
    /* falls through */
    case 'month':
      date.setDate(1);
    /* falls through */
    case 'day':
      date.setHours(0, 0, 0, 0);
      break;
    case 'week':
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case 'quarter':
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
      break;
  }
  if (withCorrection && dateUnitInterval !== 'hour' && dateUnitInterval !== 'minute' && dateUnitInterval !== 'second') {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, 'day');
}
var setToDayEnd = function setToDayEnd(date) {
  var result = trimTime(date);
  result.setDate(result.getDate() + 1);
  return new Date(result.getTime() - 1);
};
var getDatesDifferences = function getDatesDifferences(date1, date2) {
  var counter = 0;
  var differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  (0, _iterator.each)(differences, function (key, value) {
    if (value) {
      counter++;
    }
  });
  if (counter === 0 && getTimezonesDifference(date1, date2) !== 0) {
    differences.hour = true;
    counter++;
  }
  differences.count = counter;
  return differences;
};
function addDateInterval(value, interval, dir) {
  var result = new Date(value.getTime());
  var intervalObject = (0, _type.isString)(interval) ? getDateIntervalByString(interval.toLowerCase()) : (0, _type.isNumeric)(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result.setFullYear(result.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result.setMonth(result.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result.setDate(result.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result.setDate(result.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result.setTime(result.getTime() + intervalObject.hours * 3600000 * dir);
  }
  if (intervalObject.minutes) {
    result.setTime(result.getTime() + intervalObject.minutes * 60000 * dir);
  }
  if (intervalObject.seconds) {
    result.setTime(result.getTime() + intervalObject.seconds * 1000 * dir);
  }
  if (intervalObject.milliseconds) {
    result.setTime(result.getTime() + intervalObject.milliseconds * dir);
  }
  return result;
}
var addInterval = function addInterval(value, interval, isNegative) {
  var dir = isNegative ? -1 : +1;
  return (0, _type.isDate)(value) ? addDateInterval(value, interval, dir) : (0, _math.adjust)(value + interval * dir, interval);
};
var getSequenceByInterval = function getSequenceByInterval(min, max, interval) {
  var intervals = [];
  var cur;
  intervals.push((0, _type.isDate)(min) ? new Date(min.getTime()) : min);
  cur = min;
  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }
  return intervals;
};
var getViewFirstCellDate = function getViewFirstCellDate(viewType, date) {
  if (viewType === 'month') {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }
  if (viewType === 'year') {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }
  if (viewType === 'decade') {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }
  if (viewType === 'century') {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};
var getViewLastCellDate = function getViewLastCellDate(viewType, date) {
  if (viewType === 'month') {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }
  if (viewType === 'year') {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }
  if (viewType === 'decade') {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }
  if (viewType === 'century') {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};
var getViewMinBoundaryDate = function getViewMinBoundaryDate(viewType, date) {
  var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  if (viewType === 'month') {
    return resultDate;
  }
  resultDate.setMonth(0);
  if (viewType === 'year') {
    return resultDate;
  }
  if (viewType === 'decade') {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }
  if (viewType === 'century') {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }
  return resultDate;
};
var getViewMaxBoundaryDate = function getViewMaxBoundaryDate(viewType, date) {
  var resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));
  if (viewType === 'month') {
    return resultDate;
  }
  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));
  if (viewType === 'year') {
    return resultDate;
  }
  if (viewType === 'decade') {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }
  if (viewType === 'century') {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }
  return resultDate;
};
function getLastMonthDay(date) {
  var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
var getViewUp = function getViewUp(typeView) {
  switch (typeView) {
    case 'month':
      return 'year';
    case 'year':
      return 'decade';
    case 'decade':
      return 'century';
    default:
      break;
  }
};
var getViewDown = function getViewDown(typeView) {
  switch (typeView) {
    case 'century':
      return 'decade';
    case 'decade':
      return 'year';
    case 'year':
      return 'month';
    default:
      break;
  }
};
var getDifferenceInMonth = function getDifferenceInMonth(typeView) {
  var difference = 1;
  if (typeView === 'year') {
    difference = 12;
  }
  if (typeView === 'decade') {
    difference = 12 * 10;
  }
  if (typeView === 'century') {
    difference = 12 * 100;
  }
  return difference;
};
var getDifferenceInMonthForCells = function getDifferenceInMonthForCells(typeView) {
  var difference = 1;
  if (typeView === 'decade') {
    difference = 12;
  }
  if (typeView === 'century') {
    difference = 12 * 10;
  }
  return difference;
};
function getDateIntervalByString(intervalString) {
  var result = {};
  switch (intervalString) {
    case 'year':
      result.years = 1;
      break;
    case 'month':
      result.months = 1;
      break;
    case 'quarter':
      result.months = 3;
      break;
    case 'week':
      result.weeks = 1;
      break;
    case 'day':
      result.days = 1;
      break;
    case 'hour':
      result.hours = 1;
      break;
    case 'minute':
      result.minutes = 1;
      break;
    case 'second':
      result.seconds = 1;
      break;
    case 'millisecond':
      result.milliseconds = 1;
      break;
  }
  return result;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
function sameHoursAndMinutes(date1, date2) {
  return date1 && date2 && date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes();
}
var sameDecade = function sameDecade(date1, date2) {
  if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) return;
  var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  var startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};
var sameCentury = function sameCentury(date1, date2) {
  if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) return;
  var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  var startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
var getShortDateFormat = function getShortDateFormat() {
  return 'yyyy/MM/dd';
};
var getFirstMonthDate = function getFirstMonthDate(date) {
  if (!(0, _type.isDefined)(date)) return;
  return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
};
var getLastMonthDate = function getLastMonthDate(date) {
  if (!(0, _type.isDefined)(date)) return;
  return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
};
function getFirstWeekDate(date, firstDayOfWeek) {
  var delta = (date.getDay() - firstDayOfWeek + DAYS_IN_WEEK) % DAYS_IN_WEEK;
  var result = new Date(date);
  result.setDate(date.getDate() - delta);
  return result;
}
function getUTCTime(date) {
  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
}
function getDayNumber(date) {
  var ms = getUTCTime(date) - getUTCTime(getFirstDateInYear(date.getFullYear()));
  return 1 + Math.floor(ms / (0, _index.toMilliseconds)('day'));
}
function getFirstDateInYear(year) {
  return new Date(year, 0, 1);
}
function getLastDateInYear(year) {
  return new Date(year, 11, 31);
}
function getDayWeekNumber(date, firstDayOfWeek) {
  var day = date.getDay() - firstDayOfWeek + 1;
  if (day <= 0) {
    day += DAYS_IN_WEEK;
  }
  return day;
}
function getWeekNumber(date, firstDayOfWeek, rule) {
  var firstWeekDayInYear = getDayWeekNumber(getFirstDateInYear(date.getFullYear()), firstDayOfWeek);
  var lastWeekDayInYear = getDayWeekNumber(getLastDateInYear(date.getFullYear()), firstDayOfWeek);
  var daysInFirstWeek = DAYS_IN_WEEK - firstWeekDayInYear + 1;
  var weekNumber = Math.ceil((getDayNumber(date) - daysInFirstWeek) / 7);
  switch (rule) {
    case 'fullWeek':
      {
        if (daysInFirstWeek === DAYS_IN_WEEK) {
          weekNumber++;
        }
        if (weekNumber === 0) {
          var lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
          return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
        }
        return weekNumber;
      }
    case 'firstDay':
      {
        if (daysInFirstWeek > 0) {
          weekNumber++;
        }
        var isSunday = firstWeekDayInYear === SUNDAY_WEEK_NUMBER || lastWeekDayInYear === SUNDAY_WEEK_NUMBER;
        if (weekNumber > USUAL_WEEK_COUNT_IN_YEAR && !isSunday || weekNumber === 54) {
          weekNumber = 1;
        }
        return weekNumber;
      }
    case 'firstFourDays':
      {
        if (daysInFirstWeek > 3) {
          weekNumber++;
        }
        var isThursday = firstWeekDayInYear === THURSDAY_WEEK_NUMBER || lastWeekDayInYear === THURSDAY_WEEK_NUMBER;
        if (weekNumber > USUAL_WEEK_COUNT_IN_YEAR && !isThursday) {
          weekNumber = 1;
        }
        if (weekNumber === 0) {
          var _lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
          return getWeekNumber(_lastDateInPreviousYear, firstDayOfWeek, rule);
        }
        return weekNumber;
      }
    default:
      break;
  }
}
var normalizeDateByWeek = function normalizeDateByWeek(date, currentDate) {
  var differenceInDays = dateUtils.getDatesInterval(date, currentDate, 'day');
  var resultDate = new Date(date);
  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }
  return resultDate;
};
var dateInRange = function dateInRange(date, min, max, format) {
  if (format === 'date') {
    min = min && dateUtils.correctDateWithUnitBeginning(min, 'day');
    max = max && dateUtils.correctDateWithUnitBeginning(max, 'day');
    date = date && dateUtils.correctDateWithUnitBeginning(date, 'day');
  }
  return normalizeDate(date, min, max) === date;
};
var intervalsOverlap = function intervalsOverlap(options) {
  var firstMin = options.firstMin,
    firstMax = options.firstMax,
    secondMin = options.secondMin,
    secondMax = options.secondMax;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};
var dateTimeFromDecimal = function dateTimeFromDecimal(number) {
  var hours = Math.floor(number);
  var minutes = number % 1 * 60;
  return {
    hours: hours,
    minutes: minutes
  };
};
var roundDateByStartDayHour = function roundDateByStartDayHour(date, startDayHour) {
  var startTime = this.dateTimeFromDecimal(startDayHour);
  var result = new Date(date);
  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result.setHours(startTime.hours, startTime.minutes, 0, 0);
  }
  return result;
};
function normalizeDate(date, min, max) {
  var normalizedDate = date;
  if (!(0, _type.isDefined)(date)) {
    return date;
  }
  if ((0, _type.isDefined)(min) && date < min) {
    normalizedDate = min;
  }
  if ((0, _type.isDefined)(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  // NOTE: T182866
  if (!(0, _type.isDefined)(oldDate)) {
    return;
  }
  var diff = newDate.getHours() - oldDate.getHours();
  if (diff === 0) {
    return;
  }
  var sign = diff === 1 || diff === -23 ? -1 : 1;
  var trial = new Date(newDate.getTime() + sign * 3600000);
  if (sign > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
var roundToHour = function roundToHour(date) {
  var result = new Date(date.getTime());
  result.setHours(result.getHours() + 1);
  result.setMinutes(0);
  return result;
};
function getTimezonesDifference(min, max) {
  return (max.getTimezoneOffset() - min.getTimezoneOffset()) * 60 * 1000;
}
var makeDate = function makeDate(date) {
  // TODO: will be useful later for work with different timezones
  return new Date(date);
};
var getDatesOfInterval = function getDatesOfInterval(startDate, endDate, step) {
  var result = [];
  var currentDate = new Date(startDate.getTime());
  while (currentDate < endDate) {
    result.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }
  return result;
};
var createDateWithFullYear = function createDateWithFullYear(year) {
  var result = _construct(Date, Array.prototype.slice.call(arguments));
  result.setFullYear(year);
  return result;
};
var dateUtils = {
  dateUnitIntervals: dateUnitIntervals,
  convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
  dateToMilliseconds: dateToMilliseconds,
  getNextDateUnit: getNextDateUnit,
  convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
  getDateUnitInterval: getDateUnitInterval,
  getDateFormatByTickInterval: getDateFormatByTickInterval,
  // T375972
  getDatesDifferences: getDatesDifferences,
  correctDateWithUnitBeginning: correctDateWithUnitBeginning,
  trimTime: trimTime,
  setToDayEnd: setToDayEnd,
  roundDateByStartDayHour: roundDateByStartDayHour,
  dateTimeFromDecimal: dateTimeFromDecimal,
  addDateInterval: addDateInterval,
  addInterval: addInterval,
  getSequenceByInterval: getSequenceByInterval,
  getDateIntervalByString: getDateIntervalByString,
  sameHoursAndMinutes: sameHoursAndMinutes,
  sameDate: sameDate,
  sameMonthAndYear: sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear: sameYear,
  sameDecade: sameDecade,
  sameCentury: sameCentury,
  getDifferenceInMonth: getDifferenceInMonth,
  getDifferenceInMonthForCells: getDifferenceInMonthForCells,
  getFirstYearInDecade: getFirstYearInDecade,
  getFirstDecadeInCentury: getFirstDecadeInCentury,
  getShortDateFormat: getShortDateFormat,
  getViewFirstCellDate: getViewFirstCellDate,
  getViewLastCellDate: getViewLastCellDate,
  getViewDown: getViewDown,
  getViewUp: getViewUp,
  getLastMonthDay: getLastMonthDay,
  getLastMonthDate: getLastMonthDate,
  getFirstMonthDate: getFirstMonthDate,
  getFirstWeekDate: getFirstWeekDate,
  getWeekNumber: getWeekNumber,
  normalizeDateByWeek: normalizeDateByWeek,
  getQuarter: getQuarter,
  getFirstQuarterMonth: getFirstQuarterMonth,
  dateInRange: dateInRange,
  intervalsOverlap: intervalsOverlap,
  roundToHour: roundToHour,
  normalizeDate: normalizeDate,
  getViewMinBoundaryDate: getViewMinBoundaryDate,
  getViewMaxBoundaryDate: getViewMaxBoundaryDate,
  fixTimezoneGap: fixTimezoneGap,
  getTimezonesDifference: getTimezonesDifference,
  makeDate: makeDate,
  getDatesInterval: getDatesInterval,
  getDatesOfInterval: getDatesOfInterval,
  createDateWithFullYear: createDateWithFullYear
};
dateUtils.sameView = function (view, date1, date2) {
  return dateUtils[(0, _inflector.camelize)('same ' + view)](date1, date2);
};
var _default = dateUtils;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 69434:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _date = __webpack_require__(40594);
var _default_date_names = _interopRequireDefault(__webpack_require__(15564));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var NUMBER_SERIALIZATION_FORMAT = 'number';
var DATE_SERIALIZATION_FORMAT = 'yyyy/MM/dd';
var DATETIME_SERIALIZATION_FORMAT = 'yyyy/MM/dd HH:mm:ss';
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ['', 'yyyy', '', 'MM', '', 'dd', 'THH', '', 'mm', '', 'ss', '.SSS'];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var MILLISECOND_LENGHT = 3;
var dateParser = function dateParser(text, skipISO8601Parsing) {
  var result;
  if ((0, _type.isString)(text) && !skipISO8601Parsing) {
    result = parseISO8601String(text);
  }
  return result || parseDate(text);
};
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  var isDefaultSerializationFormat = getDateSerializationFormat(text) === DATE_SERIALIZATION_FORMAT;
  var parsedValue = !(0, _type.isDate)(text) && Date.parse(text);
  if (!parsedValue && isDefaultSerializationFormat) {
    var parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      var newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return (0, _type.isNumeric)(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  var parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  var year = getTimePart(parts[1]);
  var month = --parts[3];
  var day = parts[5];
  var timeZoneHour = 0;
  var timeZoneMinute = 0;
  var correctYear = function correctYear(d) {
    year < 100 && d.setFullYear(year);
    return d;
  };
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if (parts[13] === '-') {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  var hour = getTimePart(parts[6]) - timeZoneHour;
  var minute = getTimePart(parts[8]) - timeZoneMinute;
  var second = getTimePart(parts[10]);
  var parseMilliseconds = function parseMilliseconds(part) {
    part = part || '';
    return getTimePart(part) * Math.pow(10, MILLISECOND_LENGHT - part.length);
  };
  var millisecond = parseMilliseconds(parts[11]);
  if (parts[12]) {
    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));
  }
  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));
}
var getIso8601Format = function getIso8601Format(text, useUtc) {
  var parts = text.match(ISO8601_PATTERN);
  var result = '';
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return parts[3] ? 'HH:mm:ss' : 'HH:mm';
    }
    return;
  }
  for (var i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }
  if (parts[12] === 'Z') {
    result += '\'Z\'';
  }
  if (parts[14]) {
    if (parts[15]) {
      result += 'xxx';
    } else if (parts[16]) {
      result += 'xx';
    } else {
      result += 'x';
    }
  }
  return result;
};
var deserializeDate = function deserializeDate(value) {
  if (typeof value === 'number') {
    return new Date(value);
  }
  return dateParser(value, !(0, _config.default)().forceIsoDateParsing);
};
var serializeDate = function serializeDate(value, serializationFormat) {
  if (!serializationFormat) {
    return value;
  }
  if (!(0, _type.isDate)(value)) {
    return null;
  }
  if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
    return value && value.valueOf ? value.valueOf() : null;
  }
  return (0, _date.getFormatter)(serializationFormat, _default_date_names.default)(value);
};
var getDateSerializationFormat = function getDateSerializationFormat(value) {
  if (typeof value === 'number') {
    return NUMBER_SERIALIZATION_FORMAT;
  } else if ((0, _type.isString)(value)) {
    var format;
    if ((0, _config.default)().forceIsoDateParsing) {
      format = getIso8601Format(value);
    }
    if (format) {
      return format;
    } else if (value.indexOf(':') >= 0) {
      return DATETIME_SERIALIZATION_FORMAT;
    } else {
      return DATE_SERIALIZATION_FORMAT;
    }
  } else if (value) {
    return null;
  }
};
var _default = {
  dateParser: dateParser,
  deserializeDate: deserializeDate,
  serializeDate: serializeDate,
  getDateSerializationFormat: getDateSerializationFormat
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 62754:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Deferred = Deferred;
exports.fromPromise = fromPromise;
exports.setStrategy = setStrategy;
exports.when = when;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var deferredConfig = [{
  method: 'resolve',
  handler: 'done',
  state: 'resolved'
}, {
  method: 'reject',
  handler: 'fail',
  state: 'rejected'
}, {
  method: 'notify',
  handler: 'progress'
}];
var _DeferredObj = function DeferredObj() {
  var that = this;
  this._state = 'pending';
  this._promise = {};
  deferredConfig.forEach(function (config) {
    var methodName = config.method;
    this[methodName + 'Callbacks'] = (0, _callbacks.default)();
    this[methodName] = function () {
      return this[methodName + 'With'](this._promise, arguments);
    }.bind(this);
    this._promise[config.handler] = function (handler) {
      if (!handler) return this;
      var callbacks = that[methodName + 'Callbacks'];
      if (callbacks.fired()) {
        handler.apply(that[methodName + 'Context'], that[methodName + 'Args']);
      } else {
        callbacks.add(function (context, args) {
          handler.apply(context, args);
        }.bind(this));
      }
      return this;
    };
  }.bind(this));
  this._promise.always = function (handler) {
    return this.done(handler).fail(handler);
  };
  this._promise.catch = function (handler) {
    return this.then(null, handler);
  };
  this._promise.then = function (resolve, reject) {
    var result = new _DeferredObj();
    ['done', 'fail'].forEach(function (method) {
      var callback = method === 'done' ? resolve : reject;
      this[method](function () {
        if (!callback) {
          result[method === 'done' ? 'resolve' : 'reject'].apply(this, arguments);
          return;
        }
        var callbackResult = callback && callback.apply(this, arguments);
        if ((0, _type.isDeferred)(callbackResult)) {
          callbackResult.done(result.resolve).fail(result.reject);
        } else if ((0, _type.isPromise)(callbackResult)) {
          callbackResult.then(result.resolve, result.reject);
        } else {
          result.resolve.apply(this, (0, _type.isDefined)(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }.bind(this));
    return result.promise();
  };
  this._promise.state = function () {
    return that._state;
  };
  this._promise.promise = function (args) {
    return args ? (0, _extend.extend)(args, that._promise) : that._promise;
  };
  this._promise.promise(this);
};
deferredConfig.forEach(function (config) {
  var methodName = config.method;
  var state = config.state;
  _DeferredObj.prototype[methodName + 'With'] = function (context, args) {
    var callbacks = this[methodName + 'Callbacks'];
    if (this.state() === 'pending') {
      this[methodName + 'Args'] = args;
      this[methodName + 'Context'] = context;
      if (state) this._state = state;
      callbacks.fire(context, args);
    }
    return this;
  };
});
function fromPromise(promise, context) {
  if ((0, _type.isDeferred)(promise)) {
    return promise;
  } else if ((0, _type.isPromise)(promise)) {
    var d = new _DeferredObj();
    promise.then(function () {
      d.resolveWith.apply(d, [context].concat([[].slice.call(arguments)]));
    }, function () {
      d.rejectWith.apply(d, [context].concat([[].slice.call(arguments)]));
    });
    return d;
  }
  return new _DeferredObj().resolveWith(context, [promise]);
}
var whenFunc = function whenFunc() {
  if (arguments.length === 1) {
    return fromPromise(arguments[0]);
  }
  var values = [].slice.call(arguments);
  var contexts = [];
  var resolvedCount = 0;
  var deferred = new _DeferredObj();
  var updateState = function updateState(i) {
    return function (value) {
      contexts[i] = this;
      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value;
      resolvedCount++;
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };
  for (var i = 0; i < values.length; i++) {
    if ((0, _type.isDeferred)(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }
  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }
  return deferred.promise();
};
function setStrategy(value) {
  _DeferredObj = value.Deferred;
  whenFunc = value.when;
}
function Deferred() {
  return new _DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}

/***/ }),

/***/ 20476:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _class = _interopRequireDefault(__webpack_require__(38377));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _default(object) {
  var BaseClass = _class.default.inherit(object);
  var InjectedClass = BaseClass;
  var instance = new InjectedClass(object);
  var initialFields = {};
  var injectFields = function injectFields(injectionObject, initial) {
    (0, _iterator.each)(injectionObject, function (key) {
      if ((0, _type.isFunction)(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function () {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function (injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function () {
    (0, _extend.extend)(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 3532:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.resetActiveElement = exports.replaceWith = exports.normalizeTemplateElement = exports.isElementInDom = exports.insertBefore = exports.extractTemplateMarkup = exports.createTextElementHiddenCopy = exports.contains = exports.closestCommonParent = exports.clipboardText = exports.clearSelection = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var getRootNodeHost = function getRootNodeHost(element) {
  if (!element.getRootNode) {
    return undefined;
  }
  var host = element.getRootNode().host;

  // NOTE: getRootNode().host can return a string if element is detached "a" element
  if ((0, _type.isString)(host)) {
    return undefined;
  }
  return host;
};
var resetActiveElement = function resetActiveElement() {
  var activeElement = _dom_adapter.default.getActiveElement();
  if (activeElement && activeElement !== _dom_adapter.default.getBody()) {
    var _activeElement$blur;
    (_activeElement$blur = activeElement.blur) === null || _activeElement$blur === void 0 ? void 0 : _activeElement$blur.call(activeElement);
  }
};
exports.resetActiveElement = resetActiveElement;
var clearSelection = function clearSelection() {
  var selection = window.getSelection();
  if (!selection) return;
  if (selection.type === 'Caret') return;
  if (selection.empty) {
    selection.empty();
  } else if (selection.removeAllRanges) {
    // T522811
    try {
      selection.removeAllRanges();
    } catch (e) {}
  }
};
exports.clearSelection = clearSelection;
var closestCommonParent = function closestCommonParent(startTarget, endTarget) {
  var $startTarget = (0, _renderer.default)(startTarget);
  var $endTarget = (0, _renderer.default)(endTarget);
  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }
  var $startParents = $startTarget.parents();
  var $endParents = $endTarget.parents();
  var startingParent = Math.min($startParents.length, $endParents.length);
  for (var i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};
exports.closestCommonParent = closestCommonParent;
var extractTemplateMarkup = function extractTemplateMarkup(element) {
  element = (0, _renderer.default)(element);
  var templateTag = element.length && element.filter(function isNotExecutableScript() {
    var $node = (0, _renderer.default)(this);
    return $node.is('script[type]') && $node.attr('type').indexOf('script') < 0;
  });
  if (templateTag.length) {
    return templateTag.eq(0).html();
  } else {
    element = (0, _renderer.default)('<div>').append(element);
    return element.html();
  }
};
exports.extractTemplateMarkup = extractTemplateMarkup;
var normalizeTemplateElement = function normalizeTemplateElement(element) {
  var $element = (0, _type.isDefined)(element) && (element.nodeType || (0, _type.isRenderer)(element)) ? (0, _renderer.default)(element) : (0, _renderer.default)('<div>').html(element).contents();
  if ($element.length === 1) {
    if ($element.is('script')) {
      $element = normalizeTemplateElement($element.html().trim());
    } else if ($element.is('table')) {
      $element = $element.children('tbody').contents();
    }
  }
  return $element;
};
exports.normalizeTemplateElement = normalizeTemplateElement;
var clipboardText = function clipboardText(event, text) {
  var clipboard = event.originalEvent && event.originalEvent.clipboardData || window.clipboardData;
  if (!text) {
    return clipboard && clipboard.getData('Text');
  }
  clipboard && clipboard.setData('Text', text);
};
exports.clipboardText = clipboardText;
var contains = function contains(container, element) {
  if (!element) {
    return false;
  }
  if ((0, _type.isWindow)(container)) {
    return contains(container.document, element);
  }
  return container.contains(element) || contains(container, getRootNodeHost(element));
};
exports.contains = contains;
var createTextElementHiddenCopy = function createTextElementHiddenCopy(element, text, options) {
  var elementStyles = window.getComputedStyle((0, _renderer.default)(element).get(0));
  var includePaddings = options && options.includePaddings;
  return (0, _renderer.default)('<div>').text(text).css({
    'fontStyle': elementStyles.fontStyle,
    'fontVariant': elementStyles.fontVariant,
    'fontWeight': elementStyles.fontWeight,
    'fontSize': elementStyles.fontSize,
    'fontFamily': elementStyles.fontFamily,
    'letterSpacing': elementStyles.letterSpacing,
    'border': elementStyles.border,
    'paddingTop': includePaddings ? elementStyles.paddingTop : '',
    'paddingRight': includePaddings ? elementStyles.paddingRight : '',
    'paddingBottom': includePaddings ? elementStyles.paddingBottom : '',
    'paddingLeft': includePaddings ? elementStyles.paddingLeft : '',
    'visibility': 'hidden',
    'whiteSpace': 'pre',
    'position': 'absolute',
    'float': 'left'
  });
};
exports.createTextElementHiddenCopy = createTextElementHiddenCopy;
var insertBefore = function insertBefore(element, newElement) {
  if (newElement) {
    _dom_adapter.default.insertElement(element.parentNode, newElement, element);
  }
  return element;
};
exports.insertBefore = insertBefore;
var replaceWith = function replaceWith(element, newElement) {
  if (!(newElement && newElement[0])) return;
  if (newElement.is(element)) return element;
  (0, _iterator.each)(newElement, function (_, currentElement) {
    insertBefore(element[0], currentElement);
  });
  element.remove();
  return newElement;
};
exports.replaceWith = replaceWith;
var isElementInDom = function isElementInDom($element) {
  var element = $element === null || $element === void 0 ? void 0 : $element.get(0);
  var shadowHost = element === null || element === void 0 ? void 0 : element.getRootNode().host;
  return !!(0, _renderer.default)(shadowHost || element).closest((0, _window.getWindow)().document).length;
};
exports.isElementInDom = isElementInDom;

/***/ }),

/***/ 95640:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _extend = __webpack_require__(13306);
var _console = __webpack_require__(30869);
var _string = __webpack_require__(68752);
var _version = __webpack_require__(36739);
/* eslint-disable import/no-commonjs */

var ERROR_URL = 'http://js.devexpress.com/error/' + _version.version.split('.').slice(0, 2).join('_') + '/';
function _default(baseErrors, errors) {
  var exports = {
    ERROR_MESSAGES: (0, _extend.extend)(errors, baseErrors),
    Error: function Error() {
      return makeError([].slice.call(arguments));
    },
    log: function log(id) {
      var method = 'log';
      if (/^E\d+$/.test(id)) {
        method = 'error';
      } else if (/^W\d+$/.test(id)) {
        method = 'warn';
      }
      _console.logger[method](method === 'log' ? id : combineMessage([].slice.call(arguments)));
    }
  };
  function combineMessage(args) {
    var id = args[0];
    args = args.slice(1);
    return formatMessage(id, formatDetails(id, args));
  }
  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return _string.format.apply(this, args).replace(/\.*\s*?$/, '');
  }
  function formatMessage(id, details) {
    return _string.format.apply(this, ['{0} - {1}. See:\n{2}', id, details, getErrorUrl(id)]);
  }
  function makeError(args) {
    var id = args[0];
    args = args.slice(1);
    var details = formatDetails(id, args);
    var url = getErrorUrl(id);
    var message = formatMessage(id, details);
    return (0, _extend.extend)(new Error(message), {
      __id: id,
      __details: details,
      url: url
    });
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 13306:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.extendFromObject = exports.extend = void 0;
var _type = __webpack_require__(35922);
var extendFromObject = function extendFromObject(target, source, overrideExistingValues) {
  target = target || {};
  for (var prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      var value = source[prop];
      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value;
      }
    }
  }
  return target;
};
exports.extendFromObject = extendFromObject;
var extend = function extend(target) {
  target = target || {};
  var i = 1;
  var deep = false;
  if (typeof target === 'boolean') {
    deep = target;
    target = arguments[1] || {};
    i++;
  }
  for (; i < arguments.length; i++) {
    var source = arguments[i];
    if (source == null) {
      continue;
    }
    for (var key in source) {
      var targetValue = target[key];
      var sourceValue = source[key];
      var sourceValueIsArray = false;
      var clone = void 0;
      if (key === '__proto__' || key === 'constructor' || target === sourceValue) {
        continue;
      }
      if (deep && sourceValue && ((0, _type.isPlainObject)(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone = targetValue && (0, _type.isPlainObject)(targetValue) ? targetValue : {};
        }
        target[key] = extend(deep, clone, sourceValue);
      } else if (sourceValue !== undefined) {
        target[key] = sourceValue;
      }
    }
  }
  return target;
};
exports.extend = extend;

/***/ }),

/***/ 61371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.parseHTML = exports.isTablePart = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
var tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: '',
    endTags: ''
  },
  thead: {
    tagsCount: 1,
    startTags: '<table>',
    endTags: '</table>'
  },
  td: {
    tagsCount: 3,
    startTags: '<table><tbody><tr>',
    endTags: '</tr></tbody></table>'
  },
  col: {
    tagsCount: 2,
    startTags: '<table><colgroup>',
    endTags: '</colgroup></table>'
  },
  tr: {
    tagsCount: 2,
    startTags: '<table><tbody>',
    endTags: '</tbody></table>'
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;
var parseHTML = function parseHTML(html) {
  if (typeof html !== 'string') {
    return null;
  }
  var fragment = _dom_adapter.default.createDocumentFragment();
  var container = fragment.appendChild(_dom_adapter.default.createElement('div'));
  var tags = isTagName.exec(html);
  var firstRootTag = tags && tags[1].toLowerCase();
  var tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
  for (var i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }
  return _toConsumableArray(container.childNodes);
};
exports.parseHTML = parseHTML;
var isTablePart = function isTablePart(html) {
  var tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};
exports.isTablePart = isTablePart;

/***/ }),

/***/ 44899:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getImageSourceType = exports.getImageContainer = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ICON_CLASS = 'dx-icon';
var SVG_ICON_CLASS = 'dx-svg-icon';
var getImageSourceType = function getImageSourceType(source) {
  if (!source || typeof source !== 'string') {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return 'svg';
  }
  if (/data:.*base64|\.|[^<\s]\/{1,1}/.test(source)) {
    return 'image';
  }
  if (/^[\w-_]+$/.test(source)) {
    return 'dxIcon';
  }
  if (/^\s?([\w-_]\s?)+$/.test(source)) {
    return 'fontIcon';
  }
  return false;
};
exports.getImageSourceType = getImageSourceType;
var getImageContainer = function getImageContainer(source) {
  switch (getImageSourceType(source)) {
    case 'image':
      return (0, _renderer.default)('<img>').attr('src', source).addClass(ICON_CLASS);
    case 'fontIcon':
      return (0, _renderer.default)('<i>').addClass("".concat(ICON_CLASS, " ").concat(source));
    case 'dxIcon':
      return (0, _renderer.default)('<i>').addClass("".concat(ICON_CLASS, " ").concat(ICON_CLASS, "-").concat(source));
    case 'svg':
      return (0, _renderer.default)('<i>').addClass("".concat(ICON_CLASS, " ").concat(SVG_ICON_CLASS)).append(source);
    default:
      return null;
  }
};
exports.getImageContainer = getImageContainer;

/***/ }),

/***/ 78008:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.underscore = exports.titleize = exports.humanize = exports.dasherize = exports.captionize = exports.camelize = void 0;
var _iterator = __webpack_require__(95479);
var _normalize = function _normalize(text) {
  if (text === undefined || text === null) {
    return '';
  }
  return String(text);
};
var _upperCaseFirst = function _upperCaseFirst(text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};
var _chop = function _chop(text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, '$1 $2').split(/[\s_-]+/);
};
var dasherize = function dasherize(text) {
  return (0, _iterator.map)(_chop(text), function (p) {
    return p.toLowerCase();
  }).join('-');
};
exports.dasherize = dasherize;
var underscore = function underscore(text) {
  return dasherize(text).replace(/-/g, '_');
};
exports.underscore = underscore;
var camelize = function camelize(text, upperFirst) {
  return (0, _iterator.map)(_chop(text), function (p, i) {
    p = p.toLowerCase();
    if (upperFirst || i > 0) {
      p = _upperCaseFirst(p);
    }
    return p;
  }).join('');
};
exports.camelize = camelize;
var humanize = function humanize(text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, ' '));
};
exports.humanize = humanize;
var titleize = function titleize(text) {
  return (0, _iterator.map)(_chop(text), function (p) {
    return _upperCaseFirst(p.toLowerCase());
  }).join(' ');
};
exports.titleize = titleize;
var DIGIT_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
var captionize = function captionize(name) {
  var captionList = [];
  var i;
  var char;
  var isPrevCharNewWord = false;
  var isNewWord = false;
  for (i = 0; i < name.length; i++) {
    char = name.charAt(i);
    isNewWord = char === char.toUpperCase() && char !== '-' && char !== ')' && char !== '/' || char in DIGIT_CHARS;
    if (char === '_' || char === '.') {
      char = ' ';
      isNewWord = true;
    } else if (i === 0) {
      char = char.toUpperCase();
      isNewWord = true;
    } else if (!isPrevCharNewWord && isNewWord) {
      if (captionList.length > 0) {
        captionList.push(' ');
      }
    }
    captionList.push(char);
    isPrevCharNewWord = isNewWord;
  }
  return captionList.join('');
};
exports.captionize = captionize;

/***/ }),

/***/ 95479:
/***/ (function(__unused_webpack_module, exports) {



exports.reverseEach = exports.map = exports.each = void 0;
var map = function map(values, callback) {
  if (Array.isArray(values)) {
    return values.map(callback);
  }
  var result = [];
  for (var key in values) {
    result.push(callback(values[key], key));
  }
  return result;
};

/**
 * @type {{
 *   <T>(values: T[], callback: (this: T,          index: number,  value: T)          => void | boolean): T[],
 *   <T>(values: T,   callback: (this: T[keyof T], index: keyof T, value: T[keyof T]) => void | boolean): T,
 * }}
 */
exports.map = map;
var each = function each(values, callback) {
  if (!values) return;
  if ('length' in values) {
    for (var i = 0; i < values.length; i++) {
      if (callback.call(values[i], i, values[i]) === false) {
        break;
      }
    }
  } else {
    for (var key in values) {
      if (callback.call(values[key], key, values[key]) === false) {
        break;
      }
    }
  }
  return values;
};
exports.each = each;
var reverseEach = function reverseEach(array, callback) {
  if (!array || !('length' in array) || array.length === 0) return;
  for (var i = array.length - 1; i >= 0; i--) {
    if (callback.call(array[i], i, array[i]) === false) {
      break;
    }
  }
};
exports.reverseEach = reverseEach;

/***/ }),

/***/ 88933:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var Locker = function Locker() {
  var info = {};
  var currentCount = function currentCount(lockName) {
    return info[lockName] || 0;
  };
  return {
    obtain: function obtain(lockName) {
      info[lockName] = currentCount(lockName) + 1;
    },
    release: function release(lockName) {
      var count = currentCount(lockName);
      if (count < 1) {
        throw _errors.default.Error('E0014');
      }
      if (count === 1) {
        delete info[lockName];
      } else {
        info[lockName] = count - 1;
      }
    },
    locked: function locked(lockName) {
      return currentCount(lockName) > 0;
    }
  };
};
var _default = Locker;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 60810:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.adjust = adjust;
exports.fitIntoRange = void 0;
exports.getExponent = getExponent;
exports.getExponentLength = getExponentLength;
exports.getPrecision = getPrecision;
exports.getRemainderByDivision = getRemainderByDivision;
exports.getRoot = getRoot;
exports.inRange = void 0;
exports.multiplyInExponentialForm = multiplyInExponentialForm;
exports.roundFloatPart = roundFloatPart;
exports.sign = void 0;
exports.solveCubicEquation = solveCubicEquation;
exports.trunc = trunc;
var _type = __webpack_require__(35922);
var sign = function sign(value) {
  if (value === 0) {
    return 0;
  }
  return value / Math.abs(value);
};
exports.sign = sign;
var fitIntoRange = function fitIntoRange(value, minValue, maxValue) {
  var isMinValueUndefined = !minValue && minValue !== 0;
  var isMaxValueUndefined = !maxValue && maxValue !== 0;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value, maxValue) : value);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value, minValue) : value);
  return Math.min(Math.max(value, minValue), maxValue);
};
exports.fitIntoRange = fitIntoRange;
var inRange = function inRange(value, minValue, maxValue) {
  return value >= minValue && value <= maxValue;
};
exports.inRange = inRange;
function getExponent(value) {
  return Math.abs(parseInt(value.toExponential().split('e')[1]));
}
function getExponentialNotation(value) {
  var parts = value.toExponential().split('e');
  var mantissa = parseFloat(parts[0]);
  var exponent = parseInt(parts[1]);
  return {
    exponent,
    mantissa
  };
}
function multiplyInExponentialForm(value, exponentShift) {
  var exponentialNotation = getExponentialNotation(value);
  return parseFloat("".concat(exponentialNotation.mantissa, "e").concat(exponentialNotation.exponent + exponentShift));
}

// T570217
function _isEdgeBug() {
  var value = 0.0003;
  var correctValue = '0.000300';
  var precisionValue = 3;
  return correctValue !== value.toPrecision(precisionValue);
}
function adjust(value, interval) {
  var precision = getPrecision(interval || 0) + 2;
  var separatedValue = value.toString().split('.');
  var sourceValue = value;
  var absValue = Math.abs(value);
  var separatedAdjustedValue;
  var isExponentValue = (0, _type.isExponential)(value);
  var integerPart = absValue > 1 ? 10 : 0;
  if (separatedValue.length === 1) {
    return value;
  }
  if (!isExponentValue) {
    if ((0, _type.isExponential)(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value = absValue;
    value = value - Math.floor(value) + integerPart;
  }
  precision = _isEdgeBug() && getExponent(value) > 6 || precision > 7 ? 15 : 7; // fix toPrecision() bug in Edge (T570217)

  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value.toPrecision(precision)).toString().split('.');
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(separatedValue[0] + '.' + separatedAdjustedValue[1]);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value) {
  var str = value.toString();
  if (str.indexOf('.') < 0) {
    return 0;
  }
  var mantissa = str.split('.');
  var positionOfDelimiter = mantissa[1].indexOf('e');
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}
function getRoot(x, n) {
  if (x < 0 && n % 2 !== 1) {
    return NaN;
  }
  var y = Math.pow(Math.abs(x), 1 / n);
  return n % 2 === 1 && x < 0 ? -y : y;
}
function solveCubicEquation(a, b, c, d) {
  var min = 1e-8;
  if (Math.abs(a) < min) {
    a = b;
    b = c;
    c = d;
    if (Math.abs(a) < min) {
      a = b;
      b = c;
      if (Math.abs(a) < min) {
        return [];
      }
      return [-b / a];
    }
    var D2 = b * b - 4 * a * c;
    if (Math.abs(D2) < min) {
      return [-b / (2 * a)];
    } else if (D2 > 0) {
      return [(-b + Math.sqrt(D2)) / (2 * a), (-b - Math.sqrt(D2)) / (2 * a)];
    }
    return [];
  }
  var p = (3 * a * c - b * b) / (3 * a * a);
  var q = (2 * b * b * b - 9 * a * b * c + 27 * a * a * d) / (27 * a * a * a);
  var roots;
  var u;
  if (Math.abs(p) < min) {
    roots = [getRoot(-q, 3)];
  } else if (Math.abs(q) < min) {
    roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);
  } else {
    var D3 = q * q / 4 + p * p * p / 27;
    if (Math.abs(D3) < min) {
      roots = [-1.5 * q / p, 3 * q / p];
    } else if (D3 > 0) {
      u = getRoot(-q / 2 - Math.sqrt(D3), 3);
      roots = [u - p / (3 * u)];
    } else {
      u = 2 * Math.sqrt(-p / 3);
      var t = Math.acos(3 * q / p / u) / 3;
      var k = 2 * Math.PI / 3;
      roots = [u * Math.cos(t), u * Math.cos(t - k), u * Math.cos(t - 2 * k)];
    }
  }
  for (var i = 0; i < roots.length; i++) {
    roots[i] -= b / (3 * a);
  }
  return roots;
}
function trunc(value) {
  return Math.trunc ? Math.trunc(value) : value > 0 ? Math.floor(value) : Math.ceil(value);
}
function getRemainderByDivision(dividend, divider, digitsCount) {
  if (divider === parseInt(divider)) {
    return dividend % divider;
  }
  var quotient = roundFloatPart(dividend / divider, digitsCount);
  return (quotient - parseInt(quotient)) * divider;
}
function getExponentLength(value) {
  var _valueString$split$;
  var valueString = value.toString();
  return ((_valueString$split$ = valueString.split('.')[1]) === null || _valueString$split$ === void 0 ? void 0 : _valueString$split$.length) || parseInt(valueString.split('e-')[1]) || 0;
}
function roundFloatPart(value) {
  var digitsCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return parseFloat(value.toFixed(digitsCount));
}

/***/ }),

/***/ 48013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.orderEach = exports.deepExtendArraySafe = exports.clone = void 0;
var _type = __webpack_require__(35922);
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var clone = function () {
  function Clone() {}
  return function (obj) {
    Clone.prototype = obj;
    return new Clone();
  };
}();
exports.clone = clone;
var orderEach = function orderEach(map, func) {
  var keys = [];
  var key;
  var i;
  for (key in map) {
    if (Object.prototype.hasOwnProperty.call(map, key)) {
      keys.push(key);
    }
  }
  keys.sort(function (x, y) {
    var isNumberX = (0, _type.isNumeric)(x);
    var isNumberY = (0, _type.isNumeric)(y);
    if (isNumberX && isNumberY) return x - y;
    if (isNumberX && !isNumberY) return -1;
    if (!isNumberX && isNumberY) return 1;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
  });
  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    func(key, map[key]);
  }
};
exports.orderEach = orderEach;
var assignValueToProperty = function assignValueToProperty(target, property, value, assignByReference) {
  if (!assignByReference && _variable_wrapper.default.isWrapped(target[property])) {
    _variable_wrapper.default.assign(target[property], value);
  } else {
    target[property] = value;
  }
};

// B239679, http://bugs.jquery.com/ticket/9477
var deepExtendArraySafe = function deepExtendArraySafe(target, changes, extendComplexObject, assignByReference) {
  var prevValue;
  var newValue;
  for (var name in changes) {
    prevValue = target[name];
    newValue = changes[name];
    if (name === '__proto__' || name === 'constructor' || target === newValue) {
      continue;
    }
    if ((0, _type.isPlainObject)(newValue)) {
      var goDeeper = extendComplexObject ? (0, _type.isObject)(prevValue) : (0, _type.isPlainObject)(prevValue);
      newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference);
    }
    if (newValue !== undefined && prevValue !== newValue) {
      assignValueToProperty(target, name, newValue, assignByReference);
    }
  }
  return target;
};
exports.deepExtendArraySafe = deepExtendArraySafe;

/***/ }),

/***/ 37518:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getDefaultAlignment = exports.getBoundingRect = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var getDefaultAlignment = function getDefaultAlignment(isRtlEnabled) {
  var rtlEnabled = isRtlEnabled !== null && isRtlEnabled !== void 0 ? isRtlEnabled : (0, _config.default)().rtlEnabled;
  return rtlEnabled ? 'right' : 'left';
};
exports.getDefaultAlignment = getDefaultAlignment;
var getBoundingRect = function getBoundingRect(element) {
  if ((0, _type.isWindow)(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }
  return element.getBoundingClientRect();
};
exports.getBoundingRect = getBoundingRect;

/***/ }),

/***/ 9321:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.attachInstanceToElement = attachInstanceToElement;
exports.getInstanceByElement = getInstanceByElement;
exports.name = void 0;
var _element_data = __webpack_require__(97906);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _type = __webpack_require__(35922);
var _remove = __webpack_require__(29007);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var COMPONENT_NAMES_DATA_KEY = 'dxComponents';
var ANONYMOUS_COMPONENT_DATA_KEY = 'dxPrivateComponent';
var componentNames = new WeakMap();
var nextAnonymousComponent = 0;
var getName = function getName(componentClass, newName) {
  if ((0, _type.isDefined)(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }
  if (!componentNames.has(componentClass)) {
    var generatedName = ANONYMOUS_COMPONENT_DATA_KEY + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }
  return componentNames.get(componentClass);
};
exports.name = getName;
function attachInstanceToElement($element, componentInstance, disposeFn) {
  var data = (0, _element_data.data)($element.get(0));
  var name = getName(componentInstance.constructor);
  data[name] = componentInstance;
  if (disposeFn) {
    _events_engine.default.one($element, _remove.removeEvent, function () {
      disposeFn.call(componentInstance);
    });
  }
  if (!data[COMPONENT_NAMES_DATA_KEY]) {
    data[COMPONENT_NAMES_DATA_KEY] = [];
  }
  data[COMPONENT_NAMES_DATA_KEY].push(name);
}
function getInstanceByElement($element, componentClass) {
  var name = getName(componentClass);
  return (0, _element_data.data)($element.get(0), name);
}

/***/ }),

/***/ 59504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.create = createQueue;
exports.enqueue = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function createQueue(discardPendingTasks) {
  var _tasks = [];
  var _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      var task = _tasks.shift();
      var result = task();
      if (result === undefined) {
        continue;
      }
      if (result.then) {
        // NOTE: immediate "then" on the next line can reset it back to false
        (0, _deferred.when)(result).always(exec);
        return;
      }
      throw _errors.default.Error('E0015');
    }
    _busy = false;
  }
  function add(task, removeTaskCallback) {
    if (!discardPendingTasks) {
      _tasks.push(task);
    } else {
      if (_tasks[0] && removeTaskCallback) {
        removeTaskCallback(_tasks[0]);
      }
      _tasks = [task];
    }
    if (!_busy) {
      exec();
    }
  }
  function busy() {
    return _busy;
  }
  return {
    add: add,
    busy: busy
  };
}
var enqueue = createQueue().add; // Default global queue for UI sync, consider renaming
exports.enqueue = enqueue;

/***/ }),

/***/ 24311:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _window = __webpack_require__(58201);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var callbacks = [];
var subscribeReady = (0, _call_once.default)(function () {
  var removeListener = _dom_adapter.default.listen(_dom_adapter.default.getDocument(), 'DOMContentLoaded', function () {
    readyCallbacks.fire();
    removeListener();
  });
});
var readyCallbacks = {
  add: function add(callback) {
    var windowExists = (0, _window.hasWindow)();
    if (windowExists && _dom_adapter.default.getReadyState() !== 'loading') {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: function fire() {
    callbacks.forEach(function (callback) {
      return callback();
    });
    callbacks = [];
  }
};
var _default = (0, _dependency_injector.default)(readyCallbacks);
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 55814:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _call_once = _interopRequireDefault(__webpack_require__(39618));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var resizeCallbacks = function () {
  var prevSize;
  var callbacks = (0, _callbacks.default)();
  var originalCallbacksAdd = callbacks.add;
  var originalCallbacksRemove = callbacks.remove;
  if (!(0, _window.hasWindow)()) {
    return callbacks;
  }
  var formatSize = function formatSize() {
    var window = (0, _window.getWindow)();
    return {
      width: window.innerWidth,
      height: window.innerHeight
    };
  };
  var handleResize = function handleResize() {
    var now = formatSize();
    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }
    var changedDimension;
    if (now.width === prevSize.width) {
      changedDimension = 'height';
    }
    if (now.height === prevSize.height) {
      changedDimension = 'width';
    }
    prevSize = now;
    callbacks.fire(changedDimension);
  };
  var setPrevSize = (0, _call_once.default)(function () {
    prevSize = formatSize();
  });
  var removeListener;
  callbacks.add = function () {
    var result = originalCallbacksAdd.apply(callbacks, arguments);
    setPrevSize();
    _ready_callbacks.default.add(function () {
      if (!removeListener && callbacks.has()) {
        removeListener = _dom_adapter.default.listen((0, _window.getWindow)(), 'resize', handleResize);
      }
    });
    return result;
  };
  callbacks.remove = function () {
    var result = originalCallbacksRemove.apply(callbacks, arguments);
    if (!callbacks.has() && removeListener) {
      removeListener();
      removeListener = undefined;
    }
    return result;
  };
  return callbacks;
}();
var _default = resizeCallbacks;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49601:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SelectionFilterCreator = void 0;
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var SelectionFilterCreator = function SelectionFilterCreator(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function (keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = equalKeys === undefined ? _common.equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };
  this.getExpr = function (keyExpr) {
    if (!keyExpr) {
      return;
    }
    var filterExpr;
    selectedItemKeys.forEach(function (key, index) {
      filterExpr = filterExpr || [];
      var filterExprPart;
      if (index > 0) {
        filterExpr.push(isSelectAll ? 'and' : 'or');
      }
      if ((0, _type.isString)(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = getFilterForCompositeKey(keyExpr, key);
      }
      filterExpr.push(filterExprPart);
    });
    if (filterExpr && filterExpr.length === 1) {
      filterExpr = filterExpr[0];
    }
    return filterExpr;
  };
  this.getCombinedFilter = function (keyExpr, dataSourceFilter) {
    var forceCombinedFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var filterExpr = this.getExpr(keyExpr);
    var combinedFilter = filterExpr;
    if ((forceCombinedFilter || isSelectAll) && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }
    return combinedFilter;
  };
  var selectedItemKeyHashesMap;
  var getSelectedItemKeyHashesMap = function getSelectedItemKeyHashesMap(keyOf, keyExpr) {
    if (!selectedItemKeyHashesMap) {
      selectedItemKeyHashesMap = {};
      var normalizedKeys = normalizeKeys(selectedItemKeys, keyOf, keyExpr);
      for (var i = 0; i < normalizedKeys.length; i++) {
        selectedItemKeyHashesMap[(0, _common.getKeyHash)(normalizedKeys[i])] = true;
      }
    }
    return selectedItemKeyHashesMap;
  };
  var normalizeKeys = function normalizeKeys(keys, keyOf, keyExpr) {
    return Array.isArray(keyExpr) ? keys.map(function (key) {
      return keyOf(key);
    }) : keys;
  };
  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    var key = keyOf(item);
    var keyHash;
    var i;
    if (!equalByReference) {
      keyHash = (0, _common.getKeyHash)(key);
      if (!(0, _type.isObject)(keyHash)) {
        var selectedKeyHashesMap = getSelectedItemKeyHashesMap(keyOf, keyExpr);
        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }
        return !!isSelectAll;
      }
    }
    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }
    return !!isSelectAll;
  }
  function getFilterForPlainKey(keyExpr, keyValue) {
    if (keyValue === undefined) {
      return;
    }
    return [keyExpr, isSelectAll ? '<>' : '=', keyValue];
  }
  function getFilterForCompositeKey(keyExpr, itemKeyValue) {
    var filterExpr = [];
    for (var i = 0, length = keyExpr.length; i < length; i++) {
      var currentKeyExpr = keyExpr[i];
      var currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr];
      var filterExprPart = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
      if (!filterExprPart) {
        break;
      }
      if (i > 0) {
        filterExpr.push(isSelectAll ? 'or' : 'and');
      }
      filterExpr.push(filterExprPart);
    }
    return filterExpr;
  }
};
exports.SelectionFilterCreator = SelectionFilterCreator;

/***/ }),

/***/ 90330:
/***/ (function(__unused_webpack_module, exports) {



exports.addShadowDomStyles = addShadowDomStyles;
exports.getShadowElementsFromPoint = getShadowElementsFromPoint;
var DX_RULE_PREFIX = 'dx-';
var ownerDocumentStyleSheet = null;
function createConstructedStyleSheet(rootNode) {
  try {
    // eslint-disable-next-line no-undef
    return new CSSStyleSheet();
  } catch (err) {
    var styleElement = rootNode.ownerDocument.createElement('style');
    rootNode.appendChild(styleElement);
    return styleElement.sheet;
  }
}
function processRules(targetStyleSheet, styleSheets, needApplyAllStyles) {
  for (var i = 0; i < styleSheets.length; i++) {
    var sheet = styleSheets[i];
    try {
      for (var j = 0; j < sheet.cssRules.length; j++) {
        insertRule(targetStyleSheet, sheet.cssRules[j], needApplyAllStyles);
      }
    } catch (err) {
      // NOTE: need try/catch block for not-supported cross-domain css
    }
  }
}
function insertRule(targetStyleSheet, rule, needApplyAllStyles) {
  var _rule$selectorText, _rule$cssRules, _rule$cssRules$, _rule$cssRules$$selec, _rule$name, _rule$style;
  var isDxRule = needApplyAllStyles || ((_rule$selectorText = rule.selectorText) === null || _rule$selectorText === void 0 ? void 0 : _rule$selectorText.includes(DX_RULE_PREFIX)) || ((_rule$cssRules = rule.cssRules) === null || _rule$cssRules === void 0 ? void 0 : (_rule$cssRules$ = _rule$cssRules[0]) === null || _rule$cssRules$ === void 0 ? void 0 : (_rule$cssRules$$selec = _rule$cssRules$.selectorText) === null || _rule$cssRules$$selec === void 0 ? void 0 : _rule$cssRules$$selec.includes(DX_RULE_PREFIX)) || ((_rule$name = rule.name) === null || _rule$name === void 0 ? void 0 : _rule$name.startsWith(DX_RULE_PREFIX)) || ((_rule$style = rule.style) === null || _rule$style === void 0 ? void 0 : _rule$style.fontFamily) === 'DXIcons';
  if (isDxRule) {
    targetStyleSheet.insertRule(rule.cssText, targetStyleSheet.cssRules.length);
  }
}
function addShadowDomStyles($element) {
  var _el$getRootNode;
  var el = $element.get(0);
  var root = (_el$getRootNode = el.getRootNode) === null || _el$getRootNode === void 0 ? void 0 : _el$getRootNode.call(el);
  if (!(root !== null && root !== void 0 && root.host)) {
    return;
  }
  if (!ownerDocumentStyleSheet) {
    ownerDocumentStyleSheet = createConstructedStyleSheet(root);
    processRules(ownerDocumentStyleSheet, el.ownerDocument.styleSheets, false);
  }
  var currentShadowDomStyleSheet = createConstructedStyleSheet(root);
  processRules(currentShadowDomStyleSheet, root.styleSheets, true);
  root.adoptedStyleSheets = [ownerDocumentStyleSheet, currentShadowDomStyleSheet];
}
function isPositionInElementRectangle(element, x, y) {
  var rect = element.getBoundingClientRect();
  return rect && x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;
}
function createQueue() {
  var shiftIndex = 0;
  var items = [];
  return Object.defineProperties({
    push(item) {
      items.push(item);
      return this;
    },
    shift() {
      shiftIndex++;
      return items[shiftIndex - 1];
    }
  }, {
    length: {
      get: function get() {
        return items.length - shiftIndex;
      },
      configurable: true,
      enumerable: true
    },
    items: {
      get: function get() {
        return items;
      },
      configurable: true,
      enumerable: true
    }
  });
}
function getShadowElementsFromPoint(x, y, root) {
  var elementQueue = createQueue().push(root);
  while (elementQueue.length) {
    var el = elementQueue.shift();
    for (var i = 0; i < el.childNodes.length; i++) {
      var childNode = el.childNodes[i];

      // eslint-disable-next-line no-undef
      if (childNode.nodeType === Node.ELEMENT_NODE && isPositionInElementRectangle(childNode, x, y) &&
      // eslint-disable-next-line no-undef
      getComputedStyle(childNode).pointerEvents !== 'none') {
        elementQueue.push(childNode);
      }
    }
  }
  var result = elementQueue.items.reverse();
  result.pop();
  return result;
}

/***/ }),

/***/ 58664:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.setWidth = exports.setOuterWidth = exports.setOuterHeight = exports.setInnerWidth = exports.setInnerHeight = exports.setHeight = exports.parseHeight = exports.implementationsMap = exports.getWindowByElement = exports.getWidth = exports.getVisibleHeight = exports.getVerticalOffsets = exports.getSize = exports.getOuterWidth = exports.getOuterHeight = exports.getOffset = exports.getInnerWidth = exports.getInnerHeight = exports.getHeight = exports.getElementBoxParams = exports.addOffsetToMinHeight = exports.addOffsetToMaxHeight = void 0;
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var SPECIAL_HEIGHT_VALUES = ['auto', 'none', 'inherit', 'initial'];
var getSizeByStyles = function getSizeByStyles(elementStyles, styles) {
  var result = 0;
  styles.forEach(function (style) {
    result += parseFloat(elementStyles[style]) || 0;
  });
  return result;
};
var getElementBoxParams = function getElementBoxParams(name, elementStyles) {
  var beforeName = name === 'width' ? 'Left' : 'Top';
  var afterName = name === 'width' ? 'Right' : 'Bottom';
  return {
    padding: getSizeByStyles(elementStyles, ['padding' + beforeName, 'padding' + afterName]),
    border: getSizeByStyles(elementStyles, ['border' + beforeName + 'Width', 'border' + afterName + 'Width']),
    margin: getSizeByStyles(elementStyles, ['margin' + beforeName, 'margin' + afterName])
  };
};
exports.getElementBoxParams = getElementBoxParams;
var getElementComputedStyle = function getElementComputedStyle(element) {
  var _element$ownerDocumen;
  var view = (element === null || element === void 0 ? void 0 : (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.defaultView) || window;
  return view.getComputedStyle && view.getComputedStyle(element);
};
var getCSSProperty = function getCSSProperty(element, styles, name, defaultValue) {
  var _element$style;
  return (styles === null || styles === void 0 ? void 0 : styles[name]) || ((_element$style = element.style) === null || _element$style === void 0 ? void 0 : _element$style[name]) || defaultValue;
};
var boxIndices = {
  content: 0,
  padding: 1,
  border: 2,
  margin: 3,
  'content-box': 0,
  'border-box': 2
};
var dimensionComponents = {
  width: ['left', 'right'],
  height: ['top', 'bottom']
};
function getComponentThickness(elem, dimension, component, styles) {
  var get = function get(elem, styles, field) {
    return parseFloat(getCSSProperty(elem, styles, field, '0')) || 0;
  };
  var suffix = component === 'border' ? '-width' : '';
  return get(elem, styles, "".concat(component, "-").concat(dimensionComponents[dimension][0]).concat(suffix)) + get(elem, styles, "".concat(component, "-").concat(dimensionComponents[dimension][1]).concat(suffix));
}
var getSize = function getSize(element, dimension, box) {
  var offsetFieldName = dimension === 'width' ? 'offsetWidth' : 'offsetHeight';
  var styles = getElementComputedStyle(element);
  var result = getCSSProperty(element, styles, dimension);
  if (result === '' || result === 'auto') {
    result = element[offsetFieldName];
  }
  result = parseFloat(result) || 0;
  var currentBox = getCSSProperty(element, styles, 'boxSizing', 'content-box');
  var targetBox = box || currentBox;
  var targetBoxIndex = boxIndices[targetBox];
  var currentBoxIndex = boxIndices[currentBox];
  if (targetBoxIndex === undefined || currentBoxIndex === undefined) {
    throw new Error();
  }
  if (currentBoxIndex === targetBoxIndex) {
    return result;
  }
  var coeff = Math.sign(targetBoxIndex - currentBoxIndex);
  var padding = false;
  var border = false;
  var margin = false;
  var scrollThickness = false;
  if (coeff === 1) {
    targetBoxIndex += 1;
    currentBoxIndex += 1;
  }
  for (var boxPart = currentBoxIndex; boxPart !== targetBoxIndex; boxPart += coeff) {
    switch (boxPart) {
      case boxIndices.content:
        break;
      case boxIndices.padding:
        padding = coeff * getComponentThickness(element, dimension, 'padding', styles);
        break;
      case boxIndices.border:
        border = coeff * getComponentThickness(element, dimension, 'border', styles);
        break;
      case boxIndices.margin:
        margin = coeff * getComponentThickness(element, dimension, 'margin', styles);
        break;
    }
  }
  if (padding || border) {
    var paddingAndBorder = (padding === false ? coeff * getComponentThickness(element, dimension, 'padding', styles) : padding) + (border === false ? coeff * getComponentThickness(element, dimension, 'border', styles) : border);
    scrollThickness = coeff * Math.max(0, Math.floor(element[offsetFieldName] - result - coeff * paddingAndBorder)) || 0;
  }
  return result + margin + padding + border + scrollThickness;
};
exports.getSize = getSize;
var getContainerHeight = function getContainerHeight(container) {
  return (0, _type.isWindow)(container) ? container.innerHeight : container.offsetHeight;
};
var parseHeight = function parseHeight(value, container, element) {
  if (value.indexOf('px') > 0) {
    value = parseInt(value.replace('px', ''));
  } else if (value.indexOf('%') > 0) {
    value = parseInt(value.replace('%', '')) * getContainerHeight(container) / 100;
  } else if (!isNaN(value)) {
    value = parseInt(value);
  } else if (value.indexOf('vh') > 0) {
    value = window.innerHeight / 100 * parseInt(value.replace('vh', ''));
  } else if (element && value.indexOf('em') > 0) {
    value = parseFloat(value.replace('em', '')) * parseFloat(window.getComputedStyle(element).fontSize);
  }
  return value;
};
exports.parseHeight = parseHeight;
var getHeightWithOffset = function getHeightWithOffset(value, offset, container) {
  if (!value) {
    return null;
  }
  if (SPECIAL_HEIGHT_VALUES.indexOf(value) > -1) {
    return offset ? null : value;
  }
  if ((0, _type.isString)(value)) {
    value = parseHeight(value, container);
  }
  if ((0, _type.isNumeric)(value)) {
    return Math.max(0, value + offset);
  }
  var operationString = offset < 0 ? ' - ' : ' ';
  return 'calc(' + value + operationString + Math.abs(offset) + 'px)';
};
var addOffsetToMaxHeight = function addOffsetToMaxHeight(value, offset, container) {
  var maxHeight = getHeightWithOffset(value, offset, container);
  return maxHeight !== null ? maxHeight : 'none';
};
exports.addOffsetToMaxHeight = addOffsetToMaxHeight;
var addOffsetToMinHeight = function addOffsetToMinHeight(value, offset, container) {
  var minHeight = getHeightWithOffset(value, offset, container);
  return minHeight !== null ? minHeight : 0;
};
exports.addOffsetToMinHeight = addOffsetToMinHeight;
var getVerticalOffsets = function getVerticalOffsets(element, withMargins) {
  if (!element) {
    return 0;
  }
  var boxParams = getElementBoxParams('height', window.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};
exports.getVerticalOffsets = getVerticalOffsets;
var getVisibleHeight = function getVisibleHeight(element) {
  if (element) {
    var boundingClientRect = element.getBoundingClientRect();
    if (boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }
  return 0;
};

// TODO: remove when we'll start mocking named exports
exports.getVisibleHeight = getVisibleHeight;
var implementationsMap = {
  getWidth: function getWidth() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return elementSizeHelper.apply(void 0, ['width'].concat(args));
  },
  setWidth: function setWidth() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return elementSizeHelper.apply(void 0, ['width'].concat(args));
  },
  getHeight: function getHeight() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return elementSizeHelper.apply(void 0, ['height'].concat(args));
  },
  setHeight: function setHeight() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return elementSizeHelper.apply(void 0, ['height'].concat(args));
  },
  getOuterWidth: function getOuterWidth() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return elementSizeHelper.apply(void 0, ['outerWidth'].concat(args));
  },
  setOuterWidth: function setOuterWidth() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return elementSizeHelper.apply(void 0, ['outerWidth'].concat(args));
  },
  getOuterHeight: function getOuterHeight() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return elementSizeHelper.apply(void 0, ['outerHeight'].concat(args));
  },
  setOuterHeight: function setOuterHeight() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return elementSizeHelper.apply(void 0, ['outerHeight'].concat(args));
  },
  getInnerWidth: function getInnerWidth() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return elementSizeHelper.apply(void 0, ['innerWidth'].concat(args));
  },
  setInnerWidth: function setInnerWidth() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return elementSizeHelper.apply(void 0, ['innerWidth'].concat(args));
  },
  getInnerHeight: function getInnerHeight() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return elementSizeHelper.apply(void 0, ['innerHeight'].concat(args));
  },
  setInnerHeight: function setInnerHeight() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return elementSizeHelper.apply(void 0, ['innerHeight'].concat(args));
  }
};
exports.implementationsMap = implementationsMap;
function elementSizeHelper(sizeProperty, el, value) {
  return arguments.length === 2 ? elementSize(el, sizeProperty) : elementSize(el, sizeProperty, value);
}
var getWidth = function getWidth(el) {
  return implementationsMap.getWidth(el);
};
exports.getWidth = getWidth;
var setWidth = function setWidth(el, value) {
  return implementationsMap.setWidth(el, value);
};
exports.setWidth = setWidth;
var getHeight = function getHeight(el) {
  return implementationsMap.getHeight(el);
};
exports.getHeight = getHeight;
var setHeight = function setHeight(el, value) {
  return implementationsMap.setHeight(el, value);
};
exports.setHeight = setHeight;
var getOuterWidth = function getOuterWidth(el, includeMargin) {
  return implementationsMap.getOuterWidth(el, includeMargin || false);
};
exports.getOuterWidth = getOuterWidth;
var setOuterWidth = function setOuterWidth(el, value) {
  return implementationsMap.setOuterWidth(el, value);
};
exports.setOuterWidth = setOuterWidth;
var getOuterHeight = function getOuterHeight(el, includeMargin) {
  return implementationsMap.getOuterHeight(el, includeMargin || false);
};
exports.getOuterHeight = getOuterHeight;
var setOuterHeight = function setOuterHeight(el, value) {
  return implementationsMap.setOuterHeight(el, value);
};
exports.setOuterHeight = setOuterHeight;
var getInnerWidth = function getInnerWidth(el) {
  return implementationsMap.getInnerWidth(el);
};
exports.getInnerWidth = getInnerWidth;
var setInnerWidth = function setInnerWidth(el, value) {
  return implementationsMap.setInnerWidth(el, value);
};
exports.setInnerWidth = setInnerWidth;
var getInnerHeight = function getInnerHeight(el) {
  return implementationsMap.getInnerHeight(el);
};
exports.getInnerHeight = getInnerHeight;
var setInnerHeight = function setInnerHeight(el, value) {
  return implementationsMap.setInnerHeight(el, value);
};
exports.setInnerHeight = setInnerHeight;
var elementSize = function elementSize(el, sizeProperty, value) {
  var partialName = sizeProperty.toLowerCase().indexOf('width') >= 0 ? 'Width' : 'Height';
  var propName = partialName.toLowerCase();
  var isOuter = sizeProperty.indexOf('outer') === 0;
  var isInner = sizeProperty.indexOf('inner') === 0;
  var isGetter = arguments.length === 2 || typeof value === 'boolean';
  if ((0, _type.isRenderer)(el)) {
    if (el.length > 1 && !isGetter) {
      for (var i = 0; i < el.length; i++) {
        elementSize(el[i], sizeProperty, value);
      }
      return;
    }
    el = el[0];
  }
  if (!el) return;
  if ((0, _type.isWindow)(el)) {
    return isOuter ? el['inner' + partialName] : _dom_adapter.default.getDocumentElement()['client' + partialName];
  }
  if (_dom_adapter.default.isDocument(el)) {
    var documentElement = _dom_adapter.default.getDocumentElement();
    var body = _dom_adapter.default.getBody();
    return Math.max(body['scroll' + partialName], body['offset' + partialName], documentElement['scroll' + partialName], documentElement['offset' + partialName], documentElement['client' + partialName]);
  }
  if (isGetter) {
    var box = 'content';
    if (isOuter) {
      box = value ? 'margin' : 'border';
    }
    if (isInner) {
      box = 'padding';
    }
    return getSize(el, propName, box);
  }
  if ((0, _type.isNumeric)(value)) {
    var elementStyles = getElementComputedStyle(el);
    var sizeAdjustment = getElementBoxParams(propName, elementStyles);
    var isBorderBox = elementStyles.boxSizing === 'border-box';
    value = Number(value);
    if (isOuter) {
      value -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
    } else if (isInner) {
      value += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
    } else if (isBorderBox) {
      value += sizeAdjustment.border + sizeAdjustment.padding;
    }
  }
  value += (0, _type.isNumeric)(value) ? 'px' : '';
  _dom_adapter.default.setStyle(el, propName, value);
  return null;
};
var getWindowByElement = function getWindowByElement(el) {
  return (0, _type.isWindow)(el) ? el : el.defaultView;
};
exports.getWindowByElement = getWindowByElement;
var getOffset = function getOffset(el) {
  if (!el.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }
  var rect = el.getBoundingClientRect();
  var win = getWindowByElement(el.ownerDocument);
  var docElem = el.ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};
exports.getOffset = getOffset;

/***/ }),

/***/ 36613:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.sessionStorage = void 0;
var _window = __webpack_require__(58201);
var window = (0, _window.getWindow)();
var getSessionStorage = function getSessionStorage() {
  var sessionStorage;
  try {
    sessionStorage = window.sessionStorage;
  } catch (e) {}
  return sessionStorage;
};
exports.sessionStorage = getSessionStorage;

/***/ }),

/***/ 68752:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.encodeHtml = void 0;
exports.format = format;
exports.replaceAll = exports.quadToObject = exports.isEmpty = void 0;
var _type = __webpack_require__(35922);
var encodeHtml = function () {
  var encodeRegExp = [new RegExp('&', 'g'), new RegExp('"', 'g'), new RegExp('\'', 'g'), new RegExp('<', 'g'), new RegExp('>', 'g')];
  return function (str) {
    return String(str).replace(encodeRegExp[0], '&amp;').replace(encodeRegExp[1], '&quot;').replace(encodeRegExp[2], '&#39;').replace(encodeRegExp[3], '&lt;').replace(encodeRegExp[4], '&gt;');
  };
}();
exports.encodeHtml = encodeHtml;
var splitQuad = function splitQuad(raw) {
  switch (typeof raw) {
    case 'string':
      return raw.split(/\s+/, 4);
    case 'object':
      return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
    case 'number':
      return [raw];
    default:
      return raw;
  }
};
var quadToObject = function quadToObject(raw) {
  var quad = splitQuad(raw);
  var left = parseInt(quad && quad[0], 10);
  var top = parseInt(quad && quad[1], 10);
  var right = parseInt(quad && quad[2], 10);
  var bottom = parseInt(quad && quad[3], 10);
  if (!isFinite(left)) {
    left = 0;
  }
  if (!isFinite(top)) {
    top = left;
  }
  if (!isFinite(right)) {
    right = left;
  }
  if (!isFinite(bottom)) {
    bottom = top;
  }
  return {
    top: top,
    right: right,
    bottom: bottom,
    left: left
  };
};
exports.quadToObject = quadToObject;
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if ((0, _type.isFunction)(template)) {
    return template.apply(void 0, values);
  }
  values.forEach(function (value, index) {
    if ((0, _type.isString)(value)) {
      value = value.replace(/\$/g, '$$$$');
    }
    var placeholderReg = new RegExp('\\{' + index + '\\}', 'gm');
    template = template.replace(placeholderReg, value);
  });
  return template;
}
var replaceAll = function () {
  var quote = function quote(str) {
    return (str + '').replace(/([+*?.[^\]$(){}><|=!:])/g, '\\$1'); // lgtm[js/incomplete-sanitization]
  };

  return function (text, searchToken, replacementToken) {
    return text.replace(new RegExp('(' + quote(searchToken) + ')', 'gi'), replacementToken);
  };
}();
exports.replaceAll = replaceAll;
var isEmpty = function () {
  var SPACE_REGEXP = /\s/g;
  return function (text) {
    return !text || !text.replace(SPACE_REGEXP, '');
  };
}();
exports.isEmpty = isEmpty;

/***/ }),

/***/ 80968:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.stylePropPrefix = exports.styleProp = exports.setWidth = exports.setStyle = exports.setHeight = exports.parsePixelValue = exports.normalizeStyleProp = void 0;
var _inflector = __webpack_require__(78008);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _type = __webpack_require__(35922);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var jsPrefixes = ['', 'Webkit', 'Moz', 'O', 'Ms'];
var cssPrefixes = {
  '': '',
  'Webkit': '-webkit-',
  'Moz': '-moz-',
  'O': '-o-',
  'ms': '-ms-'
};
var getStyles = (0, _call_once.default)(function () {
  return _dom_adapter.default.createElement('dx').style;
});
var forEachPrefixes = function forEachPrefixes(prop, callBack) {
  prop = (0, _inflector.camelize)(prop, true);
  var result;
  for (var i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    var jsPrefix = jsPrefixes[i];
    var prefixedProp = jsPrefix + prop;
    var lowerPrefixedProp = (0, _inflector.camelize)(prefixedProp);
    result = callBack(lowerPrefixedProp, jsPrefix);
    if (result === undefined) {
      result = callBack(prefixedProp, jsPrefix);
    }
    if (result !== undefined) {
      break;
    }
  }
  return result || '';
};
var styleProp = function styleProp(name) {
  if (name in getStyles()) {
    return name;
  }
  var originalName = name;
  name = name.charAt(0).toUpperCase() + name.substr(1);
  for (var i = 1; i < jsPrefixes.length; i++) {
    var prefixedProp = jsPrefixes[i].toLowerCase() + name;
    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }
  return originalName;
};
exports.styleProp = styleProp;
var stylePropPrefix = function stylePropPrefix(prop) {
  return forEachPrefixes(prop, function (specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};
exports.stylePropPrefix = stylePropPrefix;
var pxExceptions = ['fillOpacity', 'columnCount', 'flexGrow', 'flexShrink', 'fontWeight', 'lineHeight', 'opacity', 'zIndex', 'zoom'];
var parsePixelValue = function parsePixelValue(value) {
  if ((0, _type.isNumeric)(value)) {
    return value;
  } else if ((0, _type.isString)(value)) {
    return Number(value.replace('px', ''));
  }
  return NaN;
};
exports.parsePixelValue = parsePixelValue;
var normalizeStyleProp = function normalizeStyleProp(prop, value) {
  if ((0, _type.isNumeric)(value) && pxExceptions.indexOf(prop) === -1) {
    value += 'px';
  }
  return value;
};
exports.normalizeStyleProp = normalizeStyleProp;
var setDimensionProperty = function setDimensionProperty(elements, propertyName, value) {
  if (elements) {
    value = (0, _type.isNumeric)(value) ? value += 'px' : value;
    for (var i = 0; i < elements.length; ++i) {
      elements[i].style[propertyName] = value;
    }
  }
};
var setWidth = function setWidth(elements, value) {
  setDimensionProperty(elements, 'width', value);
};
exports.setWidth = setWidth;
var setHeight = function setHeight(elements, value) {
  setDimensionProperty(elements, 'height', value);
};
exports.setHeight = setHeight;
var setStyle = function setStyle(element, styleString) {
  var resetStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (resetStyle) {
    var styleList = [].slice.call(element.style);
    styleList.forEach(function (propertyName) {
      element.style.removeProperty(propertyName);
    });
  }
  styleString.split(';').forEach(function (style) {
    var parts = style.split(':').map(function (stylePart) {
      return stylePart.trim();
    });
    if (parts.length === 2) {
      var _parts = _slicedToArray(parts, 2),
        property = _parts[0],
        value = _parts[1];
      element.style[property] = value;
    }
  });
};
exports.setStyle = setStyle;

/***/ }),

/***/ 60137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.pointerEvents = exports.nativeScrolling = exports.inputType = exports.animation = void 0;
Object.defineProperty(exports, "styleProp", ({
  enumerable: true,
  get: function get() {
    return _style.styleProp;
  }
}));
Object.defineProperty(exports, "stylePropPrefix", ({
  enumerable: true,
  get: function get() {
    return _style.stylePropPrefix;
  }
}));
exports.transitionEndEventName = exports.transition = exports.touchEvents = exports.touch = exports.supportProp = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _window = __webpack_require__(58201);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _style = __webpack_require__(80968);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _getNavigator = (0, _window.getNavigator)(),
  maxTouchPoints = _getNavigator.maxTouchPoints;
var transitionEndEventNames = {
  'webkitTransition': 'webkitTransitionEnd',
  'MozTransition': 'transitionend',
  'OTransition': 'oTransitionEnd',
  'transition': 'transitionend'
};
var supportProp = function supportProp(prop) {
  return !!(0, _style.styleProp)(prop);
};
exports.supportProp = supportProp;
var isNativeScrollingSupported = function isNativeScrollingSupported() {
  var _devices$real = _devices.default.real(),
    platform = _devices$real.platform,
    isMac = _devices$real.mac;
  var isNativeScrollDevice = platform === 'ios' || platform === 'android' || isMac;
  return isNativeScrollDevice;
};
var inputType = function inputType(type) {
  if (type === 'text') {
    return true;
  }
  var input = _dom_adapter.default.createElement('input');
  try {
    input.setAttribute('type', type);
    input.value = 'wrongValue';
    return !input.value;
  } catch (e) {
    return false;
  }
};
exports.inputType = inputType;
var detectTouchEvents = function detectTouchEvents(hasWindowProperty, maxTouchPoints) {
  return (hasWindowProperty('ontouchstart') || !!maxTouchPoints) && !hasWindowProperty('callPhantom');
};
var detectPointerEvent = function detectPointerEvent(hasWindowProperty) {
  return hasWindowProperty('PointerEvent');
};
var touchEvents = detectTouchEvents(_window.hasProperty, maxTouchPoints);
exports.touchEvents = touchEvents;
var pointerEvents = detectPointerEvent(_window.hasProperty);
exports.pointerEvents = pointerEvents;
var touchPointersPresent = !!maxTouchPoints;
var touch = touchEvents || pointerEvents && touchPointersPresent;
exports.touch = touch;
var transition = (0, _call_once.default)(function () {
  return supportProp('transition');
});
exports.transition = transition;
var transitionEndEventName = (0, _call_once.default)(function () {
  return transitionEndEventNames[(0, _style.styleProp)('transition')];
});
exports.transitionEndEventName = transitionEndEventName;
var animation = (0, _call_once.default)(function () {
  return supportProp('animation');
});
exports.animation = animation;
var nativeScrolling = isNativeScrollingSupported();
exports.nativeScrolling = nativeScrolling;

/***/ }),

/***/ 19155:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.HIDDEN_FOR_EXPORT = void 0;
exports.getSvgElement = getSvgElement;
exports.getSvgMarkup = getSvgMarkup;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
function getMarkup(element, backgroundColor) {
  var temp = _dom_adapter.default.createElement('div');
  var clone = element.cloneNode(true);
  if (backgroundColor) {
    (0, _renderer.default)(clone).css('backgroundColor', backgroundColor);
  }
  temp.appendChild(clone);
  return temp.innerHTML;
}
function fixNamespaces(markup) {
  var first = true;
  if (markup.indexOf('xmlns:xlink') === -1) {
    markup = markup.replace('<svg', '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
  }
  markup = markup.replace(/xmlns="[\s\S]*?"/gi, function (match) {
    if (!first) return '';
    first = false;
    return match;
  });
  return markup.replace(/xmlns:NS1="[\s\S]*?"/gi, '').replace(/NS1:xmlns:xlink="([\s\S]*?)"/gi, 'xmlns:xlink="$1"');
}

// T428345 we decode only restricted HTML entities, looks like other entities do not cause problems
// as they presented as symbols itself, not named entities
function decodeHtmlEntities(markup) {
  return markup.replace(/&quot;/gi, '&#34;').replace(/&amp;/gi, '&#38;').replace(/&apos;/gi, '&#39;').replace(/&lt;/gi, '&#60;').replace(/&gt;/gi, '&#62;').replace(/&nbsp;/gi, '&#160;').replace(/&shy;/gi, '&#173;');
}
var HIDDEN_FOR_EXPORT = 'hidden-for-export';
exports.HIDDEN_FOR_EXPORT = HIDDEN_FOR_EXPORT;
function getSvgMarkup(element, backgroundColor) {
  return fixNamespaces(decodeHtmlEntities(getMarkup(element, backgroundColor)));
}
function getSvgElement(markup) {
  return _dom_adapter.default.isNode(markup) ? markup : new window.DOMParser().parseFromString(markup, 'image/svg+xml').childNodes[0];
}

/***/ }),

/***/ 69697:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.validateTemplateSource = exports.templateKey = exports.suitableTemplatesByName = exports.getNormalizedTemplateArgs = exports.findTemplates = exports.defaultCreateElement = exports.addOneRenderedCall = exports.acquireTemplate = exports.acquireIntegrationTemplate = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _child_default_template = __webpack_require__(91627);
var _empty_template = __webpack_require__(10688);
var _template = __webpack_require__(9545);
var _template_base = __webpack_require__(81033);
var _array = __webpack_require__(89386);
var _common = __webpack_require__(20576);
var _dom = __webpack_require__(3532);
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var findTemplates = function findTemplates(element, name) {
  var optionsAttributeName = 'data-options';
  var templates = (0, _renderer.default)(element).contents().filter("[".concat(optionsAttributeName, "*=\"").concat(name, "\"]"));
  return [].slice.call(templates).map(function (element) {
    var optionsString = (0, _renderer.default)(element).attr(optionsAttributeName) || '';
    return {
      element,
      options: (0, _config.default)().optionsParser(optionsString)[name]
    };
  }).filter(function (template) {
    return !!template.options;
  });
};
exports.findTemplates = findTemplates;
var suitableTemplatesByName = function suitableTemplatesByName(rawTemplates) {
  var templatesMap = (0, _array.groupBy)(rawTemplates, function (template) {
    return template.options.name;
  });
  if (templatesMap['undefined']) {
    throw _errors.default.Error('E0023');
  }
  var result = {};
  Object.keys(templatesMap).forEach(function (name) {
    var _findBestMatches$;
    var suitableTemplate = (_findBestMatches$ = (0, _common.findBestMatches)(_devices.default.current(), templatesMap[name], function (template) {
      return template.options;
    })[0]) === null || _findBestMatches$ === void 0 ? void 0 : _findBestMatches$.element;
    if (suitableTemplate) {
      result[name] = suitableTemplate;
    }
  });
  return result;
};
exports.suitableTemplatesByName = suitableTemplatesByName;
var addOneRenderedCall = function addOneRenderedCall(template) {
  var render = template.render.bind(template);
  return (0, _extend.extend)({}, template, {
    render(options) {
      var templateResult = render(options);
      options && options.onRendered && options.onRendered();
      return templateResult;
    }
  });
};
exports.addOneRenderedCall = addOneRenderedCall;
var getNormalizedTemplateArgs = function getNormalizedTemplateArgs(options) {
  var args = [];
  if ('model' in options) {
    args.push(options.model);
  }
  if ('index' in options) {
    args.push(options.index);
  }
  args.push(options.container);
  return args;
};
exports.getNormalizedTemplateArgs = getNormalizedTemplateArgs;
var validateTemplateSource = function validateTemplateSource(templateSource) {
  return typeof templateSource === 'string' ? (0, _dom.normalizeTemplateElement)(templateSource) : templateSource;
};
exports.validateTemplateSource = validateTemplateSource;
var templateKey = function templateKey(templateSource) {
  return (0, _type.isRenderer)(templateSource) && templateSource[0] || templateSource;
};
exports.templateKey = templateKey;
var defaultCreateElement = function defaultCreateElement(element) {
  return new _template.Template(element);
};
exports.defaultCreateElement = defaultCreateElement;
var acquireIntegrationTemplate = function acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) {
  var integrationTemplate = null;
  if (!skipTemplates || skipTemplates.indexOf(templateSource) === -1) {
    integrationTemplate = templates[templateSource];
    if (integrationTemplate && !(integrationTemplate instanceof _template_base.TemplateBase) && !isAsyncTemplate) {
      integrationTemplate = addOneRenderedCall(integrationTemplate);
    }
  }
  return integrationTemplate;
};
exports.acquireIntegrationTemplate = acquireIntegrationTemplate;
var acquireTemplate = function acquireTemplate(templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) {
  if (templateSource == null) {
    return new _empty_template.EmptyTemplate();
  }
  if (templateSource instanceof _child_default_template.ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }
  if (templateSource instanceof _template_base.TemplateBase) {
    return templateSource;
  }

  // TODO: templateSource.render is needed for angular2 integration. Try to remove it after supporting TypeScript modules.
  if ((0, _type.isFunction)(templateSource.render) && !(0, _type.isRenderer)(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }
  if (templateSource.nodeType || (0, _type.isRenderer)(templateSource)) {
    return createTemplate((0, _renderer.default)(templateSource));
  }
  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};
exports.acquireTemplate = acquireTemplate;

/***/ }),

/***/ 35922:
/***/ (function(__unused_webpack_module, exports) {



exports.type = exports.isWindow = exports.isString = exports.isRenderer = exports.isPromise = exports.isPrimitive = exports.isPlainObject = exports.isObject = exports.isNumeric = exports.isFunction = exports.isExponential = exports.isEvent = exports.isEmptyObject = exports.isDefined = exports.isDeferred = exports.isDate = exports.isBoolean = void 0;
var types = {
  '[object Array]': 'array',
  '[object Date]': 'date',
  '[object Object]': 'object',
  '[object String]': 'string'
};
var type = function type(object) {
  if (object === null) {
    return 'null';
  }
  var typeOfObject = Object.prototype.toString.call(object);
  return typeof object === 'object' ? types[typeOfObject] || 'object' : typeof object;
};
exports.type = type;
var isBoolean = function isBoolean(object) {
  return typeof object === 'boolean';
};
exports.isBoolean = isBoolean;
var isExponential = function isExponential(value) {
  return isNumeric(value) && value.toString().indexOf('e') !== -1;
};
exports.isExponential = isExponential;
var isDate = function isDate(object) {
  return type(object) === 'date';
};
exports.isDate = isDate;
var isDefined = function isDefined(object) {
  return object !== null && object !== undefined;
};
exports.isDefined = isDefined;
var isFunction = function isFunction(object) {
  return typeof object === 'function';
};
exports.isFunction = isFunction;
var isString = function isString(object) {
  return typeof object === 'string';
};
exports.isString = isString;
var isNumeric = function isNumeric(object) {
  return typeof object === 'number' && isFinite(object) || !isNaN(object - parseFloat(object));
};
exports.isNumeric = isNumeric;
var isObject = function isObject(object) {
  return type(object) === 'object';
};
exports.isObject = isObject;
var isEmptyObject = function isEmptyObject(object) {
  var property;
  for (property in object) {
    return false;
  }
  return true;
};
exports.isEmptyObject = isEmptyObject;
var isPlainObject = function isPlainObject(object) {
  if (!object || type(object) !== 'object') {
    return false;
  }
  var proto = Object.getPrototypeOf(object);
  if (!proto) {
    return true;
  }
  var ctor = Object.hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof ctor === 'function' && Object.toString.call(ctor) === Object.toString.call(Object);
};
exports.isPlainObject = isPlainObject;
var isPrimitive = function isPrimitive(value) {
  return ['object', 'array', 'function'].indexOf(type(value)) === -1;
};
exports.isPrimitive = isPrimitive;
var isWindow = function isWindow(object) {
  return object != null && object === object.window;
};
exports.isWindow = isWindow;
var isRenderer = function isRenderer(object) {
  return !!object && !!(object.jquery || object.dxRenderer);
};
exports.isRenderer = isRenderer;
var isPromise = function isPromise(object) {
  return !!object && isFunction(object.then);
};
exports.isPromise = isPromise;
var isDeferred = function isDeferred(object) {
  return !!object && isFunction(object.done) && isFunction(object.fail);
};
exports.isDeferred = isDeferred;
var isEvent = function isEvent(object) {
  return !!(object && object.preventDefault);
};
exports.isEvent = isEvent;

/***/ }),

/***/ 26974:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _console = __webpack_require__(30869);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = (0, _dependency_injector.default)({
  isWrapped: function isWrapped() {
    return false;
  },
  isWritableWrapped: function isWritableWrapped() {
    return false;
  },
  wrap: function wrap(value) {
    return value;
  },
  unwrap: function unwrap(value) {
    return value;
  },
  assign: function assign() {
    _console.logger.error('Method \'assign\' should not be used for not wrapped variables. Use \'isWrapped\' method for ensuring.');
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 58020:
/***/ (function(__unused_webpack_module, exports) {



exports.compare = compare;
function compare(x, y, maxLevel) {
  function normalizeArg(value) {
    if (typeof value === 'string') {
      return value.split('.');
    }
    if (typeof value === 'number') {
      return [value];
    }
    return value;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  var length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (var i = 0; i < length; i++) {
    var xItem = parseInt(x[i] || 0, 10);
    var yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}

/***/ }),

/***/ 77695:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.changeCallback = void 0;
exports.originalViewPort = originalViewPort;
exports.value = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ready = _ready_callbacks.default.add;
var changeCallback = (0, _callbacks.default)();
exports.changeCallback = changeCallback;
var $originalViewPort = (0, _renderer.default)();
var value = function () {
  var $current;
  return function (element) {
    if (!arguments.length) {
      return $current;
    }
    var $element = (0, _renderer.default)(element);
    $originalViewPort = $element;
    var isNewViewportFound = !!$element.length;
    var prevViewPort = value();
    $current = isNewViewportFound ? $element : (0, _renderer.default)('body');
    changeCallback.fire(isNewViewportFound ? value() : (0, _renderer.default)(), prevViewPort);
  };
}();
exports.value = value;
ready(function () {
  value('.dx-viewport');
});
function originalViewPort() {
  return $originalViewPort;
}

/***/ }),

/***/ 58201:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.setWindow = exports.hasWindow = exports.hasProperty = exports.getWindow = exports.getNavigator = exports.getCurrentScreenFactor = exports.defaultScreenFactorFunc = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global window */

var hasWindowValue = typeof window !== 'undefined';
var hasWindow = function hasWindow() {
  return hasWindowValue;
};
exports.hasWindow = hasWindow;
var windowObject = hasWindow() ? window : undefined;
if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}
var getWindow = function getWindow() {
  return windowObject;
};
exports.getWindow = getWindow;
var setWindow = function setWindow(newWindowObject, hasWindow) {
  if (hasWindow === undefined) {
    hasWindowValue = typeof window !== 'undefined' && window === newWindowObject;
  } else {
    hasWindowValue = hasWindow;
  }
  windowObject = newWindowObject;
};
exports.setWindow = setWindow;
var hasProperty = function hasProperty(prop) {
  return hasWindow() && prop in windowObject;
};
exports.hasProperty = hasProperty;
var defaultScreenFactorFunc = function defaultScreenFactorFunc(width) {
  if (width < 768) {
    return 'xs';
  } else if (width < 992) {
    return 'sm';
  } else if (width < 1200) {
    return 'md';
  } else {
    return 'lg';
  }
};
exports.defaultScreenFactorFunc = defaultScreenFactorFunc;
var getCurrentScreenFactor = function getCurrentScreenFactor(screenFactorCallback) {
  var screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
  var windowWidth = _dom_adapter.default.getDocumentElement()['clientWidth'];
  return screenFactorFunc(windowWidth);
};
exports.getCurrentScreenFactor = getCurrentScreenFactor;
var getNavigator = function getNavigator() {
  return hasWindow() ? windowObject.navigator : {
    userAgent: ''
  };
};
exports.getNavigator = getNavigator;

/***/ }),

/***/ 36739:
/***/ (function(__unused_webpack_module, exports) {



exports.version = void 0;
var version = '23.2.0';
exports.version = version;

/***/ }),

/***/ 67403:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _events_strategy = __webpack_require__(80566);
var _iterator = __webpack_require__(95479);
var _errors = __webpack_require__(18438);
var _utils = __webpack_require__(16454);
var _data = __webpack_require__(47617);
var _store_helper = _interopRequireDefault(__webpack_require__(99236));
var _deferred = __webpack_require__(62754);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var abstract = _class.default.abstract;
var queryByOptions = _store_helper.default.queryByOptions;
var storeImpl = {};
var Store = _class.default.inherit({
  _langParams: {},
  ctor: function ctor(options) {
    var that = this;
    options = options || {};
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
    (0, _iterator.each)(['onLoaded', 'onLoading', 'onInserted', 'onInserting', 'onUpdated', 'onUpdating', 'onPush', 'onRemoved', 'onRemoving', 'onModified', 'onModifying'], function (_, optionName) {
      if (optionName in options) {
        that.on(optionName.slice(2).toLowerCase(), options[optionName]);
      }
    });
    this._key = options.key;
    this._errorHandler = options.errorHandler;
    this._useDefaultSearch = true;
  },
  _clearCache: _common.noop,
  _customLoadOptions: function _customLoadOptions() {
    return null;
  },
  key: function key() {
    return this._key;
  },
  keyOf: function keyOf(obj) {
    if (!this._keyGetter) {
      this._keyGetter = (0, _data.compileGetter)(this.key());
    }
    return this._keyGetter(obj);
  },
  _requireKey: function _requireKey() {
    if (!this.key()) {
      throw _errors.errors.Error('E4005');
    }
  },
  load: function load(options) {
    var that = this;
    options = options || {};
    this._eventsStrategy.fireEvent('loading', [options]);
    return this._withLock(this._loadImpl(options)).done(function (result) {
      that._eventsStrategy.fireEvent('loaded', [result, options]);
    });
  },
  _loadImpl: function _loadImpl(options) {
    if (!(0, _type.isEmptyObject)(this._langParams)) {
      options = options || {};
      options._langParams = _extends({}, this._langParams, options._langParams);
    }
    return queryByOptions(this.createQuery(options), options).enumerate();
  },
  _withLock: function _withLock(task) {
    var result = new _deferred.Deferred();
    task.done(function () {
      var that = this;
      var args = arguments;
      _utils.processRequestResultLock.promise().done(function () {
        result.resolveWith(that, args);
      });
    }).fail(function () {
      result.rejectWith(this, arguments);
    });
    return result;
  },
  createQuery: abstract,
  totalCount: function totalCount(options) {
    return this._totalCountImpl(options);
  },
  _totalCountImpl: function _totalCountImpl(options) {
    return queryByOptions(this.createQuery(options), options, true).count();
  },
  byKey: function byKey(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract,
  insert: function insert(values) {
    var that = this;
    that._eventsStrategy.fireEvent('modifying');
    that._eventsStrategy.fireEvent('inserting', [values]);
    return that._addFailHandlers(that._insertImpl(values).done(function (callbackValues, callbackKey) {
      that._eventsStrategy.fireEvent('inserted', [callbackValues, callbackKey]);
      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _insertImpl: abstract,
  update: function update(key, values) {
    var that = this;
    that._eventsStrategy.fireEvent('modifying');
    that._eventsStrategy.fireEvent('updating', [key, values]);
    return that._addFailHandlers(that._updateImpl(key, values).done(function () {
      that._eventsStrategy.fireEvent('updated', [key, values]);
      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _updateImpl: abstract,
  push: function push(changes) {
    var _this = this;
    var beforePushArgs = {
      changes,
      waitFor: []
    };
    this._eventsStrategy.fireEvent('beforePush', [beforePushArgs]);
    _deferred.when.apply(void 0, _toConsumableArray(beforePushArgs.waitFor)).done(function () {
      _this._pushImpl(changes);
      _this._eventsStrategy.fireEvent('push', [changes]);
    });
  },
  _pushImpl: _common.noop,
  remove: function remove(key) {
    var that = this;
    that._eventsStrategy.fireEvent('modifying');
    that._eventsStrategy.fireEvent('removing', [key]);
    return that._addFailHandlers(that._removeImpl(key).done(function (callbackKey) {
      that._eventsStrategy.fireEvent('removed', [callbackKey]);
      that._eventsStrategy.fireEvent('modified');
    }));
  },
  _removeImpl: abstract,
  _addFailHandlers: function _addFailHandlers(deferred) {
    return deferred.fail(this._errorHandler).fail(_errors.handleError);
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
Store.create = function (alias, options) {
  if (!(alias in storeImpl)) {
    throw _errors.errors.Error('E4020', alias);
  }
  return new storeImpl[alias](options);
};
Store.registerClass = function (type, alias) {
  if (alias) {
    storeImpl[alias] = type;
  }
  return type;
};
Store.inherit = function (inheritor) {
  return function (members, alias) {
    var type = inheritor.apply(this, [members]);
    Store.registerClass(type, alias);
    return type;
  };
}(Store.inherit);
var _default = Store;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 36893:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _array_utils = __webpack_require__(60637);
var _default = _array_utils.applyChanges;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 35042:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _data = __webpack_require__(47617);
var _deferred = __webpack_require__(62754);
var _errors = __webpack_require__(18438);
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var Iterator = _class.default.inherit({
  toArray: function toArray() {
    var result = [];
    this.reset();
    while (this.next()) {
      result.push(this.current());
    }
    return result;
  },
  countable: function countable() {
    return false;
  }
});
var ArrayIterator = Iterator.inherit({
  ctor: function ctor(array) {
    this.array = array;
    this.index = -1;
  },
  next: function next() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }
    return false;
  },
  current: function current() {
    return this.array[this.index];
  },
  reset: function reset() {
    this.index = -1;
  },
  toArray: function toArray() {
    return this.array.slice(0);
  },
  countable: function countable() {
    return true;
  },
  count: function count() {
    return this.array.length;
  }
});
var WrappedIterator = Iterator.inherit({
  ctor: function ctor(iter) {
    this.iter = iter;
  },
  next: function next() {
    return this.iter.next();
  },
  current: function current() {
    return this.iter.current();
  },
  reset: function reset() {
    return this.iter.reset();
  }
});
var MapIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, mapper) {
    this.callBase(iter);
    this.index = -1;
    this.mapper = mapper;
  },
  current: function current() {
    return this.mapper(this.callBase(), this.index);
  },
  next: function next() {
    var hasNext = this.callBase();
    if (hasNext) {
      this.index++;
    }
    return hasNext;
  }
});
var defaultCompare = function defaultCompare(xValue, yValue, options) {
  if ((0, _type.isString)(xValue) && (0, _type.isString)(yValue) && (options !== null && options !== void 0 && options.locale || options !== null && options !== void 0 && options.collatorOptions)) {
    /* eslint-disable-next-line no-undef */
    return new Intl.Collator((options === null || options === void 0 ? void 0 : options.locale) || undefined, (options === null || options === void 0 ? void 0 : options.collatorOptions) || undefined).compare(xValue, yValue);
  }
  xValue = (0, _data.toComparable)(xValue, false, options);
  yValue = (0, _data.toComparable)(yValue, false, options);
  if (xValue === null && yValue !== null) {
    return -1;
  }
  if (xValue !== null && yValue === null) {
    return 1;
  }
  if (xValue === undefined && yValue !== undefined) {
    return 1;
  }
  if (xValue !== undefined && yValue === undefined) {
    return -1;
  }
  if (xValue < yValue) {
    return -1;
  }
  if (xValue > yValue) {
    return 1;
  }
  return 0;
};
var SortIterator = Iterator.inherit({
  ctor: function ctor(iter, getter, desc, compare) {
    this.langParams = iter.langParams;
    if (!(iter instanceof MapIterator)) {
      iter = new MapIterator(iter, this._wrap);
      iter.langParams = this.langParams;
    }
    this.iter = iter;
    this.rules = [{
      getter: getter,
      desc: desc,
      compare: compare,
      langParams: this.langParams
    }];
  },
  thenBy: function thenBy(getter, desc, compare) {
    var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);
    if (!this.sortedIter) {
      result.rules = this.rules.concat(result.rules);
    }
    return result;
  },
  next: function next() {
    this._ensureSorted();
    return this.sortedIter.next();
  },
  current: function current() {
    this._ensureSorted();
    return this.sortedIter.current();
  },
  reset: function reset() {
    delete this.sortedIter;
  },
  countable: function countable() {
    return this.sortedIter || this.iter.countable();
  },
  count: function count() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }
    return this.iter.count();
  },
  _ensureSorted: function _ensureSorted() {
    var that = this;
    if (that.sortedIter) {
      return;
    }
    (0, _iterator.each)(that.rules, function () {
      this.getter = (0, _data.compileGetter)(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function (x, y) {
      return that._compare(x, y);
    })), that._unwrap);
  },
  _wrap: function _wrap(record, index) {
    return {
      index: index,
      value: record
    };
  },
  _unwrap: function _unwrap(wrappedItem) {
    return wrappedItem.value;
  },
  _getDefaultCompare(langParams) {
    return function (xValue, yValue) {
      return defaultCompare(xValue, yValue, langParams);
    };
  },
  _compare: function _compare(x, y) {
    var xIndex = x.index;
    var yIndex = y.index;
    x = x.value;
    y = y.value;
    if (x === y) {
      return xIndex - yIndex;
    }
    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      var rule = this.rules[i];
      var xValue = rule.getter(x);
      var yValue = rule.getter(y);
      var compare = rule.compare || this._getDefaultCompare(rule.langParams);
      var compareResult = compare(xValue, yValue);
      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }
    return xIndex - yIndex;
  }
});
var compileCriteria = function () {
  var langParams = {};
  var _toComparable = function _toComparable(value) {
    return (0, _data.toComparable)(value, false, langParams);
  };
  var compileGroup = function compileGroup(crit) {
    var ops = [];
    var isConjunctiveOperator = false;
    var isConjunctiveNextOperator = false;
    (0, _iterator.each)(crit, function () {
      if (Array.isArray(this) || (0, _type.isFunction)(this)) {
        if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {
          throw new _errors.errors.Error('E4019');
        }
        ops.push(compileCriteria(this, langParams));
        isConjunctiveOperator = isConjunctiveNextOperator;
        isConjunctiveNextOperator = true;
      } else {
        isConjunctiveNextOperator = (0, _utils.isConjunctiveOperator)(this);
      }
    });
    return function (d) {
      var result = isConjunctiveOperator;
      for (var i = 0; i < ops.length; i++) {
        if (ops[i](d) !== isConjunctiveOperator) {
          result = !isConjunctiveOperator;
          break;
        }
      }
      return result;
    };
  };
  var toString = function toString(value) {
    var _langParams;
    return (0, _type.isDefined)(value) ? (_langParams = langParams) !== null && _langParams !== void 0 && _langParams.locale ? value.toLocaleString(langParams.locale) : value.toString() : '';
  };
  var compileBinary = function compileBinary(crit) {
    crit = (0, _utils.normalizeBinaryCriterion)(crit);
    var getter = (0, _data.compileGetter)(crit[0]);
    var op = crit[1];
    var value = crit[2];
    value = _toComparable(value);
    var compare = function compare(obj, operatorFn) {
      obj = _toComparable(getter(obj));
      return (value == null || obj == null) && value !== obj ? false : operatorFn(obj, value);
    };
    switch (op.toLowerCase()) {
      case '=':
        return compileEquals(getter, value);
      case '<>':
        return compileEquals(getter, value, true);
      case '>':
        return function (obj) {
          return compare(obj, function (a, b) {
            return a > b;
          });
        };
      case '<':
        return function (obj) {
          return compare(obj, function (a, b) {
            return a < b;
          });
        };
      case '>=':
        return function (obj) {
          return compare(obj, function (a, b) {
            return a >= b;
          });
        };
      case '<=':
        return function (obj) {
          return compare(obj, function (a, b) {
            return a <= b;
          });
        };
      case 'startswith':
        return function (obj) {
          return _toComparable(toString(getter(obj))).indexOf(value) === 0;
        };
      case 'endswith':
        return function (obj) {
          var getterValue = _toComparable(toString(getter(obj)));
          var searchValue = toString(value);
          if (getterValue.length < searchValue.length) {
            return false;
          }
          var index = getterValue.lastIndexOf(value);
          return index !== -1 && index === getterValue.length - value.length;
        };
      case 'contains':
        return function (obj) {
          return _toComparable(toString(getter(obj))).indexOf(value) > -1;
        };
      case 'notcontains':
        return function (obj) {
          return _toComparable(toString(getter(obj))).indexOf(value) === -1;
        };
    }
    throw _errors.errors.Error('E4003', op);
  };
  function compileEquals(getter, value, negate) {
    return function (obj) {
      obj = _toComparable(getter(obj));
      // eslint-disable-next-line eqeqeq
      var result = useStrictComparison(value) ? obj === value : obj == value;
      if (negate) {
        result = !result;
      }
      return result;
    };
  }
  function useStrictComparison(value) {
    return value === '' || value === 0 || value === false;
  }
  function compileUnary(crit) {
    var op = crit[0];
    var criteria = compileCriteria(crit[1], langParams);
    if (op === '!') {
      return function (obj) {
        return !criteria(obj);
      };
    }
    throw _errors.errors.Error('E4003', op);
  }
  return function (crit, options) {
    langParams = options || {};
    if ((0, _type.isFunction)(crit)) {
      return crit;
    }
    if ((0, _utils.isGroupCriterion)(crit)) {
      return compileGroup(crit);
    }
    if ((0, _utils.isUnaryOperation)(crit)) {
      return compileUnary(crit);
    }
    return compileBinary(crit);
  };
}();
var FilterIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, criteria) {
    this.callBase(iter);
    this.langParams = iter.langParams;
    this.criteria = compileCriteria(criteria, this.langParams);
  },
  next: function next() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }
    return false;
  }
});
var GroupIterator = Iterator.inherit({
  ctor: function ctor(iter, getter) {
    this.iter = iter;
    this.getter = getter;
  },
  next: function next() {
    this._ensureGrouped();
    return this.groupedIter.next();
  },
  current: function current() {
    this._ensureGrouped();
    return this.groupedIter.current();
  },
  reset: function reset() {
    delete this.groupedIter;
  },
  countable: function countable() {
    return !!this.groupedIter;
  },
  count: function count() {
    return this.groupedIter.count();
  },
  _ensureGrouped: function _ensureGrouped() {
    if (this.groupedIter) {
      return;
    }
    var hash = {};
    var keys = [];
    var iter = this.iter;
    var getter = (0, _data.compileGetter)(this.getter);
    iter.reset();
    while (iter.next()) {
      var current = iter.current();
      var key = getter(current);
      if (key in hash) {
        hash[key].push(current);
      } else {
        hash[key] = [current];
        keys.push(key);
      }
    }
    this.groupedIter = new ArrayIterator((0, _iterator.map)(keys, function (key) {
      return {
        key: key,
        items: hash[key]
      };
    }));
  }
});
var SelectIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, getter) {
    this.callBase(iter);
    this.getter = (0, _data.compileGetter)(getter);
  },
  current: function current() {
    return this.getter(this.callBase());
  },
  countable: function countable() {
    return this.iter.countable();
  },
  count: function count() {
    return this.iter.count();
  }
});
var SliceIterator = WrappedIterator.inherit({
  ctor: function ctor(iter, skip, take) {
    this.callBase(iter);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next: function next() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }
    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }
    this.pos++;
    return this.iter.next();
  },
  reset: function reset() {
    this.callBase();
    this.pos = 0;
  },
  countable: function countable() {
    return this.iter.countable();
  },
  count: function count() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});
var arrayQueryImpl = function arrayQueryImpl(iter, queryOptions) {
  queryOptions = queryOptions || {};
  if (!(iter instanceof Iterator)) {
    iter = new ArrayIterator(iter);
  }
  if (queryOptions.langParams) {
    iter.langParams = queryOptions.langParams;
  }
  var handleError = function handleError(error) {
    var handler = queryOptions.errorHandler;
    if (handler) {
      handler(error);
    }
    (0, _errors.handleError)(error);
  };
  var aggregateCore = function aggregateCore(aggregator) {
    var d = new _deferred.Deferred().fail(handleError);
    var seed;
    var step = aggregator.step;
    var finalize = aggregator.finalize;
    try {
      iter.reset();
      if ('seed' in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter.next() ? iter.current() : NaN;
      }
      var accumulator = seed;
      while (iter.next()) {
        accumulator = step(accumulator, iter.current());
      }
      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }
    return d.promise();
  };
  var aggregate = function aggregate(seed, step, finalize) {
    if (arguments.length < 2) {
      return aggregateCore({
        step: arguments[0]
      });
    }
    return aggregateCore({
      seed: seed,
      step: step,
      finalize: finalize
    });
  };
  var standardAggregate = function standardAggregate(name) {
    return aggregateCore(_utils.aggregators[name]);
  };
  var select = function select(getter) {
    if (!(0, _type.isFunction)(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }
    return chainQuery(new SelectIterator(iter, getter));
  };
  var selectProp = function selectProp(name) {
    return select((0, _data.compileGetter)(name));
  };
  function chainQuery(iter) {
    return arrayQueryImpl(iter, queryOptions);
  }
  return {
    toArray: function toArray() {
      return iter.toArray();
    },
    enumerate: function enumerate() {
      var d = new _deferred.Deferred().fail(handleError);
      try {
        d.resolve(iter.toArray());
      } catch (x) {
        d.reject(x);
      }
      return d.promise();
    },
    setLangParams(options) {
      iter.langParams = options;
    },
    sortBy: function sortBy(getter, desc, compare) {
      return chainQuery(new SortIterator(iter, getter, desc, compare));
    },
    thenBy: function thenBy(getter, desc, compare) {
      if (iter instanceof SortIterator) {
        return chainQuery(iter.thenBy(getter, desc, compare));
      }
      throw _errors.errors.Error('E4004');
    },
    filter: function filter(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }
      return chainQuery(new FilterIterator(iter, criteria));
    },
    slice: function slice(skip, take) {
      if (take === undefined) {
        take = Number.MAX_VALUE;
      }
      return chainQuery(new SliceIterator(iter, skip, take));
    },
    select: select,
    groupBy: function groupBy(getter) {
      return chainQuery(new GroupIterator(iter, getter));
    },
    aggregate: aggregate,
    count: function count() {
      if (iter.countable()) {
        var d = new _deferred.Deferred().fail(handleError);
        try {
          d.resolve(iter.count());
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      }
      return standardAggregate('count');
    },
    sum: function sum(getter) {
      if (getter) {
        return selectProp(getter).sum();
      }
      return standardAggregate('sum');
    },
    min: function min(getter) {
      if (getter) {
        return selectProp(getter).min();
      }
      return standardAggregate('min');
    },
    max: function max(getter) {
      if (getter) {
        return selectProp(getter).max();
      }
      return standardAggregate('max');
    },
    avg: function avg(getter) {
      if (getter) {
        return selectProp(getter).avg();
      }
      return standardAggregate('avg');
    }
  };
};
var _default = arrayQueryImpl;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 26562:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(16454);
var _query = _interopRequireDefault(__webpack_require__(96687));
var _errors = __webpack_require__(18438);
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _array_utils = __webpack_require__(60637);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ArrayStore = _abstract_store.default.inherit({
  ctor: function ctor(options) {
    if (Array.isArray(options)) {
      options = {
        data: options
      };
    } else {
      options = options || {};
    }
    this.callBase(options);
    var initialArray = options.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw _errors.errors.Error('E4006');
    }
    this._array = initialArray || [];
  },
  createQuery: function createQuery() {
    return (0, _query.default)(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl: function _byKeyImpl(key) {
    var index = (0, _array_utils.indexByKey)(this, this._array, key);
    if (index === -1) {
      return (0, _utils.rejectedPromise)(_errors.errors.Error('E4009'));
    }
    return (0, _utils.trivialPromise)(this._array[index]);
  },
  _insertImpl: function _insertImpl(values) {
    return (0, _array_utils.insert)(this, this._array, values);
  },
  _pushImpl: function _pushImpl(changes) {
    (0, _array_utils.applyBatch)({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl: function _updateImpl(key, values) {
    return (0, _array_utils.update)(this, this._array, key, values);
  },
  _removeImpl: function _removeImpl(key) {
    return (0, _array_utils.remove)(this, this._array, key);
  },
  clear: function clear() {
    this._eventsStrategy.fireEvent('modifying');
    this._array = [];
    this._eventsStrategy.fireEvent('modified');
  }
}, 'array');
var _default = ArrayStore;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 60637:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.applyBatch = applyBatch;
exports.applyChanges = applyChanges;
exports.createObjectWithChanges = createObjectWithChanges;
exports.indexByKey = indexByKey;
exports.insert = insert;
exports.remove = remove;
exports.update = update;
var _type = __webpack_require__(35922);
var _config = _interopRequireDefault(__webpack_require__(80209));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _extend = __webpack_require__(13306);
var _errors = __webpack_require__(18438);
var _object = __webpack_require__(48013);
var _data = __webpack_require__(47617);
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function hasKey(target, keyOrKeys) {
  var key;
  var keys = typeof keyOrKeys === 'string' ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys.length) {
    key = keys.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  var childItems;
  var result;
  if (groupCount) {
    for (var i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result) {
        return result;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    var dataByKeyMap = {};
    var arrayLength = array.length;
    for (var i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data;
    array._dataByKeyMapLength += data ? 1 : -1;
  }
}
function cloneInstanceWithChangedPaths(instance, changes, clonedInstances) {
  clonedInstances = clonedInstances || new WeakMap();
  var result = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  if (instance) {
    clonedInstances.set(instance, result);
  }
  var instanceWithoutPrototype = _extends({}, instance);
  (0, _object.deepExtendArraySafe)(result, instanceWithoutPrototype, true, true);
  for (var name in instanceWithoutPrototype) {
    var value = instanceWithoutPrototype[name];
    var change = changes === null || changes === void 0 ? void 0 : changes[name];
    if ((0, _type.isObject)(value) && !(0, _type.isPlainObject)(value) && (0, _type.isObject)(change) && !clonedInstances.has(value)) {
      result[name] = cloneInstanceWithChangedPaths(value, change, clonedInstances);
    }
  }
  for (var _name in result) {
    var prop = result[_name];
    if ((0, _type.isObject)(prop) && clonedInstances.has(prop)) {
      result[_name] = clonedInstances.get(prop);
    }
  }
  return result;
}
function createObjectWithChanges(target, changes) {
  var result = cloneInstanceWithChangedPaths(target, changes);
  return (0, _object.deepExtendArraySafe)(result, changes, true, true);
}
function applyBatch(_ref) {
  var keyInfo = _ref.keyInfo,
    data = _ref.data,
    changes = _ref.changes,
    groupCount = _ref.groupCount,
    useInsertIndex = _ref.useInsertIndex,
    immutable = _ref.immutable,
    disableCache = _ref.disableCache,
    logError = _ref.logError,
    skipCopying = _ref.skipCopying;
  var resultItems = immutable === true ? _toConsumableArray(data) : data;
  changes.forEach(function (item) {
    var items = item.type === 'insert' ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    switch (item.type) {
      case 'update':
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case 'insert':
        insert(keyInfo, items, item.data, useInsertIndex && (0, _type.isDefined)(item.index) ? item.index : -1, true, logError, skipCopying);
        break;
      case 'remove':
        remove(keyInfo, items, item.key, true, logError);
        break;
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? (0, _utils.rejectedPromise)(_errors.errors.Error(errorCode)) : logError && _errors.errors.log(errorCode);
}
function applyChanges(data, changes) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$keyExpr = options.keyExpr,
    keyExpr = _options$keyExpr === void 0 ? 'id' : _options$keyExpr,
    _options$immutable = options.immutable,
    immutable = _options$immutable === void 0 ? true : _options$immutable;
  var keyGetter = (0, _data.compileGetter)(keyExpr);
  var keyInfo = {
    key: function key() {
      return keyExpr;
    },
    keyOf: function keyOf(obj) {
      return keyGetter(obj);
    }
  };
  return applyBatch({
    keyInfo,
    data,
    changes,
    immutable,
    disableCache: true,
    logError: true
  });
}
function update(keyInfo, array, key, data, isBatch, immutable, logError) {
  var target;
  var extendComplexObject = true;
  var keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data, keyExpr) && !(0, _utils.keysEqual)(keyExpr, key, keyInfo.keyOf(data))) {
      return getErrorResult(isBatch, logError, 'E4017');
    }
    target = getCacheValue(array, key);
    if (!target) {
      var index = indexByKey(keyInfo, array, key);
      if (index < 0) {
        return getErrorResult(isBatch, logError, 'E4009');
      }
      target = array[index];
      if (immutable === true && (0, _type.isDefined)(target)) {
        var newTarget = createObjectWithChanges(target, data);
        array[index] = newTarget;
        return !isBatch && (0, _utils.trivialPromise)(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  (0, _object.deepExtendArraySafe)(target, data, extendComplexObject);
  if (!isBatch) {
    if ((0, _config.default)().useLegacyStoreResult) {
      return (0, _utils.trivialPromise)(key, data);
    } else {
      return (0, _utils.trivialPromise)(target, key);
    }
  }
}
function insert(keyInfo, array, data, index, isBatch, logError, skipCopying) {
  var keyValue;
  var keyExpr = keyInfo.key();
  var obj = (0, _type.isPlainObject)(data) && !skipCopying ? (0, _extend.extend)({}, data) : data;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (keyValue === undefined || typeof keyValue === 'object' && (0, _type.isEmptyObject)(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw _errors.errors.Error('E4007');
      }
      keyValue = obj[keyExpr] = String(new _guid.default());
    } else {
      if (array[indexByKey(keyInfo, array, keyValue)] !== undefined) {
        return getErrorResult(isBatch, logError, 'E4008');
      }
    }
  } else {
    keyValue = obj;
  }
  if (index >= 0) {
    array.splice(index, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return (0, _utils.trivialPromise)((0, _config.default)().useLegacyStoreResult ? data : obj, keyValue);
  }
}
function remove(keyInfo, array, key, isBatch, logError) {
  var index = indexByKey(keyInfo, array, key);
  if (index > -1) {
    array.splice(index, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return (0, _utils.trivialPromise)(key);
  } else if (index < 0) {
    return getErrorResult(isBatch, logError, 'E4009');
  }
}
function indexByKey(keyInfo, array, key) {
  var keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (var i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if ((0, _utils.keysEqual)(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}

/***/ }),

/***/ 88036:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _utils = __webpack_require__(16454);
var _array_utils = __webpack_require__(60637);
var _type = __webpack_require__(35922);
var _config = _interopRequireDefault(__webpack_require__(80209));
var _errors = __webpack_require__(18438);
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _array_query = _interopRequireDefault(__webpack_require__(35042));
var _store_helper = _interopRequireDefault(__webpack_require__(99236));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var TOTAL_COUNT = 'totalCount';
var LOAD = 'load';
var BY_KEY = 'byKey';
var INSERT = 'insert';
var UPDATE = 'update';
var REMOVE = 'remove';
function isPromise(obj) {
  return obj && (0, _type.isFunction)(obj.then);
}
function trivialPromise(value) {
  return new _deferred.Deferred().resolve(value).promise();
}
function ensureRequiredFuncOption(name, obj) {
  if (!(0, _type.isFunction)(obj)) {
    throw _errors.errors.Error('E4011', name);
  }
}
function throwInvalidUserFuncResult(name) {
  throw _errors.errors.Error('E4012', name);
}
function createUserFuncFailureHandler(pendingDeferred) {
  function errorMessageFromXhr(promiseArguments) {
    var xhr = promiseArguments[0];
    var textStatus = promiseArguments[1];
    if (!xhr || !xhr.getResponseHeader) {
      return null;
    }
    return (0, _utils.errorMessageFromXhr)(xhr, textStatus);
  }
  return function (arg) {
    var error;
    if (arg instanceof Error) {
      error = arg;
    } else {
      error = new Error(errorMessageFromXhr(arguments) || arg && String(arg) || 'Unknown error');
    }
    if (error.message !== _utils.XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error);
    }
  };
}
function invokeUserLoad(store, options) {
  var userFunc = store._loadFunc;
  var userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise(userResult);
  } else if (userResult === null || userResult === undefined) {
    userResult = trivialPromise([]);
  } else {
    if (!isPromise(userResult)) {
      throwInvalidUserFuncResult(LOAD);
    }
  }
  return (0, _deferred.fromPromise)(userResult);
}
function invokeUserTotalCountFunc(store, options) {
  var userFunc = store._totalCountFunc;
  var userResult;
  if (!(0, _type.isFunction)(userFunc)) {
    throw _errors.errors.Error('E4021');
  }
  userResult = userFunc.apply(store, [options]);
  if (!isPromise(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise(userResult);
  }
  return (0, _deferred.fromPromise)(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  var userFunc = store._byKeyFunc;
  var userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise(userResult)) {
    userResult = trivialPromise(userResult);
  }
  return (0, _deferred.fromPromise)(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    var loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(function () {
      delete store.__rawDataPromise;
    }).done(function (rawData) {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail(createUserFuncFailureHandler(pendingDeferred));
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options, countOnly) {
  options = options || {};
  var userFuncOptions = {};
  if ('userData' in options) {
    userFuncOptions.userData = options.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, function (rawData) {
    var rawDataQuery = (0, _array_query.default)(rawData, {
      errorHandler: store._errorHandler
    });
    var itemsQuery;
    var totalCountQuery;
    var waitList = [];
    var items;
    var totalCount;
    if (!countOnly) {
      itemsQuery = _store_helper.default.queryByOptions(rawDataQuery, options);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done(function (asyncResult) {
          items = asyncResult;
        }));
      }
    }
    if (options.requireTotalCount || countOnly) {
      totalCountQuery = _store_helper.default.queryByOptions(rawDataQuery, options, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done(function (asyncResult) {
          totalCount = asyncResult;
        }));
      }
    }
    _deferred.when.apply(_renderer.default, waitList).done(function () {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount: totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail(function (x) {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, function (rawData) {
    var keyExpr = store.key();
    var item;
    for (var i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if ((0, _utils.keysEqual)(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(_errors.errors.Error('E4009'));
  });
}
var CustomStore = _abstract_store.default.inherit({
  ctor: function ctor(options) {
    options = options || {};
    this.callBase(options);
    this._useDefaultSearch = !!options.useDefaultSearch || options.loadMode === 'raw';
    this._loadMode = options.loadMode;
    this._cacheRawData = options.cacheRawData !== false;
    this._loadFunc = options[LOAD];
    this._totalCountFunc = options[TOTAL_COUNT];
    this._byKeyFunc = options[BY_KEY];
    this._insertFunc = options[INSERT];
    this._updateFunc = options[UPDATE];
    this._removeFunc = options[REMOVE];
  },
  _clearCache() {
    delete this.__rawData;
  },
  createQuery: function createQuery() {
    throw _errors.errors.Error('E4010');
  },
  clearRawDataCache: function clearRawDataCache() {
    this._clearCache();
  },
  _totalCountImpl: function _totalCountImpl(options) {
    var d = new _deferred.Deferred();
    if (this._loadMode === 'raw' && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options, true);
    } else {
      invokeUserTotalCountFunc(this, options).done(function (count) {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _pushImpl: function _pushImpl(changes) {
    if (this.__rawData) {
      (0, _array_utils.applyBatch)({
        keyInfo: this,
        data: this.__rawData,
        changes
      });
    }
  },
  _loadImpl: function _loadImpl(options) {
    var d = new _deferred.Deferred();
    if (this._loadMode === 'raw') {
      runRawLoadWithQuery(d, this, options, false);
    } else {
      invokeUserLoad(this, options).done(function (data, extra) {
        d.resolve(data, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _byKeyImpl: function _byKeyImpl(key, extraOptions) {
    var d = new _deferred.Deferred();
    if (this._byKeyViaLoad()) {
      this._requireKey();
      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done(function (obj) {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }
    return d.promise();
  },
  _byKeyViaLoad: function _byKeyViaLoad() {
    return this._loadMode === 'raw' && !this._byKeyFunc;
  },
  _insertImpl: function _insertImpl(values) {
    var that = this;
    var userFunc = that._insertFunc;
    var userResult;
    var d = new _deferred.Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]); // should return key or data

    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }
    (0, _deferred.fromPromise)(userResult).done(function (serverResponse) {
      if ((0, _config.default)().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl: function _updateImpl(key, values) {
    var userFunc = this._updateFunc;
    var userResult;
    var d = new _deferred.Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);
    if (!isPromise(userResult)) {
      userResult = trivialPromise(userResult);
    }
    (0, _deferred.fromPromise)(userResult).done(function (serverResponse) {
      if ((0, _config.default)().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl: function _removeImpl(key) {
    var userFunc = this._removeFunc;
    var userResult;
    var d = new _deferred.Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);
    if (!isPromise(userResult)) {
      userResult = trivialPromise();
    }
    (0, _deferred.fromPromise)(userResult).done(function () {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});
var _default = CustomStore;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 33546:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _data_source = __webpack_require__(85273);
var _default = _data_source.DataSource;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 85273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.DataSource = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend = __webpack_require__(13306);
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(16454);
var _array_utils = __webpack_require__(60637);
var _custom_store = _interopRequireDefault(__webpack_require__(88036));
var _events_strategy = __webpack_require__(80566);
var _errors = __webpack_require__(18438);
var _queue = __webpack_require__(59504);
var _deferred = __webpack_require__(62754);
var _operation_manager = _interopRequireDefault(__webpack_require__(88665));
var _utils2 = __webpack_require__(9234);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var DataSource = _class.default.inherit({
  /**
  * @name DataSource.ctor
  * @publicName ctor(url)
  * @param1 url:string
  * @hidden
  */
  /**
  * @name DataSource.ctor
  * @publicName ctor(data)
  * @param1 data:Array<any>
  * @hidden
  */
  /**
  * @name DataSource.ctor
  * @publicName ctor(store)
  * @param1 store:Store
  * @hidden
  */
  /**
  * @name DataSource.ctor
  * @publicName ctor(options)
  * @param1 options:CustomStoreOptions|DataSourceOptions
  * @hidden
  */
  ctor(options) {
    var _this = this,
      _options$reshapeOnPus;
    options = (0, _utils2.normalizeDataSourceOptions)(options);
    this._eventsStrategy = new _events_strategy.EventsStrategy(this, {
      syncStrategy: true
    });

    /**
    * @name DataSourceOptions.store.type
    * @type Enums.StoreType
    */

    this._store = options.store;
    this._changedTime = 0;
    var needThrottling = options.pushAggregationTimeout !== 0;
    if (needThrottling) {
      var throttlingTimeout = options.pushAggregationTimeout === undefined ? function () {
        return _this._changedTime * 5;
      } : options.pushAggregationTimeout;
      var pushDeferred;
      var lastPushWaiters;
      var throttlingPushHandler = (0, _utils.throttleChanges)(function (changes) {
        pushDeferred.resolve();
        var storePushPending = _deferred.when.apply(void 0, _toConsumableArray(lastPushWaiters));
        storePushPending.done(function () {
          return _this._onPush(changes);
        });
        lastPushWaiters = undefined;
        pushDeferred = undefined;
      }, throttlingTimeout);
      this._onPushHandler = function (args) {
        _this._aggregationTimeoutId = throttlingPushHandler(args.changes);
        if (!pushDeferred) {
          pushDeferred = new _deferred.Deferred();
        }
        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };
      this._store.on('beforePush', this._onPushHandler);
    } else {
      this._onPushHandler = function (changes) {
        return _this._onPush(changes);
      };
      this._store.on('push', this._onPushHandler);
    }
    this._storeLoadOptions = this._extractLoadOptions(options);
    this._mapFunc = options.map;
    this._postProcessFunc = options.postProcess;
    this._pageIndex = options.pageIndex !== undefined ? options.pageIndex : 0;
    this._pageSize = options.pageSize !== undefined ? options.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = 'searchValue' in options ? options.searchValue : null;
    this._searchOperation = options.searchOperation || 'contains';
    this._searchExpr = options.searchExpr;
    this._paginate = options.paginate;
    this._reshapeOnPush = (_options$reshapeOnPus = options.reshapeOnPush) !== null && _options$reshapeOnPus !== void 0 ? _options$reshapeOnPus : false;
    (0, _iterator.each)(['onChanged', 'onLoadError', 'onLoadingChanged', 'onCustomizeLoadResult', 'onCustomizeStoreLoadOptions'], function (_, optionName) {
      if (optionName in options) {
        _this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options[optionName]);
      }
    });
    this._operationManager = new _operation_manager.default();
    this._init();
  },
  _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;
    if (!(0, _type.isDefined)(this._paginate)) {
      this._paginate = !this.group();
    }
    this._isLastPage = !this._paginate;
  },
  dispose() {
    var _this$_delayedLoadTas;
    this._store.off('beforePush', this._onPushHandler);
    this._store.off('push', this._onPushHandler);
    this._eventsStrategy.dispose();
    clearTimeout(this._aggregationTimeoutId);
    (_this$_delayedLoadTas = this._delayedLoadTask) === null || _this$_delayedLoadTas === void 0 ? void 0 : _this$_delayedLoadTas.abort();
    this._operationManager.cancelAll();
    delete this._store;
    delete this._items;
    delete this._delayedLoadTask;
    this._disposed = true;
  },
  _extractLoadOptions(options) {
    var result = {};
    var names = ['sort', 'filter', 'langParams', 'select', 'group', 'requireTotalCount'];
    var customNames = this._store._customLoadOptions();
    if (customNames) {
      names = names.concat(customNames);
    }
    (0, _iterator.each)(names, function () {
      result[this] = options[this];
    });
    return result;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(newIndex) {
    if (!(0, _type.isNumeric)(newIndex)) {
      return this._pageIndex;
    }
    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate(value) {
    if (!(0, _type.isBoolean)(value)) {
      return this._paginate;
    }
    if (this._paginate !== value) {
      this._paginate = value;
      this.pageIndex(0);
    }
  },
  pageSize(value) {
    if (!(0, _type.isNumeric)(value)) {
      return this._pageSize;
    }
    this._pageSize = value;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(optionName) {
    var _this2 = this;
    return function (args) {
      var normalizedArgs = (0, _utils2.normalizeStoreLoadOptionAccessorArguments)(args);
      if (normalizedArgs === undefined) {
        return _this2._storeLoadOptions[optionName];
      }
      _this2._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.generateStoreLoadOptionAccessor('sort')(args);
  },
  filter() {
    var newFilter = (0, _utils2.normalizeStoreLoadOptionAccessorArguments)(arguments);
    if (newFilter === undefined) {
      return this._storeLoadOptions.filter;
    }
    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.generateStoreLoadOptionAccessor('group')(args);
  },
  select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.generateStoreLoadOptionAccessor('select')(args);
  },
  requireTotalCount(value) {
    if (!(0, _type.isBoolean)(value)) {
      return this._storeLoadOptions.requireTotalCount;
    }
    this._storeLoadOptions.requireTotalCount = value;
  },
  searchValue(value) {
    if (arguments.length < 1) {
      return this._searchValue;
    }
    this._searchValue = value;
    this.pageIndex(0);
  },
  searchOperation(op) {
    if (!(0, _type.isString)(op)) {
      return this._searchOperation;
    }
    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr(expr) {
    var argc = arguments.length;
    if (argc === 0) {
      return this._searchExpr;
    }
    if (argc > 1) {
      expr = [].slice.call(arguments);
    }
    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var _this$_store;
    return (_this$_store = this._store) === null || _this$_store === void 0 ? void 0 : _this$_store.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue() {
    return (0, _queue.create)();
  },
  _changeLoadingCount(increment) {
    var oldLoading = this.isLoading();
    this._loadingCount += increment;
    var newLoading = this.isLoading();
    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent('loadingChanged', [newLoading]);
    }
  },
  _scheduleLoadCallbacks(deferred) {
    var _this3 = this;
    this.beginLoading();
    deferred.always(function () {
      _this3.endLoading();
    });
  },
  _scheduleFailCallbacks(deferred) {
    var _this4 = this;
    deferred.fail(function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (args[0] === _utils2.CANCELED_TOKEN) {
        return;
      }
      _this4._eventsStrategy.fireEvent('loadError', args);
    });
  },
  _fireChanged(args) {
    var date = new Date();
    this._eventsStrategy.fireEvent('changed', args);
    this._changedTime = new Date() - date;
  },
  _scheduleChangedCallbacks(deferred) {
    var _this5 = this;
    deferred.done(function () {
      return _this5._fireChanged();
    });
  },
  loadSingle(propName, propValue) {
    var _this6 = this;
    var d = new _deferred.Deferred();
    var key = this.key();
    var store = this._store;
    var options = this._createStoreLoadOptions();
    var handleDone = function handleDone(data) {
      var isEmptyArray = Array.isArray(data) && !data.length;
      if (!(0, _type.isDefined)(data) || isEmptyArray) {
        d.reject(new _errors.errors.Error('E4009'));
      } else {
        if (!Array.isArray(data)) {
          data = [data];
        }
        d.resolve(_this6._applyMapFunction(data)[0]);
      }
    };
    this._scheduleFailCallbacks(d);
    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }
    delete options.skip;
    delete options.group;
    delete options.refresh;
    delete options.pageIndex;
    delete options.searchString;
    var shouldForceByKey = function shouldForceByKey() {
      return store instanceof _custom_store.default && !store._byKeyViaLoad();
    };
    (function () {
      // NOTE for CustomStore always using byKey for backward compatibility with "old user datasource"
      if (propName === key || shouldForceByKey()) {
        return store.byKey(propValue, options);
      }
      options.take = 1;
      options.filter = options.filter ? [options.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options);
    })().fail(d.reject).done(handleDone);
    return d.promise();
  },
  load() {
    var _this7 = this;
    var d = new _deferred.Deferred();
    var loadTask = function loadTask() {
      if (_this7._disposed) {
        return undefined;
      }
      if (!(0, _utils2.isPending)(d)) {
        return;
      }
      return _this7._loadFromStore(loadOperation, d);
    };
    this._scheduleLoadCallbacks(d);
    this._scheduleFailCallbacks(d);
    this._scheduleChangedCallbacks(d);
    var loadOperation = this._createLoadOperation(d);
    this._eventsStrategy.fireEvent('customizeStoreLoadOptions', [loadOperation]);
    this._loadQueue.add(function () {
      if (typeof loadOperation.delay === 'number') {
        _this7._delayedLoadTask = (0, _common.executeAsync)(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }
      return d.promise();
    });
    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush(changes) {
    var _this8 = this;
    if (this._reshapeOnPush) {
      this.load();
    } else {
      var changingArgs = {
        changes
      };
      this._eventsStrategy.fireEvent('changing', [changingArgs]);
      var group = this.group();
      var items = this.items();
      var groupLevel = 0;
      var dataSourceChanges = this.paginate() || group ? changes.filter(function (item) {
        return item.type === 'update';
      }) : changes;
      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }
      if (this._mapFunc) {
        dataSourceChanges.forEach(function (item) {
          if (item.type === 'insert') {
            item.data = _this8._mapFunc(item.data);
          }
        });
      }
      if (changingArgs.postProcessChanges) {
        dataSourceChanges = changingArgs.postProcessChanges(dataSourceChanges);
      }
      (0, _array_utils.applyBatch)({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });
      this._fireChanged([{
        changes: changes
      }]);
    }
  },
  _createLoadOperation(deferred) {
    var _this9 = this;
    var operationId = this._operationManager.add(deferred);
    var storeLoadOptions = this._createStoreLoadOptions();
    if (this._store && !(0, _type.isEmptyObject)(storeLoadOptions === null || storeLoadOptions === void 0 ? void 0 : storeLoadOptions.langParams)) {
      this._store._langParams = _extends({}, this._store._langParams, storeLoadOptions.langParams);
    }
    deferred.always(function () {
      return _this9._operationManager.remove(operationId);
    });
    return {
      operationId,
      storeLoadOptions
    };
  },
  reload() {
    var store = this.store();
    store._clearCache();
    this._init();
    return this.load();
  },
  cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }
    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions() {
    var result = (0, _extend.extend)({}, this._storeLoadOptions);
    this._addSearchOptions(result);
    if (this._paginate) {
      if (this._pageSize) {
        result.skip = this._pageIndex * this._pageSize;
        result.take = this._pageSize;
      }
    }
    result.userData = this._userData;
    return result;
  },
  _addSearchFilter(storeLoadOptions) {
    var value = this._searchValue;
    var op = this._searchOperation;
    var selector = this._searchExpr;
    var searchFilter = [];
    if (!value) {
      return;
    }
    if (!selector) {
      selector = 'this';
    }
    if (!Array.isArray(selector)) {
      selector = [selector];
    }

    // TODO optimize for byKey case

    (0, _iterator.each)(selector, function (i, item) {
      if (searchFilter.length) {
        searchFilter.push('or');
      }
      searchFilter.push([item, op, value]);
    });
    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore(loadOptions, pendingDeferred) {
    var _this10 = this;
    var handleSuccess = function handleSuccess(data, extra) {
      if (_this10._disposed) {
        return;
      }
      if (!(0, _utils2.isPending)(pendingDeferred)) {
        return;
      }

      // Process result
      var loadResult = (0, _extend.extend)((0, _utils2.normalizeLoadResult)(data, extra), loadOptions);
      _this10._eventsStrategy.fireEvent('customizeLoadResult', [loadResult]);
      (0, _deferred.when)(loadResult.data).done(function (data) {
        loadResult.data = data;
        _this10._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };
    if (loadOptions.data) {
      return new _deferred.Deferred().resolve(loadOptions.data).done(handleSuccess);
    }
    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult(loadResult, pendingDeferred) {
    var _this11 = this;
    var data = loadResult.data;
    var extra = loadResult.extra;
    var storeLoadOptions = loadResult.storeLoadOptions;
    var resolvePendingDeferred = function resolvePendingDeferred() {
      _this11._isLoaded = true;
      _this11._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data, extra);
    };
    var proceedLoadingTotalCount = function proceedLoadingTotalCount() {
      _this11.store().totalCount(storeLoadOptions).done(function (count) {
        extra.totalCount = count;
        resolvePendingDeferred();
      }).fail(pendingDeferred.reject);
    };
    if (this._disposed) {
      return;
    }

    // todo: if operation is canceled there is no need to do data transformation

    data = this._applyPostProcessFunction(this._applyMapFunction(data));
    if (!(0, _type.isObject)(extra)) {
      extra = {};
    }
    this._items = data;
    if (!data.length || !this._paginate || this._pageSize && data.length < this._pageSize) {
      this._isLastPage = true;
    }
    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      proceedLoadingTotalCount();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction(data) {
    if (this._mapFunc) {
      return (0, _utils2.mapDataRespectingGrouping)(data, this._mapFunc, this.group());
    }
    return data;
  },
  _applyPostProcessFunction(data) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data);
    }
    return data;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
exports.DataSource = DataSource;

/***/ }),

/***/ 88665:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(9234);
var OperationManager = /*#__PURE__*/function () {
  function OperationManager() {
    this._counter = -1;
    this._deferreds = {};
  }
  var _proto = OperationManager.prototype;
  _proto.add = function add(deferred) {
    this._counter++;
    this._deferreds[this._counter] = deferred;
    return this._counter;
  };
  _proto.remove = function remove(operationId) {
    return delete this._deferreds[operationId];
  };
  _proto.cancel = function cancel(operationId) {
    if (operationId in this._deferreds) {
      this._deferreds[operationId].reject(_utils.CANCELED_TOKEN);
      return true;
    }
    return false;
  };
  _proto.cancelAll = function cancelAll() {
    while (this._counter > -1) {
      this.cancel(this._counter);
      this._counter--;
    }
  };
  return OperationManager;
}();
exports["default"] = OperationManager;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 9234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.normalizeStoreLoadOptionAccessorArguments = exports.normalizeLoadResult = exports.normalizeDataSourceOptions = exports.mapDataRespectingGrouping = exports.isPending = exports.CANCELED_TOKEN = void 0;
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _array_store = _interopRequireDefault(__webpack_require__(26562));
var _iterator = __webpack_require__(95479);
var _custom_store = _interopRequireDefault(__webpack_require__(88036));
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(16454);
var _excluded = ["items"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
var CANCELED_TOKEN = 'canceled';
exports.CANCELED_TOKEN = CANCELED_TOKEN;
var isPending = function isPending(deferred) {
  return deferred.state() === 'pending';
};
exports.isPending = isPending;
var normalizeStoreLoadOptionAccessorArguments = function normalizeStoreLoadOptionAccessorArguments(originalArguments) {
  switch (originalArguments.length) {
    case 0:
      return undefined;
    case 1:
      return originalArguments[0];
  }
  return [].slice.call(originalArguments);
};
exports.normalizeStoreLoadOptionAccessorArguments = normalizeStoreLoadOptionAccessorArguments;
var mapGroup = function mapGroup(group, level, mapper) {
  return (0, _iterator.map)(group, function (item) {
    var items = item.items,
      restItem = _objectWithoutProperties(item, _excluded);
    return _extends({}, restItem, {
      items: mapRecursive(item.items, level - 1, mapper)
    });
  });
};
var mapRecursive = function mapRecursive(items, level, mapper) {
  if (!Array.isArray(items)) return items;
  return level ? mapGroup(items, level, mapper) : (0, _iterator.map)(items, mapper);
};
var mapDataRespectingGrouping = function mapDataRespectingGrouping(items, mapper, groupInfo) {
  var level = groupInfo ? (0, _utils.normalizeSortingInfo)(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};
exports.mapDataRespectingGrouping = mapDataRespectingGrouping;
var normalizeLoadResult = function normalizeLoadResult(data, extra) {
  var _data;
  if ((_data = data) !== null && _data !== void 0 && _data.data) {
    extra = data;
    data = data.data;
  }
  if (!Array.isArray(data)) {
    data = [data];
  }
  return {
    data,
    extra
  };
};
exports.normalizeLoadResult = normalizeLoadResult;
var createCustomStoreFromLoadFunc = function createCustomStoreFromLoadFunc(options) {
  var storeConfig = {};
  (0, _iterator.each)(['useDefaultSearch', 'key', 'load', 'loadMode', 'cacheRawData', 'byKey', 'lookup', 'totalCount', 'insert', 'update', 'remove'], function () {
    storeConfig[this] = options[this];
    delete options[this];
  });
  return new _custom_store.default(storeConfig);
};
var createStoreFromConfig = function createStoreFromConfig(storeConfig) {
  var alias = storeConfig.type;
  delete storeConfig.type;
  return _abstract_store.default.create(alias, storeConfig);
};
var createCustomStoreFromUrl = function createCustomStoreFromUrl(url, normalizationOptions) {
  return new _custom_store.default({
    load: function load() {
      return _ajax.default.sendRequest({
        url,
        dataType: 'json'
      });
    },
    loadMode: normalizationOptions === null || normalizationOptions === void 0 ? void 0 : normalizationOptions.fromUrlLoadMode
  });
};
var normalizeDataSourceOptions = function normalizeDataSourceOptions(options, normalizationOptions) {
  var store;
  if (typeof options === 'string') {
    options = {
      paginate: false,
      store: createCustomStoreFromUrl(options, normalizationOptions)
    };
  }
  if (options === undefined) {
    options = [];
  }
  if (Array.isArray(options) || options instanceof _abstract_store.default) {
    options = {
      store: options
    };
  } else {
    options = (0, _extend.extend)({}, options);
  }
  if (options.store === undefined) {
    options.store = [];
  }
  store = options.store;
  if ('load' in options) {
    store = createCustomStoreFromLoadFunc(options);
  } else if (Array.isArray(store)) {
    store = new _array_store.default(store);
  } else if ((0, _type.isPlainObject)(store)) {
    store = createStoreFromConfig((0, _extend.extend)({}, store));
  }
  options.store = store;
  return options;
};
exports.normalizeDataSourceOptions = normalizeDataSourceOptions;

/***/ }),

/***/ 8162:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global Debug*/

var window = (0, _window.getWindow)();
var IS_WINJS_ORIGIN;
var IS_LOCAL_ORIGIN;
function isLocalHostName(url) {
  return /^(localhost$|127\.)/i.test(url); // TODO more precise check for 127.x.x.x IP
}

/**
* @name EndpointSelector.ctor
* @publicName ctor(options)
* @param1 options:Object
* @hidden
*/
var EndpointSelector = function EndpointSelector(config) {
  this.config = config;
  IS_WINJS_ORIGIN = window.location.protocol === 'ms-appx:';
  IS_LOCAL_ORIGIN = isLocalHostName(window.location.hostname);
};
EndpointSelector.prototype = {
  urlFor: function urlFor(key) {
    var bag = this.config[key];
    if (!bag) {
      throw _errors.default.Error('E0006');
    }
    if (bag.production) {
      if (IS_WINJS_ORIGIN && !Debug.debuggerEnabled || !IS_WINJS_ORIGIN && !IS_LOCAL_ORIGIN) {
        return bag.production;
      }
    }
    return bag.local;
  }
};
var _default = EndpointSelector;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18438:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.setErrorHandler = exports.handleError = exports.errors = exports.errorHandler = void 0;
var _error = _interopRequireDefault(__webpack_require__(95640));
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
* @docid
* @name ErrorsData
*/
var errors = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsData.E4000
  */
  E4000: '[DevExpress.data]: {0}',
  /**
    * @name ErrorsData.E4001
    */
  E4001: 'Unknown aggregating function is detected: \'{0}\'',
  /**
  * @name ErrorsData.E4002
  */
  E4002: 'Unsupported OData protocol version is used',
  /**
  * @name ErrorsData.E4003
  */
  E4003: 'Unknown filter operation is used: {0}',
  /**
  * @name ErrorsData.E4004
  */
  E4004: 'The thenby() method is called before the sortby() method',
  /**
  * @name ErrorsData.E4005
  */
  E4005: 'Store requires a key expression for this operation',
  /**
  * @name ErrorsData.E4006
  */
  E4006: 'ArrayStore \'data\' option must be an array',
  /**
  * @name ErrorsData.E4007
  */
  E4007: 'Compound keys cannot be auto-generated',
  /**
  * @name ErrorsData.E4008
  */
  E4008: 'Attempt to insert an item with a duplicated key',
  /**
  * @name ErrorsData.E4009
  */
  E4009: 'Data item cannot be found',
  /**
  * @name ErrorsData.E4010
  */
  E4010: 'CustomStore does not support creating queries',
  /**
  * @name ErrorsData.E4011
  */
  E4011: 'Custom Store method is not implemented or is not a function: {0}',
  /**
  * @name ErrorsData.E4012
  */
  E4012: 'Custom Store method returns an invalid value: {0}',
  /**
  * @name ErrorsData.E4013
  */
  E4013: 'Local Store requires the \'name\' configuration option is specified',
  /**
  * @name ErrorsData.E4014
  */
  E4014: 'Unknown data type is specified for ODataStore: {0}',
  /**
  * @name ErrorsData.E4015
  */
  E4015: 'Unknown entity name or alias is used: {0}',
  /**
  * @name ErrorsData.E4016
  */
  E4016: 'The compileSetter(expr) method is called with \'self\' passed as a parameter',
  /**
  * @name ErrorsData.E4017
  */
  E4017: 'Keys cannot be modified',
  /**
  * @name ErrorsData.E4018
  */
  E4018: 'The server has returned a non-numeric value in a response to an item count request',
  /**
  * @name ErrorsData.E4019
  */
  E4019: 'Mixing of group operators inside a single group of filter expression is not allowed',
  /**
  * @name ErrorsData.E4020
  */
  E4020: 'Unknown store type is detected: {0}',
  /**
  * @name ErrorsData.E4021
  */
  E4021: 'The server response does not provide the totalCount value',
  /**
  * @name ErrorsData.E4022
  */
  E4022: 'The server response does not provide the groupCount value',
  /**
  * @name ErrorsData.E4023
  */
  E4023: 'Could not parse the following XML: {0}',
  /**
  * @name ErrorsData.E4024
  */
  E4024: 'String function {0} cannot be used with the data field {1} of type {2}.',
  /**
  * @name ErrorsData.W4000
  */
  W4000: 'Data returned from the server has an incorrect structure',
  /**
  * @name ErrorsData.W4001
  */
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  /**
  * @name ErrorsData.W4002
  */
  W4002: 'Data loading has failed for some cells due to the following error: {0}'
});
exports.errors = errors;
var errorHandler = null;
exports.errorHandler = errorHandler;
var handleError = function handleError(error) {
  var _errorHandler;
  (_errorHandler = errorHandler) === null || _errorHandler === void 0 ? void 0 : _errorHandler(error);
};
exports.handleError = handleError;
var setErrorHandler = function setErrorHandler(handler) {
  return exports.errorHandler = errorHandler = handler;
};
exports.setErrorHandler = setErrorHandler;

/***/ }),

/***/ 82837:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _errors = __webpack_require__(18438);
var _array_store = _interopRequireDefault(__webpack_require__(26562));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var abstract = _class.default.abstract;
var LocalStoreBackend = _class.default.inherit({
  ctor: function ctor(store, storeOptions) {
    this._store = store;
    this._dirty = !!storeOptions.data;
    this.save();
    var immediate = this._immediate = storeOptions.immediate;
    var flushInterval = Math.max(100, storeOptions.flushInterval || 10 * 1000);
    if (!immediate) {
      var saveProxy = this.save.bind(this);
      setInterval(saveProxy, flushInterval);
      _events_engine.default.on(window, 'beforeunload', saveProxy);
      if (window.cordova) {
        _dom_adapter.default.listen(_dom_adapter.default.getDocument(), 'pause', saveProxy, false);
      }
    }
  },
  notifyChanged: function notifyChanged() {
    this._dirty = true;
    if (this._immediate) {
      this.save();
    }
  },
  load: function load() {
    this._store._array = this._loadImpl();
    this._dirty = false;
  },
  save: function save() {
    if (!this._dirty) {
      return;
    }
    this._saveImpl(this._store._array);
    this._dirty = false;
  },
  _loadImpl: abstract,
  _saveImpl: abstract
});
var DomLocalStoreBackend = LocalStoreBackend.inherit({
  ctor: function ctor(store, storeOptions) {
    var name = storeOptions.name;
    if (!name) {
      throw _errors.errors.Error('E4013');
    }
    this._key = 'dx-data-localStore-' + name;
    this.callBase(store, storeOptions);
  },
  _loadImpl: function _loadImpl() {
    var raw = window.localStorage.getItem(this._key);
    if (raw) {
      return JSON.parse(raw);
    }
    return [];
  },
  _saveImpl: function _saveImpl(array) {
    if (!array.length) {
      window.localStorage.removeItem(this._key);
    } else {
      window.localStorage.setItem(this._key, JSON.stringify(array));
    }
  }
});
var localStoreBackends = {
  'dom': DomLocalStoreBackend
};
var LocalStore = _array_store.default.inherit({
  ctor: function ctor(options) {
    if (typeof options === 'string') {
      options = {
        name: options
      };
    } else {
      options = options || {};
    }
    this.callBase(options);
    this._backend = new localStoreBackends[options.backend || 'dom'](this, options);
    this._backend.load();
  },
  _clearCache() {
    this._backend.load();
  },
  clear: function clear() {
    this.callBase();
    this._backend.notifyChanged();
  },
  _insertImpl: function _insertImpl(values) {
    var b = this._backend;
    return this.callBase(values).done(b.notifyChanged.bind(b));
  },
  _updateImpl: function _updateImpl(key, values) {
    var b = this._backend;
    return this.callBase(key, values).done(b.notifyChanged.bind(b));
  },
  _removeImpl: function _removeImpl(key) {
    var b = this._backend;
    return this.callBase(key).done(b.notifyChanged.bind(b));
  }
}, 'local');
var _default = LocalStore;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 47256:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _errors = __webpack_require__(18438);
var _store = _interopRequireDefault(__webpack_require__(341));
var _request_dispatcher = _interopRequireDefault(__webpack_require__(63081));
var _utils = __webpack_require__(77869);
var _deferred = __webpack_require__(62754);
__webpack_require__(54263);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ODataContext = _class.default.inherit({
  ctor(options) {
    var _this = this;
    this._requestDispatcher = new _request_dispatcher.default(options);
    this._errorHandler = options.errorHandler;
    (0, _iterator.each)(options.entities || [], function (entityAlias, entityOptions) {
      _this[entityAlias] = new _store.default((0, _extend.extend)({}, options, {
        url: "".concat(_this._requestDispatcher.url, "/").concat(encodeURIComponent(entityOptions.name || entityAlias))
      }, entityOptions));
    });
  },
  get(operationName, params) {
    return this.invoke(operationName, params, 'GET');
  },
  invoke(operationName) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var httpMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';
    httpMethod = httpMethod.toLowerCase();
    var d = new _deferred.Deferred();
    var url = "".concat(this._requestDispatcher.url, "/").concat(encodeURIComponent(operationName));
    var payload;
    if (this.version() === 4) {
      if (httpMethod === 'get') {
        url = (0, _utils.formatFunctionInvocationUrl)(url, (0, _utils.escapeServiceOperationParams)(params, this.version()));
        params = null;
      } else if (httpMethod === 'post') {
        payload = params;
        params = null;
      }
    }
    (0, _deferred.when)(this._requestDispatcher.sendRequest(url, httpMethod, (0, _utils.escapeServiceOperationParams)(params, this.version()), payload)).done(function (r) {
      if ((0, _type.isPlainObject)(r) && operationName in r) {
        r = r[operationName];
      }
      d.resolve(r);
    }).fail(this._errorHandler).fail(_errors.handleError).fail(d.reject);
    return d.promise();
  },
  objectLink(entityAlias, key) {
    var store = this[entityAlias];
    if (!store) {
      throw _errors.errors.Error('E4015', entityAlias);
    }
    if (!(0, _type.isDefined)(key)) {
      return null;
    }
    return {
      __metadata: {
        uri: store._byKeyUrl(key)
      }
    };
  },
  version() {
    return this._requestDispatcher.version;
  }
});
var _default = ODataContext;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 54263:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.odata = void 0;
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _config = _interopRequireDefault(__webpack_require__(80209));
var _extend = __webpack_require__(13306);
var _query_adapters = _interopRequireDefault(__webpack_require__(16135));
var _utils = __webpack_require__(77869);
var _errors = __webpack_require__(18438);
var _utils2 = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DEFAULT_PROTOCOL_VERSION = 2;
var STRING_FUNCTIONS = ['contains', 'notcontains', 'startswith', 'endswith'];
var compileCriteria = function () {
  var protocolVersion;
  var forceLowerCase;
  var fieldTypes;
  var createBinaryOperationFormatter = function createBinaryOperationFormatter(op) {
    return function (prop, val) {
      return "".concat(prop, " ").concat(op, " ").concat(val);
    };
  };
  var createStringFuncFormatter = function createStringFuncFormatter(op, reverse) {
    return function (prop, val) {
      var bag = [op, '('];
      if (forceLowerCase) {
        prop = prop.indexOf('tolower(') === -1 ? "tolower(".concat(prop, ")") : prop;
        val = val.toLowerCase();
      }
      if (reverse) {
        bag.push(val, ',', prop);
      } else {
        bag.push(prop, ',', val);
      }
      bag.push(')');
      return bag.join('');
    };
  };
  var isStringFunction = function isStringFunction(name) {
    return STRING_FUNCTIONS.some(function (funcName) {
      return funcName === name;
    });
  };
  var formatters = {
    '=': createBinaryOperationFormatter('eq'),
    '<>': createBinaryOperationFormatter('ne'),
    '>': createBinaryOperationFormatter('gt'),
    '>=': createBinaryOperationFormatter('ge'),
    '<': createBinaryOperationFormatter('lt'),
    '<=': createBinaryOperationFormatter('le'),
    'startswith': createStringFuncFormatter('startswith'),
    'endswith': createStringFuncFormatter('endswith')
  };
  var formattersV2 = (0, _extend.extend)({}, formatters, {
    'contains': createStringFuncFormatter('substringof', true),
    'notcontains': createStringFuncFormatter('not substringof', true)
  });
  var formattersV4 = (0, _extend.extend)({}, formatters, {
    'contains': createStringFuncFormatter('contains'),
    'notcontains': createStringFuncFormatter('not contains')
  });
  var compileBinary = function compileBinary(criteria) {
    var _fieldTypes;
    criteria = (0, _utils2.normalizeBinaryCriterion)(criteria);
    var op = criteria[1];
    var fieldName = criteria[0];
    var fieldType = fieldTypes && fieldTypes[fieldName];
    if (fieldType && isStringFunction(op) && fieldType !== 'String') {
      throw new _errors.errors.Error('E4024', op, fieldName, fieldType);
    }
    var formatters = protocolVersion === 4 ? formattersV4 : formattersV2;
    var formatter = formatters[op.toLowerCase()];
    if (!formatter) {
      throw _errors.errors.Error('E4003', op);
    }
    var value = criteria[2];
    if ((_fieldTypes = fieldTypes) !== null && _fieldTypes !== void 0 && _fieldTypes[fieldName]) {
      value = (0, _utils.convertPrimitiveValue)(fieldTypes[fieldName], value);
    }
    return formatter((0, _utils.serializePropName)(fieldName), (0, _utils.serializeValue)(value, protocolVersion));
  };
  var compileUnary = function compileUnary(criteria) {
    var op = criteria[0];
    var crit = compileCore(criteria[1]);
    if (op === '!') {
      return "not (".concat(crit, ")");
    }
    throw _errors.errors.Error('E4003', op);
  };
  var compileGroup = function compileGroup(criteria) {
    var bag = [];
    var groupOperator;
    var nextGroupOperator;
    (0, _iterator.each)(criteria, function (index, criterion) {
      if (Array.isArray(criterion)) {
        if (bag.length > 1 && groupOperator !== nextGroupOperator) {
          throw new _errors.errors.Error('E4019');
        }
        bag.push("(".concat(compileCore(criterion), ")"));
        groupOperator = nextGroupOperator;
        nextGroupOperator = 'and';
      } else {
        nextGroupOperator = (0, _utils2.isConjunctiveOperator)(this) ? 'and' : 'or';
      }
    });
    return bag.join(" ".concat(groupOperator, " "));
  };
  var compileCore = function compileCore(criteria) {
    if (Array.isArray(criteria[0])) {
      return compileGroup(criteria);
    }
    if ((0, _utils2.isUnaryOperation)(criteria)) {
      return compileUnary(criteria);
    }
    return compileBinary(criteria);
  };
  return function (criteria, version, types, filterToLower) {
    fieldTypes = types;
    forceLowerCase = filterToLower !== null && filterToLower !== void 0 ? filterToLower : (0, _config.default)().oDataFilterToLower;
    protocolVersion = version;
    return compileCore(criteria);
  };
}();
var createODataQueryAdapter = function createODataQueryAdapter(queryOptions) {
  var _sorting = [];
  var _criteria = [];
  var _expand = queryOptions.expand;
  var _select;
  var _skip;
  var _take;
  var _countQuery;
  var _oDataVersion = queryOptions.version || DEFAULT_PROTOCOL_VERSION;
  var hasSlice = function hasSlice() {
    return _skip || _take !== undefined;
  };
  var hasFunction = function hasFunction(criterion) {
    for (var i = 0; i < criterion.length; i++) {
      if ((0, _type.isFunction)(criterion[i])) {
        return true;
      }
      if (Array.isArray(criterion[i]) && hasFunction(criterion[i])) {
        return true;
      }
    }
    return false;
  };
  var requestData = function requestData() {
    var result = {};
    if (!_countQuery) {
      if (_sorting.length) {
        result['$orderby'] = _sorting.join(',');
      }
      if (_skip) {
        result['$skip'] = _skip;
      }
      if (_take !== undefined) {
        result['$top'] = _take;
      }
      result['$select'] = (0, _utils.generateSelect)(_oDataVersion, _select) || undefined;
      result['$expand'] = (0, _utils.generateExpand)(_oDataVersion, _expand, _select) || undefined;
    }
    if (_criteria.length) {
      var criteria = _criteria.length < 2 ? _criteria[0] : _criteria;
      var fieldTypes = queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fieldTypes;
      var filterToLower = queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.filterToLower;
      result['$filter'] = compileCriteria(criteria, _oDataVersion, fieldTypes, filterToLower);
    }
    if (_countQuery) {
      result['$top'] = 0;
    }
    if (queryOptions.requireTotalCount || _countQuery) {
      // todo: tests!!!
      if (_oDataVersion !== 4) {
        result['$inlinecount'] = 'allpages';
      } else {
        result['$count'] = 'true';
      }
    }
    return result;
  };
  var tryLiftSelect = function tryLiftSelect(tasks) {
    var selectIndex = -1;
    for (var i = 0; i < tasks.length; i++) {
      if (tasks[i].name === 'select') {
        selectIndex = i;
        break;
      }
    }
    if (selectIndex < 0 || !(0, _type.isFunction)(tasks[selectIndex].args[0])) return;
    var nextTask = tasks[1 + selectIndex];
    if (!nextTask || nextTask.name !== 'slice') return;
    tasks[1 + selectIndex] = tasks[selectIndex];
    tasks[selectIndex] = nextTask;
  };
  return {
    optimize: tryLiftSelect,
    exec(url) {
      return (0, _utils.sendRequest)(_oDataVersion, {
        url,
        params: (0, _extend.extend)(requestData(), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.params)
      }, {
        beforeSend: queryOptions.beforeSend,
        jsonp: queryOptions.jsonp,
        withCredentials: queryOptions.withCredentials,
        countOnly: _countQuery,
        deserializeDates: queryOptions.deserializeDates,
        fieldTypes: queryOptions.fieldTypes,
        isPaged: isFinite(_take)
      });
    },
    multiSort(args) {
      var rules;
      if (hasSlice()) {
        return false;
      }
      for (var i = 0; i < args.length; i++) {
        var getter = args[i][0];
        var desc = !!args[i][1];
        var rule = void 0;
        if (typeof getter !== 'string') {
          return false;
        }
        rule = (0, _utils.serializePropName)(getter);
        if (desc) {
          rule += ' desc';
        }
        rules = rules || [];
        rules.push(rule);
      }
      _sorting = rules;
    },
    slice(skipCount, takeCount) {
      if (hasSlice()) {
        return false;
      }
      _skip = skipCount;
      _take = takeCount;
    },
    filter(criterion) {
      if (hasSlice()) {
        return false;
      }
      if (!Array.isArray(criterion)) {
        criterion = [].slice.call(arguments);
      }
      if (hasFunction(criterion)) {
        return false;
      }
      if (_criteria.length) {
        _criteria.push('and');
      }
      _criteria.push(criterion);
    },
    select(expr) {
      if (_select || (0, _type.isFunction)(expr)) {
        return false;
      }
      if (!Array.isArray(expr)) {
        expr = [].slice.call(arguments);
      }
      _select = expr;
    },
    count: function count() {
      return _countQuery = true;
    }
  };
};
_query_adapters.default.odata = createODataQueryAdapter;
var odata = createODataQueryAdapter;
exports.odata = odata;

/***/ }),

/***/ 63081:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(77869);
__webpack_require__(54263);
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var DEFAULT_PROTOCOL_VERSION = 2;
var RequestDispatcher = /*#__PURE__*/function () {
  function RequestDispatcher(options) {
    options = options || {};
    this._url = String(options.url).replace(/\/+$/, '');
    this._beforeSend = options.beforeSend;
    this._jsonp = options.jsonp;
    this._version = options.version || DEFAULT_PROTOCOL_VERSION;
    this._withCredentials = options.withCredentials;
    this._deserializeDates = options.deserializeDates;
    this._filterToLower = options.filterToLower;
  }
  var _proto = RequestDispatcher.prototype;
  _proto.sendRequest = function sendRequest(url, method, params, payload) {
    return (0, _utils.sendRequest)(this.version, {
      url,
      method,
      params: params || {},
      payload
    }, {
      beforeSend: this._beforeSend,
      jsonp: this._jsonp,
      withCredentials: this._withCredentials,
      deserializeDates: this._deserializeDates
    });
  };
  _createClass(RequestDispatcher, [{
    key: "version",
    get: function get() {
      return this._version;
    }
  }, {
    key: "beforeSend",
    get: function get() {
      return this._beforeSend;
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "jsonp",
    get: function get() {
      return this._jsonp;
    }
  }, {
    key: "filterToLower",
    get: function get() {
      return this._filterToLower;
    }
  }]);
  return RequestDispatcher;
}();
exports["default"] = RequestDispatcher;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 341:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _config = _interopRequireDefault(__webpack_require__(80209));
var _utils = __webpack_require__(77869);
var _errors = __webpack_require__(18438);
var _query = _interopRequireDefault(__webpack_require__(96687));
var _abstract_store = _interopRequireDefault(__webpack_require__(67403));
var _request_dispatcher = _interopRequireDefault(__webpack_require__(63081));
var _deferred = __webpack_require__(62754);
__webpack_require__(54263);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ANONYMOUS_KEY_NAME = '5d46402c-7899-4ea9-bd81-8b73c47c7683';
var expandKeyType = function expandKeyType(key, keyType) {
  return {
    [key]: keyType
  };
};
var mergeFieldTypesWithKeyType = function mergeFieldTypesWithKeyType(fieldTypes, keyType) {
  var result = {};
  for (var field in fieldTypes) {
    result[field] = fieldTypes[field];
  }
  for (var keyName in keyType) {
    if (keyName in result) {
      if (result[keyName] !== keyType[keyName]) {
        _errors.errors.log('W4001', keyName);
      }
    } else {
      result[keyName] = keyType[keyName];
    }
  }
  return result;
};
var ODataStore = _abstract_store.default.inherit({
  ctor(options) {
    this.callBase(options);
    this._requestDispatcher = new _request_dispatcher.default(options);
    var key = this.key();
    var fieldTypes = options.fieldTypes;
    var keyType = options.keyType;
    if (keyType) {
      var keyTypeIsString = typeof keyType === 'string';
      if (!key) {
        key = keyTypeIsString ? ANONYMOUS_KEY_NAME : Object.keys(keyType);
        this._legacyAnonymousKey = key;
      }
      if (keyTypeIsString) {
        keyType = expandKeyType(key, keyType);
      }
      fieldTypes = mergeFieldTypesWithKeyType(fieldTypes, keyType);
    }
    this._fieldTypes = fieldTypes || {};
    if (this.version() === 2) {
      this._updateMethod = 'MERGE';
    } else {
      this._updateMethod = 'PATCH';
    }
  },
  _customLoadOptions() {
    return ['expand', 'customQueryParams'];
  },
  _byKeyImpl(key, extraOptions) {
    var params = {};
    if (extraOptions) {
      params['$expand'] = (0, _utils.generateExpand)(this.version(), extraOptions.expand, extraOptions.select) || undefined;
      params['$select'] = (0, _utils.generateSelect)(this.version(), extraOptions.select) || undefined;
    }
    return this._requestDispatcher.sendRequest(this._byKeyUrl(key), 'GET', params);
  },
  createQuery(loadOptions) {
    var _loadOptions$urlOverr;
    var url;
    var queryOptions = {
      adapter: 'odata',
      beforeSend: this._requestDispatcher.beforeSend,
      errorHandler: this._errorHandler,
      jsonp: this._requestDispatcher.jsonp,
      version: this._requestDispatcher.version,
      withCredentials: this._requestDispatcher._withCredentials,
      expand: loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.expand,
      requireTotalCount: loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.requireTotalCount,
      deserializeDates: this._requestDispatcher._deserializeDates,
      fieldTypes: this._fieldTypes
    };

    // NOTE: For AppBuilder, do not remove
    url = (_loadOptions$urlOverr = loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.urlOverride) !== null && _loadOptions$urlOverr !== void 0 ? _loadOptions$urlOverr : this._requestDispatcher.url;
    if ((0, _type.isDefined)(this._requestDispatcher.filterToLower)) {
      queryOptions.filterToLower = this._requestDispatcher.filterToLower;
    }
    if (loadOptions !== null && loadOptions !== void 0 && loadOptions.customQueryParams) {
      var params = (0, _utils.escapeServiceOperationParams)(loadOptions === null || loadOptions === void 0 ? void 0 : loadOptions.customQueryParams, this.version());
      if (this.version() === 4) {
        url = (0, _utils.formatFunctionInvocationUrl)(url, params);
      } else {
        queryOptions.params = params;
      }
    }
    return (0, _query.default)(url, queryOptions);
  },
  _insertImpl(values) {
    var _this = this;
    this._requireKey();
    var d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._requestDispatcher.url, 'POST', null, values)).done(function (serverResponse) {
      return d.resolve(serverResponse && !(0, _config.default)().useLegacyStoreResult ? serverResponse : values, _this.keyOf(serverResponse));
    }).fail(d.reject);
    return d.promise();
  },
  _updateImpl(key, values) {
    var d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), this._updateMethod, null, values)).done(function (serverResponse) {
      return (0, _config.default)().useLegacyStoreResult ? d.resolve(key, values) : d.resolve(serverResponse || values, key);
    }).fail(d.reject);
    return d.promise();
  },
  _removeImpl(key) {
    var d = new _deferred.Deferred();
    (0, _deferred.when)(this._requestDispatcher.sendRequest(this._byKeyUrl(key), 'DELETE')).done(function () {
      return d.resolve(key);
    }).fail(d.reject);
    return d.promise();
  },
  _convertKey(value) {
    var result = value;
    var fieldTypes = this._fieldTypes;
    var key = this.key() || this._legacyAnonymousKey;
    if (Array.isArray(key)) {
      result = {};
      for (var i = 0; i < key.length; i++) {
        var keyName = key[i];
        result[keyName] = (0, _utils.convertPrimitiveValue)(fieldTypes[keyName], value[keyName]);
      }
    } else if (fieldTypes[key]) {
      result = (0, _utils.convertPrimitiveValue)(fieldTypes[key], value);
    }
    return result;
  },
  _byKeyUrl(value) {
    var baseUrl = this._requestDispatcher.url;
    var convertedKey = this._convertKey(value);
    return "".concat(baseUrl, "(").concat(encodeURIComponent((0, _utils.serializeKey)(convertedKey, this.version())), ")");
  },
  version() {
    return this._requestDispatcher.version;
  }
}, 'odata');
var _default = ODataStore;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 77869:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.serializeValue = exports.serializePropName = exports.serializeKey = exports.sendRequest = exports.keyConverters = exports.generateSelect = exports.generateExpand = exports.formatFunctionInvocationUrl = exports.escapeServiceOperationParams = exports.convertPrimitiveValue = exports.EdmLiteral = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _errors = __webpack_require__(18438);
var _utils = __webpack_require__(16454);
var _string = __webpack_require__(68752);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var GUID_REGEX = /^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$/;
var VERBOSE_DATE_REGEX = /^\/Date\((-?\d+)((\+|-)?(\d+)?)\)\/$/;
var ISO8601_DATE_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[-+]{1}\d{2}(:?)(\d{2})?)?$/;

// Request processing
var JSON_VERBOSE_MIME_TYPE = 'application/json;odata=verbose';
var makeArray = function makeArray(value) {
  return (0, _type.type)(value) === 'string' ? value.split() : value;
};
var hasDot = function hasDot(x) {
  return /\./.test(x);
};
var pad = function pad(text, length, right) {
  text = String(text);
  while (text.length < length) {
    text = right ? "".concat(text, "0") : "0".concat(text);
  }
  return text;
};
var formatISO8601 = function formatISO8601(date, skipZeroTime, skipTimezone) {
  var bag = [];
  var isZeroTime = function isZeroTime() {
    return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1;
  };
  var padLeft2 = function padLeft2(text) {
    return pad(text, 2);
  };
  bag.push(date.getFullYear());
  bag.push('-');
  bag.push(padLeft2(date.getMonth() + 1));
  bag.push('-');
  bag.push(padLeft2(date.getDate()));
  if (!(skipZeroTime && isZeroTime())) {
    bag.push('T');
    bag.push(padLeft2(date.getHours()));
    bag.push(':');
    bag.push(padLeft2(date.getMinutes()));
    bag.push(':');
    bag.push(padLeft2(date.getSeconds()));
    if (date.getMilliseconds()) {
      bag.push('.');
      bag.push(pad(date.getMilliseconds(), 3));
    }
    if (!skipTimezone) {
      bag.push('Z');
    }
  }
  return bag.join('');
};
var parseISO8601 = function parseISO8601(isoString) {
  var result = new Date(new Date(0).getTimezoneOffset() * 60 * 1000);
  var chunks = isoString.replace('Z', '').split('T');
  var date = /(\d{4})-(\d{2})-(\d{2})/.exec(chunks[0]);
  var time = /(\d{2}):(\d{2}):(\d{2})\.?(\d{0,7})?/.exec(chunks[1]);
  result.setFullYear(Number(date[1]));
  result.setMonth(Number(date[2]) - 1);
  result.setDate(Number(date[3]));
  if (Array.isArray(time) && time.length) {
    result.setHours(Number(time[1]));
    result.setMinutes(Number(time[2]));
    result.setSeconds(Number(time[3]));
    var fractional = (time[4] || '').slice(0, 3);
    fractional = pad(fractional, 3, true);
    result.setMilliseconds(Number(fractional));
  }
  return result;
};
var isAbsoluteUrl = function isAbsoluteUrl(url) {
  return /^(?:[a-z]+:)?\/{2,2}/i.test(url);
};
var stripParams = function stripParams(url) {
  var index = url.indexOf('?');
  if (index > -1) {
    return url.substr(0, index);
  }
  return url;
};
var toAbsoluteUrl = function toAbsoluteUrl(basePath, relativePath) {
  var part;
  var baseParts = stripParams(basePath).split('/');
  var relativeParts = relativePath.split('/');
  baseParts.pop();
  while (relativeParts.length) {
    part = relativeParts.shift();
    if (part === '..') {
      baseParts.pop();
    } else {
      baseParts.push(part);
    }
  }
  return baseParts.join('/');
};
var param = function param(params) {
  var result = [];
  for (var name in params) {
    result.push(name + '=' + params[name]);
  }
  return result.join('&');
};
var ajaxOptionsForRequest = function ajaxOptionsForRequest(protocolVersion, request) {
  var _options$beforeSend;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var formatPayload = function formatPayload(payload) {
    return JSON.stringify(payload, function (key, value) {
      if (!(this[key] instanceof Date)) {
        return value;
      }
      value = formatISO8601(this[key]);
      switch (protocolVersion) {
        case 2:
          return value.substr(0, value.length - 1);
        case 3:
        case 4:
          return value;
        default:
          throw _errors.errors.Error('E4002');
      }
    });
  };
  request = (0, _extend.extend)({
    async: true,
    method: 'get',
    url: '',
    params: {},
    payload: null,
    headers: {},
    timeout: 30000
  }, request);
  (_options$beforeSend = options.beforeSend) === null || _options$beforeSend === void 0 ? void 0 : _options$beforeSend.call(options, request);
  var _request = request,
    async = _request.async,
    timeout = _request.timeout,
    headers = _request.headers;
  var _request2 = request,
    url = _request2.url,
    method = _request2.method;
  var jsonp = options.jsonp,
    withCredentials = options.withCredentials;
  method = (method || 'get').toLowerCase();
  var isGet = method === 'get';
  var useJsonp = isGet && jsonp;
  var params = (0, _extend.extend)({}, request.params);
  var ajaxData = isGet ? params : formatPayload(request.payload);
  var qs = !isGet && param(params);
  var contentType = !isGet && JSON_VERBOSE_MIME_TYPE;
  if (qs) {
    url += (url.indexOf('?') > -1 ? '&' : '?') + qs;
  }
  if (useJsonp) {
    ajaxData['$format'] = 'json';
  }
  return {
    url,
    data: ajaxData,
    dataType: useJsonp ? 'jsonp' : 'json',
    jsonp: useJsonp && '$callback',
    method,
    async,
    timeout,
    headers,
    contentType,
    accepts: {
      json: [JSON_VERBOSE_MIME_TYPE, 'text/plain'].join()
    },
    xhrFields: {
      withCredentials
    }
  };
};
var sendRequest = function sendRequest(protocolVersion, request, options) {
  var deserializeDates = options.deserializeDates,
    fieldTypes = options.fieldTypes,
    countOnly = options.countOnly,
    isPaged = options.isPaged;
  var d = new _deferred.Deferred();
  var ajaxOptions = ajaxOptionsForRequest(protocolVersion, request, options);
  _ajax.default.sendRequest(ajaxOptions).always(function (obj, textStatus) {
    var transformOptions = {
      deserializeDates,
      fieldTypes
    };
    var tuple = interpretJsonFormat(obj, textStatus, transformOptions, ajaxOptions);
    var error = tuple.error,
      data = tuple.data,
      count = tuple.count;
    var nextUrl = tuple.nextUrl;
    if (error) {
      if (error.message !== _utils.XHR_ERROR_UNLOAD) {
        d.reject(error);
      }
    } else if (countOnly) {
      if (isFinite(count)) {
        d.resolve(count);
      } else {
        d.reject(new _errors.errors.Error('E4018'));
      }
    } else if (nextUrl && !isPaged) {
      if (!isAbsoluteUrl(nextUrl)) {
        nextUrl = toAbsoluteUrl(ajaxOptions.url, nextUrl);
      }
      sendRequest(protocolVersion, {
        url: nextUrl
      }, options).fail(d.reject).done(function (nextData) {
        return d.resolve(data.concat(nextData));
      });
    } else {
      var extra = isFinite(count) ? {
        totalCount: count
      } : undefined;
      d.resolve(data, extra);
    }
  });
  return d.promise();
};
exports.sendRequest = sendRequest;
var formatDotNetError = function formatDotNetError(errorObj) {
  var message;
  var currentMessage;
  var currentError = errorObj;
  if ('message' in errorObj) {
    var _errorObj$message;
    message = ((_errorObj$message = errorObj.message) === null || _errorObj$message === void 0 ? void 0 : _errorObj$message.value) || errorObj.message;
  }
  while (currentError = currentError['innererror'] || currentError['internalexception']) {
    var _currentMessage;
    currentMessage = currentError.message;
    message = (_currentMessage = currentMessage) !== null && _currentMessage !== void 0 ? _currentMessage : message;
    if (currentError['internalexception'] && message.indexOf('inner exception') === -1) {
      break;
    }
  }
  return message;
};

// TODO split: decouple HTTP errors from OData errors
var errorFromResponse = function errorFromResponse(obj, textStatus, ajaxOptions) {
  var _response, _response2, _response3, _response4;
  if (textStatus === 'nocontent') {
    return null; // workaround for http://bugs.jquery.com/ticket/13292
  }

  var message = 'Unknown error';
  var response = obj;
  var httpStatus = 200;
  var errorData = {
    requestOptions: ajaxOptions
  };
  if (textStatus !== 'success') {
    var status = obj.status,
      responseText = obj.responseText;
    httpStatus = status;
    message = (0, _utils.errorMessageFromXhr)(obj, textStatus);
    try {
      response = JSON.parse(responseText);
    } catch (x) {}
  }
  var errorObj = ((_response = response) === null || _response === void 0 ? void 0 : _response.then) || ((_response2 = response) === null || _response2 === void 0 ? void 0 : _response2.error) || ((_response3 = response) === null || _response3 === void 0 ? void 0 : _response3['odata.error']) || ((_response4 = response) === null || _response4 === void 0 ? void 0 : _response4['@odata.error']);
  // NOTE: $.Deferred rejected and response contain error message
  // NOTE: $.Deferred resolved with odata error

  if (errorObj) {
    message = formatDotNetError(errorObj) || message;
    errorData.errorDetails = errorObj;
    if (httpStatus === 200) {
      httpStatus = 500;
    }
    var customCode = Number(errorObj.code);
    if (isFinite(customCode) && customCode >= 400) {
      httpStatus = customCode;
    }
  }
  if (httpStatus >= 400 || httpStatus === 0) {
    errorData.httpStatus = httpStatus;
    return (0, _extend.extend)(Error(message), errorData);
  }
  return null;
};
var interpretJsonFormat = function interpretJsonFormat(obj, textStatus, transformOptions, ajaxOptions) {
  var error = errorFromResponse(obj, textStatus, ajaxOptions);
  if (error) {
    return {
      error
    };
  }
  if (!(0, _type.isPlainObject)(obj)) {
    return {
      data: obj
    };
  }
  var value = 'd' in obj && (Array.isArray(obj.d) || (0, _type.isObject)(obj.d)) ? interpretVerboseJsonFormat(obj) : interpretLightJsonFormat(obj);
  transformTypes(value, transformOptions);
  return value;
};
var interpretVerboseJsonFormat = function interpretVerboseJsonFormat(_ref) {
  var _data$results;
  var data = _ref.d;
  if (!(0, _type.isDefined)(data)) {
    return {
      error: Error('Malformed or unsupported JSON response received')
    };
  }
  return {
    data: (_data$results = data.results) !== null && _data$results !== void 0 ? _data$results : data,
    nextUrl: data.__next,
    count: parseInt(data.__count, 10)
  };
};
var interpretLightJsonFormat = function interpretLightJsonFormat(obj) {
  var _obj$value;
  return {
    data: (_obj$value = obj.value) !== null && _obj$value !== void 0 ? _obj$value : obj,
    nextUrl: obj['@odata.nextLink'],
    count: parseInt(obj['@odata.count'], 10)
  };
};

// Serialization and parsing

var EdmLiteral = _class.default.inherit({
  /**
  * @name EdmLiteral.ctor
  * @publicName ctor(value)
  * @param1 value:string
  */
  ctor(value) {
    this._value = value;
  },
  valueOf() {
    return this._value;
  }
});
exports.EdmLiteral = EdmLiteral;
var transformTypes = function transformTypes(obj) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _iterator.each)(obj, function (key, value) {
    if (value !== null && typeof value === 'object') {
      if ('results' in value) {
        obj[key] = value.results;
      }
      transformTypes(obj[key], options);
    } else if (typeof value === 'string') {
      var fieldTypes = options.fieldTypes,
        deserializeDates = options.deserializeDates;
      var canBeGuid = !fieldTypes || fieldTypes[key] !== 'String';
      if (canBeGuid && GUID_REGEX.test(value)) {
        obj[key] = new _guid.default(value);
      }
      if (deserializeDates !== false) {
        if (value.match(VERBOSE_DATE_REGEX)) {
          var date = new Date(Number(RegExp.$1) + RegExp.$2 * 60 * 1000);
          obj[key] = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1000);
        } else if (ISO8601_DATE_REGEX.test(value)) {
          obj[key] = new Date(parseISO8601(obj[key]).valueOf());
        }
      }
    }
  });
};
var serializeDate = function serializeDate(date) {
  return "datetime'".concat(formatISO8601(date, true, true), "'");
};
var serializeString = function serializeString(value) {
  return "'".concat(value.replace(/'/g, '\'\''), "'");
};
var serializePropName = function serializePropName(propName) {
  return propName instanceof EdmLiteral ? propName.valueOf() : propName.replace(/\./g, '/');
};
exports.serializePropName = serializePropName;
var serializeValueV4 = function serializeValueV4(value) {
  if (value instanceof Date) {
    return formatISO8601(value, false, false);
  }
  if (value instanceof _guid.default) {
    return value.valueOf();
  }
  if (Array.isArray(value)) {
    return "[".concat(value.map(function (item) {
      return serializeValueV4(item);
    }).join(','), "]");
  }
  return serializeValueV2(value);
};
var serializeValueV2 = function serializeValueV2(value) {
  if (value instanceof Date) {
    return serializeDate(value);
  }
  if (value instanceof _guid.default) {
    return "guid'".concat(value, "'");
  }
  if (value instanceof EdmLiteral) {
    return value.valueOf();
  }
  if (typeof value === 'string') {
    return serializeString(value);
  }
  return String(value);
};
var serializeValue = function serializeValue(value, protocolVersion) {
  switch (protocolVersion) {
    case 2:
    case 3:
      return serializeValueV2(value);
    case 4:
      return serializeValueV4(value);
    default:
      throw _errors.errors.Error('E4002');
  }
};
exports.serializeValue = serializeValue;
var serializeKey = function serializeKey(key, protocolVersion) {
  if ((0, _type.isPlainObject)(key)) {
    var parts = [];
    (0, _iterator.each)(key, function (k, v) {
      return parts.push("".concat(serializePropName(k), "=").concat(serializeValue(v, protocolVersion)));
    });
    return parts.join();
  }
  return serializeValue(key, protocolVersion);
};
exports.serializeKey = serializeKey;
var keyConverters = {
  String: function String(value) {
    return "".concat(value);
  },
  Int32: function Int32(value) {
    return Math.floor(value);
  },
  Int64: function Int64(value) {
    return value instanceof EdmLiteral ? value : new EdmLiteral("".concat(value, "L"));
  },
  Guid: function Guid(value) {
    return value instanceof _guid.default ? value : new _guid.default(value);
  },
  Boolean: function Boolean(value) {
    return !!value;
  },
  Single: function Single(value) {
    return value instanceof EdmLiteral ? value : new EdmLiteral(value + 'f');
  },
  Decimal: function Decimal(value) {
    return value instanceof EdmLiteral ? value : new EdmLiteral(value + 'm');
  }
};
exports.keyConverters = keyConverters;
var convertPrimitiveValue = function convertPrimitiveValue(type, value) {
  if (value === null) return null;
  var converter = keyConverters[type];
  if (!converter) {
    throw _errors.errors.Error('E4014', type);
  }
  return converter(value);
};
exports.convertPrimitiveValue = convertPrimitiveValue;
var generateSelect = function generateSelect(oDataVersion, select) {
  if (!select) {
    return;
  }
  return oDataVersion < 4 ? serializePropName(select.join()) : (0, _common.grep)(select, hasDot, true).join();
};
exports.generateSelect = generateSelect;
var formatCore = function formatCore(hash) {
  var result = '';
  var selectValue = [];
  var expandValue = [];
  (0, _iterator.each)(hash, function (key, value) {
    if (Array.isArray(value)) {
      [].push.apply(selectValue, value);
    }
    if ((0, _type.isPlainObject)(value)) {
      expandValue.push("".concat(key).concat(formatCore(value)));
    }
  });
  if (selectValue.length || expandValue.length) {
    result += '(';
    if (selectValue.length) {
      result += "$select=".concat((0, _iterator.map)(selectValue, serializePropName).join());
    }
    if (expandValue.length) {
      if (selectValue.length) {
        result += ';';
      }
      result += "$expand=".concat((0, _iterator.map)(expandValue, serializePropName).join());
    }
    result += ')';
  }
  return result;
};
var format = function format(hash) {
  var result = [];
  (0, _iterator.each)(hash, function (key, value) {
    return result.push("".concat(key).concat(formatCore(value)));
  });
  return result.join();
};
var parseCore = function parseCore(exprParts, root, stepper) {
  var result = stepper(root, exprParts.shift(), exprParts);
  if (result === false) {
    return;
  }
  parseCore(exprParts, result, stepper);
};
var parseTree = function parseTree(exprs, root, stepper) {
  return (0, _iterator.each)(exprs, function (_, x) {
    return parseCore(x.split('.'), root, stepper);
  });
};
var generatorV2 = function generatorV2(expand, select) {
  var hash = {};
  if (expand) {
    (0, _iterator.each)(makeArray(expand), function () {
      hash[serializePropName(this)] = 1;
    });
  }
  if (select) {
    (0, _iterator.each)(makeArray(select), function () {
      var path = this.split('.');
      if (path.length < 2) {
        return;
      }
      path.pop();
      hash[serializePropName(path.join('.'))] = 1;
    });
  }
  return (0, _iterator.map)(hash, function (_, v) {
    return v;
  }).join();
};
var generatorV4 = function generatorV4(expand, select) {
  var hash = {};
  if (expand || select) {
    if (expand) {
      parseTree(makeArray(expand), hash, function (node, key, path) {
        node[key] = node[key] || {};
        return !path.length ? false : node[key];
      });
    }
    if (select) {
      parseTree((0, _common.grep)(makeArray(select), hasDot), hash, function (node, key, path) {
        if (!path.length) {
          node[key] = node[key] || [];
          node[key].push(key);
          return false;
        }
        return node[key] = node[key] || {};
      });
    }
    return format(hash);
  }
};
var generateExpand = function generateExpand(oDataVersion, expand, select) {
  return oDataVersion < 4 ? generatorV2(expand, select) : generatorV4(expand, select);
};
exports.generateExpand = generateExpand;
var formatFunctionInvocationUrl = function formatFunctionInvocationUrl(baseUrl, args) {
  return (0, _string.format)('{0}({1})', baseUrl, (0, _iterator.map)(args || {}, function (value, key) {
    return (0, _string.format)('{0}={1}', key, value);
  }).join(','));
};
exports.formatFunctionInvocationUrl = formatFunctionInvocationUrl;
var escapeServiceOperationParams = function escapeServiceOperationParams(params, version) {
  if (!params) {
    return params;
  }

  // From WCF Data Services docs:
  // The type of each parameter must be a primitive type.
  // Any data of a non-primitive type must be serialized and passed into a string parameter
  var result = {};
  (0, _iterator.each)(params, function (k, v) {
    result[k] = serializeValue(v, version);
  });
  return result;
};
exports.escapeServiceOperationParams = escapeServiceOperationParams;

/***/ }),

/***/ 96687:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _query_implementation = __webpack_require__(77549);
var query = function query() {
  var impl = Array.isArray(arguments[0]) ? 'array' : 'remote';
  return _query_implementation.queryImpl[impl].apply(this, arguments);
};
var _default = query;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 16135:
/***/ (function(module, exports) {



exports["default"] = void 0;
var _default = {};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 77549:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.queryImpl = void 0;
var _array_query = _interopRequireDefault(__webpack_require__(35042));
var _remote_query = _interopRequireDefault(__webpack_require__(41428));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var queryImpl = {
  array: _array_query.default,
  remote: _remote_query.default
};
exports.queryImpl = queryImpl;

/***/ }),

/***/ 41428:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _query_adapters = _interopRequireDefault(__webpack_require__(16135));
var _errors = __webpack_require__(18438);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
var _array_query = _interopRequireDefault(__webpack_require__(35042));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var remoteQueryImpl = function remoteQueryImpl(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  var createTask = function createTask(name, args) {
    return {
      name: name,
      args: args
    };
  };
  var exec = function exec(executorTask) {
    var d = new _deferred.Deferred();
    var _adapterFactory;
    var _adapter;
    var _taskQueue;
    var _currentTask;
    var _mergedSortArgs;
    var rejectWithNotify = function rejectWithNotify(error) {
      var handler = queryOptions.errorHandler;
      if (handler) {
        handler(error);
      }
      (0, _errors.handleError)(error);
      d.reject(error);
    };
    function mergeSortTask(task) {
      switch (task.name) {
        case 'sortBy':
          _mergedSortArgs = [task.args];
          return true;
        case 'thenBy':
          if (!_mergedSortArgs) {
            throw _errors.errors.Error('E4004');
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    function unmergeSortTasks() {
      var head = _taskQueue[0];
      var unmergedTasks = [];
      if (head && head.name === 'multiSort') {
        _taskQueue.shift();
        (0, _iterator.each)(head.args[0], function () {
          unmergedTasks.push(createTask(unmergedTasks.length ? 'thenBy' : 'sortBy', this));
        });
      }
      _taskQueue = unmergedTasks.concat(_taskQueue);
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!(0, _type.isFunction)(_adapterFactory)) {
        _adapterFactory = _query_adapters.default[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      var optimize = _adapter.optimize;
      if (optimize) optimize(_taskQueue);
      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask('multiSort', [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if (String(_currentTask.name) !== 'enumerate') {
            if (!_adapter[_currentTask.name] || _adapter[_currentTask.name].apply(_adapter, _currentTask.args) === false) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      unmergeSortTasks();
      _adapter.exec(url).done(function (result, extra) {
        if (!_taskQueue.length) {
          d.resolve(result, extra);
        } else {
          var clientChain = (0, _array_query.default)(result, {
            errorHandler: queryOptions.errorHandler
          });
          (0, _iterator.each)(_taskQueue, function () {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain.done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  var query = {};
  (0, _iterator.each)(['sortBy', 'thenBy', 'filter', 'slice', 'select', 'groupBy'], function () {
    var name = String(this);
    query[name] = function () {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name, arguments)));
    };
  });
  (0, _iterator.each)(['count', 'min', 'max', 'sum', 'avg', 'aggregate', 'enumerate'], function () {
    var name = String(this);
    query[name] = function () {
      return exec.call(this, createTask(name, arguments));
    };
  });
  return query;
};
var _default = remoteQueryImpl;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99236:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _array_query = _interopRequireDefault(__webpack_require__(35042));
var _utils = __webpack_require__(16454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function multiLevelGroup(query, groupInfo) {
  query = query.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query = query.select(function (g) {
      return (0, _extend.extend)({}, g, {
        items: multiLevelGroup((0, _array_query.default)(g.items), groupInfo.slice(1)).toArray()
      });
    });
  }
  return query;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  var filteredGroup = [];
  (0, _iterator.each)(groupInfo, function (_, group) {
    var collision = (0, _common.grep)(sortInfo, function (sort) {
      return group.selector === sort.selector;
    });
    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions(query, options, isCountQuery) {
  var _options;
  options = options || {};
  var filter = options.filter;
  if ((_options = options) !== null && _options !== void 0 && _options.langParams) {
    var _query$setLangParams, _query;
    (_query$setLangParams = (_query = query).setLangParams) === null || _query$setLangParams === void 0 ? void 0 : _query$setLangParams.call(_query, options.langParams);
  }
  if (filter) {
    query = query.filter(filter);
  }
  if (isCountQuery) {
    return query;
  }
  var sort = options.sort;
  var select = options.select;
  var group = options.group;
  var skip = options.skip;
  var take = options.take;
  if (group) {
    group = (0, _utils.normalizeSortingInfo)(group);
    group.keepInitialKeyOrder = !!options.group.keepInitialKeyOrder;
  }
  if (sort || group) {
    sort = (0, _utils.normalizeSortingInfo)(sort || []);
    if (group && !group.keepInitialKeyOrder) {
      sort = arrangeSortingInfo(group, sort);
    }
    (0, _iterator.each)(sort, function (index) {
      query = query[index ? 'thenBy' : 'sortBy'](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query = query.select(select);
  }
  if (group) {
    query = multiLevelGroup(query, group);
  }
  if (take || skip) {
    query = query.slice(skip || 0, take);
  }
  return query;
}
var _default = {
  multiLevelGroup,
  arrangeSortingInfo,
  queryByOptions
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 16454:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.errorMessageFromXhr = exports.base64_encode = exports.aggregators = exports.XHR_ERROR_UNLOAD = void 0;
exports.isConjunctiveOperator = isConjunctiveOperator;
exports.isDisjunctiveOperator = isDisjunctiveOperator;
exports.rejectedPromise = exports.processRequestResultLock = exports.normalizeSortingInfo = exports.normalizeBinaryCriterion = exports.keysEqual = exports.isUnaryOperation = exports.isGroupCriterion = void 0;
exports.throttleChanges = throttleChanges;
exports.trivialPromise = void 0;
var _type = __webpack_require__(35922);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _window = __webpack_require__(58201);
var _iterator = __webpack_require__(95479);
var _deferred = __webpack_require__(62754);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var ready = _ready_callbacks.default.add;
var XHR_ERROR_UNLOAD = 'DEVEXTREME_XHR_ERROR_UNLOAD';
exports.XHR_ERROR_UNLOAD = XHR_ERROR_UNLOAD;
var normalizeBinaryCriterion = function normalizeBinaryCriterion(crit) {
  return [crit[0], crit.length < 3 ? '=' : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};
exports.normalizeBinaryCriterion = normalizeBinaryCriterion;
var normalizeSortingInfo = function normalizeSortingInfo(info) {
  if (!Array.isArray(info)) {
    info = [info];
  }
  return (0, _iterator.map)(info, function (i) {
    var result = {
      selector: (0, _type.isFunction)(i) || typeof i === 'string' ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || String(i.dir).charAt(0).toLowerCase() === 'd')
    };
    if (i.compare) {
      result.compare = i.compare;
    }
    return result;
  });
};
exports.normalizeSortingInfo = normalizeSortingInfo;
var errorMessageFromXhr = function () {
  var textStatusMessages = {
    'timeout': 'Network connection timeout',
    'error': 'Unspecified network error',
    'parsererror': 'Unexpected server response'
  };
  var explainTextStatus = function explainTextStatus(textStatus) {
    var result = textStatusMessages[textStatus];
    if (!result) {
      return textStatus;
    }
    return result;
  };

  // T542570, https://stackoverflow.com/a/18170879
  var unloading;
  ready(function () {
    var window = (0, _window.getWindow)();
    _dom_adapter.default.listen(window, 'beforeunload', function () {
      unloading = true;
    });
  });
  return function (xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }
    if (xhr.status < 400) {
      return explainTextStatus(textStatus);
    }
    return xhr.statusText;
  };
}();
exports.errorMessageFromXhr = errorMessageFromXhr;
var aggregators = {
  count: {
    seed: 0,
    step: function step(count) {
      return 1 + count;
    }
  },
  sum: {
    seed: 0,
    step: function step(sum, item) {
      return sum + item;
    }
  },
  min: {
    step: function step(min, item) {
      return item < min ? item : min;
    }
  },
  max: {
    step: function step(max, item) {
      return item > max ? item : max;
    }
  },
  avg: {
    seed: [0, 0],
    step: function step(pair, value) {
      return [pair[0] + value, pair[1] + 1];
    },
    finalize: function finalize(pair) {
      return pair[1] ? pair[0] / pair[1] : NaN;
    }
  }
};
exports.aggregators = aggregators;
var processRequestResultLock = function () {
  var lockCount = 0;
  var lockDeferred;
  var obtain = function obtain() {
    if (lockCount === 0) {
      lockDeferred = new _deferred.Deferred();
    }
    lockCount++;
  };
  var release = function release() {
    lockCount--;
    if (lockCount < 1) {
      lockDeferred.resolve();
    }
  };
  var promise = function promise() {
    var deferred = lockCount === 0 ? new _deferred.Deferred().resolve() : lockDeferred;
    return deferred.promise();
  };
  var reset = function reset() {
    lockCount = 0;
    if (lockDeferred) {
      lockDeferred.resolve();
    }
  };
  return {
    obtain: obtain,
    release: release,
    promise: promise,
    reset: reset
  };
}();
exports.processRequestResultLock = processRequestResultLock;
function isDisjunctiveOperator(condition) {
  return /^(or|\|\||\|)$/i.test(condition);
}
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
var keysEqual = function keysEqual(keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    var names = (0, _iterator.map)(key1, function (v, k) {
      return k;
    });
    var name;
    for (var i = 0; i < names.length; i++) {
      name = names[i];
      if (!(0, _common.equalByValue)(key1[name], key2[name], {
        strict: false
      })) {
        return false;
      }
    }
    return true;
  }
  return (0, _common.equalByValue)(key1, key2, {
    strict: false
  });
};
exports.keysEqual = keysEqual;
var BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var base64_encode = function base64_encode(input) {
  if (!Array.isArray(input)) {
    input = stringToByteArray(String(input));
  }
  var result = '';
  function getBase64Char(index) {
    return BASE64_CHARS.charAt(index);
  }
  for (var i = 0; i < input.length; i += 3) {
    var octet1 = input[i];
    var octet2 = input[i + 1];
    var octet3 = input[i + 2];
    result += (0, _iterator.map)([octet1 >> 2, (octet1 & 3) << 4 | octet2 >> 4, isNaN(octet2) ? 64 : (octet2 & 15) << 2 | octet3 >> 6, isNaN(octet3) ? 64 : octet3 & 63], getBase64Char).join('');
  }
  return result;
};
exports.base64_encode = base64_encode;
function stringToByteArray(str) {
  var bytes = [];
  var code;
  var i;
  for (i = 0; i < str.length; i++) {
    code = str.charCodeAt(i);
    if (code < 128) {
      bytes.push(code);
    } else if (code < 2048) {
      bytes.push(192 + (code >> 6), 128 + (code & 63));
    } else if (code < 65536) {
      bytes.push(224 + (code >> 12), 128 + (code >> 6 & 63), 128 + (code & 63));
    } else if (code < 2097152) {
      bytes.push(240 + (code >> 18), 128 + (code >> 12 & 63), 128 + (code >> 6 & 63), 128 + (code & 63));
    }
  }
  return bytes;
}
var isUnaryOperation = function isUnaryOperation(crit) {
  return crit[0] === '!' && Array.isArray(crit[1]);
};
exports.isUnaryOperation = isUnaryOperation;
var isGroupOperator = function isGroupOperator(value) {
  return value === 'and' || value === 'or';
};
var isGroupCriterion = function isGroupCriterion(crit) {
  var first = crit[0];
  var second = crit[1];
  if (Array.isArray(first)) {
    return true;
  }
  if ((0, _type.isFunction)(first)) {
    if (Array.isArray(second) || (0, _type.isFunction)(second) || isGroupOperator(second)) {
      return true;
    }
  }
  return false;
};
exports.isGroupCriterion = isGroupCriterion;
var trivialPromise = function trivialPromise() {
  var d = new _deferred.Deferred();
  return d.resolve.apply(d, arguments).promise();
};
exports.trivialPromise = trivialPromise;
var rejectedPromise = function rejectedPromise() {
  var d = new _deferred.Deferred();
  return d.reject.apply(d, arguments).promise();
};
exports.rejectedPromise = rejectedPromise;
function throttle(func, timeout) {
  var timeoutId;
  return function () {
    var _this = this;
    if (!timeoutId) {
      timeoutId = setTimeout(function () {
        timeoutId = undefined;
        func.call(_this);
      }, (0, _type.isFunction)(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  var cache = [];
  var throttled = throttle(function () {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function (changes) {
    if (Array.isArray(changes)) {
      var _cache;
      (_cache = cache).push.apply(_cache, _toConsumableArray(changes));
    }
    return throttled.call(this, cache);
  };
}

/**
* @name Utils
*/

/***/ }),

/***/ 53305:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _data_source = __webpack_require__(85273);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(9234);
var _data_controller = _interopRequireDefault(__webpack_require__(97326));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DATA_SOURCE_OPTIONS_METHOD = '_dataSourceOptions';
var DATA_SOURCE_CHANGED_METHOD = '_dataSourceChangedHandler';
var DATA_SOURCE_LOAD_ERROR_METHOD = '_dataSourceLoadErrorHandler';
var DATA_SOURCE_LOADING_CHANGED_METHOD = '_dataSourceLoadingChangedHandler';
var DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = '_dataSourceFromUrlLoadMode';
var SPECIFIC_DATA_SOURCE_OPTION = '_getSpecificDataSourceOption';
var NORMALIZE_DATA_SOURCE = '_normalizeDataSource';
var DataHelperMixin = {
  postCtor: function postCtor() {
    this.on('disposing', function () {
      this._disposeDataSource();
    }.bind(this));
  },
  _refreshDataSource: function _refreshDataSource() {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource: function _initDataSource() {
    var dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option('dataSource');
    var widgetDataSourceOptions;
    var dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof _data_source.DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : _data_source.DataSource;
        dataSourceOptions = (0, _utils.normalizeDataSourceOptions)(dataSourceOptions, {
          fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
        });
        this._dataSource = new dataSourceType((0, _extend.extend)(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  },
  _initDataController: function _initDataController() {
    var _this$option;
    var dataController = (_this$option = this.option) === null || _this$option === void 0 ? void 0 : _this$option.call(this, '_dataController');
    var dataSource = this._dataSource;
    if (dataController) {
      this._dataController = dataController;
    } else {
      this._dataController = new _data_controller.default(dataSource);
    }
  },
  _addDataSourceHandlers: function _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher: function _addReadyWatcher() {
    this._dataSource.on('loadingChanged', function (isLoading) {
      this._ready && this._ready(!isLoading);
    }.bind(this));
  },
  _addDataSourceChangeHandler: function _addDataSourceChangeHandler() {
    var dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = function (e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }.bind(this);
    dataSource.on('changed', this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler: function _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);
    this._dataSource.on('loadError', this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler: function _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);
    this._dataSource.on('loadingChanged', this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource: function _loadDataSource() {
    var dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle: function _loadSingle(key, value) {
    key = key === 'this' ? this._dataSource.key() || 'this' : key;
    return this._dataSource.loadSingle(key, value);
  },
  _isLastPage: function _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading: function _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource: function _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off('changed', this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off('loadError', this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off('loadingChanged', this._proxiedDataSourceLoadingChangedHandler);
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource: function getDataSource() {
    return this._dataSource || null;
  }
};
var _default = DataHelperMixin;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 95429:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.name = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom = __webpack_require__(3532);
var _frame = __webpack_require__(90057);
var _index = __webpack_require__(39611);
var _event_nodes_disposing = __webpack_require__(27575);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var CLICK_EVENT_NAME = 'dxclick';
exports.name = CLICK_EVENT_NAME;
var misc = {
  requestAnimationFrame: _frame.requestAnimationFrame,
  cancelAnimationFrame: _frame.cancelAnimationFrame
};
var prevented = null;
var lastFiredEvent = null;
var onNodeRemove = function onNodeRemove() {
  lastFiredEvent = null;
};
var clickHandler = function clickHandler(e) {
  var originalEvent = e.originalEvent;
  var eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
  var leftButton = !e.which || e.which === 1;
  if (leftButton && !prevented && !eventAlreadyFired) {
    if (originalEvent) {
      originalEvent.DXCLICK_FIRED = true;
    }
    (0, _event_nodes_disposing.unsubscribeNodesDisposing)(lastFiredEvent, onNodeRemove);
    lastFiredEvent = originalEvent;
    (0, _event_nodes_disposing.subscribeNodesDisposing)(lastFiredEvent, onNodeRemove);
    (0, _index.fireEvent)({
      type: CLICK_EVENT_NAME,
      originalEvent: e
    });
  }
};
var ClickEmitter = _emitter.default.inherit({
  ctor: function ctor(element) {
    this.callBase(element);
    _events_engine.default.on(this.getElement(), 'click', clickHandler);
  },
  start: function start(e) {
    prevented = null;
  },
  cancel: function cancel() {
    prevented = true;
  },
  dispose: function dispose() {
    _events_engine.default.off(this.getElement(), 'click', clickHandler);
  }
});

// NOTE: fixes native click blur on slow devices
(function () {
  var desktopDevice = _devices.default.real().generic;
  if (!desktopDevice) {
    var startTarget = null;
    var blurPrevented = false;
    var isInput = function isInput(element) {
      return (0, _renderer.default)(element).is('input, textarea, select, button ,:focus, :focus *');
    };
    var pointerDownHandler = function pointerDownHandler(e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    };
    var _clickHandler = function _clickHandler(e) {
      var $target = (0, _renderer.default)(e.target);
      if (!blurPrevented && startTarget && !$target.is(startTarget) && !(0, _renderer.default)(startTarget).is('label') && isInput($target)) {
        (0, _dom.resetActiveElement)();
      }
      startTarget = null;
      blurPrevented = false;
    };
    var NATIVE_CLICK_FIXER_NAMESPACE = 'NATIVE_CLICK_FIXER';
    var document = _dom_adapter.default.getDocument();
    _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);
    _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)('click', NATIVE_CLICK_FIXER_NAMESPACE), _clickHandler);
  }
})();

/**
  * @name UI Events.dxclick
  * @type eventType
  * @type_function_param1 event:event
  * @module events/click
*/
(0, _emitter_registrator.default)({
  emitter: ClickEmitter,
  bubble: true,
  events: [CLICK_EVENT_NAME]
});

/***/ }),

/***/ 49166:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.name = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _support = __webpack_require__(60137);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _index = __webpack_require__(39611);
var _hold = _interopRequireDefault(__webpack_require__(11699));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var CONTEXTMENU_NAMESPACE = 'dxContexMenu';
var CONTEXTMENU_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)('contextmenu', CONTEXTMENU_NAMESPACE);
var HOLD_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_hold.default.name, CONTEXTMENU_NAMESPACE);
var CONTEXTMENU_EVENT_NAME = 'dxcontextmenu';
var ContextMenu = _class.default.inherit({
  setup: function setup(element) {
    var $element = (0, _renderer.default)(element);
    _events_engine.default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (_support.touch || _devices.default.isSimulator()) {
      _events_engine.default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler: function _holdHandler(e) {
    if ((0, _index.isMouseEvent)(e) && !_devices.default.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler: function _contextMenuHandler(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: function _fireContextMenu(e) {
    return (0, _index.fireEvent)({
      type: CONTEXTMENU_EVENT_NAME,
      originalEvent: e
    });
  },
  teardown: function teardown(element) {
    _events_engine.default.off(element, '.' + CONTEXTMENU_NAMESPACE);
  }
});

/**
  * @name UI Events.dxcontextmenu
  * @type eventType
  * @type_function_param1 event:event
  * @module events/contextmenu
*/

(0, _event_registrator.default)(CONTEXTMENU_EVENT_NAME, new ContextMenu());
var name = CONTEXTMENU_EVENT_NAME;
exports.name = name;

/***/ }),

/***/ 91633:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.lock = exports.inactive = exports.active = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _common = __webpack_require__(20576);
var _dom = __webpack_require__(3532);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ACTIVE_EVENT_NAME = 'dxactive';
exports.active = ACTIVE_EVENT_NAME;
var INACTIVE_EVENT_NAME = 'dxinactive';
exports.inactive = INACTIVE_EVENT_NAME;
var ACTIVE_TIMEOUT = 30;
var INACTIVE_TIMEOUT = 400;
var FeedbackEvent = _class.default.inherit({
  ctor: function ctor(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start: function start() {
    var that = this;
    this._schedule(function () {
      that.force();
    });
  },
  _schedule: function _schedule(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop: function stop() {
    clearTimeout(this._timer);
  },
  force: function force() {
    if (this._fired) {
      return;
    }
    this.stop();
    this._fire();
    this._fired = true;
  },
  fired: function fired() {
    return this._fired;
  }
});
var activeFeedback;
var FeedbackEmitter = _emitter.default.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, _common.noop);
    this._inactive = new FeedbackEvent(0, _common.noop);
  },
  configure: function configure(data, eventName) {
    switch (eventName) {
      case ACTIVE_EVENT_NAME:
        data.activeTimeout = data.timeout;
        break;
      case INACTIVE_EVENT_NAME:
        data.inactiveTimeout = data.timeout;
        break;
    }
    this.callBase(data);
  },
  start: function start(e) {
    if (activeFeedback) {
      var activeChildExists = (0, _dom.contains)(this.getElement().get(0), activeFeedback.getElement().get(0));
      var childJustActivated = !activeFeedback._active.fired();
      if (activeChildExists && childJustActivated) {
        this._cancel();
        return;
      }
      activeFeedback._inactive.force();
    }
    activeFeedback = this;
    this._initEvents(e);
    this._active.start();
  },
  _initEvents: function _initEvents(e) {
    var that = this;
    var eventTarget = this._getEmitterTarget(e);
    var mouseEvent = (0, _index.isMouseEvent)(e);
    var isSimulator = _devices.default.isSimulator();
    var deferFeedback = isSimulator || !mouseEvent;
    var activeTimeout = (0, _common.ensureDefined)(this.activeTimeout, ACTIVE_TIMEOUT);
    var inactiveTimeout = (0, _common.ensureDefined)(this.inactiveTimeout, INACTIVE_TIMEOUT);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, function () {
      that._fireEvent(ACTIVE_EVENT_NAME, e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, function () {
      that._fireEvent(INACTIVE_EVENT_NAME, e, {
        target: eventTarget
      });
      activeFeedback = null;
    });
  },
  cancel: function cancel(e) {
    this.end(e);
  },
  end: function end(e) {
    var skipTimers = e.type !== _pointer.default.up;
    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }
    this._inactive.start();
    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose: function dispose() {
    this._active.stop();
    this._inactive.stop();
    if (activeFeedback === this) {
      activeFeedback = null;
    }
    this.callBase();
  },
  lockInactive: function lockInactive() {
    this._active.force();
    this._inactive.stop();
    activeFeedback = null;
    this._cancel();
    return this._inactive.force.bind(this._inactive);
  }
});
FeedbackEmitter.lock = function (deferred) {
  var lockInactive = activeFeedback ? activeFeedback.lockInactive() : _common.noop;
  deferred.done(lockInactive);
};
(0, _emitter_registrator.default)({
  emitter: FeedbackEmitter,
  events: [ACTIVE_EVENT_NAME, INACTIVE_EVENT_NAME]
});
var lock = FeedbackEmitter.lock;
exports.lock = lock;

/***/ }),

/***/ 31391:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _extend = __webpack_require__(13306);
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var Emitter = _class.default.inherit({
  ctor: function ctor(element) {
    this._$element = (0, _renderer.default)(element);
    this._cancelCallback = (0, _callbacks.default)();
    this._acceptCallback = (0, _callbacks.default)();
  },
  getElement: function getElement() {
    return this._$element;
  },
  validate: function validate(e) {
    return !(0, _index.isDxMouseWheelEvent)(e);
  },
  validatePointers: function validatePointers(e) {
    return (0, _index.hasTouches)(e) === 1;
  },
  allowInterruptionByMouseWheel: function allowInterruptionByMouseWheel() {
    return true;
  },
  configure: function configure(data) {
    (0, _extend.extend)(this, data);
  },
  addCancelCallback: function addCancelCallback(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback: function removeCancelCallback() {
    this._cancelCallback.empty();
  },
  _cancel: function _cancel(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback: function addAcceptCallback(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback: function removeAcceptCallback() {
    this._acceptCallback.empty();
  },
  _accept: function _accept(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept: function _requestAccept(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept: function _forgetAccept() {
    this._accept(this._acceptRequestEvent);
    this._acceptRequestEvent = null;
  },
  start: _common.noop,
  move: _common.noop,
  end: _common.noop,
  cancel: _common.noop,
  reset: function reset() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent: function _fireEvent(eventName, e, params) {
    var eventData = (0, _extend.extend)({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = (0, _index.fireEvent)(eventData);
    if (e.cancel) {
      this._cancel(e);
    }
    return e;
  },
  _getEmitterTarget: function _getEmitterTarget(e) {
    return (this.delegateSelector ? (0, _renderer.default)(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: _common.noop
});
var _default = Emitter;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82495:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _element_data = __webpack_require__(97906);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _wheel = __webpack_require__(765);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var MANAGER_EVENT = 'dxEventManager';
var EMITTER_DATA = 'dxEmitter';
var EventManager = _class.default.inherit({
  ctor: function ctor() {
    this._attachHandlers();
    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers: function _attachHandlers() {
    _ready_callbacks.default.add(function () {
      var document = _dom_adapter.default.getDocument();
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_pointer.default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)([_pointer.default.up, _pointer.default.cancel].join(' '), MANAGER_EVENT), this._pointerUpHandler.bind(this));
      _events_engine.default.subscribeGlobal(document, (0, _index.addNamespace)(_wheel.name, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    }.bind(this));
  },
  _eachEmitter: function _eachEmitter(callback) {
    var activeEmitters = this._activeEmitters || [];
    var i = 0;
    while (activeEmitters.length > i) {
      var emitter = activeEmitters[i];
      if (callback(emitter) === false) {
        break;
      }
      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters: function _applyToEmitters(method, arg) {
    this._eachEmitter(function (emitter) {
      emitter[method].call(emitter, arg);
    });
  },
  reset: function reset() {
    this._eachEmitter(this._proxiedCancelHandler);
    this._activeEmitters = [];
  },
  resetEmitter: function resetEmitter(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler: function _pointerDownHandler(e) {
    if ((0, _index.isMouseEvent)(e) && e.which > 1) {
      return;
    }
    this._updateEmitters(e);
  },
  _updateEmitters: function _updateEmitters(e) {
    if (!this._isSetChanged(e)) {
      return;
    }
    this._cleanEmitters(e);
    this._fetchEmitters(e);
  },
  _isSetChanged: function _isSetChanged(e) {
    var currentSet = this._closestEmitter(e);
    var previousSet = this._emittersSet || [];
    var setChanged = currentSet.length !== previousSet.length;
    (0, _iterator.each)(currentSet, function (index, emitter) {
      setChanged = setChanged || previousSet[index] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter: function _closestEmitter(e) {
    var that = this;
    var result = [];
    var $element = (0, _renderer.default)(e.target);
    function handleEmitter(_, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result.push(emitter);
      }
    }
    while ($element.length) {
      var emitters = (0, _element_data.data)($element.get(0), EMITTER_DATA) || [];
      (0, _iterator.each)(emitters, handleEmitter);
      $element = $element.parent();
    }
    return result;
  },
  _acceptHandler: function _acceptHandler(acceptedEmitter, e) {
    var that = this;
    this._eachEmitter(function (emitter) {
      if (emitter !== acceptedEmitter) {
        that._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler: function _cancelHandler(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter: function _cancelEmitter(emitter, e) {
    var activeEmitters = this._activeEmitters;
    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }
    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    var emitterIndex = activeEmitters.indexOf(emitter);
    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters: function _cleanEmitters(e) {
    this._applyToEmitters('end', e);
    this.reset(e);
  },
  _fetchEmitters: function _fetchEmitters(e) {
    this._activeEmitters = this._emittersSet.slice();
    this._applyToEmitters('start', e);
  },
  _pointerMoveHandler: function _pointerMoveHandler(e) {
    this._applyToEmitters('move', e);
  },
  _pointerUpHandler: function _pointerUpHandler(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler: function _mouseWheelHandler(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }
    e.pointers = [null];
    this._pointerDownHandler(e);
    this._adjustWheelEvent(e);
    this._pointerMoveHandler(e);
    e.pointers = [];
    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel: function _allowInterruptionByMouseWheel() {
    var allowInterruption = true;
    this._eachEmitter(function (emitter) {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });
    return allowInterruption;
  },
  _adjustWheelEvent: function _adjustWheelEvent(e) {
    var closestGestureEmitter = null;
    this._eachEmitter(function (emitter) {
      if (!emitter.gesture) {
        return;
      }
      var direction = emitter.getDirection(e);
      if (direction !== 'horizontal' && !e.shiftKey || direction !== 'vertical' && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });
    if (!closestGestureEmitter) {
      return;
    }
    var direction = closestGestureEmitter.getDirection(e);
    var verticalGestureDirection = direction === 'both' && !e.shiftKey || direction === 'vertical';
    var prop = verticalGestureDirection ? 'pageY' : 'pageX';
    e[prop] += e.delta;
  },
  isActive: function isActive(element) {
    var result = false;
    this._eachEmitter(function (emitter) {
      result = result || emitter.getElement().is(element);
    });
    return result;
  }
});
var eventManager = new EventManager();
var EMITTER_SUBSCRIPTION_DATA = 'dxEmitterSubscription';
var registerEmitter = function registerEmitter(emitterConfig) {
  var emitterClass = emitterConfig.emitter;
  var emitterName = emitterConfig.events[0];
  var emitterEvents = emitterConfig.events;
  (0, _iterator.each)(emitterEvents, function (_, eventName) {
    (0, _event_registrator.default)(eventName, {
      noBubble: !emitterConfig.bubble,
      setup: function setup(element) {
        var subscriptions = (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA) || {};
        var emitters = (0, _element_data.data)(element, EMITTER_DATA) || {};
        var emitter = emitters[emitterName] || new emitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        (0, _element_data.data)(element, EMITTER_DATA, emitters);
        (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA, subscriptions);
      },
      add: function add(element, handleObj) {
        var emitters = (0, _element_data.data)(element, EMITTER_DATA);
        var emitter = emitters[emitterName];
        emitter.configure((0, _extend.extend)({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown: function teardown(element) {
        var subscriptions = (0, _element_data.data)(element, EMITTER_SUBSCRIPTION_DATA);
        var emitters = (0, _element_data.data)(element, EMITTER_DATA);
        var emitter = emitters[emitterName];
        delete subscriptions[eventName];
        var disposeEmitter = true;
        (0, _iterator.each)(emitterEvents, function (_, eventName) {
          disposeEmitter = disposeEmitter && !subscriptions[eventName];
          return disposeEmitter;
        });
        if (disposeEmitter) {
          if (eventManager.isActive(element)) {
            eventManager.resetEmitter(emitter);
          }
          emitter && emitter.dispose();
          delete emitters[emitterName];
        }
      }
    });
  });
};
var _default = registerEmitter;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 85788:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var registerEvent = function registerEvent(name, eventObject) {
  var strategy = {};
  if ('noBubble' in eventObject) {
    strategy.noBubble = eventObject.noBubble;
  }
  if ('bindType' in eventObject) {
    strategy.bindType = eventObject.bindType;
  }
  if ('delegateType' in eventObject) {
    strategy.delegateType = eventObject.delegateType;
  }
  (0, _iterator.each)(['setup', 'teardown', 'add', 'remove', 'trigger', 'handle', '_default', 'dispose'], function (_, methodName) {
    if (!eventObject[methodName]) {
      return;
    }
    strategy[methodName] = function () {
      var args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });
  _event_registrator_callbacks.default.fire(name, strategy);
};
registerEvent.callbacks = _event_registrator_callbacks.default;
var _default = registerEvent;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 94553:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _memorized_callbacks = _interopRequireDefault(__webpack_require__(83358));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = new _memorized_callbacks.default();
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 55994:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
var _extend = __webpack_require__(13306);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _type = __webpack_require__(35922);
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _hook_touch_props = _interopRequireDefault(__webpack_require__(2418));
var _call_once = _interopRequireDefault(__webpack_require__(39618));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var window = (0, _window.getWindow)();
var EMPTY_EVENT_NAME = 'dxEmptyEventType';
var NATIVE_EVENTS_TO_SUBSCRIBE = {
  'mouseenter': 'mouseover',
  'mouseleave': 'mouseout',
  'pointerenter': 'pointerover',
  'pointerleave': 'pointerout'
};
var NATIVE_EVENTS_TO_TRIGGER = {
  'focusin': 'focus',
  'focusout': 'blur'
};
var NO_BUBBLE_EVENTS = ['blur', 'focus', 'load'];
var forcePassiveFalseEventNames = ['touchmove', 'wheel', 'mousewheel', 'touchstart'];
var EVENT_PROPERTIES = ['target', 'relatedTarget', 'delegateTarget', 'altKey', 'bubbles', 'cancelable', 'changedTouches', 'ctrlKey', 'detail', 'eventPhase', 'metaKey', 'shiftKey', 'view', 'char', 'code', 'charCode', 'key', 'keyCode', 'button', 'buttons', 'offsetX', 'offsetY', 'pointerId', 'pointerType', 'targetTouches', 'toElement', 'touches'];
function matchesSafe(target, selector) {
  return !(0, _type.isWindow)(target) && target.nodeName !== '#document' && _dom_adapter.default.elementMatches(target, selector);
}
var elementDataMap = new WeakMap();
var guid = 0;
var skipEvent;
var special = function () {
  var specialData = {};
  _event_registrator_callbacks.default.add(function (eventName, eventObject) {
    specialData[eventName] = eventObject;
  });
  return {
    getField: function getField(eventName, field) {
      return specialData[eventName] && specialData[eventName][field];
    },
    callMethod: function callMethod(eventName, methodName, context, args) {
      return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context, args);
    }
  };
}();
var eventsEngine = (0, _dependency_injector.default)({
  on: getHandler(normalizeOnArguments(iterate(function (element, eventName, selector, data, handler) {
    var handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data);
  }))),
  one: getHandler(normalizeOnArguments(function (element, eventName, selector, data, handler) {
    var oneTimeHandler = function oneTimeHandler() {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    };
    eventsEngine.on(element, eventName, selector, data, oneTimeHandler);
  })),
  off: getHandler(normalizeOffArguments(iterate(function (element, eventName, selector, handler) {
    var handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments(function (element, event, extraParameters) {
    var eventName = event.type;
    var handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, 'trigger', element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    var noBubble = special.getField(eventName, 'noBubble') || event.isPropagationStopped() || NO_BUBBLE_EVENTS.indexOf(eventName) !== -1;
    if (!noBubble) {
      var parents = [];
      var getParents = function getParents(element) {
        var _element$parentNode;
        var parent = (_element$parentNode = element.parentNode) !== null && _element$parentNode !== void 0 ? _element$parentNode : element.host;
        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      };
      getParents(element);
      parents.push(window);
      var i = 0;
      while (parents[i] && !event.isPropagationStopped()) {
        var parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers((0, _extend.extend)(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }
    if (element.nodeType || (0, _type.isWindow)(element)) {
      special.callMethod(eventName, '_default', element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments(function (element, event, extraParameters) {
    var handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});
function applyForEach(args, method) {
  var element = args[0];
  if (!element) {
    return;
  }
  if (_dom_adapter.default.isNode(element) || (0, _type.isWindow)(element)) {
    method.apply(eventsEngine, args);
  } else if (!(0, _type.isString)(element) && 'length' in element) {
    var itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, function (itemElement) {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw _errors.default.Error('E0025');
  }
}
function getHandler(method) {
  return function () {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  var isSupported = false;
  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        isSupported = true;
        return true;
      }
    });
    window.addEventListener('test', null, options);
  } catch (e) {}
  return isSupported;
}
var passiveEventHandlersSupported = (0, _call_once.default)(detectPassiveEventHandlersSupport);
var contains = function contains(container, element) {
  if ((0, _type.isWindow)(container)) {
    return contains(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
function getHandlersController(element, eventName) {
  var elementData = elementDataMap.get(element);
  eventName = eventName || '';
  var eventNameParts = eventName.split('.');
  var namespaces = eventNameParts.slice(1);
  var eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  var eventData = elementData[eventName];
  return {
    addHandler: function addHandler(handler, selector, data) {
      var callHandler = function callHandler(e, extraParameters) {
        var handlerArgs = [e];
        var target = e.currentTarget;
        var relatedTarget = e.relatedTarget;
        var secondaryTargetIsInside;
        var result;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }
        if (extraParameters !== undefined) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, 'handle', element, [e, data]);
        if (!secondaryTargetIsInside) {
          result = handler.apply(target, handlerArgs);
        }
        if (result === false) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      var wrappedHandler = function wrappedHandler(e, extraParameters) {
        if (skipEvent && e.type === skipEvent) {
          return;
        }
        e.data = data;
        e.delegateTarget = element;
        if (selector) {
          var currentTarget = e.target;
          while (currentTarget && currentTarget !== element) {
            if (matchesSafe(currentTarget, selector)) {
              e.currentTarget = currentTarget;
              callHandler(e, extraParameters);
            }
            currentTarget = currentTarget.parentNode;
          }
        } else {
          e.currentTarget = e.delegateTarget || e.target;
          callHandler(e, extraParameters);
        }
      };
      var handleObject = {
        handler: handler,
        wrappedHandler: wrappedHandler,
        selector: selector,
        type: eventName,
        data: data,
        namespace: namespaces.join('.'),
        namespaces: namespaces,
        guid: ++guid
      };
      eventData.handleObjects.push(handleObject);
      var firstHandlerForTheType = eventData.handleObjects.length === 1;
      var shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      var nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, 'setup', element, [data, namespaces, handler]);
      }
      if (shouldAddNativeListener) {
        eventData.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {
          nativeListenerOptions = {
            passive: false
          };
        }
        eventData.removeListener = _dom_adapter.default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, 'add', element, [handleObject]);
    },
    removeHandler: function removeHandler(handler, selector) {
      var removeByEventName = function removeByEventName(eventName) {
        var eventData = elementData[eventName];
        if (!eventData.handleObjects.length) {
          delete elementData[eventName];
          return;
        }
        var removedHandler;
        eventData.handleObjects = eventData.handleObjects.filter(function (handleObject) {
          var skip = namespaces.length && !isSubset(handleObject.namespaces, namespaces) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName, 'remove', element, [handleObject]);
          }
          return skip;
        });
        var lastHandlerForTheType = !eventData.handleObjects.length;
        var shouldRemoveNativeListener = lastHandlerForTheType && eventName !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName, 'teardown', element, [namespaces, removedHandler]);
          if (eventData.nativeHandler) {
            eventData.removeListener();
          }
          delete elementData[eventName];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (var name in elementData) {
          removeByEventName(name);
        }
      }
      var elementDataIsEmpty = Object.keys(elementData).length === 0;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers: function callHandlers(event, extraParameters) {
      var forceStop = false;
      var handleCallback = function handleCallback(handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces.length || isSubset(handleObject.namespaces, namespaces)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData.handleObjects.forEach(handleCallback);
      if (namespaces.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function (event, extraParameters) {
    var handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (var i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) return false;
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function (element, eventName, selector, data, handler) {
    if (!handler) {
      handler = data;
      data = undefined;
    }
    if (typeof selector !== 'string') {
      data = selector;
      selector = undefined;
    }
    if (!handler && typeof eventName === 'string') {
      handler = data || selector;
      selector = undefined;
      data = undefined;
    }
    callback(element, eventName, selector, data, handler);
  };
}
function normalizeOffArguments(callback) {
  return function (element, eventName, selector, handler) {
    if (typeof selector === 'function') {
      handler = selector;
      selector = undefined;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function (element, src, extraParameters) {
    if (typeof src === 'string') {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  eventsEngine.Event = function (src, config) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config);
    }
    if (!src) {
      src = {};
    }
    if (typeof src === 'string') {
      src = {
        type: src
      };
    }
    if (!config) {
      config = {};
    }
    callback.call(this, src, config);
  };
  _extends(eventsEngine.Event.prototype, {
    _propagationStopped: false,
    _immediatePropagationStopped: false,
    _defaultPrevented: false,
    isPropagationStopped: function isPropagationStopped() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation: function stopPropagation() {
      this._propagationStopped = true;
      this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped: function isImmediatePropagationStopped() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      this.stopPropagation();
      this._immediatePropagationStopped = true;
      this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented: function isDefaultPrevented() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault: function preventDefault() {
      this._defaultPrevented = true;
      this.originalEvent && this.originalEvent.preventDefault();
    }
  });
  return eventsEngine.Event;
}
function iterate(callback) {
  var iterateEventNames = function iterateEventNames(element, eventName) {
    if (eventName && eventName.indexOf(' ') > -1) {
      var args = Array.prototype.slice.call(arguments, 0);
      eventName.split(' ').forEach(function (eventName) {
        args[1] = eventName;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function (element, eventName) {
    if (typeof eventName === 'object') {
      var args = Array.prototype.slice.call(arguments, 0);
      for (var name in eventName) {
        args[1] = name;
        args[args.length - 1] = eventName[name];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  var nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  var isLinkClickEvent = function isLinkClickEvent(eventName, element) {
    return eventName === 'click' && element.localName === 'a';
  };
  if (isLinkClickEvent(eventName, element)) return;
  if ((0, _type.isFunction)(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = undefined;
  }
}
function calculateWhich(event) {
  var setForMouseEvent = function setForMouseEvent(event) {
    var mouseEventRegex = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
    return !event.which && event.button !== undefined && mouseEventRegex.test(event.type);
  };
  var setForKeyEvent = function setForKeyEvent(event) {
    return event.which == null && event.type.indexOf('key') === 0;
  };
  if (setForKeyEvent(event)) {
    return event.charCode != null ? event.charCode : event.keyCode;
  }
  if (setForMouseEvent(event)) {
    var whichByButton = {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    };
    return whichByButton[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
initEvent(normalizeEventArguments(function (src, config) {
  var _src$view;
  var srcIsEvent = src instanceof eventsEngine.Event || (0, _window.hasWindow)() && src instanceof window.Event || ((_src$view = src.view) === null || _src$view === void 0 ? void 0 : _src$view.Event) && src instanceof src.view.Event;
  if (srcIsEvent) {
    this.originalEvent = src;
    this.type = src.type;
    this.currentTarget = undefined;
    if (Object.prototype.hasOwnProperty.call(src, 'isTrusted')) {
      this.isTrusted = src.isTrusted;
    }
    this.timeStamp = src.timeStamp || Date.now();
  } else {
    _extends(this, src);
  }
  addProperty('which', calculateWhich, this);
  if (src.type.indexOf('touch') === 0) {
    delete config.pageX;
    delete config.pageY;
  }
  _extends(this, config);
  this.guid = ++guid;
}));
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get: function get() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set: function set(value) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value
      });
    }
  });
}
EVENT_PROPERTIES.forEach(function (prop) {
  return addProperty(prop, function (event) {
    return event[prop];
  });
});
(0, _hook_touch_props.default)(addProperty);
var beforeSetStrategy = (0, _callbacks.default)();
var afterSetStrategy = (0, _callbacks.default)();
eventsEngine.set = function (engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};
eventsEngine.subscribeGlobal = function () {
  applyForEach(arguments, normalizeOnArguments(function () {
    var args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function () {
      var offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function () {
      eventsEngine.on.apply(this, args);
    });
  }));
};
eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var _default = eventsEngine;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 2418:
/***/ (function(module, exports) {



exports["default"] = _default;
var touchPropsToHook = ['pageX', 'pageY', 'screenX', 'screenY', 'clientX', 'clientY'];
var touchPropHook = function touchPropHook(name, event) {
  if (event[name] && !event.touches || !event.touches) {
    return event[name];
  }
  var touches = event.touches.length ? event.touches : event.changedTouches;
  if (!touches.length) {
    return;
  }
  return touches[0][name];
};
function _default(callback) {
  touchPropsToHook.forEach(function (name) {
    callback(name, function (event) {
      return touchPropHook(name, event);
    });
  }, this);
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 51661:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var COMPOSITION_START_EVENT = 'compositionstart';
var COMPOSITION_END_EVENT = 'compositionend';
var KEYDOWN_EVENT = 'keydown';
var NAMESPACE = 'KeyboardProcessor';
var createKeyDownOptions = function createKeyDownOptions(e) {
  return {
    keyName: (0, _index.normalizeKeyName)(e),
    key: e.key,
    code: e.code,
    ctrl: e.ctrlKey,
    location: e.location,
    metaKey: e.metaKey,
    shift: e.shiftKey,
    alt: e.altKey,
    which: e.which,
    originalEvent: e
  };
};
var KeyboardProcessor = _class.default.inherit({
  _keydown: (0, _index.addNamespace)(KEYDOWN_EVENT, NAMESPACE),
  _compositionStart: (0, _index.addNamespace)(COMPOSITION_START_EVENT, NAMESPACE),
  _compositionEnd: (0, _index.addNamespace)(COMPOSITION_END_EVENT, NAMESPACE),
  ctor: function ctor(options) {
    var _this = this;
    options = options || {};
    if (options.element) {
      this._element = (0, _renderer.default)(options.element);
    }
    if (options.focusTarget) {
      this._focusTarget = options.focusTarget;
    }
    this._handler = options.handler;
    if (this._element) {
      this._processFunction = function (e) {
        var focusTargets = (0, _renderer.default)(_this._focusTarget).toArray();
        var isNotFocusTarget = _this._focusTarget && _this._focusTarget !== e.target && !focusTargets.includes(e.target);
        var shouldSkipProcessing = _this._isComposingJustFinished && e.which === 229 || _this._isComposing || isNotFocusTarget;
        _this._isComposingJustFinished = false;
        if (!shouldSkipProcessing) {
          _this.process(e);
        }
      };
      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
      _events_engine.default.on(this._element, this._keydown, this._processFunction);
      _events_engine.default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
      _events_engine.default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose: function dispose() {
    if (this._element) {
      _events_engine.default.off(this._element, this._keydown, this._processFunction);
      _events_engine.default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
      _events_engine.default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
    this._element = undefined;
    this._handler = undefined;
  },
  process: function process(e) {
    this._handler(createKeyDownOptions(e));
  },
  toggleProcessing: function toggleProcessing(_ref) {
    var type = _ref.type;
    this._isComposing = type === COMPOSITION_START_EVENT;
    this._isComposingJustFinished = !this._isComposing;
  }
});
KeyboardProcessor.createKeyDownOptions = createKeyDownOptions;
var _default = KeyboardProcessor;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 765:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.name = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var EVENT_NAME = 'dxmousewheel';
exports.name = EVENT_NAME;
var EVENT_NAMESPACE = 'dxWheel';
var NATIVE_EVENT_NAME = 'wheel';
var PIXEL_MODE = 0;
var DELTA_MUTLIPLIER = 30;
var wheel = {
  setup: function setup(element) {
    var $element = (0, _renderer.default)(element);
    _events_engine.default.on($element, (0, _index.addNamespace)(NATIVE_EVENT_NAME, EVENT_NAMESPACE), wheel._wheelHandler.bind(wheel));
  },
  teardown: function teardown(element) {
    _events_engine.default.off(element, ".".concat(EVENT_NAMESPACE));
  },
  _wheelHandler: function _wheelHandler(e) {
    var _e$originalEvent = e.originalEvent,
      deltaMode = _e$originalEvent.deltaMode,
      deltaY = _e$originalEvent.deltaY,
      deltaX = _e$originalEvent.deltaX,
      deltaZ = _e$originalEvent.deltaZ;
    (0, _index.fireEvent)({
      type: EVENT_NAME,
      originalEvent: e,
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX,
      deltaY,
      deltaZ,
      deltaMode,
      pointerType: 'mouse'
    });
    e.stopPropagation();
  },
  _normalizeDelta(delta) {
    var deltaMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIXEL_MODE;
    if (deltaMode === PIXEL_MODE) {
      return -delta;
    } else {
      // Use multiplier to get rough delta value in px for the LINE or PAGE mode
      // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460
      return -DELTA_MUTLIPLIER * delta;
    }
  }
};
(0, _event_registrator.default)(EVENT_NAME, wheel);

/***/ }),

/***/ 85272:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.name = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _dom = __webpack_require__(3532);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _click = __webpack_require__(95429);
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DBLCLICK_EVENT_NAME = 'dxdblclick';
exports.name = DBLCLICK_EVENT_NAME;
var DBLCLICK_NAMESPACE = 'dxDblClick';
var NAMESPACED_CLICK_EVENT = (0, _index.addNamespace)(_click.name, DBLCLICK_NAMESPACE);
var DBLCLICK_TIMEOUT = 300;
var DblClick = _class.default.inherit({
  ctor: function ctor() {
    this._handlerCount = 0;
    this._forgetLastClick();
  },
  _forgetLastClick: function _forgetLastClick() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -DBLCLICK_TIMEOUT;
  },
  add: function add() {
    if (this._handlerCount <= 0) {
      _events_engine.default.on(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }
    this._handlerCount++;
  },
  _clickHandler: function _clickHandler(e) {
    var timeStamp = e.timeStamp || Date.now();
    var timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
    // NOTE: jQuery sets `timeStamp = Date.now()` for the triggered events, but
    // in the real event timeStamp is the number of milliseconds elapsed from the
    // beginning of the current document's lifetime till the event was created
    // (https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp).
    var isSimulated = timeBetweenClicks < 0;
    var isDouble = !isSimulated && timeBetweenClicks < DBLCLICK_TIMEOUT;
    if (isDouble) {
      (0, _index.fireEvent)({
        type: DBLCLICK_EVENT_NAME,
        target: (0, _dom.closestCommonParent)(this._firstClickTarget, e.target),
        originalEvent: e
      });
      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
    }
  },
  remove: function remove() {
    this._handlerCount--;
    if (this._handlerCount <= 0) {
      this._forgetLastClick();
      _events_engine.default.off(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT);
    }
  }
});
(0, _event_registrator.default)(DBLCLICK_EVENT_NAME, new DblClick());

/***/ }),

/***/ 23174:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.start = exports.move = exports.leave = exports.enter = exports.end = exports.drop = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _element_data = __webpack_require__(97906);
var _array = __webpack_require__(89386);
var iteratorUtils = _interopRequireWildcard(__webpack_require__(95479));
var _dom = __webpack_require__(3532);
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _index = __webpack_require__(39611);
var _emitter = _interopRequireDefault(__webpack_require__(98621));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DRAG_START_EVENT = 'dxdragstart';
exports.start = DRAG_START_EVENT;
var DRAG_EVENT = 'dxdrag';
exports.move = DRAG_EVENT;
var DRAG_END_EVENT = 'dxdragend';
exports.end = DRAG_END_EVENT;
var DRAG_ENTER_EVENT = 'dxdragenter';
exports.enter = DRAG_ENTER_EVENT;
var DRAG_LEAVE_EVENT = 'dxdragleave';
exports.leave = DRAG_LEAVE_EVENT;
var DROP_EVENT = 'dxdrop';
exports.drop = DROP_EVENT;
var DX_DRAG_EVENTS_COUNT_KEY = 'dxDragEventsCount';
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
  setup: function setup(element, data) {
    var knownDropTarget = knownDropTargets.includes(element);
    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data || {});
    }
  },
  add: function add(element, handleObj) {
    var index = knownDropTargets.indexOf(element);
    this.updateEventsCounter(element, handleObj.type, 1);
    var selector = handleObj.selector;
    if (!knownDropTargetSelectors[index].includes(selector)) {
      knownDropTargetSelectors[index].push(selector);
    }
  },
  updateEventsCounter: function updateEventsCounter(element, event, value) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
      var eventsCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;
      (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value));
    }
  },
  remove: function remove(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown: function teardown(element) {
    var handlersCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY);
    if (!handlersCount) {
      var index = knownDropTargets.indexOf(element);
      knownDropTargets.splice(index, 1);
      knownDropTargetSelectors.splice(index, 1);
      knownDropTargetConfigs.splice(index, 1);
      (0, _element_data.removeData)(element, DX_DRAG_EVENTS_COUNT_KEY);
    }
  }
};

/**
* @name UI Events.dxdragenter
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 draggingElement:Element
* @module events/drag
*/
/**
* @name UI Events.dxdrop
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 draggingElement:Element
* @module events/drag
*/
/**
* @name UI Events.dxdragleave
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 draggingElement:Element
* @module events/drag
*/

(0, _event_registrator.default)(DRAG_ENTER_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DRAG_LEAVE_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function getItemDelegatedTargets($element) {
  var dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  var dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter(function (selector) {
    return selector;
  });
  var $delegatedTargets = $element.find(dropTargetSelectors.join(', '));
  if (knownDropTargetSelectors[dropTargetIndex].includes(undefined)) {
    $delegatedTargets = $delegatedTargets.add($element);
  }
  return $delegatedTargets;
};
var getItemConfig = function getItemConfig($element) {
  var dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  return knownDropTargetConfigs[dropTargetIndex];
};
var getItemPosition = function getItemPosition(dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  } else {
    return $element.offset();
  }
};
var getItemSize = function getItemSize(dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }
  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};
var DragEmitter = _emitter.default.inherit({
  ctor: function ctor(element) {
    this.callBase(element);
    this.direction = 'both';
  },
  _init: function _init(e) {
    this._initEvent = e;
  },
  _start: function _start(e) {
    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    if (e.targetElements || e.targetElements === null) {
      var dropTargets = (0, _array.wrapToArray)(e.targetElements || []);
      this._dropTargets = iteratorUtils.map(dropTargets, function (element) {
        return (0, _renderer.default)(element).get(0);
      });
    } else {
      this._dropTargets = knownDropTargets;
    }
  },
  _move: function _move(e) {
    var eventData = (0, _index.eventData)(e);
    var dragOffset = this._calculateOffset(eventData);
    e = this._fireEvent(DRAG_EVENT, e, {
      offset: dragOffset
    });
    this._processDropTargets(e);
    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset: function _calculateOffset(eventData) {
    return {
      x: this._calculateXOffset(eventData),
      y: this._calculateYOffset(eventData)
    };
  },
  _calculateXOffset: function _calculateXOffset(eventData) {
    if (this.direction !== 'vertical') {
      var offset = eventData.x - this._startEventData.x;
      return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset: function _calculateYOffset(eventData) {
    if (this.direction !== 'horizontal') {
      var offset = eventData.y - this._startEventData.y;
      return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset: function _fitOffset(offset, minOffset, maxOffset) {
    if (minOffset != null) {
      offset = Math.max(offset, -minOffset);
    }
    if (maxOffset != null) {
      offset = Math.min(offset, maxOffset);
    }
    return offset;
  },
  _processDropTargets: function _processDropTargets(e) {
    var target = this._findDropTarget(e);
    var sameTarget = target === this._currentDropTarget;
    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
      this._currentDropTarget = target;
      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent: function _fireDropTargetEvent(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }
    var eventData = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    (0, _index.fireEvent)(eventData);
  },
  _findDropTarget: function _findDropTarget(e) {
    var that = this;
    var result;
    iteratorUtils.each(knownDropTargets, function (_, target) {
      if (!that._checkDropTargetActive(target)) {
        return;
      }
      var $target = (0, _renderer.default)(target);
      iteratorUtils.each(getItemDelegatedTargets($target), function (_, delegatedTarget) {
        var $delegatedTarget = (0, _renderer.default)(delegatedTarget);
        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, (0, _renderer.default)(result), e)) {
          result = delegatedTarget;
        }
      });
    });
    return result;
  },
  _checkDropTargetActive: function _checkDropTargetActive(target) {
    var active = false;
    iteratorUtils.each(this._dropTargets, function (_, activeTarget) {
      active = active || activeTarget === target || (0, _dom.contains)(activeTarget, target);
      return !active;
    });
    return active;
  },
  _checkDropTarget: function _checkDropTarget(config, $target, $prevTarget, e) {
    var isDraggingElement = $target.get(0) === (0, _renderer.default)(e.target).get(0);
    if (isDraggingElement) {
      return false;
    }
    var targetPosition = getItemPosition(config, $target);
    if (e.pageX < targetPosition.left) {
      return false;
    }
    if (e.pageY < targetPosition.top) {
      return false;
    }
    var targetSize = getItemSize(config, $target);
    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }
    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }
    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }
    if (config.checkDropTarget && !config.checkDropTarget($target, e)) {
      return false;
    }
    return $target;
  },
  _end: function _end(e) {
    var eventData = (0, _index.eventData)(e);
    this._fireEvent(DRAG_END_EVENT, e, {
      offset: this._calculateOffset(eventData)
    });
    this._fireDropTargetEvent(e, DROP_EVENT);
    delete this._currentDropTarget;
  }
});

/**
 * @name UI Events.dxdragstart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/drag
*/
/**
  * @name UI Events.dxdrag
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 cancel:boolean
  * @module events/drag
*/
/**
  * @name UI Events.dxdragend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 cancel:boolean
  * @module events/drag
*/

(0, _emitter_registrator.default)({
  emitter: DragEmitter,
  events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
});

/***/ }),

/***/ 98621:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _style = __webpack_require__(80968);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _dom = __webpack_require__(3532);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _math = __webpack_require__(60810);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _index = __webpack_require__(39611);
var _emitter = _interopRequireDefault(__webpack_require__(31391));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ready = _ready_callbacks.default.add;
var abs = Math.abs;
var SLEEP = 0;
var INITED = 1;
var STARTED = 2;
var TOUCH_BOUNDARY = 10;
var IMMEDIATE_TOUCH_BOUNDARY = 0;
var IMMEDIATE_TIMEOUT = 180;
var supportPointerEvents = function supportPointerEvents() {
  return (0, _style.styleProp)('pointer-events');
};
var setGestureCover = (0, _call_once.default)(function () {
  var GESTURE_COVER_CLASS = 'dx-gesture-cover';
  var isDesktop = _devices.default.real().deviceType === 'desktop';
  if (!supportPointerEvents() || !isDesktop) {
    return _common.noop;
  }
  var $cover = (0, _renderer.default)('<div>').addClass(GESTURE_COVER_CLASS).css('pointerEvents', 'none');
  _events_engine.default.subscribeGlobal($cover, 'dxmousewheel', function (e) {
    e.preventDefault();
  });
  ready(function () {
    $cover.appendTo('body');
  });
  return function (toggle, cursor) {
    $cover.css('pointerEvents', toggle ? 'all' : 'none');
    toggle && $cover.css('cursor', cursor);
  };
});
var gestureCover = function gestureCover(toggle, cursor) {
  var gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};
var GestureEmitter = _emitter.default.inherit({
  gesture: true,
  configure: function configure(data) {
    this.getElement().css('msTouchAction', data.immediate ? 'pinch-zoom' : '');
    this.callBase(data);
  },
  allowInterruptionByMouseWheel: function allowInterruptionByMouseWheel() {
    return this._stage !== STARTED;
  },
  getDirection: function getDirection() {
    return this.direction;
  },
  _cancel: function _cancel() {
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
    this._stage = SLEEP;
  },
  start: function start(e) {
    if (e._needSkipEvent || (0, _index.needSkipEvent)(e)) {
      this._cancel(e);
      return;
    }
    this._startEvent = (0, _index.createEvent)(e);
    this._startEventData = (0, _index.eventData)(e);
    this._stage = INITED;
    this._init(e);
    this._setupImmediateTimer();
  },
  _setupImmediateTimer: function _setupImmediateTimer() {
    var _this$immediateTimeou;
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;
    if (!this.immediate) {
      return;
    }
    if (this.immediateTimeout === 0) {
      this._immediateAccepted = true;
      return;
    }
    this._immediateTimer = setTimeout(function () {
      this._immediateAccepted = true;
    }.bind(this), (_this$immediateTimeou = this.immediateTimeout) !== null && _this$immediateTimeou !== void 0 ? _this$immediateTimeou : IMMEDIATE_TIMEOUT);
  },
  move: function move(e) {
    if (this._stage === INITED && this._directionConfirmed(e)) {
      this._stage = STARTED;
      this._resetActiveElement();
      this._toggleGestureCover(true);
      this._clearSelection(e);
      this._adjustStartEvent(e);
      this._start(this._startEvent);
      if (this._stage === SLEEP) {
        return;
      }
      this._requestAccept(e);
      this._move(e);
      this._forgetAccept();
    } else if (this._stage === STARTED) {
      this._clearSelection(e);
      this._move(e);
    }
  },
  _directionConfirmed: function _directionConfirmed(e) {
    var touchBoundary = this._getTouchBoundary(e);
    var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    var deltaX = abs(delta.x);
    var deltaY = abs(delta.y);
    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
    var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
    var direction = this.getDirection(e);
    var bothAccepted = direction === 'both' && (horizontalMove || verticalMove);
    var horizontalAccepted = direction === 'horizontal' && horizontalMove;
    var verticalAccepted = direction === 'vertical' && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove: function _validateMove(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary: function _getTouchBoundary(e) {
    return this.immediate || (0, _index.isDxMouseWheelEvent)(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY;
  },
  _adjustStartEvent: function _adjustStartEvent(e) {
    var touchBoundary = this._getTouchBoundary(e);
    var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    this._startEvent.pageX += (0, _math.sign)(delta.x) * touchBoundary;
    this._startEvent.pageY += (0, _math.sign)(delta.y) * touchBoundary;
  },
  _resetActiveElement: function _resetActiveElement() {
    if (_devices.default.real().platform === 'ios' && this.getElement().find(':focus').length) {
      (0, _dom.resetActiveElement)();
    }
  },
  _toggleGestureCover: function _toggleGestureCover(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl: function _toggleGestureCoverImpl(toggle) {
    var isStarted = this._stage === STARTED;
    if (isStarted) {
      gestureCover(toggle, this.getElement().css('cursor'));
    }
  },
  _clearSelection: function _clearSelection(e) {
    if ((0, _index.isDxMouseWheelEvent)(e) || (0, _index.isTouchEvent)(e)) {
      return;
    }
    (0, _dom.clearSelection)();
  },
  end: function end(e) {
    this._toggleGestureCover(false);
    if (this._stage === STARTED) {
      this._end(e);
    } else if (this._stage === INITED) {
      this._stop(e);
    }
    this._stage = SLEEP;
  },
  dispose: function dispose() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
  },
  _init: _common.noop,
  _start: _common.noop,
  _move: _common.noop,
  _stop: _common.noop,
  _end: _common.noop
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
GestureEmitter.touchBoundary = function (newBoundary) {
  if ((0, _type.isDefined)(newBoundary)) {
    TOUCH_BOUNDARY = newBoundary;
    return;
  }
  return TOUCH_BOUNDARY;
};
var _default = GestureEmitter;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 37334:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _index = __webpack_require__(39611);
var _emitter = _interopRequireDefault(__webpack_require__(98621));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
var _frame = __webpack_require__(90057);
var _devices = _interopRequireDefault(__webpack_require__(20530));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var abstract = _class.default.abstract;
var realDevice = _devices.default.real();
var SCROLL_EVENT = 'scroll';
var SCROLL_INIT_EVENT = 'dxscrollinit';
var SCROLL_START_EVENT = 'dxscrollstart';
var SCROLL_MOVE_EVENT = 'dxscroll';
var SCROLL_END_EVENT = 'dxscrollend';
var SCROLL_STOP_EVENT = 'dxscrollstop';
var SCROLL_CANCEL_EVENT = 'dxscrollcancel';
var Locker = _class.default.inherit(function () {
  var NAMESPACED_SCROLL_EVENT = (0, _index.addNamespace)(SCROLL_EVENT, 'dxScrollEmitter');
  return {
    ctor: function ctor(element) {
      var _this = this;
      this._element = element;
      this._locked = false;
      this._proxiedScroll = function (e) {
        if (!_this._disposed) {
          _this._scroll(e);
        }
      };
      _events_engine.default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract,
    check: function check(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose: function dispose() {
      this._disposed = true;
      _events_engine.default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
}());
var TimeoutLocker = Locker.inherit(function () {
  return {
    ctor: function ctor(element, timeout) {
      this.callBase(element);
      this._timeout = timeout;
    },
    _scroll: function _scroll() {
      this._prepare();
      this._forget();
    },
    _prepare: function _prepare() {
      if (this._timer) {
        this._clearTimer();
      }
      this._locked = true;
    },
    _clearTimer: function _clearTimer() {
      clearTimeout(this._timer);
      this._locked = false;
      this._timer = null;
    },
    _forget: function _forget() {
      var that = this;
      this._timer = setTimeout(function () {
        that._clearTimer();
      }, this._timeout);
    },
    dispose: function dispose() {
      this.callBase();
      this._clearTimer();
    }
  };
}());
var WheelLocker = TimeoutLocker.inherit(function () {
  var WHEEL_UNLOCK_TIMEOUT = 400;
  return {
    ctor: function ctor(element) {
      this.callBase(element, WHEEL_UNLOCK_TIMEOUT);
      this._lastWheelDirection = null;
    },
    check: function check(e, callback) {
      this._checkDirectionChanged(e);
      this.callBase(e, callback);
    },
    _checkDirectionChanged: function _checkDirectionChanged(e) {
      if (!(0, _index.isDxMouseWheelEvent)(e)) {
        this._lastWheelDirection = null;
        return;
      }
      var direction = e.shiftKey || false;
      var directionChange = this._lastWheelDirection !== null && direction !== this._lastWheelDirection;
      this._lastWheelDirection = direction;
      this._locked = this._locked && !directionChange;
    }
  };
}());
var PointerLocker = TimeoutLocker.inherit(function () {
  var POINTER_UNLOCK_TIMEOUT = 400;
  return {
    ctor: function ctor(element) {
      this.callBase(element, POINTER_UNLOCK_TIMEOUT);
    }
  };
}());
(function () {
  var isIos = realDevice.ios,
    isAndroid = realDevice.android;
  if (!(isIos || isAndroid)) {
    return;
  }
  PointerLocker = Locker.inherit(function () {
    return {
      _scroll: function _scroll() {
        this._locked = true;
        var that = this;
        (0, _frame.cancelAnimationFrame)(this._scrollFrame);
        this._scrollFrame = (0, _frame.requestAnimationFrame)(function () {
          that._locked = false;
        });
      },
      check: function check(e, callback) {
        (0, _frame.cancelAnimationFrame)(this._scrollFrame);
        (0, _frame.cancelAnimationFrame)(this._checkFrame);
        var that = this;
        var callBase = this.callBase;
        this._checkFrame = (0, _frame.requestAnimationFrame)(function () {
          callBase.call(that, e, callback);
          that._locked = false;
        });
      },
      dispose: function dispose() {
        this.callBase();
        (0, _frame.cancelAnimationFrame)(this._scrollFrame);
        (0, _frame.cancelAnimationFrame)(this._checkFrame);
      }
    };
  }());
})();
var ScrollEmitter = _emitter.default.inherit(function () {
  var INERTIA_TIMEOUT = 100;
  var VELOCITY_CALC_TIMEOUT = 200;
  var FRAME_DURATION = Math.round(1000 / 60);
  return {
    ctor: function ctor(element) {
      this.callBase.apply(this, arguments);
      this.direction = 'both';
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate: function validate() {
      return true;
    },
    configure: function configure(data) {
      if (data.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data.scrollTarget);
        this._wheelLocker = new WheelLocker(data.scrollTarget);
      }
      this.callBase(data);
    },
    _init: function _init(e) {
      this._wheelLocker.check(e, function () {
        if ((0, _index.isDxMouseWheelEvent)(e)) {
          this._accept(e);
        }
      }.bind(this));
      this._pointerLocker.check(e, function () {
        var skipCheck = this.isNative && (0, _index.isMouseEvent)(e);
        if (!(0, _index.isDxMouseWheelEvent)(e) && !skipCheck) {
          this._accept(e);
        }
      }.bind(this));
      this._fireEvent(SCROLL_INIT_EVENT, e);
      this._prevEventData = (0, _index.eventData)(e);
    },
    move: function move(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start: function _start(e) {
      this._savedEventData = (0, _index.eventData)(e);
      this._fireEvent(SCROLL_START_EVENT, e);
      this._prevEventData = (0, _index.eventData)(e);
    },
    _move: function _move(e) {
      var currentEventData = (0, _index.eventData)(e);
      this._fireEvent(SCROLL_MOVE_EVENT, e, {
        delta: (0, _index.eventDelta)(this._prevEventData, currentEventData)
      });
      var delta = (0, _index.eventDelta)(this._savedEventData, currentEventData);
      if (delta.time > VELOCITY_CALC_TIMEOUT) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = (0, _index.eventData)(e);
    },
    _end: function _end(e) {
      var endEventDelta = (0, _index.eventDelta)(this._prevEventData, (0, _index.eventData)(e));
      var velocity = {
        x: 0,
        y: 0
      };
      if (!(0, _index.isDxMouseWheelEvent)(e) && endEventDelta.time < INERTIA_TIMEOUT) {
        var delta = (0, _index.eventDelta)(this._savedEventData, this._prevEventData);
        var velocityMultiplier = FRAME_DURATION / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent(SCROLL_END_EVENT, e, {
        velocity: velocity
      });
    },
    _stop: function _stop(e) {
      this._fireEvent(SCROLL_STOP_EVENT, e);
    },
    cancel: function cancel(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent(SCROLL_CANCEL_EVENT, e);
    },
    dispose: function dispose() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection: function _clearSelection() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover: function _toggleGestureCover() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
}());
(0, _emitter_registrator.default)({
  emitter: ScrollEmitter,
  events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
});
var _default = {
  init: SCROLL_INIT_EVENT,
  start: SCROLL_START_EVENT,
  move: SCROLL_MOVE_EVENT,
  end: SCROLL_END_EVENT,
  stop: SCROLL_STOP_EVENT,
  cancel: SCROLL_CANCEL_EVENT,
  scroll: SCROLL_EVENT
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 11699:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _index = __webpack_require__(39611);
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var abs = Math.abs;
var HOLD_EVENT_NAME = 'dxhold';
var HOLD_TIMEOUT = 750;
var TOUCH_BOUNDARY = 5;
var HoldEmitter = _emitter.default.inherit({
  start: function start(e) {
    this._startEventData = (0, _index.eventData)(e);
    this._startTimer(e);
  },
  _startTimer: function _startTimer(e) {
    var holdTimeout = 'timeout' in this ? this.timeout : HOLD_TIMEOUT;
    this._holdTimer = setTimeout(function () {
      this._requestAccept(e);
      this._fireEvent(HOLD_EVENT_NAME, e, {
        target: e.target
      });
      this._forgetAccept();
    }.bind(this), holdTimeout);
  },
  move: function move(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved: function _touchWasMoved(e) {
    var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
    return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY;
  },
  end: function end() {
    this._stopTimer();
  },
  _stopTimer: function _stopTimer() {
    clearTimeout(this._holdTimer);
  },
  cancel: function cancel() {
    this._stopTimer();
  },
  dispose: function dispose() {
    this._stopTimer();
  }
});

/**
  * @name UI Events.dxhold
  * @type eventType
  * @type_function_param1 event:event
  * @module events/hold
*/

(0, _emitter_registrator.default)({
  emitter: HoldEmitter,
  bubble: true,
  events: [HOLD_EVENT_NAME]
});
var _default = {
  name: HOLD_EVENT_NAME
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 24028:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.start = exports.end = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _element_data = __webpack_require__(97906);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var HOVERSTART_NAMESPACE = 'dxHoverStart';
var HOVERSTART = 'dxhoverstart';
exports.start = HOVERSTART;
var POINTERENTER_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.enter, HOVERSTART_NAMESPACE);
var HOVEREND_NAMESPACE = 'dxHoverEnd';
var HOVEREND = 'dxhoverend';
exports.end = HOVEREND;
var POINTERLEAVE_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.leave, HOVEREND_NAMESPACE);
var Hover = _class.default.inherit({
  noBubble: true,
  ctor: function ctor() {
    this._handlerArrayKeyPath = this._eventNamespace + '_HandlerStore';
  },
  setup: function setup(element) {
    (0, _element_data.data)(element, this._handlerArrayKeyPath, {});
  },
  add: function add(element, handleObj) {
    var that = this;
    var handler = function handler(e) {
      that._handler(e);
    };
    _events_engine.default.on(element, this._originalEventName, handleObj.selector, handler);
    (0, _element_data.data)(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler: function _handler(e) {
    if ((0, _index.isTouchEvent)(e) || _devices.default.isSimulator()) {
      return;
    }
    (0, _index.fireEvent)({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove: function remove(element, handleObj) {
    var handler = (0, _element_data.data)(element, this._handlerArrayKeyPath)[handleObj.guid];
    _events_engine.default.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown: function teardown(element) {
    (0, _element_data.removeData)(element, this._handlerArrayKeyPath);
  }
});
var HoverStart = Hover.inherit({
  ctor: function ctor() {
    this._eventNamespace = HOVERSTART_NAMESPACE;
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler: function _handler(e) {
    var pointers = e.pointers || [];
    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
var HoverEnd = Hover.inherit({
  ctor: function ctor() {
    this._eventNamespace = HOVEREND_NAMESPACE;
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});

/**
 * @name UI Events.dxhoverstart
 * @type eventType
 * @type_function_param1 event:event
 * @module events/hover
*/

/**
 * @name UI Events.dxhoverend
 * @type eventType
 * @type_function_param1 event:event
 * @module events/hover
*/

(0, _event_registrator.default)(HOVERSTART, new HoverStart());
(0, _event_registrator.default)(HOVEREND, new HoverEnd());

/***/ }),

/***/ 66365:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.triggerHandler = exports.trigger = exports.one = exports.on = exports.off = exports.Event = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
* @name events
*/

var on = _events_engine.default.on;
exports.on = on;
var one = _events_engine.default.one;
exports.one = one;
var off = _events_engine.default.off;
exports.off = off;
var trigger = _events_engine.default.trigger;
exports.trigger = trigger;
var triggerHandler = _events_engine.default.triggerHandler;

/**
* @name events.Event
* @type function
* @param1 source:string|event
* @param2 config:object
* @return event
* @module events
* @export Event
* @hidden
*/
exports.triggerHandler = triggerHandler;
var Event = _events_engine.default.Event;
exports.Event = Event;

/***/ }),

/***/ 93786:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var support = _interopRequireWildcard(__webpack_require__(60137));
var _iterator = __webpack_require__(95479);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _touch = _interopRequireDefault(__webpack_require__(69120));
var _mouse = _interopRequireDefault(__webpack_require__(66509));
var _mouse_and_touch = _interopRequireDefault(__webpack_require__(87720));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
  * @name UI Events.dxpointerdown
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
/**
  * @name UI Events.dxpointermove
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
/**
  * @name UI Events.dxpointerup
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
/**
  * @name UI Events.dxpointercancel
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
/**
  * @name UI Events.dxpointerover
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
/**
  * @name UI Events.dxpointerout
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
/**
  * @name UI Events.dxpointerenter
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
/**
  * @name UI Events.dxpointerleave
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 pointerType:string
  * @module events/pointer
*/
var getStrategy = function getStrategy(support, device) {
  var tablet = device.tablet,
    phone = device.phone;
  if (support.touch && !(tablet || phone)) {
    return _mouse_and_touch.default;
  }
  if (support.touch) {
    return _touch.default;
  }
  return _mouse.default;
};
var EventStrategy = getStrategy(support, _devices.default.real());
(0, _iterator.each)(EventStrategy.map, function (pointerEvent, originalEvents) {
  (0, _event_registrator.default)(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
var pointer = {
  down: 'dxpointerdown',
  up: 'dxpointerup',
  move: 'dxpointermove',
  cancel: 'dxpointercancel',
  enter: 'dxpointerenter',
  leave: 'dxpointerleave',
  over: 'dxpointerover',
  out: 'dxpointerout'
};
var _default = pointer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88136:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _browser = _interopRequireDefault(__webpack_require__(47810));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var POINTER_EVENTS_NAMESPACE = 'dxPointerEvents';
var BaseStrategy = _class.default.inherit({
  ctor: function ctor(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = (0, _index.addNamespace)(originalEvents, POINTER_EVENTS_NAMESPACE);
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble: function _isNoBubble() {
    var eventName = this._eventName;
    return eventName === 'dxpointerenter' || eventName === 'dxpointerleave';
  },
  _handler: function _handler(e) {
    var _originalEvent$target;
    var delegateTarget = this._getDelegateTarget(e);
    var event = {
      type: this._eventName,
      pointerType: e.pointerType || (0, _index.eventSource)(e),
      originalEvent: e,
      delegateTarget: delegateTarget,
      // NOTE: TimeStamp normalization (FF bug #238041) (T277118)
      timeStamp: _browser.default.mozilla ? new Date().getTime() : e.timeStamp
    };
    var originalEvent = e.originalEvent;
    if (originalEvent !== null && originalEvent !== void 0 && (_originalEvent$target = originalEvent.target) !== null && _originalEvent$target !== void 0 && _originalEvent$target.shadowRoot) {
      var _originalEvent$path, _originalEvent$compos;
      var path = (_originalEvent$path = originalEvent.path) !== null && _originalEvent$path !== void 0 ? _originalEvent$path : (_originalEvent$compos = originalEvent.composedPath) === null || _originalEvent$compos === void 0 ? void 0 : _originalEvent$compos.call(originalEvent);
      event.target = path[0];
    }
    return this._fireEvent(event);
  },
  _getDelegateTarget: function _getDelegateTarget(e) {
    var delegateTarget;
    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }
    return delegateTarget;
  },
  _fireEvent: function _fireEvent(args) {
    return (0, _index.fireEvent)(args);
  },
  _setSelector: function _setSelector(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector: function _getSelector() {
    return this._selector;
  },
  setup: function setup() {
    return true;
  },
  add: function add(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : _dom_adapter.default.getDocument();
      this._setSelector(handleObj);
      var that = this;
      _events_engine.default.on(element, this._originalEvents, this._getSelector(), function (e) {
        that._handler(e);
      });
    }
    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove: function remove(handleObj) {
    this._setSelector(handleObj);
    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown: function teardown(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }
    element = this.noBubble ? element : _dom_adapter.default.getDocument();
    if (this._originalEvents !== '.' + POINTER_EVENTS_NAMESPACE) {
      _events_engine.default.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose: function dispose(element) {
    element = this.noBubble ? element : _dom_adapter.default.getDocument();
    _events_engine.default.off(element, this._originalEvents);
  }
});
var _default = BaseStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 66509:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _base = _interopRequireDefault(__webpack_require__(88136));
var _observer = _interopRequireDefault(__webpack_require__(25544));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var eventMap = {
  'dxpointerdown': 'mousedown',
  'dxpointermove': 'mousemove',
  'dxpointerup': 'mouseup',
  'dxpointercancel': '',
  'dxpointerover': 'mouseover',
  'dxpointerout': 'mouseout',
  'dxpointerenter': 'mouseenter',
  'dxpointerleave': 'mouseleave'
};
var normalizeMouseEvent = function normalizeMouseEvent(e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};
var observer;
var activated = false;
var activateStrategy = function activateStrategy() {
  if (activated) {
    return;
  }
  observer = new _observer.default(eventMap, function () {
    return true;
  });
  activated = true;
};
var MouseStrategy = _base.default.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent: function _fireEvent(args) {
    return this.callBase((0, _extend.extend)(normalizeMouseEvent(args.originalEvent), args));
  }
});
MouseStrategy.map = eventMap;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy;
MouseStrategy.resetObserver = function () {
  observer.reset();
};
var _default = MouseStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 87720:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _base = _interopRequireDefault(__webpack_require__(88136));
var _mouse = _interopRequireDefault(__webpack_require__(66509));
var _touch = _interopRequireDefault(__webpack_require__(69120));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var eventMap = {
  'dxpointerdown': 'touchstart mousedown',
  'dxpointermove': 'touchmove mousemove',
  'dxpointerup': 'touchend mouseup',
  'dxpointercancel': 'touchcancel',
  'dxpointerover': 'mouseover',
  'dxpointerout': 'mouseout',
  'dxpointerenter': 'mouseenter',
  'dxpointerleave': 'mouseleave'
};
var activated = false;
var activateStrategy = function activateStrategy() {
  if (activated) {
    return;
  }
  _mouse.default.activate();
  activated = true;
};
var MouseAndTouchStrategy = _base.default.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _handler: function _handler(e) {
    var isMouse = (0, _index.isMouseEvent)(e);
    if (!isMouse) {
      this._skipNextEvents = true;
    }
    if (isMouse && this._mouseLocked) {
      return;
    }
    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      var that = this;
      this._unlockMouseTimer = setTimeout(function () {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }
    return this.callBase(e);
  },
  _fireEvent: function _fireEvent(args) {
    var normalizer = (0, _index.isMouseEvent)(args.originalEvent) ? _mouse.default.normalize : _touch.default.normalize;
    return this.callBase((0, _extend.extend)(normalizer(args.originalEvent), args));
  },
  dispose: function dispose() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});
MouseAndTouchStrategy.map = eventMap;
MouseAndTouchStrategy.resetObserver = _mouse.default.resetObserver;
var _default = MouseAndTouchStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 25544:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var addEventsListener = function addEventsListener(events, handler) {
  _ready_callbacks.default.add(function () {
    events.split(' ').forEach(function (event) {
      _dom_adapter.default.listen(_dom_adapter.default.getDocument(), event, handler, true);
    });
  });
};
var Observer = function Observer(eventMap, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function () {};
  var pointers = [];
  var getPointerIndex = function getPointerIndex(e) {
    var index = -1;
    (0, _iterator.each)(pointers, function (i, pointer) {
      if (!pointerEquals(e, pointer)) {
        return true;
      }
      index = i;
      return false;
    });
    return index;
  };
  var addPointer = function addPointer(e) {
    if (getPointerIndex(e) === -1) {
      onPointerAdding(e);
      pointers.push(e);
    }
  };
  var removePointer = function removePointer(e) {
    var index = getPointerIndex(e);
    if (index > -1) {
      pointers.splice(index, 1);
    }
  };
  var updatePointer = function updatePointer(e) {
    pointers[getPointerIndex(e)] = e;
  };
  addEventsListener(eventMap['dxpointerdown'], addPointer);
  addEventsListener(eventMap['dxpointermove'], updatePointer);
  addEventsListener(eventMap['dxpointerup'], removePointer);
  addEventsListener(eventMap['dxpointercancel'], removePointer);
  this.pointers = function () {
    return pointers;
  };
  this.reset = function () {
    pointers = [];
  };
};
var _default = Observer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 69120:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _base = _interopRequireDefault(__webpack_require__(88136));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var eventMap = {
  'dxpointerdown': 'touchstart',
  'dxpointermove': 'touchmove',
  'dxpointerup': 'touchend',
  'dxpointercancel': 'touchcancel',
  'dxpointerover': '',
  'dxpointerout': '',
  'dxpointerenter': '',
  'dxpointerleave': ''
};
var normalizeTouchEvent = function normalizeTouchEvent(e) {
  var pointers = [];
  (0, _iterator.each)(e.touches, function (_, touch) {
    pointers.push((0, _extend.extend)({
      pointerId: touch.identifier
    }, touch));
  });
  return {
    pointers: pointers,
    pointerId: e.changedTouches[0].identifier
  };
};
var skipTouchWithSameIdentifier = function skipTouchWithSameIdentifier(pointerEvent) {
  return _devices.default.real().platform === 'ios' && (pointerEvent === 'dxpointerdown' || pointerEvent === 'dxpointerup');
};
var TouchStrategy = _base.default.inherit({
  ctor: function ctor() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler: function _handler(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      var touch = e.changedTouches[0];
      if (this._pointerId === touch.identifier && this._pointerId !== 0) {
        return;
      }
      this._pointerId = touch.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent: function _fireEvent(args) {
    return this.callBase((0, _extend.extend)(normalizeTouchEvent(args.originalEvent), args));
  }
});
TouchStrategy.map = eventMap;
TouchStrategy.normalize = normalizeTouchEvent;
var _default = TouchStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 29007:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.removeEvent = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _element_data = __webpack_require__(97906);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var removeEvent = 'dxremove';
exports.removeEvent = removeEvent;
var eventPropName = 'dxRemoveEvent';

/**
  * @name UI Events.dxremove
  * @type eventType
  * @type_function_param1 event:event
  * @module events/remove
*/

(0, _element_data.beforeCleanData)(function (elements) {
  elements = [].slice.call(elements);
  for (var i = 0; i < elements.length; i++) {
    var $element = (0, _renderer.default)(elements[i]);
    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;
      _events_engine.default.triggerHandler($element, removeEvent);
    }
  }
});
(0, _event_registrator.default)(removeEvent, {
  noBubble: true,
  setup: function setup(element) {
    (0, _renderer.default)(element).prop(eventPropName, true);
  }
});

/***/ }),

/***/ 72918:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.visibility = exports.resize = exports.keyboard = exports.hover = exports.focus = exports.dxClick = exports.click = exports.active = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _keyboard_processor = _interopRequireDefault(__webpack_require__(51661));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function addNamespace(event, namespace) {
  return namespace ? (0, _index.addNamespace)(event, namespace) : event;
}
function executeAction(action, args) {
  return typeof action === 'function' ? action(args) : action.execute(args);
}
var active = {
  on: function on($el, active, inactive, opts) {
    var selector = opts.selector,
      showTimeout = opts.showTimeout,
      hideTimeout = opts.hideTimeout,
      namespace = opts.namespace;
    _events_engine.default.on($el, addNamespace('dxactive', namespace), selector, {
      timeout: showTimeout
    }, function (event) {
      return executeAction(active, {
        event,
        element: event.currentTarget
      });
    });
    _events_engine.default.on($el, addNamespace('dxinactive', namespace), selector, {
      timeout: hideTimeout
    }, function (event) {
      return executeAction(inactive, {
        event,
        element: event.currentTarget
      });
    });
  },
  off: function off($el, _ref) {
    var namespace = _ref.namespace,
      selector = _ref.selector;
    _events_engine.default.off($el, addNamespace('dxactive', namespace), selector);
    _events_engine.default.off($el, addNamespace('dxinactive', namespace), selector);
  }
};
exports.active = active;
var resize = {
  on: function on($el, resize) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      namespace = _ref2.namespace;
    _events_engine.default.on($el, addNamespace('dxresize', namespace), resize);
  },
  off: function off($el) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      namespace = _ref3.namespace;
    _events_engine.default.off($el, addNamespace('dxresize', namespace));
  }
};
exports.resize = resize;
var hover = {
  on: function on($el, start, end, _ref4) {
    var selector = _ref4.selector,
      namespace = _ref4.namespace;
    _events_engine.default.on($el, addNamespace('dxhoverend', namespace), selector, function (event) {
      return end(event);
    });
    _events_engine.default.on($el, addNamespace('dxhoverstart', namespace), selector, function (event) {
      return executeAction(start, {
        element: event.target,
        event
      });
    });
  },
  off: function off($el, _ref5) {
    var selector = _ref5.selector,
      namespace = _ref5.namespace;
    _events_engine.default.off($el, addNamespace('dxhoverstart', namespace), selector);
    _events_engine.default.off($el, addNamespace('dxhoverend', namespace), selector);
  }
};
exports.hover = hover;
var visibility = {
  on: function on($el, shown, hiding, _ref6) {
    var namespace = _ref6.namespace;
    _events_engine.default.on($el, addNamespace('dxhiding', namespace), hiding);
    _events_engine.default.on($el, addNamespace('dxshown', namespace), shown);
  },
  off: function off($el, _ref7) {
    var namespace = _ref7.namespace;
    _events_engine.default.off($el, addNamespace('dxhiding', namespace));
    _events_engine.default.off($el, addNamespace('dxshown', namespace));
  }
};
exports.visibility = visibility;
var focus = {
  on: function on($el, focusIn, focusOut, _ref8) {
    var namespace = _ref8.namespace;
    _events_engine.default.on($el, addNamespace('focusin', namespace), focusIn);
    _events_engine.default.on($el, addNamespace('focusout', namespace), focusOut);
  },
  off: function off($el, _ref9) {
    var namespace = _ref9.namespace;
    _events_engine.default.off($el, addNamespace('focusin', namespace));
    _events_engine.default.off($el, addNamespace('focusout', namespace));
  },
  trigger: function trigger($el) {
    return _events_engine.default.trigger($el, 'focus');
  }
};
exports.focus = focus;
var dxClick = {
  on: function on($el, click) {
    var _ref10 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      namespace = _ref10.namespace;
    _events_engine.default.on($el, addNamespace('dxclick', namespace), click);
  },
  off: function off($el) {
    var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      namespace = _ref11.namespace;
    _events_engine.default.off($el, addNamespace('dxclick', namespace));
  }
};
exports.dxClick = dxClick;
var click = {
  on: function on($el, click) {
    var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      namespace = _ref12.namespace;
    _events_engine.default.on($el, addNamespace('click', namespace), click);
  },
  off: function off($el) {
    var _ref13 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      namespace = _ref13.namespace;
    _events_engine.default.off($el, addNamespace('click', namespace));
  }
};
exports.click = click;
var index = 0;
var keyboardProcessors = {};
var generateListenerId = function generateListenerId() {
  return "keyboardProcessorId".concat(index++);
};
var keyboard = {
  on: function on(element, focusTarget, handler) {
    var listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new _keyboard_processor.default({
      element,
      focusTarget,
      handler
    });
    return listenerId;
  },
  off: function off(listenerId) {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      delete keyboardProcessors[listenerId];
    }
  },
  // NOTE: For tests
  _getProcessor: function _getProcessor(listenerId) {
    return keyboardProcessors[listenerId];
  }
};
exports.keyboard = keyboard;

/***/ }),

/***/ 34309:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.swipe = exports.start = exports.end = void 0;
var _size = __webpack_require__(58664);
var _index = __webpack_require__(39611);
var _emitter = _interopRequireDefault(__webpack_require__(98621));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SWIPE_START_EVENT = 'dxswipestart';
exports.start = SWIPE_START_EVENT;
var SWIPE_EVENT = 'dxswipe';
exports.swipe = SWIPE_EVENT;
var SWIPE_END_EVENT = 'dxswipeend';
exports.end = SWIPE_END_EVENT;
var HorizontalStrategy = {
  defaultItemSizeFunc: function defaultItemSizeFunc() {
    return (0, _size.getWidth)(this.getElement());
  },
  getBounds: function getBounds() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio: function calcOffsetRatio(e) {
    var endEventData = (0, _index.eventData)(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function isFastSwipe(e) {
    var endEventData = (0, _index.eventData)(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
var VerticalStrategy = {
  defaultItemSizeFunc: function defaultItemSizeFunc() {
    return (0, _size.getHeight)(this.getElement());
  },
  getBounds: function getBounds() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio: function calcOffsetRatio(e) {
    var endEventData = (0, _index.eventData)(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe: function isFastSwipe(e) {
    var endEventData = (0, _index.eventData)(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
var STRATEGIES = {
  'horizontal': HorizontalStrategy,
  'vertical': VerticalStrategy
};
var SwipeEmitter = _emitter.default.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor: function ctor(element) {
    this.callBase(element);
    this.direction = 'horizontal';
    this.elastic = true;
  },
  _getStrategy: function _getStrategy() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc: function _defaultItemSizeFunc() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc: function _itemSizeFunc() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init: function _init(e) {
    this._tickData = (0, _index.eventData)(e);
  },
  _start: function _start(e) {
    this._savedEventData = (0, _index.eventData)(e);
    e = this._fireEvent(SWIPE_START_EVENT, e);
    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move: function _move(e) {
    var strategy = this._getStrategy();
    var moveEventData = (0, _index.eventData)(e);
    var offset = strategy.calcOffsetRatio.call(this, e);
    offset = this._fitOffset(offset, this.elastic);
    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }
    this._fireEvent(SWIPE_EVENT, e, {
      offset: offset
    });
    if (e.cancelable !== false) {
      e.preventDefault();
    }
  },
  _end: function _end(e) {
    var strategy = this._getStrategy();
    var offsetRatio = strategy.calcOffsetRatio.call(this, e);
    var isFast = strategy.isFastSwipe.call(this, e);
    var startOffset = offsetRatio;
    var targetOffset = this._calcTargetOffset(offsetRatio, isFast);
    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);
    this._fireEvent(SWIPE_END_EVENT, e, {
      offset: startOffset,
      targetOffset: targetOffset
    });
  },
  _fitOffset: function _fitOffset(offset, elastic) {
    var strategy = this._getStrategy();
    var bounds = strategy.getBounds.call(this);
    if (offset < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0];
    }
    if (offset > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1];
    }
    return offset;
  },
  _calcTargetOffset: function _calcTargetOffset(offsetRatio, isFast) {
    var result;
    if (isFast) {
      result = Math.ceil(Math.abs(offsetRatio));
      if (offsetRatio < 0) {
        result = -result;
      }
    } else {
      result = Math.round(offsetRatio);
    }
    return result;
  }
});

/**
 * @name UI Events.dxswipestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/swipe
*/
/**
  * @name UI Events.dxswipe
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 cancel:boolean
  * @module events/swipe
*/
/**
  * @name UI Events.dxswipeend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 offset:number
  * @type_function_param1_field2 targetOffset:number
  * @module events/swipe
*/

(0, _emitter_registrator.default)({
  emitter: SwipeEmitter,
  events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
});

/***/ }),

/***/ 91093:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.zoomstart = exports.zoomend = exports.zoom = exports.translatestart = exports.translateend = exports.translate = exports.transformstart = exports.transformend = exports.transform = exports.rotatestart = exports.rotateend = exports.rotate = exports.pinchstart = exports.pinchend = exports.pinch = void 0;
var _math = __webpack_require__(60810);
var iteratorUtils = _interopRequireWildcard(__webpack_require__(95479));
var _index = __webpack_require__(39611);
var _emitter = _interopRequireDefault(__webpack_require__(31391));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(82495));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var DX_PREFIX = 'dx';
var TRANSFORM = 'transform';
var TRANSLATE = 'translate';
var PINCH = 'pinch';
var ROTATE = 'rotate';
var START_POSTFIX = 'start';
var UPDATE_POSTFIX = '';
var END_POSTFIX = 'end';
var eventAliases = [];
var addAlias = function addAlias(eventName, eventArgs) {
  eventAliases.push({
    name: eventName,
    args: eventArgs
  });
};
addAlias(TRANSFORM, {
  scale: true,
  deltaScale: true,
  rotation: true,
  deltaRotation: true,
  translation: true,
  deltaTranslation: true
});
addAlias(TRANSLATE, {
  translation: true,
  deltaTranslation: true
});
addAlias(PINCH, {
  scale: true,
  deltaScale: true
});
addAlias(ROTATE, {
  rotation: true,
  deltaRotation: true
});
var getVector = function getVector(first, second) {
  return {
    x: second.pageX - first.pageX,
    y: -second.pageY + first.pageY,
    centerX: (second.pageX + first.pageX) * 0.5,
    centerY: (second.pageY + first.pageY) * 0.5
  };
};
var getEventVector = function getEventVector(e) {
  var pointers = e.pointers;
  return getVector(pointers[0], pointers[1]);
};
var getDistance = function getDistance(vector) {
  return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
};
var getScale = function getScale(firstVector, secondVector) {
  return getDistance(firstVector) / getDistance(secondVector);
};
var getRotation = function getRotation(firstVector, secondVector) {
  var scalarProduct = firstVector.x * secondVector.x + firstVector.y * secondVector.y;
  var distanceProduct = getDistance(firstVector) * getDistance(secondVector);
  if (distanceProduct === 0) {
    return 0;
  }
  var sign = (0, _math.sign)(firstVector.x * secondVector.y - secondVector.x * firstVector.y);
  var angle = Math.acos((0, _math.fitIntoRange)(scalarProduct / distanceProduct, -1, 1));
  return sign * angle;
};
var getTranslation = function getTranslation(firstVector, secondVector) {
  return {
    x: firstVector.centerX - secondVector.centerX,
    y: firstVector.centerY - secondVector.centerY
  };
};
var TransformEmitter = _emitter.default.inherit({
  validatePointers: function validatePointers(e) {
    return (0, _index.hasTouches)(e) > 1;
  },
  start: function start(e) {
    this._accept(e);
    var startVector = getEventVector(e);
    this._startVector = startVector;
    this._prevVector = startVector;
    this._fireEventAliases(START_POSTFIX, e);
  },
  move: function move(e) {
    var currentVector = getEventVector(e);
    var eventArgs = this._getEventArgs(currentVector);
    this._fireEventAliases(UPDATE_POSTFIX, e, eventArgs);
    this._prevVector = currentVector;
  },
  end: function end(e) {
    var eventArgs = this._getEventArgs(this._prevVector);
    this._fireEventAliases(END_POSTFIX, e, eventArgs);
  },
  _getEventArgs: function _getEventArgs(vector) {
    return {
      scale: getScale(vector, this._startVector),
      deltaScale: getScale(vector, this._prevVector),
      rotation: getRotation(vector, this._startVector),
      deltaRotation: getRotation(vector, this._prevVector),
      translation: getTranslation(vector, this._startVector),
      deltaTranslation: getTranslation(vector, this._prevVector)
    };
  },
  _fireEventAliases: function _fireEventAliases(eventPostfix, originalEvent, eventArgs) {
    eventArgs = eventArgs || {};
    iteratorUtils.each(eventAliases, function (_, eventAlias) {
      var args = {};
      iteratorUtils.each(eventAlias.args, function (name) {
        if (name in eventArgs) {
          args[name] = eventArgs[name];
        }
      });
      this._fireEvent(DX_PREFIX + eventAlias.name + eventPostfix, originalEvent, args);
    }.bind(this));
  }
});

/**
 * @name UI Events.dxtransformstart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/
/**
  * @name UI Events.dxtransform
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 rotation:number
  * @type_function_param1_field4 deltaRotation:number
  * @type_function_param1_field5 translation:object
  * @type_function_param1_field6 deltaTranslation:object
  * @type_function_param1_field7 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxtransformend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 rotation:number
  * @type_function_param1_field4 deltaRotation:number
  * @type_function_param1_field5 translation:object
  * @type_function_param1_field6 deltaTranslation:object
  * @type_function_param1_field7 cancel:boolean
  * @module events/transform
*/

/**
 * @name UI Events.dxtranslatestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/
/**
  * @name UI Events.dxtranslate
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 translation:object
  * @type_function_param1_field2 deltaTranslation:object
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxtranslateend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 translation:object
  * @type_function_param1_field2 deltaTranslation:object
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
* @name UI Events.dxpinchstart
* @type eventType
* @type_function_param1 event:event
* @type_function_param1_field1 cancel:boolean
* @module events/transform
   */
/**
  * @name UI Events.dxpinch
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxpinchend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 scale:number
  * @type_function_param1_field2 deltaScale:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

/**
 * @name UI Events.dxrotatestart
 * @type eventType
 * @type_function_param1 event:event
 * @type_function_param1_field1 cancel:boolean
 * @module events/transform
*/
/**
  * @name UI Events.dxrotate
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 rotation:number
  * @type_function_param1_field2 deltaRotation:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/
/**
  * @name UI Events.dxrotateend
  * @type eventType
  * @type_function_param1 event:event
  * @type_function_param1_field1 rotation:number
  * @type_function_param1_field2 deltaRotation:number
  * @type_function_param1_field3 cancel:boolean
  * @module events/transform
*/

var eventNames = eventAliases.reduce(function (result, eventAlias) {
  [START_POSTFIX, UPDATE_POSTFIX, END_POSTFIX].forEach(function (eventPostfix) {
    result.push(DX_PREFIX + eventAlias.name + eventPostfix);
  });
  return result;
}, []);
(0, _emitter_registrator.default)({
  emitter: TransformEmitter,
  events: eventNames
});
var exportNames = {};
iteratorUtils.each(eventNames, function (_, eventName) {
  exportNames[eventName.substring(DX_PREFIX.length)] = eventName;
});
/* eslint-disable spellcheck/spell-checker */
var transformstart = exportNames.transformstart,
  transform = exportNames.transform,
  transformend = exportNames.transformend,
  translatestart = exportNames.translatestart,
  translate = exportNames.translate,
  translateend = exportNames.translateend,
  zoomstart = exportNames.zoomstart,
  zoom = exportNames.zoom,
  zoomend = exportNames.zoomend,
  pinchstart = exportNames.pinchstart,
  pinch = exportNames.pinch,
  pinchend = exportNames.pinchend,
  rotatestart = exportNames.rotatestart,
  rotate = exportNames.rotate,
  rotateend = exportNames.rotateend;
exports.rotateend = rotateend;
exports.rotate = rotate;
exports.rotatestart = rotatestart;
exports.pinchend = pinchend;
exports.pinch = pinch;
exports.pinchstart = pinchstart;
exports.zoomend = zoomend;
exports.zoom = zoom;
exports.zoomstart = zoomstart;
exports.translateend = translateend;
exports.translate = translate;
exports.translatestart = translatestart;
exports.transformend = transformend;
exports.transform = transform;
exports.transformstart = transformstart;

/***/ }),

/***/ 19141:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var addNamespace = function addNamespace(eventNames, namespace) {
  if (!namespace) {
    throw _errors.default.Error('E0017');
  }
  if (Array.isArray(eventNames)) {
    return eventNames.map(function (eventName) {
      return addNamespace(eventName, namespace);
    }).join(' ');
  }
  if (eventNames.indexOf(' ') !== -1) {
    return addNamespace(eventNames.split(/\s+/g), namespace);
  }
  return "".concat(eventNames, ".").concat(namespace);
};
var _default = addNamespace;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 27575:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.unsubscribeNodesDisposing = exports.subscribeNodesDisposing = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _remove = __webpack_require__(29007);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter(function (node) {
    return !!node;
  });
}
var subscribeNodesDisposing = function subscribeNodesDisposing(event, callback) {
  _events_engine.default.one(nodesByEvent(event), _remove.removeEvent, callback);
};
exports.subscribeNodesDisposing = subscribeNodesDisposing;
var unsubscribeNodesDisposing = function unsubscribeNodesDisposing(event, callback) {
  _events_engine.default.off(nodesByEvent(event), _remove.removeEvent, callback);
};
exports.unsubscribeNodesDisposing = unsubscribeNodesDisposing;

/***/ }),

/***/ 39611:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.stopEventsSkipping = exports.setEventFixMethod = exports.normalizeKeyName = exports.needSkipEvent = exports.isTouchEvent = exports.isPointerEvent = exports.isMouseEvent = exports.isKeyboardEvent = exports.isFakeClickEvent = exports.isDxMouseWheelEvent = exports.isCommandKeyPressed = exports.hasTouches = exports.getChar = exports.forceSkipEvents = exports.fireEvent = exports.eventSource = exports.eventDelta = exports.eventData = exports.createEvent = exports.addNamespace = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _add_namespace = _interopRequireDefault(__webpack_require__(19141));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _selectors = __webpack_require__(31421);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var KEY_MAP = {
  'backspace': 'backspace',
  'tab': 'tab',
  'enter': 'enter',
  'escape': 'escape',
  'pageup': 'pageUp',
  'pagedown': 'pageDown',
  'end': 'end',
  'home': 'home',
  'arrowleft': 'leftArrow',
  'arrowup': 'upArrow',
  'arrowright': 'rightArrow',
  'arrowdown': 'downArrow',
  'delete': 'del',
  ' ': 'space',
  'f': 'F',
  'a': 'A',
  '*': 'asterisk',
  '-': 'minus',
  'alt': 'alt',
  'control': 'control',
  'shift': 'shift'
};
var LEGACY_KEY_CODES = {
  // iOS 10.2 and lower didn't supports KeyboardEvent.key
  '8': 'backspace',
  '9': 'tab',
  '13': 'enter',
  '27': 'escape',
  '33': 'pageUp',
  '34': 'pageDown',
  '35': 'end',
  '36': 'home',
  '37': 'leftArrow',
  '38': 'upArrow',
  '39': 'rightArrow',
  '40': 'downArrow',
  '46': 'del',
  '32': 'space',
  '70': 'F',
  '65': 'A',
  '106': 'asterisk',
  '109': 'minus',
  '189': 'minus',
  '173': 'minus',
  '16': 'shift',
  '17': 'control',
  '18': 'alt'
};
var EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};
var fixMethod = function fixMethod(e) {
  return e;
};
var copyEvent = function copyEvent(originalEvent) {
  return fixMethod(_events_engine.default.Event(originalEvent, originalEvent), originalEvent);
};
var isDxEvent = function isDxEvent(e) {
  return eventSource(e) === 'dx';
};
var isNativeMouseEvent = function isNativeMouseEvent(e) {
  return eventSource(e) === 'mouse';
};
var isNativeTouchEvent = function isNativeTouchEvent(e) {
  return eventSource(e) === 'touch';
};
var eventSource = function eventSource(_ref) {
  var type = _ref.type;
  var result = 'other';
  (0, _iterator.each)(EVENT_SOURCES_REGEX, function (key) {
    if (this.test(type)) {
      result = key;
      return false;
    }
  });
  return result;
};
exports.eventSource = eventSource;
var isPointerEvent = function isPointerEvent(e) {
  return eventSource(e) === 'pointer';
};
exports.isPointerEvent = isPointerEvent;
var isMouseEvent = function isMouseEvent(e) {
  return isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === 'mouse';
};
exports.isMouseEvent = isMouseEvent;
var isDxMouseWheelEvent = function isDxMouseWheelEvent(e) {
  return e && e.type === 'dxmousewheel';
};
exports.isDxMouseWheelEvent = isDxMouseWheelEvent;
var isTouchEvent = function isTouchEvent(e) {
  return isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && e.pointerType === 'touch';
};
exports.isTouchEvent = isTouchEvent;
var isKeyboardEvent = function isKeyboardEvent(e) {
  return eventSource(e) === 'keyboard';
};
exports.isKeyboardEvent = isKeyboardEvent;
var isFakeClickEvent = function isFakeClickEvent(_ref2) {
  var screenX = _ref2.screenX,
    offsetX = _ref2.offsetX,
    pageX = _ref2.pageX;
  return screenX === 0 && !offsetX && pageX === 0;
};
exports.isFakeClickEvent = isFakeClickEvent;
var eventData = function eventData(_ref3) {
  var pageX = _ref3.pageX,
    pageY = _ref3.pageY,
    timeStamp = _ref3.timeStamp;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};
exports.eventData = eventData;
var eventDelta = function eventDelta(from, to) {
  return {
    x: to.x - from.x,
    y: to.y - from.y,
    time: to.time - from.time || 1
  };
};
exports.eventDelta = eventDelta;
var hasTouches = function hasTouches(e) {
  var originalEvent = e.originalEvent,
    pointers = e.pointers;
  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }
  if (isDxEvent(e)) {
    return (pointers || []).length;
  }
  return 0;
};

// TODO: for tests
exports.hasTouches = hasTouches;
var skipEvents = false;
var forceSkipEvents = function forceSkipEvents() {
  return skipEvents = true;
};
exports.forceSkipEvents = forceSkipEvents;
var stopEventsSkipping = function stopEventsSkipping() {
  return skipEvents = false;
};
exports.stopEventsSkipping = stopEventsSkipping;
var needSkipEvent = function needSkipEvent(e) {
  // TODO: for tests
  if (skipEvents) {
    return true;
  }

  // TODO: this checking used in swipeable first move handler. is it correct?
  var target = e.target;
  var $target = (0, _renderer.default)(target);
  var isContentEditable = (target === null || target === void 0 ? void 0 : target.isContentEditable) || (target === null || target === void 0 ? void 0 : target.hasAttribute('contenteditable'));
  var touchInEditable = $target.is('input, textarea, select') || isContentEditable;
  if (isDxMouseWheelEvent(e)) {
    var isTextArea = $target.is('textarea') && $target.hasClass('dx-texteditor-input');
    if (isTextArea || isContentEditable) {
      return false;
    }
    var isInputFocused = $target.is('input[type=\'number\'], textarea, select') && $target.is(':focus');
    return isInputFocused;
  }
  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1; // only left mouse button
  }

  if (isTouchEvent(e)) {
    return touchInEditable && (0, _selectors.focused)($target);
  }
};
exports.needSkipEvent = needSkipEvent;
var setEventFixMethod = function setEventFixMethod(func) {
  return fixMethod = func;
};
exports.setEventFixMethod = setEventFixMethod;
var createEvent = function createEvent(originalEvent, args) {
  var event = copyEvent(originalEvent);
  args && (0, _extend.extend)(event, args);
  return event;
};
exports.createEvent = createEvent;
var fireEvent = function fireEvent(props) {
  var originalEvent = props.originalEvent,
    delegateTarget = props.delegateTarget;
  var event = createEvent(originalEvent, props);
  _events_engine.default.trigger(delegateTarget || event.target, event);
  return event;
};
exports.fireEvent = fireEvent;
var normalizeKeyName = function normalizeKeyName(_ref4) {
  var key = _ref4.key,
    which = _ref4.which;
  var normalizedKey = KEY_MAP[key === null || key === void 0 ? void 0 : key.toLowerCase()] || key;
  var normalizedKeyFromWhich = LEGACY_KEY_CODES[which];
  if (normalizedKeyFromWhich && normalizedKey === key) {
    return normalizedKeyFromWhich;
  } else if (!normalizedKey && which) {
    return String.fromCharCode(which);
  }
  return normalizedKey;
};
exports.normalizeKeyName = normalizeKeyName;
var getChar = function getChar(_ref5) {
  var key = _ref5.key,
    which = _ref5.which;
  return key || String.fromCharCode(which);
};
exports.getChar = getChar;
var addNamespace = _add_namespace.default;
exports.addNamespace = addNamespace;
var isCommandKeyPressed = function isCommandKeyPressed(_ref6) {
  var ctrlKey = _ref6.ctrlKey,
    metaKey = _ref6.metaKey;
  return ctrlKey || metaKey;
};
exports.isCommandKeyPressed = isCommandKeyPressed;

/***/ }),

/***/ 80506:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.triggerShownEvent = exports.triggerResizeEvent = exports.triggerHidingEvent = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var triggerVisibilityChangeEvent = function triggerVisibilityChangeEvent(eventName) {
  var VISIBILITY_CHANGE_SELECTOR = '.dx-visibility-change-handler';
  return function (element) {
    var $element = (0, _renderer.default)(element || 'body');
    var changeHandlers = $element.filter(VISIBILITY_CHANGE_SELECTOR).add($element.find(VISIBILITY_CHANGE_SELECTOR));
    for (var i = 0; i < changeHandlers.length; i++) {
      _events_engine.default.triggerHandler(changeHandlers[i], eventName);
    }
  };
};
var triggerShownEvent = triggerVisibilityChangeEvent('dxshown');
exports.triggerShownEvent = triggerShownEvent;
var triggerHidingEvent = triggerVisibilityChangeEvent('dxhiding');
exports.triggerHidingEvent = triggerHidingEvent;
var triggerResizeEvent = triggerVisibilityChangeEvent('dxresize');
exports.triggerResizeEvent = triggerResizeEvent;

/***/ }),

/***/ 2994:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "exportDataGrid", ({
  enumerable: true,
  get: function get() {
    return _export_data_grid.exportDataGrid;
  }
}));
Object.defineProperty(exports, "exportPivotGrid", ({
  enumerable: true,
  get: function get() {
    return _export_pivot_grid.exportPivotGrid;
  }
}));
var _export_data_grid = __webpack_require__(8572);
var _export_pivot_grid = __webpack_require__(77328);

/***/ }),

/***/ 78292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports["export"] = _export;
Object.defineProperty(exports, "fileSaver", ({
  enumerable: true,
  get: function get() {
    return _file_saver.fileSaver;
  }
}));
exports.svg = exports.pdf = exports.image = void 0;
var _file_saver = __webpack_require__(48351);
var _image_creator = __webpack_require__(12173);
var _svg_creator = __webpack_require__(37596);
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
var _pdf_creator = __webpack_require__(30855);
function _export(data, options, getData) {
  if (!data) {
    return new _deferred.Deferred().resolve();
  }

  // TODO: Can the following actions be not defined? (since they are provided by a widget not by a user)
  var exportingAction = options.exportingAction;
  var exportedAction = options.exportedAction;
  var fileSavingAction = options.fileSavingAction;
  var eventArgs = {
    fileName: options.fileName,
    format: options.format,
    cancel: false
  };
  if ((0, _type.isBoolean)(options.selectedRowsOnly)) {
    eventArgs.selectedRowsOnly = options.selectedRowsOnly;
  }
  (0, _type.isFunction)(exportingAction) && exportingAction(eventArgs);
  if (!eventArgs.cancel) {
    return getData(data, options).then(function (blob) {
      (0, _type.isFunction)(exportedAction) && exportedAction();
      if ((0, _type.isFunction)(fileSavingAction)) {
        eventArgs.data = blob;
        fileSavingAction(eventArgs);
      }
      if (!eventArgs.cancel) {
        var format = options.format === 'xlsx' ? 'EXCEL' : options.format;
        _file_saver.fileSaver.saveAs(eventArgs.fileName, format, blob);
      }
    });
  }
  return new _deferred.Deferred().resolve();
}
var image = {
  creator: _image_creator.imageCreator,
  getData: _image_creator.getData,
  testFormats: _image_creator.testFormats
};
exports.image = image;
var pdf = {
  getData: _pdf_creator.getData
};
exports.pdf = pdf;
var svg = {
  creator: _svg_creator.svgCreator,
  getData: _svg_creator.getData
};
exports.svg = svg;

/***/ }),

/***/ 5332:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ExportLoadPanel = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _extend = __webpack_require__(13306);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _type = __webpack_require__(35922);
var _load_panel = _interopRequireDefault(__webpack_require__(97218));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(13615));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var EXPORT_LOAD_PANEL_CLASS = 'dx-export-loadpanel';
var ExportLoadPanel = /*#__PURE__*/function () {
  function ExportLoadPanel(component, $targetElement, $container, options) {
    this._$targetElement = $targetElement;
    this._$container = $container;
    this._loadPanel = component._createComponent((0, _renderer.default)('<div>').addClass(EXPORT_LOAD_PANEL_CLASS).appendTo(this._$container), _load_panel.default, this.getOptions(options));
  }
  var _proto = ExportLoadPanel.prototype;
  _proto.getDefaultOptions = function getDefaultOptions() {
    return {
      animation: null,
      shading: false,
      height: 90,
      width: 200,
      container: this._$container
    };
  };
  _proto.getOptions = function getOptions(options) {
    if ((0, _type.isDefined)(options.text)) {
      options.message = options.text;
    } else {
      options.message = _message.default.format('dxDataGrid-exporting');
    }
    return (0, _extend.extend)(this.getDefaultOptions(), options);
  };
  _proto.show = function show() {
    this._loadPanel.option('position', _uiGrid_core.default.calculateLoadPanelPosition(this._$targetElement));
    this._loadPanel.show();
  };
  _proto.dispose = function dispose() {
    (0, _renderer.default)(this._loadPanel.element()).remove();
    delete this._loadPanel;
  };
  return ExportLoadPanel;
}();
exports.ExportLoadPanel = ExportLoadPanel;

/***/ }),

/***/ 11385:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Export = void 0;
var _type = __webpack_require__(35922);
var _export_format = __webpack_require__(38526);
var _extend = __webpack_require__(13306);
var _export_load_panel = __webpack_require__(5332);
var _window = __webpack_require__(58201);
// docs.microsoft.com/en-us/office/troubleshoot/excel/determine-column-widths - "Description of how column widths are determined in Excel"
var MAX_DIGIT_WIDTH_IN_PIXELS = 7; // Calibri font with 11pt size

// support.office.com/en-us/article/change-the-column-width-and-row-height-72f5e3cc-994d-43e8-ae58-9774a0905f46 - "Column.Max - 255"
// support.office.com/en-us/article/excel-specifications-and-limits-1672b34d-7043-467e-8e27-269d656771c3 - "Column width limit - 255 characters"
var MAX_EXCEL_COLUMN_WIDTH = 255;
var Export = {
  getFullOptions(options) {
    var fullOptions = (0, _extend.extend)({}, options);
    if (!((0, _type.isDefined)(fullOptions.worksheet) && (0, _type.isObject)(fullOptions.worksheet))) {
      throw Error('The "worksheet" field must contain an object.');
    }
    if (!(0, _type.isDefined)(fullOptions.topLeftCell)) {
      fullOptions.topLeftCell = {
        row: 1,
        column: 1
      };
    } else if ((0, _type.isString)(fullOptions.topLeftCell)) {
      var _fullOptions$workshee = fullOptions.worksheet.getCell(fullOptions.topLeftCell),
        row = _fullOptions$workshee.row,
        col = _fullOptions$workshee.col;
      fullOptions.topLeftCell = {
        row,
        column: col
      };
    }
    if (!(0, _type.isDefined)(fullOptions.keepColumnWidths)) {
      fullOptions.keepColumnWidths = true;
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
      fullOptions.loadPanel = {};
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
      fullOptions.loadPanel.enabled = true;
    }
    if (!(0, _type.isDefined)(fullOptions.encodeExecutableContent)) {
      fullOptions.encodeExecutableContent = false;
    }
    return fullOptions;
  },
  convertDateForExcelJS(date) {
    return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  },
  setNumberFormat(excelCell, numberFormat) {
    excelCell.numFmt = numberFormat;
  },
  getCellStyles(dataProvider) {
    var _this = this;
    var styles = dataProvider.getStyles();
    styles.forEach(function (style) {
      var numberFormat = _this.tryConvertToExcelNumberFormat(style.format, style.dataType);
      if ((0, _type.isDefined)(numberFormat)) {
        numberFormat = numberFormat.replace(/&quot;/g, '"');
      }
      style.numberFormat = numberFormat;
    });
    return styles;
  },
  tryConvertToExcelNumberFormat(format, dataType) {
    var newFormat = _export_format.ExportFormat.formatObjectConverter(format, dataType);
    var currency = newFormat.currency;
    format = newFormat.format;
    dataType = newFormat.dataType;
    return _export_format.ExportFormat.convertFormat(format, newFormat.precision, dataType, currency);
  },
  setAlignment(excelCell, wrapText, horizontalAlignment) {
    var _excelCell$alignment;
    excelCell.alignment = (_excelCell$alignment = excelCell.alignment) !== null && _excelCell$alignment !== void 0 ? _excelCell$alignment : {};
    if ((0, _type.isDefined)(wrapText)) {
      excelCell.alignment.wrapText = wrapText;
    }
    if ((0, _type.isDefined)(horizontalAlignment)) {
      excelCell.alignment.horizontal = horizontalAlignment;
    }
    excelCell.alignment.vertical = 'top';
  },
  setColumnsWidth(worksheet, widths, startColumnIndex) {
    if (!(0, _type.isDefined)(widths)) {
      return;
    }
    for (var i = 0; i < widths.length; i++) {
      var columnWidth = widths[i];
      if (typeof columnWidth === 'number' && isFinite(columnWidth)) {
        worksheet.getColumn(startColumnIndex + i).width = Math.min(MAX_EXCEL_COLUMN_WIDTH, Math.floor(columnWidth / MAX_DIGIT_WIDTH_IN_PIXELS * 100) / 100);
      }
    }
  },
  export(options, Helpers, getLoadPanelTargetElement, getLoadPanelContainer) {
    var _component$_getIntern,
      _this2 = this;
    var component = options.component,
      worksheet = options.worksheet,
      topLeftCell = options.topLeftCell,
      keepColumnWidths = options.keepColumnWidths,
      selectedRowsOnly = options.selectedRowsOnly,
      loadPanel = options.loadPanel,
      encodeExecutableContent = options.encodeExecutableContent;
    var dataProvider = component.getDataProvider(selectedRowsOnly);
    var internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
    var initialLoadPanelEnabledOption = internalComponent.option('loadPanel') && internalComponent.option('loadPanel').enabled;
    if (initialLoadPanelEnabledOption) {
      component.option('loadPanel.enabled', false);
    }
    var exportLoadPanel;
    if (loadPanel.enabled && (0, _window.hasWindow)()) {
      var $targetElement = getLoadPanelTargetElement(component);
      var $container = getLoadPanelContainer(component);
      exportLoadPanel = new _export_load_panel.ExportLoadPanel(component, $targetElement, $container, loadPanel);
      exportLoadPanel.show();
    }
    var wrapText = !!component.option('wordWrapEnabled');
    worksheet.properties.outlineProperties = {
      summaryBelow: false,
      summaryRight: false
    };
    var cellRange = {
      from: {
        row: topLeftCell.row,
        column: topLeftCell.column
      },
      to: {
        row: topLeftCell.row,
        column: topLeftCell.column
      }
    };
    return new Promise(function (resolve) {
      dataProvider.ready().done(function () {
        var columns = dataProvider.getColumns();
        var dataRowsCount = dataProvider.getRowsCount();
        var helpers = new Helpers(component, dataProvider, worksheet, options);
        if (keepColumnWidths) {
          _this2.setColumnsWidth(worksheet, dataProvider.getColumnsWidths(), cellRange.from.column);
        }
        helpers._exportAllFieldHeaders(columns, _this2.setAlignment);
        var fieldHeaderRowsCount = helpers._getFieldHeaderRowsCount();
        cellRange.to.row = cellRange.from.row + fieldHeaderRowsCount;
        var styles = _this2.getCellStyles(dataProvider);
        for (var rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {
          var currentRowIndex = cellRange.from.row + fieldHeaderRowsCount + rowIndex;
          var row = worksheet.getRow(currentRowIndex);
          var startColumnIndex = 0;
          if (helpers._isRowFieldHeadersRow(rowIndex)) {
            startColumnIndex = dataProvider.getRowAreaColCount();
            helpers._exportFieldHeaders('row', currentRowIndex, 0, startColumnIndex, _this2.setAlignment);
          }
          helpers._trySetOutlineLevel(row, rowIndex);
          _this2.exportRow(dataProvider, helpers, row, rowIndex, startColumnIndex, columns.length, wrapText, styles, encodeExecutableContent);
          cellRange.to.row = currentRowIndex;
        }
        helpers.mergedRangesManager.applyMergedRages();
        cellRange.to.column += columns.length > 0 ? columns.length - 1 : 0;
        var worksheetViewSettings = worksheet.views[0] || {};
        if (component.option('rtlEnabled')) {
          worksheetViewSettings.rightToLeft = true;
        }
        if (helpers._isFrozenZone(dataProvider)) {
          if (Object.keys(worksheetViewSettings).indexOf('state') === -1) {
            (0, _extend.extend)(worksheetViewSettings, helpers._getWorksheetFrozenState(cellRange));
          }
          helpers._trySetAutoFilter(cellRange);
        }
        if (Object.keys(worksheetViewSettings).length > 0) {
          worksheet.views = [worksheetViewSettings];
        }
        resolve(cellRange);
      }).always(function () {
        if (initialLoadPanelEnabledOption) {
          component.option('loadPanel.enabled', initialLoadPanelEnabledOption);
        }
        if (loadPanel.enabled && (0, _window.hasWindow)()) {
          exportLoadPanel.dispose();
        }
      });
    });
  },
  exportRow(dataProvider, helpers, row, rowIndex, startColumnIndex, columnsCount, wrapText, styles, encodeExecutableContent) {
    for (var cellIndex = startColumnIndex; cellIndex < columnsCount; cellIndex++) {
      var cellData = dataProvider.getCellData(rowIndex, cellIndex, true);
      var excelCell = row.getCell(helpers._getFirstColumnIndex() + cellIndex);
      helpers.mergedRangesManager.updateMergedRanges(excelCell, rowIndex, cellIndex, helpers);
      var cellInfo = helpers.mergedRangesManager.findMergedCellInfo(rowIndex, cellIndex, helpers._isHeaderCell(rowIndex, cellIndex));
      if ((0, _type.isDefined)(cellInfo) && excelCell !== cellInfo.masterCell) {
        excelCell.style = cellInfo.masterCell.style;
        excelCell.value = cellInfo.masterCell.value;
      } else {
        if ((0, _type.isDate)(cellData.value)) {
          excelCell.value = this.convertDateForExcelJS(cellData.value);
        } else {
          excelCell.value = cellData.value;
        }
        if ((0, _type.isDefined)(excelCell.value)) {
          var _styles$dataProvider$ = styles[dataProvider.getStyleId(rowIndex, cellIndex)],
            bold = _styles$dataProvider$.bold,
            horizontalAlignment = _styles$dataProvider$.alignment,
            numberFormat = _styles$dataProvider$.numberFormat;
          if ((0, _type.isDefined)(numberFormat)) {
            this.setNumberFormat(excelCell, numberFormat);
          } else if ((0, _type.isString)(excelCell.value) && /^[@=+-]/.test(excelCell.value)) {
            this.setNumberFormat(excelCell, '@');
          }
          helpers._trySetFont(excelCell, bold);
          this.setAlignment(excelCell, wrapText, horizontalAlignment);
        }
      }
      helpers._customizeCell(excelCell, cellData.cellSourceData);
      if (encodeExecutableContent) {
        excelCell.value = _export_format.ExportFormat.encode(excelCell.value);
      }
    }
  }
};
exports.Export = Export;

/***/ }),

/***/ 8572:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportDataGrid = exportDataGrid;
var _type = __webpack_require__(35922);
var _export = __webpack_require__(11385);
var _export_merged_ranges_manager = __webpack_require__(31980);
var DataGridHelpers = /*#__PURE__*/function () {
  function DataGridHelpers(component, dataProvider, worksheet, options) {
    this.component = component;
    this.dataProvider = dataProvider;
    this.worksheet = worksheet;
    this.mergedRangesManager = new _export_merged_ranges_manager.MergedRangesManager(dataProvider, worksheet);
    this.topLeftCell = options.topLeftCell;
    this.customizeCell = options.customizeCell;
    this.autoFilterEnabled = options.autoFilterEnabled;
  }
  var _proto = DataGridHelpers.prototype;
  _proto._getFirstColumnIndex = function _getFirstColumnIndex() {
    return this.topLeftCell.column;
  };
  _proto._getFieldHeaderRowsCount = function _getFieldHeaderRowsCount() {
    return 0;
  };
  _proto._trySetAutoFilter = function _trySetAutoFilter(cellRange) {
    if (this.autoFilterEnabled) {
      if (!(0, _type.isDefined)(this.worksheet.autoFilter) && this.dataProvider.getRowsCount() > 0) {
        var dataRange = {
          from: {
            row: cellRange.from.row + this.dataProvider.getHeaderRowCount() - 1,
            column: cellRange.from.column
          },
          to: cellRange.to
        };
        this.worksheet.autoFilter = dataRange;
      }
    }
  };
  _proto._trySetFont = function _trySetFont(excelCell, bold) {
    if ((0, _type.isDefined)(bold)) {
      excelCell.font = excelCell.font || {};
      excelCell.font.bold = bold;
    }
  };
  _proto._getWorksheetFrozenState = function _getWorksheetFrozenState(cellRange) {
    return {
      state: 'frozen',
      ySplit: cellRange.from.row + this.dataProvider.getFrozenArea().y - 1
    };
  };
  _proto._trySetOutlineLevel = function _trySetOutlineLevel(row, rowIndex) {
    if (rowIndex >= this.dataProvider.getHeaderRowCount()) {
      row.outlineLevel = this.dataProvider.getGroupLevel(rowIndex);
    }
  };
  _proto._isFrozenZone = function _isFrozenZone(dataProvider) {
    return dataProvider.getHeaderRowCount() > 0;
  };
  _proto._isHeaderCell = function _isHeaderCell(rowIndex) {
    return rowIndex < this.dataProvider.getHeaderRowCount();
  };
  _proto._isInfoCell = function _isInfoCell() {
    return false;
  };
  _proto._allowToMergeRange = function _allowToMergeRange() {
    return true;
  };
  _proto._getAllFieldHeaders = function _getAllFieldHeaders() {
    return [];
  };
  _proto._customizeCell = function _customizeCell(excelCell, gridCell) {
    if ((0, _type.isFunction)(this.customizeCell)) {
      this.customizeCell({
        excelCell,
        gridCell
      });
    }
  };
  _proto._exportFieldHeaders = function _exportFieldHeaders() {};
  _proto._exportAllFieldHeaders = function _exportAllFieldHeaders() {};
  _proto._isRowFieldHeadersRow = function _isRowFieldHeadersRow() {};
  return DataGridHelpers;
}();
function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options), DataGridHelpers, _getLoadPanelTargetElement, _getLoadPanelContainer);
}
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }
  if (!(0, _type.isDefined)(options.selectedRowsOnly)) {
    options.selectedRowsOnly = false;
  }
  if (!(0, _type.isDefined)(options.autoFilterEnabled)) {
    options.autoFilterEnabled = false;
  }
  return _export.Export.getFullOptions(options);
}
function _getLoadPanelTargetElement(component) {
  return component.getView('rowsView').element();
}
function _getLoadPanelContainer(component) {
  return component.getView('rowsView').element().parent();
}

/***/ }),

/***/ 38526:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ExportFormat = void 0;
var _string = __webpack_require__(68752);
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date = _interopRequireDefault(__webpack_require__(91500));
var _type = __webpack_require__(35922);
var _date2 = __webpack_require__(59937);
var _language_codes = __webpack_require__(9821);
var _extend = __webpack_require__(13306);
__webpack_require__(89740);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ARABIC_ZERO_CODE = 1632;
var DEFINED_NUMBER_FORMTATS = {
  thousands: '#,##0{0},&quot;K&quot;',
  millions: '#,##0{0},,&quot;M&quot;',
  billions: '#,##0{0},,,&quot;B&quot;',
  trillions: '#,##0{0},,,,&quot;T&quot;',
  percent: '0{0}%',
  decimal: '#{0}',
  'fixedpoint': '#,##0{0}',
  exponential: '0{0}E+00',
  currency: ' '
};
var PERIOD_REGEXP = /a+/g;
var DAY_REGEXP = /E/g;
var DO_REGEXP = /dE+/g;
var STANDALONE_MONTH_REGEXP = /L/g;
var HOUR_REGEXP = /h/g;
var ANY_REGEXP = /./g;
function _applyPrecision(format, precision) {
  var result;
  var i;
  if (precision > 0) {
    result = format !== 'decimal' ? '.' : '';
    for (i = 0; i < precision; i++) {
      result = result + '0';
    }
    return result;
  }
  return '';
}
function _hasArabicDigits(text) {
  var code;
  for (var i = 0; i < text.length; i++) {
    code = text.charCodeAt(i);
    if (code >= ARABIC_ZERO_CODE && code < ARABIC_ZERO_CODE + 10) {
      return true;
    }
  }
  return false;
}
function _convertDateFormat(format) {
  var formattedValue = (_date.default.format(new Date(2009, 8, 8, 6, 5, 4), format) || '').toString();
  var result = (0, _date2.getFormat)(function (value) {
    return _date.default.format(value, format);
  });
  if (result) {
    result = _convertDateFormatToOpenXml(result);
    result = _getLanguageInfo(formattedValue) + result;
  }
  return result;
}
function _getLanguageInfo(defaultPattern) {
  var languageID = (0, _language_codes.getLanguageId)();
  var languageIDStr = languageID ? languageID.toString(16) : '';
  var languageInfo = '';
  if (_hasArabicDigits(defaultPattern)) {
    while (languageIDStr.length < 3) {
      languageIDStr = '0' + languageIDStr;
    }
    languageInfo = '[$-2010' + languageIDStr + ']';
  } else if (languageIDStr) {
    languageInfo = '[$-' + languageIDStr + ']';
  }
  return languageInfo;
}
function _convertDateFormatToOpenXml(format) {
  return format.split('/').join('\\/').split('\'').map(function (datePart, index) {
    if (index % 2 === 0) {
      return datePart.replace(PERIOD_REGEXP, 'AM/PM').replace(DO_REGEXP, 'd').replace(DAY_REGEXP, 'd').replace(STANDALONE_MONTH_REGEXP, 'M').replace(HOUR_REGEXP, 'H').split('[').join('\\[').split(']').join('\\]');
    }
    if (datePart) {
      return datePart.replace(ANY_REGEXP, '\\$&');
    }
    return '\'';
  }).join('');
}
function _convertNumberFormat(format, precision, currency) {
  var result;
  var excelFormat;
  if (format === 'currency') {
    excelFormat = _number.default.getOpenXmlCurrencyFormat(currency);
  } else {
    excelFormat = DEFINED_NUMBER_FORMTATS[format.toLowerCase()];
  }
  if (excelFormat) {
    result = (0, _string.format)(excelFormat, _applyPrecision(format, precision));
  }
  return result;
}
function _hasCSVInjection(value) {
  if (!value || value.length < 2) {
    return false;
  }
  return _includesCSVExpression(value);
}
function _hasCSVQuotedInjection(value, textQualifier) {
  if (!value || value.length < 4 || value[0] !== textQualifier) {
    return false;
  }
  return _includesCSVExpression(value.substring(1, value.length - 1));
}
function _includesCSVExpression(value) {
  var injectionPrefix = /^[@=\t\r]/;
  var possibleInjectionPrefix = /^[+-]/;
  if (!value) {
    return false;
  }
  if (injectionPrefix.test(value)) {
    return true;
  }
  if (!possibleInjectionPrefix.test(value)) {
    return false;
  }
  return !(0, _type.isNumeric)(value);
}
var ExportFormat = {
  formatObjectConverter(format, dataType) {
    var result = {
      format: format,
      precision: format && format.precision,
      dataType: dataType
    };
    if ((0, _type.isObject)(format)) {
      return (0, _extend.extend)(result, format, {
        format: format.formatter || format.type,
        currency: format.currency
      });
    }
    return result;
  },
  convertFormat(format, precision, type, currency) {
    if ((0, _type.isDefined)(format)) {
      if (type === 'date') {
        return _convertDateFormat(format);
      } else {
        if ((0, _type.isString)(format) && DEFINED_NUMBER_FORMTATS[format.toLowerCase()]) {
          return _convertNumberFormat(format, precision, currency);
        }
      }
    }
  },
  encode(value) {
    var textQualifier = '"';
    var escaped = false;
    if (_hasCSVInjection(value)) {
      escaped = true;
    } else if (_hasCSVQuotedInjection(value, textQualifier)) {
      value = value.substring(1, value.length - 1);
      escaped = true;
    }
    if (escaped) {
      var singleTextQualifier = textQualifier;
      var escapedTextQualifier = "".concat(textQualifier).concat(textQualifier);
      return textQualifier + '\'' + value.replaceAll(singleTextQualifier, escapedTextQualifier) + textQualifier;
    }
    return value;
  }
};
exports.ExportFormat = ExportFormat;

/***/ }),

/***/ 31980:
/***/ (function(__unused_webpack_module, exports) {



exports.MergedRangesManager = void 0;
var MergedRangesManager = /*#__PURE__*/function () {
  function MergedRangesManager(dataProvider, worksheet) {
    this.dataProvider = dataProvider;
    this.worksheet = worksheet;
    this.mergedCells = [];
    this.mergedRanges = [];
  }
  var _proto = MergedRangesManager.prototype;
  _proto.updateMergedRanges = function updateMergedRanges(excelCell, rowIndex, cellIndex, helpers) {
    if (helpers._isHeaderCell(rowIndex, cellIndex) && !this.isCellInMergedRanges(rowIndex, cellIndex)) {
      var _this$dataProvider$ge = this.dataProvider.getCellMerging(rowIndex, cellIndex),
        rowspan = _this$dataProvider$ge.rowspan,
        colspan = _this$dataProvider$ge.colspan;
      var isMasterCellOfMergedRange = colspan || rowspan;
      if (isMasterCellOfMergedRange) {
        var allowToMergeRange = helpers._allowToMergeRange(rowIndex, cellIndex, rowspan, colspan);
        this.updateMergedCells(excelCell, rowIndex, cellIndex, rowspan, colspan);
        if (allowToMergeRange) {
          var shouldReduceInfoRange = helpers._isInfoCell(rowIndex, cellIndex) && helpers._allowExportRowFieldHeaders();
          this.mergedRanges.push({
            masterCell: excelCell,
            rowspan: rowspan - (shouldReduceInfoRange && rowspan > 0),
            colspan
          });
        }
      }
    }
  };
  _proto.isCellInMergedRanges = function isCellInMergedRanges(rowIndex, cellIndex) {
    return this.mergedCells[rowIndex] && this.mergedCells[rowIndex][cellIndex];
  };
  _proto.findMergedCellInfo = function findMergedCellInfo(rowIndex, cellIndex, isHeaderCell) {
    if (isHeaderCell && this.isCellInMergedRanges(rowIndex, cellIndex)) {
      return this.mergedCells[rowIndex][cellIndex];
    }
  };
  _proto.updateMergedCells = function updateMergedCells(excelCell, rowIndex, cellIndex, rowspan, colspan) {
    for (var i = rowIndex; i <= rowIndex + rowspan; i++) {
      for (var j = cellIndex; j <= cellIndex + colspan; j++) {
        if (!this.mergedCells[i]) {
          this.mergedCells[i] = [];
        }
        this.mergedCells[i][j] = {
          masterCell: excelCell
        };
      }
    }
  };
  _proto.addMergedRange = function addMergedRange(masterCell, rowspan, colspan) {
    this.mergedRanges.push({
      masterCell,
      rowspan,
      colspan
    });
  };
  _proto.applyMergedRages = function applyMergedRages() {
    var _this = this;
    this.mergedRanges.forEach(function (range) {
      var startRowIndex = range.masterCell.fullAddress.row;
      var startColumnIndex = range.masterCell.fullAddress.col;
      var endRowIndex = startRowIndex + range.rowspan;
      var endColumnIndex = startColumnIndex + range.colspan;
      _this.worksheet.mergeCells(startRowIndex, startColumnIndex, endRowIndex, endColumnIndex);
    });
  };
  return MergedRangesManager;
}();
exports.MergedRangesManager = MergedRangesManager;

/***/ }),

/***/ 77328:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportPivotGrid = exportPivotGrid;
var _type = __webpack_require__(35922);
var _export = __webpack_require__(11385);
var _position = __webpack_require__(37518);
var _inflector = __webpack_require__(78008);
var _export_merged_ranges_manager = __webpack_require__(31980);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var FIELD_HEADERS_SEPARATOR = ', ';
var PivotGridHelpers = /*#__PURE__*/function () {
  function PivotGridHelpers(component, dataProvider, worksheet, options) {
    this.component = component;
    this.dataProvider = dataProvider;
    this.worksheet = worksheet;
    this.mergedRangesManager = new _export_merged_ranges_manager.MergedRangesManager(dataProvider, worksheet);
    this.topLeftCell = options.topLeftCell;
    this.customizeCell = options.customizeCell;
    this.mergeColumnFieldValues = options.mergeColumnFieldValues;
    this.mergeRowFieldValues = options.mergeRowFieldValues;
    this.exportFilterFieldHeaders = options.exportFilterFieldHeaders;
    this.exportDataFieldHeaders = options.exportDataFieldHeaders;
    this.exportColumnFieldHeaders = options.exportColumnFieldHeaders;
    this.exportRowFieldHeaders = options.exportRowFieldHeaders;
    this.rtlEnabled = component.option('rtlEnabled');
    this.rowHeaderLayout = component.option('rowHeaderLayout');
    this.wrapText = !!component.option('wordWrapEnabled');
    this.filterFieldHeaders = this._tryGetFieldHeaders('filter');
    this.dataFieldHeaders = this._tryGetFieldHeaders('data');
    this.columnFieldHeaders = this._tryGetFieldHeaders('column');
    this.rowFieldHeaders = this._tryGetFieldHeaders('row');
  }
  var _proto = PivotGridHelpers.prototype;
  _proto._getFirstColumnIndex = function _getFirstColumnIndex() {
    return this.topLeftCell.column;
  };
  _proto._getWorksheetFrozenState = function _getWorksheetFrozenState(cellRange) {
    var _this$dataProvider$ge = this.dataProvider.getFrozenArea(),
      x = _this$dataProvider$ge.x,
      y = _this$dataProvider$ge.y;
    return {
      state: 'frozen',
      xSplit: cellRange.from.column + x - 1,
      ySplit: cellRange.from.row + y + this._getFieldHeaderRowsCount() - 1
    };
  };
  _proto._getFieldHeaderRowsCount = function _getFieldHeaderRowsCount() {
    return 0 + this._allowExportFilterFieldHeaders() + (this._allowExportDataFieldHeaders() || this._allowExportColumnFieldHeaders());
  };
  _proto._isFrozenZone = function _isFrozenZone() {
    return true;
  };
  _proto._isHeaderCell = function _isHeaderCell(rowIndex, cellIndex) {
    return rowIndex < this.dataProvider.getColumnAreaRowCount() || cellIndex < this.dataProvider.getRowAreaColCount();
  };
  _proto._getDefaultFieldHeaderCellsData = function _getDefaultFieldHeaderCellsData(value) {
    return {
      text: value,
      value: value
    };
  };
  _proto._isInfoCell = function _isInfoCell(rowIndex, cellIndex) {
    return rowIndex < this.dataProvider.getColumnAreaRowCount() && cellIndex < this.dataProvider.getRowAreaColCount();
  };
  _proto._allowToMergeRange = function _allowToMergeRange(rowIndex, cellIndex, rowspan, colspan) {
    return !(this.dataProvider.isColumnAreaCell(rowIndex, cellIndex) && !this.mergeColumnFieldValues && !!colspan || this.dataProvider.isRowAreaCell(rowIndex, cellIndex) && !this.mergeRowFieldValues && !!rowspan);
  };
  _proto._trySetAutoFilter = function _trySetAutoFilter() {};
  _proto._trySetFont = function _trySetFont(excelCell, bold) {
    if ((0, _type.isDefined)(bold)) {
      excelCell.font = excelCell.font || {};
      excelCell.font.bold = bold;
    }
  };
  _proto._getFieldHeaderStyles = function _getFieldHeaderStyles() {
    // eslint-disable-next-line spellcheck/spell-checker
    var borderStyle = {
      style: 'thin',
      color: {
        argb: 'FF7E7E7E'
      }
    };
    return {
      alignment: (0, _position.getDefaultAlignment)(this.rtlEnabled),
      bold: true,
      border: {
        bottom: borderStyle,
        left: borderStyle,
        right: borderStyle,
        top: borderStyle
      }
    };
  };
  _proto._trySetOutlineLevel = function _trySetOutlineLevel() {};
  _proto._getAllFieldHeaders = function _getAllFieldHeaders() {
    return this.dataProvider._exportController.getDataSource()._descriptions;
  };
  _proto._tryGetFieldHeaders = function _tryGetFieldHeaders(area) {
    if (!this["export".concat((0, _inflector.camelize)(area, true), "FieldHeaders")]) {
      return [];
    }
    var fields = this._getAllFieldHeaders()[area === 'data' ? 'values' : "".concat(area, "s")].filter(function (fieldHeader) {
      return fieldHeader.area === area;
    });
    if ((0, _position.getDefaultAlignment)(this.rtlEnabled) === 'right') {
      fields.sort(function (a, b) {
        return b.areaIndex - a.areaIndex;
      });
    }
    return fields.map(function (field) {
      return field.caption;
    });
  };
  _proto._customizeCell = function _customizeCell(excelCell, pivotCell, shouldPreventCall) {
    if ((0, _type.isFunction)(this.customizeCell) && !shouldPreventCall) {
      this.customizeCell({
        excelCell,
        pivotCell
      });
    }
  };
  _proto._isRowFieldHeadersRow = function _isRowFieldHeadersRow(rowIndex) {
    var isLastInfoRangeCell = this._isInfoCell(rowIndex, 0) && this.dataProvider.getCellData(rowIndex + 1, 0, true).cellSourceData.area === 'row';
    return this._allowExportRowFieldHeaders() && isLastInfoRangeCell;
  };
  _proto._exportAllFieldHeaders = function _exportAllFieldHeaders(columns, setAlignment) {
    var totalCellsCount = columns.length;
    var rowAreaColCount = this.dataProvider.getRowAreaColCount();
    var rowIndex = this.topLeftCell.row;
    if (this._allowExportFilterFieldHeaders()) {
      this._exportFieldHeaders('filter', rowIndex, 0, totalCellsCount, setAlignment);
      rowIndex++;
    }
    if (this._allowExportDataFieldHeaders()) {
      this._exportFieldHeaders('data', rowIndex, 0, rowAreaColCount, setAlignment);
      if (!this._allowExportColumnFieldHeaders()) {
        this._exportFieldHeaders('column', rowIndex, rowAreaColCount, totalCellsCount - rowAreaColCount, setAlignment);
      }
    }
    if (this._allowExportColumnFieldHeaders()) {
      if (!this._allowExportDataFieldHeaders()) {
        this._exportFieldHeaders('data', rowIndex, 0, rowAreaColCount, setAlignment);
      }
      this._exportFieldHeaders('column', rowIndex, rowAreaColCount, totalCellsCount - rowAreaColCount, setAlignment);
    }
  };
  _proto._exportFieldHeaders = function _exportFieldHeaders(area, rowIndex, startColumnIndex, totalColumnsCount, setAlignment) {
    var fieldHeaders = this["".concat(area, "FieldHeaders")];
    var row = this.worksheet.getRow(rowIndex);
    var shouldMergeHeaderField = area !== 'row' || area === 'row' && this.rowHeaderLayout === 'tree';
    if (shouldMergeHeaderField) {
      this.mergedRangesManager.addMergedRange(row.getCell(this.topLeftCell.column + startColumnIndex), 0, totalColumnsCount - 1);
    }
    for (var cellIndex = 0; cellIndex < totalColumnsCount; cellIndex++) {
      var excelCell = row.getCell(this.topLeftCell.column + startColumnIndex + cellIndex);
      var values = fieldHeaders;
      var cellData = [];
      var value = values.length > totalColumnsCount || shouldMergeHeaderField ? values.join(FIELD_HEADERS_SEPARATOR) : values[cellIndex];
      cellData = _extends({}, this._getDefaultFieldHeaderCellsData(value), {
        headerType: area
      });
      excelCell.value = value;
      this._applyHeaderStyles(excelCell, setAlignment);
      this._customizeCell(excelCell, cellData);
    }
  };
  _proto._applyHeaderStyles = function _applyHeaderStyles(excelCell, setAlignment) {
    var _this$_getFieldHeader = this._getFieldHeaderStyles(),
      bold = _this$_getFieldHeader.bold,
      alignment = _this$_getFieldHeader.alignment,
      border = _this$_getFieldHeader.border;
    this._trySetFont(excelCell, bold);
    setAlignment(excelCell, this.wrapText, alignment);
    excelCell.border = border;
  };
  _proto._allowExportRowFieldHeaders = function _allowExportRowFieldHeaders() {
    return this.rowFieldHeaders.length > 0;
  };
  _proto._allowExportFilterFieldHeaders = function _allowExportFilterFieldHeaders() {
    return this.filterFieldHeaders.length > 0;
  };
  _proto._allowExportDataFieldHeaders = function _allowExportDataFieldHeaders() {
    return this.dataFieldHeaders.length > 0;
  };
  _proto._allowExportColumnFieldHeaders = function _allowExportColumnFieldHeaders() {
    return this.columnFieldHeaders.length > 0;
  };
  return PivotGridHelpers;
}();
function exportPivotGrid(options) {
  return _export.Export.export(_getFullOptions(options), PivotGridHelpers, _getLoadPanelTargetElement, _getLoadPanelContainer);
}
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportPivotGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxPivotGrid')) {
    throw Error('The "component" field must contain a PivotGrid instance.');
  }
  if (!(0, _type.isDefined)(options.mergeRowFieldValues)) {
    options.mergeRowFieldValues = true;
  }
  if (!(0, _type.isDefined)(options.mergeColumnFieldValues)) {
    options.mergeColumnFieldValues = true;
  }
  if (!(0, _type.isDefined)(options.exportDataFieldHeaders)) {
    options.exportDataFieldHeaders = false;
  }
  if (!(0, _type.isDefined)(options.exportRowFieldHeaders)) {
    options.exportRowFieldHeaders = false;
  }
  if (!(0, _type.isDefined)(options.exportColumnFieldHeaders)) {
    options.exportColumnFieldHeaders = false;
  }
  if (!(0, _type.isDefined)(options.exportFilterFieldHeaders)) {
    options.exportFilterFieldHeaders = false;
  }
  return _export.Export.getFullOptions(options);
}
function _getLoadPanelTargetElement(component) {
  return component._dataArea.groupElement();
}
function _getLoadPanelContainer(component) {
  return component.$element();
}

/***/ }),

/***/ 48351:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.fileSaver = exports.MIME_TYPES = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _ui = _interopRequireDefault(__webpack_require__(96688));
var _type = __webpack_require__(35922);
var _console = __webpack_require__(30869);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* global Windows */

var window = (0, _window.getWindow)();
var navigator = (0, _window.getNavigator)();
var FILE_EXTESIONS = {
  EXCEL: 'xlsx',
  CSS: 'css',
  PNG: 'png',
  JPEG: 'jpeg',
  GIF: 'gif',
  SVG: 'svg',
  PDF: 'pdf'
};
var MIME_TYPES = {
  CSS: 'text/css',
  EXCEL: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  PNG: 'image/png',
  JPEG: 'image/jpeg',
  GIF: 'image/gif',
  SVG: 'image/svg+xml',
  PDF: 'application/pdf'
};

// Use github.com/eligrey/FileSaver.js library instead this method
exports.MIME_TYPES = MIME_TYPES;
var fileSaver = {
  _revokeObjectURLTimeout: 30000,
  _getDataUri: function _getDataUri(format, data) {
    var mimeType = this._getMimeType(format);
    return "data:".concat(mimeType, ";base64,").concat(data);
  },
  _getMimeType: function _getMimeType(format) {
    return MIME_TYPES[format] || 'application/octet-stream';
  },
  _linkDownloader: function _linkDownloader(fileName, href) {
    var exportLinkElement = _dom_adapter.default.createElement('a');
    exportLinkElement.download = fileName;
    exportLinkElement.href = href;
    exportLinkElement.target = '_blank'; // cors policy

    return exportLinkElement;
  },
  _winJSBlobSave: function _winJSBlobSave(blob, fileName, format) {
    var savePicker = new Windows.Storage.Pickers.FileSavePicker();
    savePicker.suggestedStartLocation = Windows.Storage.Pickers.PickerLocationId.documentsLibrary;
    var fileExtension = FILE_EXTESIONS[format];
    if (fileExtension) {
      var mimeType = this._getMimeType(format);
      savePicker.fileTypeChoices.insert(mimeType, ['.' + fileExtension]);
    }
    savePicker.suggestedFileName = fileName;
    savePicker.pickSaveFileAsync().then(function (file) {
      if (file) {
        file.openAsync(Windows.Storage.FileAccessMode.readWrite).then(function (outputStream) {
          var inputStream = blob.msDetachStream();
          Windows.Storage.Streams.RandomAccessStream.copyAsync(inputStream, outputStream).then(function () {
            outputStream.flushAsync().done(function () {
              inputStream.close();
              outputStream.close();
            });
          });
        });
      }
    });
  },
  _click: function _click(link) {
    try {
      // eslint-disable-next-line no-undef
      link.dispatchEvent(new MouseEvent('click', {
        cancelable: true
      }));
    } catch (e) {
      var event = _dom_adapter.default.getDocument().createEvent('MouseEvents');
      event.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      link.dispatchEvent(event);
    }
  },
  _saveBlobAs: function _saveBlobAs(fileName, format, data) {
    var _this = this;
    this._blobSaved = false;
    if ((0, _type.isDefined)(navigator.msSaveOrOpenBlob)) {
      navigator.msSaveOrOpenBlob(data, fileName);
      this._blobSaved = true;
    } else if ((0, _type.isDefined)(window.WinJS)) {
      this._winJSBlobSave(data, fileName, format);
      this._blobSaved = true;
    } else {
      var URL = window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL;
      if ((0, _type.isDefined)(URL)) {
        var objectURL = URL.createObjectURL(data);
        var downloadLink = this._linkDownloader(fileName, objectURL);
        setTimeout(function () {
          URL.revokeObjectURL(objectURL);
          _this._objectUrlRevoked = true;
        }, this._revokeObjectURLTimeout);
        this._click(downloadLink);
      } else {
        _console.logger.warn('window.URL || window.webkitURL || window.mozURL || window.msURL || window.oURL is not defined');
      }
    }
  },
  saveAs: function saveAs(fileName, format, data) {
    var fileExtension = FILE_EXTESIONS[format];
    if (fileExtension) {
      fileName += '.' + fileExtension;
    }
    if ((0, _type.isFunction)(window.Blob)) {
      this._saveBlobAs(fileName, format, data);
    } else {
      if (!(0, _type.isDefined)(navigator.userAgent.match(/iPad/i))) _ui.default.log('E1034');
      var downloadLink = this._linkDownloader(fileName, this._getDataUri(format, data));
      this._click(downloadLink);
    }
  }
};
exports.fileSaver = fileSaver;

/***/ }),

/***/ 12173:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.calcScaledInfo = calcScaledInfo;
exports.getData = getData;
exports.imageCreator = void 0;
exports.testFormats = testFormats;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _color = _interopRequireDefault(__webpack_require__(52752));
var _type = __webpack_require__(35922);
var _svg = __webpack_require__(19155);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom = __webpack_require__(3532);
var _window = __webpack_require__(58201);
var _inflector = __webpack_require__(78008);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var _math = Math;
var PI = _math.PI;
var _min = _math.min;
var _abs = _math.abs;
var _sqrt = _math.sqrt;
var _pow = _math.pow;
var _atan2 = _math.atan2;
var _cos = _math.cos;
var _sin = _math.sin;
var _number = Number;
var IMAGE_QUALITY = 1;
var TEXT_DECORATION_LINE_WIDTH_COEFF = 0.05;
var DEFAULT_FONT_SIZE = '10px';
var DEFAULT_FONT_FAMILY = 'sans-serif';
var DEFAULT_TEXT_COLOR = '#000';
var parseAttributes;
function getStringFromCanvas(canvas, mimeType) {
  var dataURL = canvas.toDataURL(mimeType, IMAGE_QUALITY);
  var imageData = window.atob(dataURL.substring(('data:' + mimeType + ';base64,').length));
  return imageData;
}
function arcTo(x1, y1, x2, y2, radius, largeArcFlag, clockwise, context) {
  var cBx = (x1 + x2) / 2;
  var cBy = (y1 + y2) / 2;
  var aB = _atan2(y1 - y2, x1 - x2);
  var k = largeArcFlag ? 1 : -1;
  aB += 90 * (PI / 180) * (clockwise ? 1 : -1);
  var opSide = _sqrt(_pow(x2 - x1, 2) + _pow(y2 - y1, 2)) / 2;
  var adjSide = _sqrt(_abs(_pow(radius, 2) - _pow(opSide, 2)));
  var centerX = cBx + k * (adjSide * _cos(aB));
  var centerY = cBy + k * (adjSide * _sin(aB));
  var startAngle = _atan2(y1 - centerY, x1 - centerX);
  var endAngle = _atan2(y2 - centerY, x2 - centerX);
  context.arc(centerX, centerY, radius, startAngle, endAngle, !clockwise);
}
function getElementOptions(element, rootAppended) {
  var attr = parseAttributes(element.attributes || {});
  var options = (0, _extend.extend)({}, attr, {
    text: element.textContent.replace(/\s+/g, ' '),
    textAlign: attr['text-anchor'] === 'middle' ? 'center' : attr['text-anchor']
  });
  var transform = attr.transform;
  var coords;
  if (transform) {
    coords = transform.match(/translate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.translateX = _number(coords[0]);
      options.translateY = coords[1] ? _number(coords[1]) : 0;
    }
    coords = transform.match(/rotate\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*,*\s*-*\d+([.]\d+)*)*/);
    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.rotationAngle = _number(coords[0]);
      options.rotationX = coords[1] && _number(coords[1]);
      options.rotationY = coords[2] && _number(coords[2]);
    }
    coords = transform.match(/scale\(-*\d+([.]\d+)*(,*\s*-*\d+([.]\d+)*)*/);
    if (coords) {
      coords = coords[0].match(/-*\d+([.]\d+)*/g);
      options.scaleX = _number(coords[0]);
      if (coords.length > 1) {
        options.scaleY = _number(coords[1]);
      } else {
        options.scaleY = options.scaleX;
      }
    }
  }
  parseStyles(element, options, rootAppended);
  return options;
}
function drawRect(context, options) {
  var x = options.x;
  var y = options.y;
  var width = options.width;
  var height = options.height;
  var cornerRadius = options.rx;
  if (!cornerRadius) {
    context.rect(x, y, width, height);
  } else {
    cornerRadius = _min(cornerRadius, width / 2, height / 2);
    context.save();
    context.translate(x, y);
    context.moveTo(width / 2, 0);
    context.arcTo(width, 0, width, height, cornerRadius);
    context.arcTo(width, height, 0, height, cornerRadius);
    context.arcTo(0, height, 0, 0, cornerRadius);
    context.arcTo(0, 0, cornerRadius, 0, cornerRadius);
    context.lineTo(width / 2, 0);
    context.restore();
  }
}
function drawImage(context, options, shared) {
  var d = new _deferred.Deferred();
  var image = new window.Image();
  image.onload = function () {
    context.save();
    context.globalAlpha = options.globalAlpha;
    transformElement(context, options);
    clipElement(context, options, shared);
    context.drawImage(image, options.x || 0, options.y || 0, options.width, options.height);
    context.restore();
    d.resolve();
  };
  image.onerror = function () {
    d.resolve();
  };
  image.setAttribute('crossOrigin', 'anonymous');
  image.src = options['href'] || options['xlink:href'];
  return d;
}
function drawPath(context, dAttr) {
  var dArray = dAttr.replace(/,/g, ' ').split(/([A-Z])/i).filter(function (item) {
    return item.trim() !== '';
  });
  var i = 0;
  var params;
  var prevParams;
  var prevParamsLen;
  do {
    params = (dArray[i + 1] || '').trim().split(' ');
    switch (dArray[i]) {
      case 'M':
        context.moveTo(_number(params[0]), _number(params[1]));
        i += 2;
        break;
      case 'L':
        for (var j = 0; j < params.length / 2; j++) {
          context.lineTo(_number(params[j * 2]), _number(params[j * 2 + 1]));
        }
        i += 2;
        break;
      case 'C':
        context.bezierCurveTo(_number(params[0]), _number(params[1]), _number(params[2]), _number(params[3]), _number(params[4]), _number(params[5]));
        i += 2;
        break;
      case 'a':
        prevParams = dArray[i - 1].trim().split(' ');
        prevParamsLen = prevParams.length - 1;
        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(prevParams[prevParamsLen - 1]) + _number(params[5]), _number(prevParams[prevParamsLen]) + _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
        i += 2;
        break;
      case 'A':
        prevParams = dArray[i - 1].trim().split(' ');
        prevParamsLen = prevParams.length - 1;
        arcTo(_number(prevParams[prevParamsLen - 1]), _number(prevParams[prevParamsLen]), _number(params[5]), _number(params[6]), _number(params[0]), _number(params[3]), _number(params[4]), context);
        i += 2;
        break;
      case 'Z':
        context.closePath();
        i += 1;
        break;
      default:
        i++;
    }
  } while (i < dArray.length);
}
function parseStyles(element, options, rootAppended) {
  var style = element.style || {};
  var field;
  for (field in style) {
    if (style[field] !== '') {
      options[(0, _inflector.camelize)(field)] = style[field];
    }
  }
  if (rootAppended && _dom_adapter.default.isElementNode(element)) {
    style = window.getComputedStyle(element);
    ['fill', 'stroke', 'stroke-width', 'font-family', 'font-size', 'font-style', 'font-weight'].forEach(function (prop) {
      if (prop in style && style[prop] !== '') {
        options[(0, _inflector.camelize)(prop)] = style[prop];
      }
    });
    ['opacity', 'fill-opacity', 'stroke-opacity'].forEach(function (prop) {
      if (prop in style && style[prop] !== '' && style[prop] !== '1') {
        options[prop] = _number(style[prop]);
      }
    });
  }
  options.textDecoration = options.textDecoration || options.textDecorationLine;
  options.globalAlpha = (0, _type.isDefined)(options.opacity) ? options.opacity : options.globalAlpha;
}
function parseUrl(urlString) {
  var matches = urlString && urlString.match(/url\(.*#(.*?)["']?\)/i);
  return matches && matches[1];
}
function setFontStyle(context, options) {
  var fontParams = [];
  options.fontSize = options.fontSize || DEFAULT_FONT_SIZE;
  options.fontFamily = options.fontFamily || DEFAULT_FONT_FAMILY;
  options.fill = options.fill || DEFAULT_TEXT_COLOR;
  options.fontStyle && fontParams.push(options.fontStyle);
  options.fontWeight && fontParams.push(options.fontWeight);
  fontParams.push(options.fontSize);
  fontParams.push(options.fontFamily);
  context.font = fontParams.join(' ');
  context.textAlign = options.textAlign;
  context.fillStyle = options.fill;
  context.globalAlpha = options.globalAlpha;
}
function drawText(context, options, shared) {
  setFontStyle(context, options);
  applyFilter(context, options, shared);
  options.text && context.fillText(options.text, options.x || 0, options.y || 0);
  strokeElement(context, options, true);
  drawTextDecoration(context, options, shared);
}
function drawTextDecoration(context, options, shared) {
  if (!options.textDecoration || options.textDecoration === 'none') {
    return;
  }
  var x = options.x;
  var textWidth = context.measureText(options.text).width;
  var textHeight = parseInt(options.fontSize, 10);
  var lineHeight = textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF < 1 ? 1 : textHeight * TEXT_DECORATION_LINE_WIDTH_COEFF;
  var y = options.y;
  switch (options.textDecoration) {
    case 'line-through':
      y -= textHeight / 3 + lineHeight / 2;
      break;
    case 'overline':
      y -= textHeight - lineHeight;
      break;
    case 'underline':
      y += lineHeight;
      break;
  }
  context.rect(x, y, textWidth, lineHeight);
  fillElement(context, options, shared);
  strokeElement(context, options);
}
function aggregateOpacity(options) {
  options.strokeOpacity = options['stroke-opacity'] !== undefined ? options['stroke-opacity'] : 1;
  options.fillOpacity = options['fill-opacity'] !== undefined ? options['fill-opacity'] : 1;
  if (options.opacity !== undefined) {
    options.strokeOpacity *= options.opacity;
    options.fillOpacity *= options.opacity;
  }
}
function hasTspan(element) {
  var nodes = element.childNodes;
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].tagName === 'tspan') {
      return true;
    }
  }
  return false;
}
function drawTextElement(childNodes, context, options, shared) {
  var lines = [];
  var line;
  var offset = 0;
  for (var i = 0; i < childNodes.length; i++) {
    var element = childNodes[i];
    if (element.tagName === undefined) {
      drawElement(element, context, options, shared);
    } else if (element.tagName === 'tspan' || element.tagName === 'text') {
      var elementOptions = getElementOptions(element, shared.rootAppended);
      var mergedOptions = (0, _extend.extend)({}, options, elementOptions);
      if (element.tagName === 'tspan' && hasTspan(element)) {
        drawTextElement(element.childNodes, context, mergedOptions, shared);
        continue;
      }
      mergedOptions.textAlign = 'start';
      if (!line || elementOptions.x !== undefined) {
        line = {
          elements: [],
          options: [],
          widths: [],
          offsets: []
        };
        lines.push(line);
      }
      if (elementOptions.y !== undefined) {
        offset = 0;
      }
      if (elementOptions.dy !== undefined) {
        offset += parseFloat(elementOptions.dy);
      }
      line.elements.push(element);
      line.options.push(mergedOptions);
      line.offsets.push(offset);
      setFontStyle(context, mergedOptions);
      line.widths.push(context.measureText(mergedOptions.text).width);
    }
  }
  lines.forEach(function (line) {
    var commonWidth = line.widths.reduce(function (commonWidth, width) {
      return commonWidth + width;
    }, 0);
    var xDiff = 0;
    var currentOffset = 0;
    if (options.textAlign === 'center') {
      xDiff = commonWidth / 2;
    }
    if (options.textAlign === 'end') {
      xDiff = commonWidth;
    }
    line.options.forEach(function (o, index) {
      var width = line.widths[index];
      o.x = o.x - xDiff + currentOffset;
      o.y += line.offsets[index];
      currentOffset += width;
    });
    line.elements.forEach(function (element, index) {
      drawTextElement(element.childNodes, context, line.options[index], shared);
    });
  });
}
function drawElement(element, context, parentOptions, shared) {
  var tagName = element.tagName;
  var isText = tagName === 'text' || tagName === 'tspan' || tagName === undefined;
  var isImage = tagName === 'image';
  var isComment = element.nodeType === 8;
  var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));
  if (options.visibility === 'hidden' || options[_svg.HIDDEN_FOR_EXPORT] || isComment) {
    return;
  }
  context.save();
  !isImage && transformElement(context, options);
  clipElement(context, options, shared);
  aggregateOpacity(options);
  var promise;
  context.beginPath();
  switch (element.tagName) {
    case undefined:
      drawText(context, options, shared);
      break;
    case 'text':
    case 'tspan':
      drawTextElement(element.childNodes, context, options, shared);
      break;
    case 'image':
      promise = drawImage(context, options, shared);
      break;
    case 'path':
      drawPath(context, options.d);
      break;
    case 'rect':
      drawRect(context, options);
      context.closePath(); // for valid clipping
      break;
    case 'circle':
      context.arc(options.cx, options.cy, options.r, 0, 2 * PI, 1);
      break;
  }
  if (!isText) {
    applyFilter(context, options, shared);
    if (!isImage) {
      promise = fillElement(context, options, shared);
    }
    strokeElement(context, options);
  }
  applyGradient(context, options, shared, element, 'linear');
  applyGradient(context, options, shared, element, 'radial');
  context.restore();
  return promise;
}
function applyGradient(context, options, _ref, element, type) {
  var linearGradients = _ref.linearGradients,
    radialGradients = _ref.radialGradients;
  var gradients = type === 'linear' ? linearGradients : radialGradients;
  if (Object.keys(gradients).length === 0) {
    return;
  }
  var id = parseUrl(options.fill);
  if (id && gradients[id]) {
    var box = element.getBBox();
    var horizontalCenter = box.x + box.width / 2;
    var verticalCenter = box.y + box.height / 2;
    var maxRadius = Math.max(box.height / 2, box.width / 2);
    var gradient = type === 'linear' ? context.createLinearGradient(box.x, 0, box.x + box.width, 0) : context.createRadialGradient(horizontalCenter, verticalCenter, 0, horizontalCenter, verticalCenter, maxRadius);
    gradients[id].colors.forEach(function (opt) {
      var offset = parseInt(opt.offset.replace(/%/, ''));
      gradient.addColorStop(offset / 100, opt.stopColor);
    });
    if (type === 'linear') {
      var _ref2, _gradients$id$transfo;
      var angle = (_ref2 = ((_gradients$id$transfo = gradients[id].transform) === null || _gradients$id$transfo === void 0 ? void 0 : _gradients$id$transfo.replace(/\D/g, '')) * Math.PI / 180) !== null && _ref2 !== void 0 ? _ref2 : 0;
      context.translate(horizontalCenter, verticalCenter);
      context.rotate(angle);
      context.translate(-horizontalCenter, -verticalCenter);
    }
    context.globalAlpha = options.opacity;
    context.fillStyle = gradient;
    context.fill();
  }
}
function applyFilter(context, options, shared) {
  var filterOptions;
  var id = parseUrl(options.filter);
  if (id) {
    filterOptions = shared.filters[id];
    if (!filterOptions) {
      filterOptions = {
        offsetX: 0,
        offsetY: 0,
        blur: 0,
        color: '#000'
      };
    }
    context.shadowOffsetX = filterOptions.offsetX;
    context.shadowOffsetY = filterOptions.offsetY;
    context.shadowColor = filterOptions.color;
    context.shadowBlur = filterOptions.blur;
  }
}

// translate and clip are the special attributtes, they should not be inherited by child nodes
function transformElement(context, options) {
  context.translate(options.translateX || 0, options.translateY || 0);
  options.translateX = undefined;
  options.translateY = undefined;
  if (options.rotationAngle) {
    context.translate(options.rotationX || 0, options.rotationY || 0);
    context.rotate(options.rotationAngle * PI / 180);
    context.translate(-(options.rotationX || 0), -(options.rotationY || 0));
    options.rotationAngle = undefined;
    options.rotationX = undefined;
    options.rotationY = undefined;
  }
  if (isFinite(options.scaleX)) {
    context.scale(options.scaleX, options.scaleY);
    options.scaleX = undefined;
    options.scaleY = undefined;
  }
}
function clipElement(context, options, shared) {
  if (options['clip-path']) {
    drawElement(shared.clipPaths[parseUrl(options['clip-path'])], context, {}, shared);
    context.clip();
    options['clip-path'] = undefined;
  }
}
function hex2rgba(hexColor, alpha) {
  var color = new _color.default(hexColor);
  return 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + alpha + ')';
}
function createGradient(element) {
  var _element$attributes$g;
  var options = {
    colors: [],
    transform: (_element$attributes$g = element.attributes.gradientTransform) === null || _element$attributes$g === void 0 ? void 0 : _element$attributes$g.textContent
  };
  (0, _iterator.each)(element.childNodes, function (_, _ref3) {
    var attributes = _ref3.attributes;
    options.colors.push({
      offset: attributes.offset.value,
      stopColor: attributes['stop-color'].value
    });
  });
  return options;
}
function createFilter(element) {
  var color;
  var opacity;
  var filterOptions = {};
  (0, _iterator.each)(element.childNodes, function (_, node) {
    var attr = node.attributes;
    if (!attr.result) {
      return;
    }
    switch (attr.result.value) {
      case 'gaussianBlurResult':
        filterOptions.blur = _number(attr.stdDeviation.value);
        break;
      case 'offsetResult':
        filterOptions.offsetX = _number(attr.dx.value);
        filterOptions.offsetY = _number(attr.dy.value);
        break;
      case 'floodResult':
        color = attr['flood-color'] ? attr['flood-color'].value : '#000';
        opacity = attr['flood-opacity'] ? attr['flood-opacity'].value : 1;
        filterOptions.color = hex2rgba(color, opacity);
        break;
    }
  });
  return filterOptions;
}
function asyncEach(array, callback) {
  var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _deferred.Deferred();
  var i = 0;
  for (; i < array.length; i++) {
    var result = callback(array[i]);
    if ((0, _type.isPromise)(result)) {
      result.then(function () {
        asyncEach(Array.prototype.slice.call(array, i + 1), callback, d);
      });
      break;
    }
  }
  if (i === array.length) {
    d.resolve();
  }
  return d;
}
function drawCanvasElements(elements, context, parentOptions, shared) {
  return asyncEach(elements, function (element) {
    switch (element.tagName && element.tagName.toLowerCase()) {
      case 'g':
      case 'svg':
        {
          var options = (0, _extend.extend)({}, parentOptions, getElementOptions(element, shared.rootAppended));
          context.save();
          transformElement(context, options);
          clipElement(context, options, shared);
          var onDone = function onDone() {
            context.restore();
          };
          var promise = drawCanvasElements(element.childNodes, context, options, shared);
          if ((0, _type.isPromise)(promise)) {
            promise.then(onDone);
          } else {
            onDone();
          }
          return promise;
        }
      case 'defs':
        return drawCanvasElements(element.childNodes, context, {}, shared);
      case 'clippath':
        shared.clipPaths[element.attributes.id.textContent] = element.childNodes[0];
        break;
      case 'pattern':
        shared.patterns[element.attributes.id.textContent] = element;
        break;
      case 'filter':
        shared.filters[element.id] = createFilter(element);
        break;
      case 'lineargradient':
        shared.linearGradients[element.attributes.id.textContent] = createGradient(element);
        break;
      case 'radialgradient':
        shared.radialGradients[element.attributes.id.textContent] = createGradient(element);
        break;
      default:
        return drawElement(element, context, parentOptions, shared);
    }
  });
}
function setLineDash(context, options) {
  var matches = options['stroke-dasharray'] && options['stroke-dasharray'].match(/(\d+)/g);
  if (matches && matches.length) {
    matches = (0, _iterator.map)(matches, function (item) {
      return _number(item);
    });
    context.setLineDash(matches);
  }
}
function strokeElement(context, options, isText) {
  var stroke = options.stroke;
  if (stroke && stroke !== 'none' && options['stroke-width'] !== 0) {
    setLineDash(context, options);
    context.lineJoin = options['stroke-linejoin'];
    context.lineWidth = options['stroke-width'];
    context.globalAlpha = options.strokeOpacity;
    context.strokeStyle = stroke;
    isText ? context.strokeText(options.text, options.x, options.y) : context.stroke();
    context.globalAlpha = 1;
  }
}
function getPattern(context, pattern, shared, parentOptions) {
  var options = getElementOptions(pattern, shared.rootAppended);
  var patternCanvas = imageCreator._createCanvas(options.width, options.height, 0);
  var patternContext = patternCanvas.getContext('2d');
  var promise = drawCanvasElements(pattern.childNodes, patternContext, options, shared);
  var onDone = function onDone() {
    context.fillStyle = context.createPattern(patternCanvas, 'repeat');
    context.globalAlpha = parentOptions.fillOpacity;
    context.fill();
    context.globalAlpha = 1;
  };
  if ((0, _type.isPromise)(promise)) {
    promise.then(onDone);
  } else {
    onDone();
  }
  return promise;
}
function fillElement(context, options, shared) {
  var fill = options.fill;
  var promise;
  if (fill && fill !== 'none') {
    if (fill.search(/url/) === -1) {
      context.fillStyle = fill;
      context.globalAlpha = options.fillOpacity;
      context.fill();
      context.globalAlpha = 1;
    } else {
      var pattern = shared.patterns[parseUrl(fill)];
      if (!pattern) {
        return;
      }
      promise = getPattern(context, pattern, shared, options);
    }
  }
  return promise;
}
parseAttributes = function parseAttributes(attributes) {
  var newAttributes = {};
  var attr;
  (0, _iterator.each)(attributes, function (index, item) {
    attr = item.textContent;
    if (isFinite(attr)) {
      attr = _number(attr);
    }
    newAttributes[item.name.toLowerCase()] = attr; // lowerCase for Edge
  });

  return newAttributes;
};
function drawBackground(context, width, height, backgroundColor, margin) {
  context.fillStyle = backgroundColor || '#ffffff';
  context.fillRect(-margin, -margin, width + margin * 2, height + margin * 2);
}
function createInvisibleDiv() {
  var invisibleDiv = _dom_adapter.default.createElement('div');
  invisibleDiv.style.left = '-9999px';
  invisibleDiv.style.position = 'absolute';
  return invisibleDiv;
}
function convertSvgToCanvas(svg, canvas, rootAppended) {
  return drawCanvasElements(svg.childNodes, canvas.getContext('2d'), {}, {
    clipPaths: {},
    patterns: {},
    filters: {},
    linearGradients: {},
    radialGradients: {},
    rootAppended
  });
}
function getCanvasFromSvg(markup, _ref4) {
  var width = _ref4.width,
    height = _ref4.height,
    backgroundColor = _ref4.backgroundColor,
    margin = _ref4.margin,
    _ref4$svgToCanvas = _ref4.svgToCanvas,
    svgToCanvas = _ref4$svgToCanvas === void 0 ? convertSvgToCanvas : _ref4$svgToCanvas;
  var scaledScreenInfo = calcScaledInfo(width, height);
  var canvas = imageCreator._createCanvas(scaledScreenInfo.width, scaledScreenInfo.height, margin);
  var context = canvas.getContext('2d');
  context.setTransform(scaledScreenInfo.pixelRatio, 0, 0, scaledScreenInfo.pixelRatio, 0, 0);
  var svgElem = (0, _svg.getSvgElement)(markup);
  var invisibleDiv;
  var markupIsDomElement = _dom_adapter.default.isElementNode(markup);
  context.translate(margin, margin);
  _dom_adapter.default.getBody().appendChild(canvas);
  if (!markupIsDomElement) {
    invisibleDiv = createInvisibleDiv();
    invisibleDiv.appendChild(svgElem);
    _dom_adapter.default.getBody().appendChild(invisibleDiv);
  }
  // for rtl mode
  if (svgElem.attributes.direction) {
    canvas.dir = svgElem.attributes.direction.textContent;
  }
  drawBackground(context, width, height, backgroundColor, margin);
  return (0, _deferred.fromPromise)(svgToCanvas(svgElem, canvas, markupIsDomElement && (0, _dom.contains)(_dom_adapter.default.getBody(), markup))).then(function () {
    return canvas;
  }).always(function () {
    invisibleDiv && _dom_adapter.default.getBody().removeChild(invisibleDiv);
    _dom_adapter.default.getBody().removeChild(canvas);
  });
}
var imageCreator = {
  getImageData: function getImageData(markup, options) {
    var mimeType = 'image/' + options.format;
    // Injection for testing T403049
    if ((0, _type.isFunction)(options.__parseAttributesFn)) {
      parseAttributes = options.__parseAttributesFn;
    }
    return getCanvasFromSvg(markup, options).then(function (canvas) {
      return getStringFromCanvas(canvas, mimeType);
    });
  },
  getData: function getData(markup, options) {
    var that = this;
    return imageCreator.getImageData(markup, options).then(function (binaryData) {
      var mimeType = 'image/' + options.format;
      var data = (0, _type.isFunction)(window.Blob) && !options.useBase64 ? that._getBlob(binaryData, mimeType) : that._getBase64(binaryData);
      return data;
    });
  },
  _getBlob: function _getBlob(binaryData, mimeType) {
    var i;
    var dataArray = new Uint8Array(binaryData.length);
    for (i = 0; i < binaryData.length; i++) {
      dataArray[i] = binaryData.charCodeAt(i);
    }
    return new window.Blob([dataArray.buffer], {
      type: mimeType
    });
  },
  _getBase64: function _getBase64(binaryData) {
    return window.btoa(binaryData);
  },
  _createCanvas(width, height, margin) {
    var canvas = (0, _renderer.default)('<canvas>')[0];
    canvas.width = width + margin * 2;
    canvas.height = height + margin * 2;
    canvas.hidden = true;
    return canvas;
  }
};
exports.imageCreator = imageCreator;
function getData(data, options) {
  return imageCreator.getData(data, options);
}
function testFormats(formats) {
  var canvas = imageCreator._createCanvas(100, 100, 0);
  return formats.reduce(function (r, f) {
    var mimeType = ('image/' + f).toLowerCase();
    if (canvas.toDataURL(mimeType).indexOf(mimeType) !== -1) {
      r.supported.push(f);
    } else {
      r.unsupported.push(f);
    }
    return r;
  }, {
    supported: [],
    unsupported: []
  });
}
function calcScaledInfo(width, height) {
  var pixelRatio = window.devicePixelRatio || 1;
  return {
    pixelRatio,
    width: width * pixelRatio,
    height: height * pixelRatio
  };
}

/***/ }),

/***/ 18577:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Export = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _date = _interopRequireDefault(__webpack_require__(91500));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _message = _interopRequireDefault(__webpack_require__(28109));
var _export_load_panel = __webpack_require__(5332);
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var Export = {
  getFullOptions: function getFullOptions(options) {
    var fullOptions = (0, _extend.extend)({}, options);
    if (!((0, _type.isDefined)(fullOptions.jsPDFDocument) && (0, _type.isObject)(fullOptions.jsPDFDocument))) {
      throw Error('The "jsPDFDocument" field must contain a jsPDF instance.');
    }
    if (!((0, _type.isDefined)(fullOptions.jsPDFDocument.autoTable) && (0, _type.isFunction)(fullOptions.jsPDFDocument.autoTable))) {
      throw Error('The "exportDataGrid" method requires a autoTable plugin for jsPDF object.');
    }
    if (!(0, _type.isDefined)(fullOptions.keepColumnWidths)) {
      fullOptions.keepColumnWidths = true;
    }
    if (!(0, _type.isDefined)(fullOptions.autoTableOptions)) {
      fullOptions.autoTableOptions = this._getDefaultAutoTableOptions();
    } else {
      if (!(0, _type.isObject)(fullOptions.autoTableOptions)) {
        throw Error('The "autoTableOptions" option must be of object type.');
      }
      fullOptions.autoTableOptions = (0, _extend.extend)(true, {}, this._getDefaultAutoTableOptions(), fullOptions.autoTableOptions);
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
      fullOptions.loadPanel = {};
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
      fullOptions.loadPanel.enabled = true;
    }
    if (!(0, _type.isDefined)(fullOptions.loadPanel.text)) {
      fullOptions.loadPanel.text = _message.default.format('dxDataGrid-exporting');
    }
    return fullOptions;
  },
  _getDefaultAutoTableOptions: function _getDefaultAutoTableOptions() {
    return {
      theme: 'plain',
      tableLineColor: 149,
      tableLineWidth: 0.1,
      styles: {
        textColor: 51,
        lineColor: 149,
        lineWidth: 0
      },
      columnStyles: {},
      headStyles: {
        fontStyle: 'normal',
        textColor: 149,
        lineWidth: 0.1
      },
      bodyStyles: {
        lineWidth: 0.1
      },
      head: [],
      body: []
    };
  },
  export: function _export(options) {
    var _component$_getIntern,
      _this = this;
    var jsPDFDocument = options.jsPDFDocument,
      autoTableOptions = options.autoTableOptions,
      component = options.component,
      customizeCell = options.customizeCell,
      keepColumnWidths = options.keepColumnWidths,
      selectedRowsOnly = options.selectedRowsOnly,
      loadPanel = options.loadPanel;
    var internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
    var initialLoadPanelEnabledOption = internalComponent.option('loadPanel') && internalComponent.option('loadPanel').enabled;
    if (initialLoadPanelEnabledOption) {
      component.option('loadPanel.enabled', false);
    }
    var exportLoadPanel;
    if (loadPanel.enabled && (0, _window.hasWindow)()) {
      var rowsView = component.getView('rowsView');
      exportLoadPanel = new _export_load_panel.ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);
      exportLoadPanel.show();
    }
    var dataProvider = component.getDataProvider(selectedRowsOnly);
    var wrapText = !!component.option('wordWrapEnabled');
    return new Promise(function (resolve) {
      dataProvider.ready().done(function () {
        var columns = dataProvider.getColumns();
        var styles = dataProvider.getStyles();
        var dataRowsCount = dataProvider.getRowsCount();
        var headerRowCount = dataProvider.getHeaderRowCount();
        var mergedCells = [];
        if (keepColumnWidths) {
          var pdfColumnWidths = _this._tryGetPdfColumnWidths(autoTableOptions.tableWidth, dataProvider.getColumnsWidths());
          if ((0, _type.isDefined)(pdfColumnWidths) && (0, _type.isDefined)(autoTableOptions.columnStyles)) {
            _this._setColumnWidths(autoTableOptions.columnStyles, pdfColumnWidths);
          }
        }
        for (var rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {
          var row = [];
          for (var cellIndex = 0; cellIndex < columns.length; cellIndex++) {
            var _dataProvider$getCell = dataProvider.getCellData(rowIndex, cellIndex, true),
              value = _dataProvider$getCell.value,
              gridCell = _dataProvider$getCell.cellSourceData;
            var cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];
            var pdfCell = {
              content: _this._getFormattedValue(value, cellStyle.format),
              styles: _this._getPDFCellStyles(gridCell.rowType, columns[cellIndex].alignment, cellStyle, wrapText)
            };
            if (gridCell.rowType === 'header') {
              var mergedRange = _this._tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider);
              if (mergedRange && mergedRange.rowSpan > 0) {
                pdfCell.rowSpan = mergedRange.rowSpan + 1;
              }
              if (mergedRange && mergedRange.colSpan > 0) {
                pdfCell.colSpan = mergedRange.colSpan + 1;
              }
              var isMergedCell = mergedCells[rowIndex] && mergedCells[rowIndex][cellIndex];
              if (!isMergedCell || pdfCell.rowSpan > 1 || pdfCell.colSpan > 1) {
                if ((0, _type.isFunction)(customizeCell)) {
                  customizeCell({
                    gridCell,
                    pdfCell
                  });
                }
                row.push(pdfCell);
              }
            } else if (gridCell.rowType === 'group' && !(0, _type.isDefined)(pdfCell.content) && row.length === 1) {
              var _row$0$colSpan;
              row[0].colSpan = (_row$0$colSpan = row[0].colSpan) !== null && _row$0$colSpan !== void 0 ? _row$0$colSpan : 1;
              row[0].colSpan++;
            } else {
              var _pdfCell$content;
              pdfCell.content = (_pdfCell$content = pdfCell.content) !== null && _pdfCell$content !== void 0 ? _pdfCell$content : '';
              if ((0, _type.isFunction)(customizeCell)) {
                customizeCell({
                  gridCell,
                  pdfCell
                });
              }
              row.push(pdfCell);
            }
          }
          if (rowIndex < headerRowCount) {
            autoTableOptions.head.push(row);
          } else {
            autoTableOptions.body.push(row);
          }
        }
        jsPDFDocument.autoTable(autoTableOptions);
        resolve();
      }).always(function () {
        if (initialLoadPanelEnabledOption) {
          component.option('loadPanel.enabled', initialLoadPanelEnabledOption);
        }
        if (loadPanel.enabled && (0, _window.hasWindow)()) {
          exportLoadPanel.dispose();
        }
      });
    });
  },
  _getFormattedValue: function _getFormattedValue(value, format) {
    if ((0, _type.isDefined)(format)) {
      if ((0, _type.isDate)(value)) {
        return _date.default.format(value, format);
      }
      if ((0, _type.isNumeric)(value)) {
        return _number.default.format(value, format);
      }
    }
    return value;
  },
  _getPDFCellStyles: function _getPDFCellStyles(rowType, columnAlignment, cellStyle, wrapText) {
    var cellAlignment = cellStyle.alignment,
      bold = cellStyle.bold;
    var align = rowType === 'header' ? columnAlignment : cellAlignment;
    var pdfCellStyle = {};
    if (align) {
      pdfCellStyle['halign'] = align;
    }
    if (bold && rowType !== 'header') {
      pdfCellStyle.fontStyle = 'bold';
    }
    if (wrapText) {
      pdfCellStyle.cellWidth = 'wrap';
    }
    return pdfCellStyle;
  },
  _tryGetMergeRange: function _tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider) {
    if (!mergedCells[rowIndex] || !mergedCells[rowIndex][cellIndex]) {
      var _dataProvider$getCell2 = dataProvider.getCellMerging(rowIndex, cellIndex),
        colspan = _dataProvider$getCell2.colspan,
        rowspan = _dataProvider$getCell2.rowspan;
      if (colspan || rowspan) {
        for (var i = rowIndex; i <= rowIndex + rowspan || 0; i++) {
          for (var j = cellIndex; j <= cellIndex + colspan || 0; j++) {
            if (!mergedCells[i]) {
              mergedCells[i] = [];
            }
            mergedCells[i][j] = true;
          }
        }
        return {
          rowSpan: rowspan,
          colSpan: colspan
        };
      }
    }
  },
  _tryGetPdfColumnWidths(autoTableWidth, columnWidths) {
    if ((0, _type.isNumeric)(autoTableWidth) && (0, _type.isDefined)(columnWidths)) {
      var tableWidth = columnWidths.reduce(function (a, b) {
        return a + b;
      }, 0);
      return columnWidths.map(function (columnWidth) {
        return autoTableWidth * columnWidth / tableWidth;
      });
    }
  },
  _setColumnWidths: function _setColumnWidths(autoTableColumnStyles, pdfColumnWidths) {
    pdfColumnWidths.forEach(function (width, index) {
      autoTableColumnStyles[index] = autoTableColumnStyles[index] || {};
      autoTableColumnStyles[index].cellWidth = width;
    });
  }
};
exports.Export = Export;

/***/ }),

/***/ 83152:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportDataGrid = exportDataGrid;
var _type = __webpack_require__(35922);
var _export = __webpack_require__(18577);
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }
  if (!(0, _type.isDefined)(options.selectedRowsOnly)) {
    options.selectedRowsOnly = false;
  }
  return _export.Export.getFullOptions(options);
}
function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options));
}

/***/ }),

/***/ 66867:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addNewPage = addNewPage;
exports.drawCellsContent = drawCellsContent;
exports.drawCellsLines = drawCellsLines;
exports.drawGridLines = drawGridLines;
exports.drawLine = drawLine;
exports.drawRect = drawRect;
exports.drawTextInRect = drawTextInRect;
exports.getDocumentStyles = getDocumentStyles;
exports.roundToThreeDecimals = roundToThreeDecimals;
exports.setDocumentStyles = setDocumentStyles;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _pdf_utils = __webpack_require__(79262);
var _excluded = ["_rect", "gridCell"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function roundToThreeDecimals(value) {
  return Math.round(value * 1000) / 1000; // checked with browser zoom - 500%
}

function drawCellsContent(doc, customDrawCell, cellsArray, docStyles) {
  cellsArray.forEach(function (cell) {
    var _rect = cell._rect,
      gridCell = cell.gridCell,
      pdfCell = _objectWithoutProperties(cell, _excluded);
    var x = _rect.x,
      y = _rect.y,
      w = _rect.w,
      h = _rect.h;
    var rect = {
      x,
      y,
      w,
      h
    };
    var eventArg = {
      doc,
      rect,
      pdfCell,
      gridCell,
      cancel: false
    };
    customDrawCell === null || customDrawCell === void 0 ? void 0 : customDrawCell(eventArg);
    if (!eventArg.cancel) {
      drawCellBackground(doc, cell);
      drawCellText(doc, cell, docStyles);
    }
  });
}
function drawLine(doc, startX, startY, endX, endY) {
  doc.line(roundToThreeDecimals(startX), roundToThreeDecimals(startY), roundToThreeDecimals(endX), roundToThreeDecimals(endY));
}
function drawRect(doc, x, y, width, height, style) {
  if ((0, _type.isDefined)(style)) {
    doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height), style);
  } else {
    doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height));
  }
}
function getLineHeightShift(doc) {
  var DEFAULT_LINE_HEIGHT = 1.15;

  // TODO: check lineHeightFactor from text options. Currently supports only doc options - https://github.com/MrRio/jsPDF/issues/3234
  return (doc.getLineHeightFactor() - DEFAULT_LINE_HEIGHT) * doc.getFontSize();
}
function drawTextInRect(doc, text, rect, verticalAlign, horizontalAlign, jsPDFTextOptions) {
  var textArray = text.split('\n');
  var linesCount = textArray.length;
  var heightOfOneLine = (0, _pdf_utils.calculateTextHeight)(doc, textArray[0], doc.getFont(), {
    wordWrapEnabled: false,
    targetRectWidth: 1000000000
  });
  var vAlign = verticalAlign !== null && verticalAlign !== void 0 ? verticalAlign : 'middle';
  var hAlign = horizontalAlign !== null && horizontalAlign !== void 0 ? horizontalAlign : 'left';
  var verticalAlignCoefficientsMap = {
    top: 0,
    middle: 0.5,
    bottom: 1
  };
  var horizontalAlignMap = {
    left: 0,
    center: 0.5,
    right: 1
  };
  var y = rect.y + rect.h * verticalAlignCoefficientsMap[vAlign] - heightOfOneLine * (linesCount - 1) * verticalAlignCoefficientsMap[vAlign] + getLineHeightShift(doc);
  var x = rect.x + rect.w * horizontalAlignMap[hAlign];
  var textOptions = (0, _extend.extend)({
    baseline: vAlign,
    align: hAlign
  }, jsPDFTextOptions);
  doc.text(textArray.join('\n'), roundToThreeDecimals(x), roundToThreeDecimals(y), textOptions);
}
function drawCellBackground(doc, cell) {
  if ((0, _type.isDefined)(cell.backgroundColor)) {
    trySetColor(doc, 'fill', cell.backgroundColor);
    drawRect(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h, 'F');
  }
}
function drawCellText(doc, cell, docStyles) {
  if ((0, _type.isDefined)(cell.text) && cell.text !== '') {
    // TODO: use cell.text.trim() ?
    var textColor = cell.textColor,
      font = cell.font,
      _rect = cell._rect,
      padding = cell.padding;
    setTextStyles(doc, {
      textColor,
      font
    }, docStyles);
    var textRect = {
      x: _rect.x + padding.left,
      y: _rect.y + padding.top,
      w: _rect.w - (padding.left + padding.right),
      h: _rect.h - (padding.top + padding.bottom)
    };
    if ((0, _type.isDefined)(cell._textLeftOffset) || (0, _type.isDefined)(cell._textTopOffset)) {
      var _cell$_textLeftOffset, _cell$_textTopOffset;
      textRect.x = textRect.x + ((_cell$_textLeftOffset = cell._textLeftOffset) !== null && _cell$_textLeftOffset !== void 0 ? _cell$_textLeftOffset : 0);
      textRect.y = textRect.y + ((_cell$_textTopOffset = cell._textTopOffset) !== null && _cell$_textTopOffset !== void 0 ? _cell$_textTopOffset : 0);
      doc.saveGraphicsState(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#saveGraphicsState
      clipOutsideRectContent(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h);
    }
    drawTextInRect(doc, cell.text, textRect, cell.verticalAlign, cell.horizontalAlign, cell._internalTextOptions);
    if ((0, _type.isDefined)(cell._textLeftOffset) || (0, _type.isDefined)(cell._textTopOffset)) {
      doc.restoreGraphicsState(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#restoreGraphicsState
    }
  }
}

function drawCellsLines(doc, cellsArray, docStyles) {
  cellsArray.filter(function (cell) {
    return !(0, _type.isDefined)(cell.borderColor);
  }).forEach(function (cell) {
    drawBorders(doc, cell._rect, cell, docStyles);
  });
  cellsArray.filter(function (cell) {
    return (0, _type.isDefined)(cell.borderColor);
  }).forEach(function (cell) {
    drawBorders(doc, cell._rect, cell, docStyles);
  });
}
function drawGridLines(doc, rect, options, docStyles) {
  drawBorders(doc, rect, options, docStyles);
}
function drawBorders(doc, rect, _ref, docStyles) {
  var borderWidth = _ref.borderWidth,
    borderColor = _ref.borderColor,
    _ref$drawLeftBorder = _ref.drawLeftBorder,
    drawLeftBorder = _ref$drawLeftBorder === void 0 ? true : _ref$drawLeftBorder,
    _ref$drawRightBorder = _ref.drawRightBorder,
    drawRightBorder = _ref$drawRightBorder === void 0 ? true : _ref$drawRightBorder,
    _ref$drawTopBorder = _ref.drawTopBorder,
    drawTopBorder = _ref$drawTopBorder === void 0 ? true : _ref$drawTopBorder,
    _ref$drawBottomBorder = _ref.drawBottomBorder,
    drawBottomBorder = _ref$drawBottomBorder === void 0 ? true : _ref$drawBottomBorder;
  if (!(0, _type.isDefined)(rect)) {
    throw 'rect is required';
  }
  if (!drawLeftBorder && !drawRightBorder && !drawTopBorder && !drawBottomBorder) {
    return;
  } else if (drawLeftBorder && drawRightBorder && drawTopBorder && drawBottomBorder) {
    setLinesStyles(doc, {
      borderWidth,
      borderColor
    }, docStyles);
    drawRect(doc, rect.x, rect.y, rect.w, rect.h);
  } else {
    setLinesStyles(doc, {
      borderWidth,
      borderColor
    }, docStyles);
    if (drawTopBorder) {
      drawLine(doc, rect.x, rect.y, rect.x + rect.w, rect.y); // top
    }

    if (drawLeftBorder) {
      drawLine(doc, rect.x, rect.y, rect.x, rect.y + rect.h); // left
    }

    if (drawRightBorder) {
      drawLine(doc, rect.x + rect.w, rect.y, rect.x + rect.w, rect.y + rect.h); // right
    }

    if (drawBottomBorder) {
      drawLine(doc, rect.x, rect.y + rect.h, rect.x + rect.w, rect.y + rect.h); // bottom
    }
  }
}

function setTextStyles(doc, _ref2, docStyles) {
  var textColor = _ref2.textColor,
    font = _ref2.font;
  trySetColor(doc, 'text', (0, _type.isDefined)(textColor) ? textColor : docStyles.textColor);
  var currentFont = (0, _type.isDefined)(font) ? (0, _extend.extend)({}, docStyles.font, font) : docStyles.font;
  var docFont = doc.getFont();
  if (currentFont.name !== docFont.fontName || currentFont.style !== docFont.fontStyle || (0, _type.isDefined)(currentFont.weight) // fontWeight logic, https://raw.githack.com/MrRio/jsPDF/master/docs/jspdf.js.html#line4842
  ) {
    doc.setFont(currentFont.name, currentFont.style, currentFont.weight);
  }
  if (currentFont.size !== doc.getFontSize()) {
    doc.setFontSize(currentFont.size);
  }
}
function setLinesStyles(doc, _ref3, docStyles) {
  var borderWidth = _ref3.borderWidth,
    borderColor = _ref3.borderColor;
  var currentBorderWidth = (0, _type.isDefined)(borderWidth) ? borderWidth : docStyles.borderWidth;
  if (currentBorderWidth !== getDocBorderWidth(doc)) {
    setDocBorderWidth(doc, (0, _pdf_utils.toPdfUnit)(doc, currentBorderWidth));
  }
  trySetColor(doc, 'draw', (0, _type.isDefined)(borderColor) ? borderColor : docStyles.borderColor);
}
function trySetColor(doc, target, color) {
  var getterName = "get".concat(capitalizeFirstLetter(target), "Color");
  var setterName = "set".concat(capitalizeFirstLetter(target), "Color");
  var _color$ch = color.ch1,
    ch1 = _color$ch === void 0 ? color : _color$ch,
    ch2 = color.ch2,
    ch3 = color.ch3,
    ch4 = color.ch4;
  var normalizedColor = doc.__private__.decodeColorString(doc.__private__.encodeColorString({
    ch1,
    ch2,
    ch3,
    ch4,
    precision: target === 'text' ? 3 : 2
  }));
  if (normalizedColor !== doc[getterName]() || target === 'fill') {
    doc[setterName].apply(doc, [ch1, ch2, ch3, ch4].filter(function (item) {
      return item !== undefined;
    }));
  }
}
function getDocumentStyles(doc) {
  var docFont = doc.getFont();
  return {
    borderWidth: getDocBorderWidth(doc),
    borderColor: doc.getDrawColor(),
    font: {
      name: docFont.fontName,
      style: docFont.fontStyle,
      size: doc.getFontSize()
    },
    textColor: doc.getTextColor()
  };
}
function setDocumentStyles(doc, styles) {
  var borderWidth = styles.borderWidth,
    borderColor = styles.borderColor,
    font = styles.font,
    textColor = styles.textColor;
  var docFont = doc.getFont();
  if (docFont.fontName !== font.name || docFont.fontStyle !== font.style) {
    doc.setFont(font.name, font.style, undefined);
  }
  var docFontSize = doc.getFontSize();
  if (docFontSize !== font.size) {
    doc.setFontSize(font.size);
  }
  if (getDocBorderWidth(doc) !== borderWidth) {
    setDocBorderWidth(doc, borderWidth);
  }
  if (doc.getDrawColor() !== borderColor) {
    doc.setDrawColor(borderColor);
  }
  if (doc.getTextColor() !== textColor) {
    doc.setTextColor(textColor);
  }
}
function addNewPage(doc) {
  doc.addPage();
  resetDocBorderWidth(doc);
}
function getDocBorderWidth(doc) {
  var _doc$__borderWidth;
  // The 'getLineWidth' method was implemented in 2.5.0 version - https://github.com/parallax/jsPDF/pull/3324
  if ((0, _type.isDefined)(doc.getLineWidth)) {
    return doc.getLineWidth();
  }
  return (_doc$__borderWidth = doc.__borderWidth) !== null && _doc$__borderWidth !== void 0 ? _doc$__borderWidth : 0.200025; // // https://github.com/parallax/jsPDF/blob/a56c882e2c139e74a9adaea0baa78fb1386cbf23/src/jspdf.js#L4946
}

function setDocBorderWidth(doc, width) {
  doc.setLineWidth(width);

  // The 'getLineWidth' method was implemented in 2.5.0 version - https://github.com/parallax/jsPDF/pull/3324
  if (!(0, _type.isDefined)(doc.getLineWidth)) {
    doc.__borderWidth = width;
  }
}
function resetDocBorderWidth(doc) {
  if (!(0, _type.isDefined)(doc.getLineWidth)) {
    doc.__borderWidth = null;
  }
}
function clipOutsideRectContent(doc, x, y, w, h) {
  doc.moveTo(roundToThreeDecimals(x), roundToThreeDecimals(y)); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#moveTo - Begin a new subpath by moving the current point to coordinates (x, y)
  doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y)); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#lineTo - Append a straight line segment from the current point to the point (x, y)
  doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y + h));
  doc.lineTo(roundToThreeDecimals(x), roundToThreeDecimals(y + h));
  doc.clip(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#clip - Clip all outside path content after calling drawing ops
  doc.discardPath(); // http://raw.githack.com/MrRio/jsPDF/master/docs/jsPDF.html#discardPath - Consumes the current path without any effect. Mainly used in combination with clip or clipEvenOdd.
}

/***/ }),

/***/ 17195:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Export = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _normalizeOptions = __webpack_require__(30646);
var _row_utils = __webpack_require__(65322);
var _height_updater = __webpack_require__(41269);
var _rows_generator = __webpack_require__(27504);
var _rows_splitting = __webpack_require__(22775);
var _draw_utils = __webpack_require__(66867);
var _pdf_utils = __webpack_require__(79262);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _export_load_panel = __webpack_require__(5332);
var _window = __webpack_require__(58201);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _getFullOptions(options) {
  var jsPDFDocument = options.jsPDFDocument;
  var fullOptions = (0, _extend.extend)({}, options);
  if (!(0, _type.isDefined)(fullOptions.topLeft)) {
    fullOptions.topLeft = {
      x: 0,
      y: 0
    };
  }
  if (!(0, _type.isDefined)(fullOptions.indent)) {
    fullOptions.indent = 0;
  }
  if (!(0, _type.isDefined)(fullOptions.repeatHeaders)) {
    fullOptions.repeatHeaders = true;
  }
  if (!(0, _type.isDefined)(fullOptions.margin)) {
    fullOptions.margin = (0, _pdf_utils.toPdfUnit)(jsPDFDocument, 40);
  }
  fullOptions.margin = (0, _normalizeOptions.normalizeBoundaryValue)(fullOptions.margin);
  if (!Array.isArray(fullOptions.columnWidths)) {
    fullOptions.columnWidths = [];
  }
  if (!(0, _type.isDefined)(fullOptions.loadPanel)) {
    fullOptions.loadPanel = {};
  }
  if (!(0, _type.isDefined)(fullOptions.loadPanel.enabled)) {
    fullOptions.loadPanel.enabled = true;
  }
  if (!(0, _type.isDefined)(fullOptions.loadPanel.text)) {
    fullOptions.loadPanel.text = _message.default.format('dxDataGrid-exporting');
  }
  return fullOptions;
}
function exportDataGrid(options) {
  var _component$_getIntern;
  var jsPDFDocument = options.jsPDFDocument,
    component = options.component,
    selectedRowsOnly = options.selectedRowsOnly,
    loadPanel = options.loadPanel;
  var internalComponent = ((_component$_getIntern = component._getInternalInstance) === null || _component$_getIntern === void 0 ? void 0 : _component$_getIntern.call(component)) || component;
  var initialLoadPanelEnabledOption = internalComponent.option('loadPanel') && internalComponent.option('loadPanel').enabled;
  if (initialLoadPanelEnabledOption) {
    component.option('loadPanel.enabled', false);
  }
  var exportLoadPanel;
  if (loadPanel.enabled && (0, _window.hasWindow)()) {
    var rowsView = component.getView('rowsView');
    exportLoadPanel = new _export_load_panel.ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);
    exportLoadPanel.show();
  }
  var dataProvider = component.getDataProvider(selectedRowsOnly);
  return new Promise(function (resolve) {
    dataProvider.ready().done(function () {
      var _options$rowOptions, _options$rowOptions$h;
      // TODO: pass rowOptions: { headerStyles: { backgroundColor }, groupStyles: {...}, totalStyles: {...} }
      var rowsInfo = (0, _rows_generator.generateRowsInfo)(jsPDFDocument, dataProvider, component, (_options$rowOptions = options.rowOptions) === null || _options$rowOptions === void 0 ? void 0 : (_options$rowOptions$h = _options$rowOptions.headerStyles) === null || _options$rowOptions$h === void 0 ? void 0 : _options$rowOptions$h.backgroundColor);
      if (options.customizeCell) {
        rowsInfo.forEach(function (rowInfo) {
          return rowInfo.cells.forEach(function (cellInfo) {
            return options.customizeCell(cellInfo);
          });
        });
      }
      (0, _normalizeOptions.normalizeRowsInfo)(rowsInfo);

      // computes withs of the cells depending of the fullOptions
      (0, _row_utils.initializeCellsWidth)(jsPDFDocument, dataProvider, rowsInfo, options);

      // apply intends for correctly set width and colSpan for grouped rows
      (0, _row_utils.resizeFirstColumnByIndentLevel)(rowsInfo, options);

      // apply colSpans + recalculate cellsWidth
      (0, _row_utils.applyColSpans)(rowsInfo);

      // set/update/initCellHeight - autocalculate by text+width+wordWrapEnabled+padding or use value from customizeCell
      (0, _row_utils.calculateHeights)(jsPDFDocument, rowsInfo, options);

      // apply rowSpans + recalculate cells height
      (0, _row_utils.applyRowSpans)(rowsInfo);

      // when we know all rowSpans we can recalculate rowsHeight
      (0, _height_updater.updateRowsAndCellsHeights)(jsPDFDocument, rowsInfo);

      // when we known all sizes we can calculate all coordinates
      (0, _row_utils.calculateCoordinates)(jsPDFDocument, rowsInfo, options); // set/init/update 'pdfCell.top/left'

      // recalculate for grouped rows
      // TODO: applyGroupIndents()

      (0, _row_utils.applyBordersConfig)(rowsInfo);
      (0, _pdf_utils.applyWordWrap)(jsPDFDocument, rowsInfo);

      // splitting to pages
      // ?? TODO: Does split a cell which have an attribute 'colSpan/rowSpan > 0' into two cells and place the first cell on the first page and second cell on the second page. And show initial 'text' in the both new cells ??
      // TODO: applySplitting()

      var docStyles = (0, _draw_utils.getDocumentStyles)(jsPDFDocument);
      var rtlEnabled = !!component.option('rtlEnabled');
      var onSeparateRectHorizontally = function onSeparateRectHorizontally(_ref) {
        var _sourceRect$sourceCel;
        var sourceRect = _ref.sourceRect,
          leftRect = _ref.leftRect,
          rightRect = _ref.rightRect;
        var leftRectTextOptions = {};
        var rightRectTextOptions = {};
        var isTextNotEmpty = ((_sourceRect$sourceCel = sourceRect.sourceCellInfo.text) === null || _sourceRect$sourceCel === void 0 ? void 0 : _sourceRect$sourceCel.length) > 0;
        if (isTextNotEmpty) {
          if (rtlEnabled) {
            var isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;
            var isTextRightAlignment = !(0, _type.isDefined)(sourceRect.sourceCellInfo.horizontalAlign) || sourceRect.sourceCellInfo.horizontalAlign === 'right';
            if (isTextWidthGreaterThanRect || !isTextRightAlignment) {
              var _sourceRect$sourceCel2, _sourceRect$sourceCel4, _sourceRect$sourceCel5;
              var rightRectTextOffset;
              var leftRectTextOffset;
              if (((_sourceRect$sourceCel2 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel2 === void 0 ? void 0 : _sourceRect$sourceCel2.horizontalAlign) === 'right') {
                var _sourceRect$sourceCel3;
                rightRectTextOffset = (_sourceRect$sourceCel3 = sourceRect.sourceCellInfo._textLeftOffset) !== null && _sourceRect$sourceCel3 !== void 0 ? _sourceRect$sourceCel3 : 0;
                leftRectTextOffset = rightRectTextOffset + leftRect.w;
              } else if (((_sourceRect$sourceCel4 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel4 === void 0 ? void 0 : _sourceRect$sourceCel4.horizontalAlign) === 'center') {
                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w) + sourceRect.sourceCellInfo._rect.w / 2 - leftRect.w / 2;
                rightRectTextOffset = leftRectTextOffset - rightRect.w;
              } else if (((_sourceRect$sourceCel5 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel5 === void 0 ? void 0 : _sourceRect$sourceCel5.horizontalAlign) === 'left') {
                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w);
                rightRectTextOffset = leftRectTextOffset - rightRect.w;
              }
              leftRectTextOptions = _extends({}, {
                _textLeftOffset: rightRectTextOffset
              });
              rightRectTextOptions = _extends({}, {
                _textLeftOffset: leftRectTextOffset
              });
            } else {
              rightRectTextOptions = _extends({}, {
                text: ''
              });
            }
          } else {
            var _isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;
            var isTextLeftAlignment = !(0, _type.isDefined)(sourceRect.sourceCellInfo.horizontalAlign) || sourceRect.sourceCellInfo.horizontalAlign === 'left';
            if (_isTextWidthGreaterThanRect || !isTextLeftAlignment) {
              var _sourceRect$sourceCel6, _sourceRect$sourceCel8, _sourceRect$sourceCel10;
              var leftTextLeftOffset;
              var rightTextLeftOffset;
              if (((_sourceRect$sourceCel6 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel6 === void 0 ? void 0 : _sourceRect$sourceCel6.horizontalAlign) === 'left') {
                var _sourceRect$sourceCel7;
                leftTextLeftOffset = (_sourceRect$sourceCel7 = sourceRect.sourceCellInfo._textLeftOffset) !== null && _sourceRect$sourceCel7 !== void 0 ? _sourceRect$sourceCel7 : 0;
                rightTextLeftOffset = leftTextLeftOffset - leftRect.w;
              } else if (((_sourceRect$sourceCel8 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel8 === void 0 ? void 0 : _sourceRect$sourceCel8.horizontalAlign) === 'center') {
                var _sourceRect$sourceCel9;
                var offset = (_sourceRect$sourceCel9 = sourceRect.sourceCellInfo._textLeftOffset) !== null && _sourceRect$sourceCel9 !== void 0 ? _sourceRect$sourceCel9 : 0;
                leftTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (leftRect.x + leftRect.w / 2);
                rightTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (rightRect.x + rightRect.w / 2);
              } else if (((_sourceRect$sourceCel10 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel10 === void 0 ? void 0 : _sourceRect$sourceCel10.horizontalAlign) === 'right') {
                leftTextLeftOffset = sourceRect.x + sourceRect.w - (leftRect.x + leftRect.w);
                rightTextLeftOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w);
              }
              leftRectTextOptions = _extends({}, {
                _textLeftOffset: leftTextLeftOffset
              });
              rightRectTextOptions = _extends({}, {
                _textLeftOffset: rightTextLeftOffset
              });
            } else {
              rightRectTextOptions = _extends({}, {
                text: ''
              });
            }
          }
        }
        leftRect.sourceCellInfo = _extends({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, leftRectTextOptions);
        rightRect.sourceCellInfo = _extends({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, rightRectTextOptions);
      };
      var onSeparateRectVertically = function onSeparateRectVertically(_ref2) {
        var _sourceRect$sourceCel11;
        var sourceRect = _ref2.sourceRect,
          topRect = _ref2.topRect,
          bottomRect = _ref2.bottomRect;
        var topRectTextOptions = {};
        var bottomRectTextOptions = {};
        var isTextNotEmpty = ((_sourceRect$sourceCel11 = sourceRect.sourceCellInfo.text) === null || _sourceRect$sourceCel11 === void 0 ? void 0 : _sourceRect$sourceCel11.length) > 0;
        if (isTextNotEmpty) {
          var _sourceRect$sourceCel12;
          var isTextHeightGreaterThanRect = jsPDFDocument.getTextDimensions(sourceRect.sourceCellInfo.text).h > topRect.h;
          var isTextTopAlignment = ((_sourceRect$sourceCel12 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel12 === void 0 ? void 0 : _sourceRect$sourceCel12.verticalAlign) === 'top';
          if (isTextHeightGreaterThanRect || !isTextTopAlignment) {
            var _sourceRect$sourceCel13, _sourceRect$sourceCel15, _sourceRect$sourceCel17;
            var topTextTopOffset;
            var bottomTextTopOffset;
            if (((_sourceRect$sourceCel13 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel13 === void 0 ? void 0 : _sourceRect$sourceCel13.verticalAlign) === 'top') {
              var _sourceRect$sourceCel14;
              topTextTopOffset = (_sourceRect$sourceCel14 = sourceRect.sourceCellInfo._textTopOffset) !== null && _sourceRect$sourceCel14 !== void 0 ? _sourceRect$sourceCel14 : 0;
              bottomTextTopOffset = topTextTopOffset - topRect.h;
            } else if (((_sourceRect$sourceCel15 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel15 === void 0 ? void 0 : _sourceRect$sourceCel15.verticalAlign) === 'middle') {
              var _sourceRect$sourceCel16;
              var offset = (_sourceRect$sourceCel16 = sourceRect.sourceCellInfo._textTopOffset) !== null && _sourceRect$sourceCel16 !== void 0 ? _sourceRect$sourceCel16 : 0;
              topTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (topRect.y + topRect.h / 2);
              bottomTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (bottomRect.y + bottomRect.h / 2);
            } else if (((_sourceRect$sourceCel17 = sourceRect.sourceCellInfo) === null || _sourceRect$sourceCel17 === void 0 ? void 0 : _sourceRect$sourceCel17.verticalAlign) === 'bottom') {
              topTextTopOffset = sourceRect.y + sourceRect.h - (topRect.y + topRect.h);
              bottomTextTopOffset = sourceRect.y + sourceRect.h - (bottomRect.y + bottomRect.h);
            }
            topRectTextOptions = _extends({}, {
              _textTopOffset: topTextTopOffset
            });
            bottomRectTextOptions = _extends({}, {
              _textTopOffset: bottomTextTopOffset
            });
          } else {
            bottomRectTextOptions = _extends({}, {
              text: ''
            });
          }
        }
        topRect.sourceCellInfo = _extends({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, topRectTextOptions);
        bottomRect.sourceCellInfo = _extends({}, sourceRect.sourceCellInfo, {
          debugSourceCellInfo: sourceRect.sourceCellInfo
        }, bottomRectTextOptions);
      };
      var rectsByPages = (0, _rows_splitting.splitByPages)(jsPDFDocument, rowsInfo, options, onSeparateRectHorizontally, onSeparateRectVertically);
      if (rtlEnabled) {
        (0, _pdf_utils.applyRtl)(jsPDFDocument, rectsByPages, options);
      }
      rectsByPages.forEach(function (pdfCellsInfo, index) {
        if (index > 0) {
          (0, _draw_utils.addNewPage)(jsPDFDocument);
        }
        (0, _draw_utils.drawCellsContent)(jsPDFDocument, options.customDrawCell, pdfCellsInfo, docStyles);
        (0, _draw_utils.drawCellsLines)(jsPDFDocument, pdfCellsInfo, docStyles);
        var isEmptyPdfCellsInfoSpecified = (0, _type.isDefined)(pdfCellsInfo) && pdfCellsInfo.length === 0;
        if (isEmptyPdfCellsInfoSpecified) {
          var tableRect = (0, _row_utils.calculateTableSize)(jsPDFDocument, pdfCellsInfo, options); // TODO: after splitting to pages we need get 'rowsInfo' for selected table in the page
          var baseStyle = (0, _rows_generator.getBaseTableStyle)();
          (0, _draw_utils.drawGridLines)(jsPDFDocument, tableRect, baseStyle, docStyles);
        }
      });
      (0, _draw_utils.setDocumentStyles)(jsPDFDocument, docStyles);
      resolve();
    }).always(function () {
      if (initialLoadPanelEnabledOption) {
        component.option('loadPanel.enabled', initialLoadPanelEnabledOption);
      }
      if (loadPanel.enabled && (0, _window.hasWindow)()) {
        exportLoadPanel.dispose();
      }
    });
  });
}
var Export = {
  getFullOptions: _getFullOptions,
  export: exportDataGrid
};
exports.Export = Export;

/***/ }),

/***/ 41269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.updateRowsAndCellsHeights = updateRowsAndCellsHeights;
var _type = __webpack_require__(35922);
var _pdf_utils = __webpack_require__(79262);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function updateRowsAndCellsHeights(doc, rows) {
  var rowsAdditionalHeights = calculateAdditionalRowsHeights(doc, rows);
  rows.forEach(function (row) {
    row.height += rowsAdditionalHeights[row.rowIndex];
  });
  rows.forEach(function (row) {
    row.cells.forEach(function (cell) {
      var _cell$rowSpan;
      var rowsCount = ((_cell$rowSpan = cell.rowSpan) !== null && _cell$rowSpan !== void 0 ? _cell$rowSpan : 0) + 1;
      cell.pdfCell._rect.h = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce(function (accumulator, rowInfo) {
        return accumulator + rowInfo.height;
      }, 0);
    });
  });
}
function calculateAdditionalRowsHeights(doc, rows) {
  var rowsAdditionalHeights = Array.from({
    length: rows.length
  }, function () {
    return 0;
  });
  var sortedRows = sortRowsByMaxRowSpanAsc(rows);
  sortedRows.forEach(function (row) {
    var cellsWithRowSpan = row.cells.filter(function (cell) {
      return (0, _type.isDefined)(cell.rowSpan);
    });
    cellsWithRowSpan.forEach(function (cell) {
      var targetRectWidth = (0, _pdf_utils.calculateTargetRectWidth)(cell.pdfCell._rect.w, cell.pdfCell.padding);
      var textHeight = (0, _pdf_utils.calculateTextHeight)(doc, cell.pdfCell.text, cell.pdfCell.font, {
        wordWrapEnabled: cell.pdfCell.wordWrapEnabled,
        targetRectWidth
      });
      var cellHeight = textHeight + cell.pdfCell.padding.top + cell.pdfCell.padding.bottom;
      var rowsCount = cell.rowSpan + 1;
      var currentRowSpanRowsHeight = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce(function (accumulator, rowInfo) {
        return accumulator + rowInfo.height + rowsAdditionalHeights[rowInfo.rowIndex];
      }, 0);
      if (cellHeight > currentRowSpanRowsHeight) {
        var delta = (cellHeight - currentRowSpanRowsHeight) / rowsCount;
        for (var spanIndex = row.rowIndex; spanIndex < row.rowIndex + rowsCount; spanIndex++) {
          rowsAdditionalHeights[spanIndex] += delta;
        }
      }
    });
  });
  return rowsAdditionalHeights;
}
function sortRowsByMaxRowSpanAsc(rows) {
  var getMaxRowSpan = function getMaxRowSpan(row) {
    var spansArray = row.cells.map(function (cell) {
      var _cell$rowSpan2;
      return (_cell$rowSpan2 = cell.rowSpan) !== null && _cell$rowSpan2 !== void 0 ? _cell$rowSpan2 : 0;
    });
    return Math.max.apply(Math, _toConsumableArray(spansArray));
  };
  var sortByMaxRowSpan = function sortByMaxRowSpan(row1, row2) {
    var row1RowSpan = getMaxRowSpan(row1);
    var row2RowSpan = getMaxRowSpan(row2);
    if (row1RowSpan > row2RowSpan) {
      return 1;
    }
    if (row2RowSpan > row1RowSpan) {
      return -1;
    }
    return 0;
  };
  return _toConsumableArray(rows).sort(sortByMaxRowSpan);
}

/***/ }),

/***/ 30646:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.normalizeBoundaryValue = normalizeBoundaryValue;
exports.normalizeRowsInfo = normalizeRowsInfo;
var _type = __webpack_require__(35922);
function normalizeBoundaryValue(value) {
  var _value$top, _value$right, _value$bottom, _value$left;
  if ((0, _type.isNumeric)(value)) {
    return {
      top: value,
      right: value,
      bottom: value,
      left: value
    };
  }
  return {
    top: (_value$top = value === null || value === void 0 ? void 0 : value.top) !== null && _value$top !== void 0 ? _value$top : 0,
    right: (_value$right = value === null || value === void 0 ? void 0 : value.right) !== null && _value$right !== void 0 ? _value$right : 0,
    bottom: (_value$bottom = value === null || value === void 0 ? void 0 : value.bottom) !== null && _value$bottom !== void 0 ? _value$bottom : 0,
    left: (_value$left = value === null || value === void 0 ? void 0 : value.left) !== null && _value$left !== void 0 ? _value$left : 0
  };
}
function normalizeRowsInfo(rowsInfo) {
  rowsInfo.forEach(function (row) {
    row.cells.forEach(function (_ref) {
      var pdfCell = _ref.pdfCell;
      pdfCell.padding = normalizeBoundaryValue(pdfCell.padding);
    });
  });
}

/***/ }),

/***/ 79262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.applyRtl = applyRtl;
exports.applyWordWrap = applyWordWrap;
exports.calculateRowHeight = calculateRowHeight;
exports.calculateTargetRectWidth = calculateTargetRectWidth;
exports.calculateTextHeight = calculateTextHeight;
exports.getPageHeight = getPageHeight;
exports.getPageWidth = getPageWidth;
exports.getTextDimensions = getTextDimensions;
exports.getTextLines = getTextLines;
exports.toPdfUnit = toPdfUnit;
var _type = __webpack_require__(35922);
var DOTS_TEXT = '...';
function toPdfUnit(doc, value) {
  var defaultScaleFactor = 1; // https://github.com/parallax/jsPDF/blob/master/src/jspdf.js#L3212
  var coefficient = defaultScaleFactor / doc.internal.scaleFactor;
  return value * coefficient;
}
function getPageWidth(doc) {
  return doc.internal.pageSize.getWidth();
}
function getPageHeight(doc) {
  return doc.internal.pageSize.getHeight();
}
function getTextLines(doc, text, font, _ref) {
  var wordWrapEnabled = _ref.wordWrapEnabled,
    targetRectWidth = _ref.targetRectWidth;
  if (wordWrapEnabled) {
    var usedFont = doc.getFont(font === null || font === void 0 ? void 0 : font.name, font === null || font === void 0 ? void 0 : font.style);
    return doc.splitTextToSize(text, targetRectWidth, {
      fontSize: (font === null || font === void 0 ? void 0 : font.size) || doc.getFontSize(),
      fontName: usedFont.fontName,
      fontStyle: usedFont.fontStyle
    });
  }
  var textWithoutLineBreak = text.split('\n').filter(function (ch) {
    return ch !== '';
  }).join(' ');
  if (getTextDimensions(doc, textWithoutLineBreak, font).w <= targetRectWidth) {
    return [textWithoutLineBreak];
  }
  var textWidth = getTextDimensions(doc, textWithoutLineBreak + DOTS_TEXT, font).w;
  while (textWithoutLineBreak.length > 0 && textWidth > targetRectWidth) {
    var symbolsCountToRemove = 0;
    if (textWidth >= targetRectWidth * 2) {
      symbolsCountToRemove = textWithoutLineBreak.length / 2;
    }
    if (symbolsCountToRemove < 1) {
      symbolsCountToRemove = 1;
    }
    textWithoutLineBreak = textWithoutLineBreak.substring(0, textWithoutLineBreak.length - symbolsCountToRemove);
    textWidth = getTextDimensions(doc, textWithoutLineBreak + DOTS_TEXT, font).w;
  }
  return [textWithoutLineBreak + DOTS_TEXT];
}
function calculateTargetRectWidth(columnWidth, padding) {
  var width = columnWidth - (padding.left + padding.right);
  return width >= 0 ? width : 0;
}
function getTextDimensions(doc, text, font) {
  return doc.getTextDimensions(text, {
    font: doc.getFont(font === null || font === void 0 ? void 0 : font.name, font === null || font === void 0 ? void 0 : font.style),
    fontSize: (font === null || font === void 0 ? void 0 : font.size) || doc.getFontSize()
  });
}
function calculateTextHeight(doc, text, font, _ref2) {
  var wordWrapEnabled = _ref2.wordWrapEnabled,
    targetRectWidth = _ref2.targetRectWidth;
  var heightOfOneLine = getTextDimensions(doc, text, font).h;
  var linesCount = getTextLines(doc, text, font, {
    wordWrapEnabled,
    targetRectWidth
  }).length;
  return heightOfOneLine * linesCount * doc.getLineHeightFactor();
}
function calculateRowHeight(doc, cells, columnWidths) {
  if (cells.length !== columnWidths.length) {
    throw 'the cells count must be equal to the count of the columns';
  }
  var rowHeight = 0;
  for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
    if ((0, _type.isDefined)(cells[cellIndex].rowSpan)) {
      // height will be computed at the recalculateHeightForMergedRows step
      continue;
    }
    var cellText = cells[cellIndex].pdfCell.text;
    var cellPadding = cells[cellIndex].pdfCell.padding;
    var font = cells[cellIndex].pdfCell.font;
    var wordWrapEnabled = cells[cellIndex].pdfCell.wordWrapEnabled;
    var columnWidth = columnWidths[cellIndex];
    var targetRectWidth = calculateTargetRectWidth(columnWidth, cellPadding);
    if ((0, _type.isDefined)(cellText)) {
      var textHeight = cellText !== '' ? calculateTextHeight(doc, cellText, font, {
        wordWrapEnabled,
        targetRectWidth
      }) : 0;
      var cellHeight = textHeight + cellPadding.top + cellPadding.bottom;
      if (rowHeight < cellHeight) {
        rowHeight = cellHeight;
      }
    }
  }
  return rowHeight;
}
function applyWordWrap(doc, rowsInfo) {
  rowsInfo.forEach(function (row) {
    row.cells.forEach(function (_ref3) {
      var pdfCell = _ref3.pdfCell;
      if ((0, _type.isDefined)(pdfCell.text)) {
        var lines = getTextLines(doc, pdfCell.text, pdfCell.font, {
          wordWrapEnabled: pdfCell.wordWrapEnabled,
          targetRectWidth: calculateTargetRectWidth(pdfCell._rect.w, pdfCell.padding)
        });
        pdfCell.text = lines.join('\n');
      }
    });
  });
}
function applyRtl(doc, rectsByPages, options) {
  rectsByPages.forEach(function (pageRects) {
    pageRects.forEach(function (pdfCell) {
      var mirroredX = getPageWidth(doc) - (pdfCell._rect.x + pdfCell._rect.w);
      var marginDiff = options.margin.left - options.margin.right;
      pdfCell._rect.x = mirroredX + marginDiff;
    });
  });
}

/***/ }),

/***/ 65322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.applyBordersConfig = applyBordersConfig;
exports.applyColSpans = applyColSpans;
exports.applyRowSpans = applyRowSpans;
exports.calculateCoordinates = calculateCoordinates;
exports.calculateHeights = calculateHeights;
exports.calculateTableSize = calculateTableSize;
exports.initializeCellsWidth = initializeCellsWidth;
exports.resizeFirstColumnByIndentLevel = resizeFirstColumnByIndentLevel;
var _type = __webpack_require__(35922);
var _pdf_utils = __webpack_require__(79262);
var getSum = function getSum(a, b) {
  return a + b;
};
function calculateColumnWidths(doc, dataProvider, topLeftX, margin, customerColumnWidths) {
  var DEFAULT_WIDTH = 150;
  var resultWidths = dataProvider.getColumnsWidths().map(function (width) {
    return (0, _pdf_utils.toPdfUnit)(doc, width !== null && width !== void 0 ? width : DEFAULT_WIDTH);
  });
  var totalAutoColumnsWidth = resultWidths.filter(function (width, index) {
    return !(0, _type.isDefined)(customerColumnWidths[index]);
  }).reduce(getSum, 0);
  var totalCustomerColumnsWidth = customerColumnWidths.filter(function (width) {
    return (0, _type.isNumeric)(width);
  }).reduce(getSum, 0);
  var availablePageWidth = getAvailablePageAreaWidth(doc, topLeftX, margin);
  var ratio = totalCustomerColumnsWidth < availablePageWidth ? (availablePageWidth - totalCustomerColumnsWidth) / totalAutoColumnsWidth : 1;
  return resultWidths.map(function (width, index) {
    var _customerColumnWidths;
    return (_customerColumnWidths = customerColumnWidths[index]) !== null && _customerColumnWidths !== void 0 ? _customerColumnWidths : width * ratio;
  });
}
function getAvailablePageAreaWidth(doc, topLeftX, margin) {
  return (0, _pdf_utils.getPageWidth)(doc) - topLeftX - margin.left - margin.right;
}
function initializeCellsWidth(doc, dataProvider, rows, options) {
  var columnWidths = calculateColumnWidths(doc, dataProvider, options.topLeft.x, options.margin, options.columnWidths);
  rows.forEach(function (row) {
    row.cells.forEach(function (_ref, index) {
      var gridCell = _ref.gridCell,
        pdfCell = _ref.pdfCell;
      pdfCell._rect.w = columnWidths[index];
    });
  });
}
function calculateHeights(doc, rows, options) {
  rows.forEach(function (row) {
    var pdfCells = row.cells.map(function (c) {
      return c.pdfCell;
    });
    var customerHeight;
    if (options.onRowExporting) {
      var args = {
        rowCells: pdfCells
      };
      options.onRowExporting(args);
      if ((0, _type.isDefined)(args.rowHeight)) {
        customerHeight = args.rowHeight;
      }
    }
    row.height = (0, _type.isDefined)(customerHeight) ? customerHeight : (0, _pdf_utils.calculateRowHeight)(doc, row.cells, pdfCells.map(function (c) {
      return c._rect.w;
    }));
    pdfCells.forEach(function (cell) {
      cell._rect.h = row.height;
    });
  });
}
function applyColSpans(rows) {
  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var row = rows[rowIndex];
    for (var cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {
      var cell = row.cells[cellIndex];
      if ((0, _type.isDefined)(cell.colSpan) && !(0, _type.isDefined)(cell.pdfCell.isMerged)) {
        for (var spanIndex = 1; spanIndex <= cell.colSpan; spanIndex++) {
          var mergedCell = rows[rowIndex].cells[cellIndex + spanIndex];
          cell.pdfCell._rect.w += mergedCell.pdfCell._rect.w;
          mergedCell.pdfCell._rect.w = 0;
          mergedCell.pdfCell.isMerged = true;
        }
      }
    }
  }
}
function applyRowSpans(rows) {
  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var row = rows[rowIndex];
    for (var cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {
      var cell = row.cells[cellIndex];
      if ((0, _type.isDefined)(cell.rowSpan) && !(0, _type.isDefined)(cell.pdfCell.isMerged)) {
        for (var spanIndex = 1; spanIndex <= cell.rowSpan; spanIndex++) {
          var mergedCell = rows[rowIndex + spanIndex].cells[cellIndex];
          cell.pdfCell._rect.h += mergedCell.pdfCell._rect.h;
          mergedCell.pdfCell._rect.h = 0;
          mergedCell.pdfCell.isMerged = true;
        }
      }
    }
  }
}
function resizeFirstColumnByIndentLevel(rows, options) {
  rows.forEach(function (row) {
    row.cells[0].pdfCell._rect.w -= row.indentLevel * options.indent;
  });
}
function applyBordersConfig(rows) {
  for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    var cells = rows[rowIndex].cells;
    for (var columnIndex = 0; columnIndex < cells.length; columnIndex++) {
      var pdfCell = cells[columnIndex].pdfCell;
      var leftPdfCell = columnIndex >= 1 ? cells[columnIndex - 1].pdfCell : null;
      var topPdfCell = rowIndex >= 1 ? rows[rowIndex - 1].cells[columnIndex].pdfCell : null;
      if (pdfCell.drawLeftBorder === false && !(0, _type.isDefined)(cells[columnIndex].colSpan)) {
        // TODO: Check this logic after implementing splitting to pages
        if ((0, _type.isDefined)(leftPdfCell)) {
          leftPdfCell.drawRightBorder = false;
        }
      } else if (!(0, _type.isDefined)(pdfCell.drawLeftBorder)) {
        if ((0, _type.isDefined)(leftPdfCell) && leftPdfCell.drawRightBorder === false) {
          pdfCell.drawLeftBorder = false;
        }
      }
      if (pdfCell.drawTopBorder === false) {
        if ((0, _type.isDefined)(topPdfCell)) {
          topPdfCell.drawBottomBorder = false;
        }
      } else if (!(0, _type.isDefined)(pdfCell.drawTopBorder)) {
        if ((0, _type.isDefined)(topPdfCell) && topPdfCell.drawBottomBorder === false) {
          pdfCell.drawTopBorder = false;
        }
      }
    }
  }
}
function calculateCoordinates(doc, rows, options) {
  var _topLeft$y;
  var topLeft = options === null || options === void 0 ? void 0 : options.topLeft;
  var margin = options === null || options === void 0 ? void 0 : options.margin;
  var y = ((_topLeft$y = topLeft === null || topLeft === void 0 ? void 0 : topLeft.y) !== null && _topLeft$y !== void 0 ? _topLeft$y : 0) + margin.top;
  rows.forEach(function (row) {
    var _topLeft$x;
    var x = ((_topLeft$x = topLeft === null || topLeft === void 0 ? void 0 : topLeft.x) !== null && _topLeft$x !== void 0 ? _topLeft$x : 0) + margin.left;
    var intend = row.indentLevel * options.indent;
    row.cells.forEach(function (cell) {
      cell.pdfCell._rect.x = x + intend;
      cell.pdfCell._rect.y = y;
      x += cell.pdfCell._rect.w;
    });
    y += row.height;
  });
}
function calculateTableSize(doc, cells, options) {
  var _ref2, _leftPos, _options$topLeft, _ref3, _topPos, _options$topLeft2;
  var leftPos;
  var topPos;
  var rightPos;
  var bottomPos;
  cells.forEach(function (cell) {
    if (!(0, _type.isDefined)(leftPos) || leftPos > cell._rect.x) {
      leftPos = cell._rect.x;
    }
    if (!(0, _type.isDefined)(topPos) || topPos > cell._rect.y) {
      topPos = cell._rect.y;
    }
    if (!(0, _type.isDefined)(rightPos) || rightPos < cell._rect.x + cell._rect.w) {
      rightPos = cell._rect.x + cell._rect.w;
    }
    if (!(0, _type.isDefined)(bottomPos) || bottomPos < cell._rect.y + cell._rect.h) {
      bottomPos = cell._rect.y + cell._rect.h;
    }
  });
  var x = (_ref2 = (_leftPos = leftPos) !== null && _leftPos !== void 0 ? _leftPos : options === null || options === void 0 ? void 0 : (_options$topLeft = options.topLeft) === null || _options$topLeft === void 0 ? void 0 : _options$topLeft.x) !== null && _ref2 !== void 0 ? _ref2 : 0;
  var y = (_ref3 = (_topPos = topPos) !== null && _topPos !== void 0 ? _topPos : options === null || options === void 0 ? void 0 : (_options$topLeft2 = options.topLeft) === null || _options$topLeft2 === void 0 ? void 0 : _options$topLeft2.y) !== null && _ref3 !== void 0 ? _ref3 : 0;
  var w = (0, _type.isDefined)(rightPos) ? rightPos - x : 0;
  var h = (0, _type.isDefined)(bottomPos) ? bottomPos - y : 0;
  return {
    x,
    y,
    w,
    h
  };
}

/***/ }),

/***/ 27504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.generateRowsInfo = generateRowsInfo;
exports.getBaseTableStyle = getBaseTableStyle;
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91500));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _pdf_utils = __webpack_require__(79262);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var defaultStyles = {
  base: {
    font: {
      size: 10
    },
    borderWidth: 0.5,
    borderColor: '#979797'
  },
  header: {
    textColor: '#979797'
  },
  group: {},
  data: {},
  groupFooter: {},
  totalFooter: {}
};
function generateRowsInfo(doc, dataProvider, dataGrid, headerBackgroundColor) {
  var result = [];
  var rowsCount = dataProvider.getRowsCount();
  var wordWrapEnabled = !!dataGrid.option('wordWrapEnabled');
  var rtlEnabled = !!dataGrid.option('rtlEnabled');
  var columns = dataProvider.getColumns();
  var styles = dataProvider.getStyles();
  for (var rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
    var rowType = dataProvider.getCellData(rowIndex, 0, true).cellSourceData.rowType;
    var indentLevel = rowType !== 'header' ? dataProvider.getGroupLevel(rowIndex) : 0;
    var previousRow = result[rowIndex - 1];
    if (rowType === 'groupFooter' && (previousRow === null || previousRow === void 0 ? void 0 : previousRow.rowType) === 'groupFooter') {
      indentLevel = previousRow.indentLevel - 1;
    }
    result.push({
      rowType: rowType,
      indentLevel,
      cells: generateRowCells({
        doc,
        dataProvider,
        rowIndex,
        wordWrapEnabled,
        columns,
        styles,
        rowType,
        backgroundColor: rowType === 'header' ? headerBackgroundColor : undefined,
        rtlEnabled
      }),
      rowIndex
    });
  }
  return result;
}
function generateRowCells(_ref) {
  var doc = _ref.doc,
    dataProvider = _ref.dataProvider,
    rowIndex = _ref.rowIndex,
    wordWrapEnabled = _ref.wordWrapEnabled,
    columns = _ref.columns,
    styles = _ref.styles,
    rowType = _ref.rowType,
    backgroundColor = _ref.backgroundColor,
    rtlEnabled = _ref.rtlEnabled;
  var result = [];
  for (var cellIndex = 0; cellIndex < columns.length; cellIndex++) {
    var _style$alignment;
    var cellData = dataProvider.getCellData(rowIndex, cellIndex, true);
    var cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];
    var style = getPdfCellStyle(columns[cellIndex], rowType, cellStyle);
    var defaultAlignment = rtlEnabled ? 'right' : 'left';
    var paddingValue = (0, _pdf_utils.toPdfUnit)(doc, 5);
    var pdfCell = {
      text: getFormattedValue(cellData.value, cellStyle.format),
      verticalAlign: 'middle',
      horizontalAlign: (_style$alignment = style.alignment) !== null && _style$alignment !== void 0 ? _style$alignment : defaultAlignment,
      wordWrapEnabled,
      backgroundColor,
      padding: {
        top: paddingValue,
        right: paddingValue,
        bottom: paddingValue,
        left: paddingValue
      },
      _rect: {},
      _internalTextOptions: {}
    };
    if (rtlEnabled) {
      // https://github.com/parallax/jsPDF/issues/2235
      pdfCell._internalTextOptions.isInputVisual = false;
      pdfCell._internalTextOptions.isOutputVisual = true;
      pdfCell._internalTextOptions.isInputRtl = true;
      pdfCell._internalTextOptions.isOutputRtl = false;
    }
    var cellInfo = {
      gridCell: cellData.cellSourceData,
      pdfCell: _extends({}, pdfCell, style)
    };
    if (rowType === 'header') {
      var cellMerging = dataProvider.getCellMerging(rowIndex, cellIndex);
      if (cellMerging && cellMerging.rowspan > 0) {
        cellInfo.rowSpan = cellMerging.rowspan;
      }
      if (cellMerging && cellMerging.colspan > 0) {
        cellInfo.colSpan = cellMerging.colspan;
      }
    } else if (rowType === 'group') {
      var drawLeftBorderField = rtlEnabled ? 'drawRightBorder' : 'drawLeftBorder';
      var drawRightBorderField = rtlEnabled ? 'drawLeftBorder' : 'drawRightBorder';
      cellInfo.pdfCell[drawLeftBorderField] = cellIndex === 0;
      cellInfo.pdfCell[drawRightBorderField] = cellIndex === columns.length - 1;
      if (cellIndex > 0) {
        var isEmptyCellsExceptFirst = result.slice(1).reduce(function (accumulate, cellInfo) {
          return accumulate && !(0, _type.isDefined)(cellInfo.pdfCell.text);
        }, true);
        if (!(0, _type.isDefined)(cellInfo.pdfCell.text) && isEmptyCellsExceptFirst) {
          result[0].pdfCell[drawRightBorderField] = true;
          for (var i = 0; i < result.length; i++) {
            result[i].colSpan = result.length;
          }
          cellInfo.colSpan = result.length;
        }
      }
    }
    result.push(cellInfo);
  }
  return result;
}
function getBaseTableStyle() {
  return defaultStyles['base'];
}
function getPdfCellStyle(column, rowType, cellStyle) {
  var styles = _extends({}, defaultStyles['base'], defaultStyles[rowType]);
  var alignment = rowType === 'header' ? column.alignment : cellStyle.alignment;
  if (alignment) {
    styles.alignment = alignment;
  }
  if (cellStyle.bold && rowType !== 'header') {
    styles.font = _extends({}, styles.font, {
      style: 'bold'
    });
  }
  return styles;
}
function getFormattedValue(value, format) {
  if ((0, _type.isDefined)(format)) {
    if ((0, _type.isDate)(value)) {
      return _date.default.format(value, format);
    }
    if ((0, _type.isNumeric)(value)) {
      return _number.default.format(value, format);
    }
  }
  return value === null || value === void 0 ? void 0 : value.toString();
}

/***/ }),

/***/ 72666:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createOnSplitMultiPageRow = void 0;
var _pdf_utils = __webpack_require__(79262);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function createMultiCellRect(rect, text, marginTop) {
  return _extends({}, rect, {
    sourceCellInfo: _extends({}, rect.sourceCellInfo, {
      text
    }),
    y: marginTop
  });
}
var createOnSplitMultiPageRow = function createOnSplitMultiPageRow(doc, options, headerHeight, maxBottomRight) {
  return function (isFirstPage, pageRects) {
    var currentPageRects = [];
    var nextPageRects = [];
    var maxCurrentPageHeight = 0;
    var maxNextPageHeight = 0;
    pageRects.forEach(function (rect) {
      var w = rect.w,
        sourceCellInfo = rect.sourceCellInfo;
      var additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : headerHeight + options.topLeft.y;
      var heightOfOneLine = (0, _pdf_utils.getTextDimensions)(doc, sourceCellInfo.text, sourceCellInfo.font).h;
      var paddingHeight = sourceCellInfo.padding.top + sourceCellInfo.padding.bottom;
      var fullPageHeight = maxBottomRight.y - additionalHeight - paddingHeight - options.margin.top;
      var possibleLinesCount = Math.floor(fullPageHeight / (heightOfOneLine * doc.getLineHeightFactor()));
      var allLines = (0, _pdf_utils.getTextLines)(doc, sourceCellInfo.text, sourceCellInfo.font, {
        wordWrapEnabled: sourceCellInfo.wordWrapEnabled,
        targetRectWidth: w
      });
      if (possibleLinesCount < allLines.length) {
        var currentPageText = allLines.slice(0, possibleLinesCount).join('\n');
        var currentPageHeight = (0, _pdf_utils.calculateTextHeight)(doc, currentPageText, sourceCellInfo.font, {
          wordWrapEnabled: sourceCellInfo.wordWrapEnabled,
          targetRectWidth: w
        });
        maxCurrentPageHeight = Math.max(maxCurrentPageHeight, currentPageHeight + paddingHeight);
        maxNextPageHeight = rect.h - currentPageHeight;
        currentPageRects.push(createMultiCellRect(rect, currentPageText, options.margin.top));
        nextPageRects.push(createMultiCellRect(rect, allLines.slice(possibleLinesCount).join('\n'), options.margin.top));
      } else {
        var _currentPageHeight = (0, _pdf_utils.calculateTextHeight)(doc, sourceCellInfo.text, sourceCellInfo.font, {
          wordWrapEnabled: sourceCellInfo.wordWrapEnabled,
          targetRectWidth: w
        });
        maxCurrentPageHeight = Math.max(maxCurrentPageHeight, _currentPageHeight + paddingHeight);
        maxNextPageHeight = Math.max(maxNextPageHeight, _currentPageHeight + paddingHeight);
        currentPageRects.push(createMultiCellRect(rect, sourceCellInfo.text, options.margin.top));
        nextPageRects.push(createMultiCellRect(rect, '', options.margin.top));
      }
    });
    currentPageRects.forEach(function (rect) {
      return rect.h = maxCurrentPageHeight;
    });
    nextPageRects.forEach(function (rect) {
      return rect.h = maxNextPageHeight;
    });
    return [currentPageRects, nextPageRects];
  };
};
exports.createOnSplitMultiPageRow = createOnSplitMultiPageRow;

/***/ }),

/***/ 10830:
/***/ (function(__unused_webpack_module, exports) {



exports.getMultiPageRowPages = exports.checkPageContainsOnlyHeader = void 0;
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var isHeader = function isHeader(rect) {
  return (rect === null || rect === void 0 ? void 0 : rect.sourceCellInfo.gridCell.rowType) === 'header';
};
var spitMultiPageRows = function spitMultiPageRows(rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc) {
  var _splitMultiPageRowFun = splitMultiPageRowFunc(isCurrentPageContainsOnlyHeader, rectsToPatch),
    _splitMultiPageRowFun2 = _slicedToArray(_splitMultiPageRowFun, 2),
    newPageRects = _splitMultiPageRowFun2[0],
    remainPageRects = _splitMultiPageRowFun2[1];
  var newPageRectsArray = [isCurrentPageContainsOnlyHeader ? newPageRects.map(function (rect) {
    return _extends({}, rect, {
      y: firstRectYAdjustment
    });
  }) : newPageRects];
  while (!checkIsFitToPageFunc(false, remainPageRects[0].h)) {
    var _splitMultiPageRowFun3 = splitMultiPageRowFunc(false, remainPageRects);
    var _splitMultiPageRowFun4 = _slicedToArray(_splitMultiPageRowFun3, 2);
    newPageRects = _splitMultiPageRowFun4[0];
    remainPageRects = _splitMultiPageRowFun4[1];
    newPageRectsArray.push(newPageRects);
  }
  return [newPageRectsArray, remainPageRects];
};
var patchRects = function patchRects(rectsToSplit, rectsToPatch, remainPageRects) {
  rectsToPatch.forEach(function (rect, rectIndex) {
    rect.sourceCellInfo.text = remainPageRects[rectIndex].sourceCellInfo.text;
    rect.h = remainPageRects[rectIndex].h;
  });
  var untouchedRowIdx = rectsToSplit.indexOf(rectsToPatch[rectsToPatch.length - 1]) + 1;
  if (untouchedRowIdx >= rectsToSplit.length) {
    return;
  }
  var delta = rectsToSplit[untouchedRowIdx].y - (rectsToPatch[0].y + remainPageRects[0].h);
  for (var idx = untouchedRowIdx; idx < rectsToSplit.length; idx++) {
    rectsToSplit[idx].y = rectsToSplit[idx].y - delta;
  }
};
var checkPageContainsOnlyHeader = function checkPageContainsOnlyHeader(pageRects, isFirstPage) {
  return isFirstPage && isHeader(pageRects[pageRects.length - 1]);
};
exports.checkPageContainsOnlyHeader = checkPageContainsOnlyHeader;
var getMultiPageRowPages = function getMultiPageRowPages(currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, splitMultiPageRowFunc, checkIsFitToPageFunc) {
  if (!splitMultiPageRowFunc) {
    return [];
  }
  var currentPageLastRect = currentPageRects[currentPageRects.length - 1];
  var nextPageFirstRect = rectsToSplit[currentPageRects.length];
  if (!nextPageFirstRect || isHeader(nextPageFirstRect)) {
    return [];
  }
  var isRectsFitsToPage = checkIsFitToPageFunc(isCurrentPageContainsOnlyHeader, nextPageFirstRect.h);
  if (isRectsFitsToPage && !isCurrentPageContainsOnlyHeader) {
    return [];
  }
  var rectsToPatch = rectsToSplit.filter(function (_ref) {
    var y = _ref.y;
    return y === nextPageFirstRect.y;
  });
  var firstRectYAdjustment = currentPageLastRect.y + currentPageLastRect.h;
  var _spitMultiPageRows = spitMultiPageRows(rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc),
    _spitMultiPageRows2 = _slicedToArray(_spitMultiPageRows, 2),
    multiPageRowPages = _spitMultiPageRows2[0],
    remainPageRects = _spitMultiPageRows2[1];
  patchRects(rectsToSplit, rectsToPatch, remainPageRects);
  return multiPageRowPages;
};
exports.getMultiPageRowPages = getMultiPageRowPages;

/***/ }),

/***/ 22775:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.splitByPages = splitByPages;
var _type = __webpack_require__(35922);
var _pdf_utils = __webpack_require__(79262);
var _draw_utils = __webpack_require__(66867);
var _get_multipage_row_pages = __webpack_require__(10830);
var _create_on_split_multipage_row = __webpack_require__(72666);
function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var COORDINATE_EPSILON = 0.001;
function convertToCellsArray(rows) {
  return [].concat.apply([], rows.map(function (rowInfo) {
    return rowInfo.cells.filter(function (cell) {
      return !(0, _type.isDefined)(cell.pdfCell.isMerged);
    }).map(function (cellInfo) {
      return _extends({}, cellInfo.pdfCell._rect, {
        sourceCellInfo: _extends({}, cellInfo.pdfCell, {
          gridCell: cellInfo.gridCell
        })
      });
    });
  }));
}
function splitByPages(doc, rowsInfo, options, onSeparateRectHorizontally, onSeparateRectVertically) {
  if (rowsInfo.length === 0) {
    // Empty Table
    return [[]];
  }
  var maxBottomRight = {
    x: (0, _pdf_utils.getPageWidth)(doc) - options.margin.right,
    y: (0, _pdf_utils.getPageHeight)(doc) - options.margin.bottom
  };
  var headerRows = rowsInfo.filter(function (r) {
    return r.rowType === 'header';
  });
  var headerHeight = headerRows.reduce(function (accumulator, row) {
    return accumulator + row.height;
  }, 0);
  var verticallyPages = splitRectsByPages(convertToCellsArray(rowsInfo), options.margin.top, 'y', 'h', function (isFirstPage, currentCoordinate) {
    var additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : 0;
    return (0, _draw_utils.roundToThreeDecimals)(currentCoordinate + additionalHeight) <= (0, _draw_utils.roundToThreeDecimals)(maxBottomRight.y);
  }, function (rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) {
    var args = {
      sourceRect: rect,
      topRect: {
        x: rect.x,
        y: rect.y,
        w: rect.w,
        h: currentPageMaxRectCoordinate - rect.y
      },
      bottomRect: {
        x: rect.x,
        y: currentPageMaxRectCoordinate,
        w: rect.w,
        h: rect.h - (currentPageMaxRectCoordinate - rect.y)
      }
    };
    onSeparateRectVertically(args);
    currentPageRects.push(args.topRect);
    rectsToSplit.push(args.bottomRect);
  }, (0, _create_on_split_multipage_row.createOnSplitMultiPageRow)(doc, options, headerHeight, maxBottomRight));
  if (options.repeatHeaders) {
    for (var i = 1; i < verticallyPages.length; i++) {
      verticallyPages[i].forEach(function (rect) {
        return rect.y += headerHeight;
      });
      // create deep copy of headers for each page
      var headerCells = convertToCellsArray(headerRows);
      headerCells.forEach(function (cell) {
        cell.y -= options.topLeft.y;
        // cell.x -= options.topLeft.x; don't forget to uncomment this line after fixing topleft.x issue
      });

      verticallyPages[i] = [].concat(_toConsumableArray(headerCells), _toConsumableArray(verticallyPages[i]));
    }
  }
  var pageIndex = 0;
  while (pageIndex < verticallyPages.length) {
    var horizontallyPages = splitRectsByPages(verticallyPages[pageIndex], options.margin.left, 'x', 'w', function (pagesLength, currentCoordinate) {
      return (0, _draw_utils.roundToThreeDecimals)(currentCoordinate) <= (0, _draw_utils.roundToThreeDecimals)(maxBottomRight.x);
    }, function (rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) {
      var args = {
        sourceRect: rect,
        leftRect: {
          x: rect.x,
          y: rect.y,
          w: currentPageMaxRectCoordinate - rect.x,
          h: rect.h
        },
        rightRect: {
          x: currentPageMaxRectCoordinate,
          y: rect.y,
          w: rect.w - (currentPageMaxRectCoordinate - rect.x),
          h: rect.h
        }
      };
      onSeparateRectHorizontally(args);
      currentPageRects.push(args.leftRect);
      rectsToSplit.push(args.rightRect);
    });
    if (horizontallyPages.length > 1) {
      verticallyPages.splice.apply(verticallyPages, [pageIndex, 1].concat(_toConsumableArray(horizontallyPages)));
      pageIndex += horizontallyPages.length;
    } else {
      pageIndex += 1;
    }
  }
  return verticallyPages.map(function (rects) {
    return rects.map(function (rect) {
      return _extends({}, rect.sourceCellInfo, {
        _rect: rect
      });
    });
  });
}
function splitRectsByPages(rects, marginValue, coordinate, dimension, isFitToPage, onSeparateCallback, onSplitMultiPageRow) {
  var pages = [];
  var rectsToSplit = _toConsumableArray(rects);
  var isFitToPageForMultiPageRow = function isFitToPageForMultiPageRow(isFirstPage, rectHeight) {
    return isFitToPage(isFirstPage, rectHeight + marginValue);
  };
  var _loop = function _loop() {
    var currentPageMaxRectCoordinate = 0;
    var currentPageRects = rectsToSplit.filter(function (rect) {
      var currentRectCoordinate = rect[coordinate] + rect[dimension];
      if (isFitToPage(pages.length === 0, currentRectCoordinate)) {
        if (currentPageMaxRectCoordinate <= currentRectCoordinate) {
          currentPageMaxRectCoordinate = currentRectCoordinate;
        }
        return true;
      } else {
        return false;
      }
    });
    var isCurrentPageContainsOnlyHeader = (0, _get_multipage_row_pages.checkPageContainsOnlyHeader)(currentPageRects, pages.length === 0);
    var multiPageRowPages = (0, _get_multipage_row_pages.getMultiPageRowPages)(currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, onSplitMultiPageRow, isFitToPageForMultiPageRow);
    var rectsToSeparate = rectsToSplit.filter(function (rect) {
      // Check cells that have 'coordinate' less than 'currentPageMaxRectCoordinate'
      var currentRectLeft = rect[coordinate];
      var currentRectRight = rect[coordinate] + rect[dimension];
      return currentPageMaxRectCoordinate - currentRectLeft > COORDINATE_EPSILON && currentRectRight - currentPageMaxRectCoordinate > COORDINATE_EPSILON;
    });
    rectsToSeparate.forEach(function (rect) {
      onSeparateCallback(rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit);
      var index = rectsToSplit.indexOf(rect);
      if (index !== -1) {
        rectsToSplit.splice(index, 1);
      }
    });
    currentPageRects.forEach(function (rect) {
      var index = rectsToSplit.indexOf(rect);
      if (index !== -1) {
        rectsToSplit.splice(index, 1);
      }
    });
    rectsToSplit.forEach(function (rect) {
      rect[coordinate] = (0, _type.isDefined)(currentPageMaxRectCoordinate) ? rect[coordinate] - currentPageMaxRectCoordinate + marginValue : rect[coordinate];
    });
    var firstPageContainsHeaderAndMultiPageRow = isCurrentPageContainsOnlyHeader && multiPageRowPages.length > 0;
    if (firstPageContainsHeaderAndMultiPageRow) {
      var _multiPageRowPages = _toArray(multiPageRowPages),
        firstPage = _multiPageRowPages[0],
        restOfPages = _multiPageRowPages.slice(1);
      pages.push([].concat(_toConsumableArray(currentPageRects), _toConsumableArray(firstPage)));
      pages.push.apply(pages, _toConsumableArray(restOfPages));
    } else if (currentPageRects.length > 0) {
      pages.push(currentPageRects);
      pages.push.apply(pages, _toConsumableArray(multiPageRowPages));
    } else if (multiPageRowPages.length > 0) {
      pages.push.apply(pages, _toConsumableArray(multiPageRowPages));
      pages.push(rectsToSplit);
    } else {
      pages.push(rectsToSplit);
      return "break";
    }
  };
  while (rectsToSplit.length > 0) {
    var _ret = _loop();
    if (_ret === "break") break;
  }
  return pages;
}

/***/ }),

/***/ 654:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.exportDataGrid = exportDataGrid;
var _type = __webpack_require__(35922);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _export = __webpack_require__(17195);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var HOW_TO_MIGRATE_ARTICLE = 'https://supportcenter.devexpress.com/ticket/details/t1077554';
function _getFullOptions(options) {
  if (!((0, _type.isDefined)(options) && (0, _type.isObject)(options))) {
    throw Error('The "exportDataGrid" method requires a configuration object.');
  }
  if (!((0, _type.isDefined)(options.component) && (0, _type.isObject)(options.component) && options.component.NAME === 'dxDataGrid')) {
    throw Error('The "component" field must contain a DataGrid instance.');
  }
  if (!((0, _type.isDefined)(options.jsPDFDocument) && (0, _type.isObject)(options.jsPDFDocument))) {
    throw Error('The "jsPDFDocument" field must contain a jsPDF instance.');
  }
  if ((0, _type.isDefined)(options.autoTableOptions)) {
    _errors.default.log('W0001', 'Export', 'autoTableOptions', '22.1', "You can migrate from exporting to PDF with the AutoTable plugin to a new export system. See the following topic for more information: ".concat(HOW_TO_MIGRATE_ARTICLE));
  }
  return _export.Export.getFullOptions(options);
}
function exportDataGrid(options) {
  return _export.Export.export(_getFullOptions(options));
}

/***/ }),

/***/ 29982:
/***/ (function(__unused_webpack_module, exports) {



exports.exportGantt = exportGantt;
function exportGantt(options) {
  var component = options.component;
  return component === null || component === void 0 ? void 0 : component.exportToPdf(options);
}

/***/ }),

/***/ 30855:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getData = getData;
var _version = __webpack_require__(36739);
var _window = __webpack_require__(58201);
var _image_creator = __webpack_require__(12173);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var window = (0, _window.getWindow)();
var mainPageTemplate = '%PDF-1.3\r\n2 0 obj\r\n<</ProcSet[/PDF/ImageB/ImageC/ImageI]/XObject<</I0 5 0 R>>>>\r\nendobj\r\n4 0 obj\r\n<</Type/Pages/Kids[1 0 R]/Count 1>>\r\nendobj\r\n7 0 obj\r\n<</OpenAction[1 0 R /FitH null]/Type/Catalog/Pages 4 0 R/PageLayout/OneColumn>>\r\nendobj\r\n1 0 obj\r\n<</Type/Page/Resources 2 0 R/MediaBox[0 0 _width_ _height_]/Contents 3 0 R/Parent 4 0 R>>\r\nendobj\r\n';
var contentTemplate = '3 0 obj\r\n<</Length 52>>stream\r\n0.20 w\n0 G\nq _width_ 0 0 _height_ 0.00 0.00 cm /I0 Do Q\r\nendstream\r\nendobj\r\n';
var infoTemplate = '6 0 obj\r\n<</CreationDate _date_/Producer(DevExtreme _version_)>>\r\nendobj\r\n';
var imageStartTemplate = '5 0 obj\r\n<</Type/XObject/Subtype/Image/Width _width_/Height _height_/ColorSpace/DeviceRGB/BitsPerComponent 8/Filter/DCTDecode/Length _length_>>stream\r\n';
var imageEndTemplate = '\r\nendstream\r\nendobj\r\n';
var trailerTemplate = 'trailer\r\n<<\r\n/Size 8\r\n/Root 7 0 R\r\n/Info 6 0 R\r\n>>\r\nstartxref\r\n_length_\r\n%%EOF';
var xrefTemplate = 'xref\r\n0 8\r\n0000000000 65535 f\r\n0000000241 00000 n\r\n0000000010 00000 n\r\n_main_ 00000 n\r\n0000000089 00000 n\r\n_image_ 00000 n\r\n_info_ 00000 n\r\n0000000143 00000 n\r\n';
var pad = function pad(str, len) {
  return str.length < len ? pad('0' + str, len) : str;
};
var composePdfString = function composePdfString(imageString, options, curDate) {
  var margin = (options.margin || 0) * 2;
  var _calcScaledInfo = (0, _image_creator.calcScaledInfo)(options.width, options.height),
    width = _calcScaledInfo.width,
    height = _calcScaledInfo.height;
  width += margin;
  height += margin;
  var widthPt = (width * 0.75).toFixed(2);
  var heightPt = (height * 0.75).toFixed(2);
  var flooredWidth = Math.floor(width);
  var flooredHeight = Math.floor(height);
  var mainPage = mainPageTemplate.replace('_width_', widthPt).replace('_height_', heightPt);
  var content = contentTemplate.replace('_width_', widthPt).replace('_height_', heightPt);
  var info = infoTemplate.replace('_date_', curDate).replace('_version_', _version.version);
  var image = imageStartTemplate.replace('_width_', flooredWidth).replace('_height_', flooredHeight).replace('_length_', imageString.length) + imageString + imageEndTemplate;
  var xref = getXref(mainPage.length, content.length, info.length);
  var mainContent = mainPage + content + info + image;
  var trailer = trailerTemplate.replace('_length_', mainContent.length);
  return mainContent + xref + trailer;
};
function getXref(mainPageLength, contentLength, infoLength) {
  return xrefTemplate.replace('_main_', pad(mainPageLength + '', 10)).replace('_info_', pad(mainPageLength + contentLength + '', 10)).replace('_image_', pad(mainPageLength + contentLength + infoLength + '', 10));
}
var getCurDate = function getCurDate() {
  return new Date();
};
var getBlob = function getBlob(binaryData) {
  var i = 0;
  var dataArray = new Uint8Array(binaryData.length);
  for (; i < binaryData.length; i++) {
    dataArray[i] = binaryData.charCodeAt(i);
  }
  return new window.Blob([dataArray.buffer], {
    type: 'application/pdf'
  });
};
var getBase64 = function getBase64(binaryData) {
  return window.btoa(binaryData);
};
function getTwoDigitValue(value) {
  var stringValue = value.toString();
  if (stringValue.length === 1) {
    return "0".concat(value);
  }
  return value;
}
function convertToPdfDateFormat(date) {
  var dateUnits = [date.getUTCFullYear(), getTwoDigitValue(date.getUTCMonth()), getTwoDigitValue(date.getUTCDate()), getTwoDigitValue(date.getUTCHours()), getTwoDigitValue(date.getUTCMinutes()), getTwoDigitValue(date.getUTCSeconds())];
  return "(D:".concat(dateUnits.join(''), "Z00'00')");
}
function getData(data, options) {
  return _image_creator.imageCreator.getImageData(data, (0, _extend.extend)({}, options, {
    format: 'JPEG'
  })).then(function (imageString) {
    var binaryData = composePdfString(imageString, options, convertToPdfDateFormat(getCurDate()));
    var pdfData = (0, _type.isFunction)(window.Blob) ? getBlob(binaryData) : getBase64(binaryData);
    return pdfData;
  });
}

/***/ }),

/***/ 37596:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getData = getData;
exports.svgCreator = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _window = __webpack_require__(58201);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _svg = __webpack_require__(19155);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var svgCreator = {
  _markup: '',
  _imageArray: {},
  _imageDeferreds: [],
  _getBinaryFile: function _getBinaryFile(src, callback) {
    _ajax.default.sendRequest({
      url: src,
      method: 'GET',
      responseType: 'arraybuffer'
    }).done(callback).fail(function () {
      callback(false);
    });
  },
  _loadImages: function _loadImages() {
    var that = this;
    (0, _iterator.each)(that._imageArray, function (src) {
      var deferred = new _deferred.Deferred();
      that._imageDeferreds.push(deferred);
      that._getBinaryFile(src, function (response) {
        if (!response) {
          delete that._imageArray[src]; // ToDo Warning
          deferred.resolve();
          return;
        }
        var i;
        var binary = '';
        var bytes = new Uint8Array(response);
        var length = bytes.byteLength;
        for (i = 0; i < length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        that._imageArray[src] = 'data:image/png;base64,' + window.btoa(binary);
        deferred.resolve();
      });
    });
  },
  _parseImages: function _parseImages(element) {
    var href;
    var that = this;
    if (element.tagName === 'image') {
      href = (0, _renderer.default)(element).attr('href') || (0, _renderer.default)(element).attr('xlink:href');
      if (!that._imageArray[href]) {
        that._imageArray[href] = '';
      }
    }
    (0, _iterator.each)(element.childNodes, function (_, element) {
      that._parseImages(element);
    });
  },
  _prepareImages: function _prepareImages(svgElem) {
    this._parseImages(svgElem);
    this._loadImages();
    return _deferred.when.apply(_renderer.default, this._imageDeferreds);
  },
  getData: function getData(data, options) {
    var markup;
    var that = this;
    var xmlVersion = '<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>';
    var svgElem = (0, _svg.getSvgElement)(data);
    var $svgObject = (0, _renderer.default)(svgElem);
    $svgObject.find("[".concat(_svg.HIDDEN_FOR_EXPORT, "]")).remove();
    markup = xmlVersion + (0, _svg.getSvgMarkup)($svgObject.get(0), options.backgroundColor);
    return that._prepareImages(svgElem).then(function () {
      (0, _iterator.each)(that._imageArray, function (href, dataURI) {
        var regexpString = "href=['|\"]".concat(href, "['|\"]");
        markup = markup.replace(new RegExp(regexpString, 'gi'), "href=\"".concat(dataURI, "\""));
      });
      return (0, _type.isFunction)(window.Blob) ? that._getBlob(markup) : that._getBase64(markup);
    });
  },
  _getBlob: function _getBlob(markup) {
    return new window.Blob([markup], {
      type: 'image/svg+xml'
    });
  },
  _getBase64: function _getBase64(markup) {
    return window.btoa(markup);
  }
};
exports.svgCreator = svgCreator;
function getData(data, options) {
  return svgCreator.getData(data, options);
}

/***/ }),

/***/ 30343:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date2 = _interopRequireDefault(__webpack_require__(91500));
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
__webpack_require__(89740);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = (0, _dependency_injector.default)({
  format: function format(value, _format) {
    var formatIsValid = (0, _type.isString)(_format) && _format !== '' || (0, _type.isPlainObject)(_format) || (0, _type.isFunction)(_format);
    var valueIsValid = (0, _type.isNumeric)(value) || (0, _type.isDate)(value);
    if (!formatIsValid || !valueIsValid) {
      return (0, _type.isDefined)(value) ? value.toString() : '';
    }
    if ((0, _type.isFunction)(_format)) {
      return _format(value);
    }
    if ((0, _type.isString)(_format)) {
      _format = {
        type: _format
      };
    }
    if ((0, _type.isNumeric)(value)) {
      return _number.default.format(value, _format);
    }
    if ((0, _type.isDate)(value)) {
      return _date2.default.format(value, _format);
    }
  },
  getTimeFormat: function getTimeFormat(showSecond) {
    return showSecond ? 'longtime' : 'shorttime';
  },
  _normalizeFormat: function _normalizeFormat(format) {
    if (!Array.isArray(format)) {
      return format;
    }
    if (format.length === 1) {
      return format[0];
    }
    return function (date) {
      return format.map(function (formatPart) {
        return _date2.default.format(date, formatPart);
      }).join(' ');
    };
  },
  getDateFormatByDifferences: function getDateFormatByDifferences(dateDifferences, intervalFormat) {
    var resultFormat = [];
    var needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
    if (needSpecialSecondFormatter) {
      var secondFormatter = function secondFormatter(date) {
        return date.getSeconds() + date.getMilliseconds() / 1000 + 's';
      };
      resultFormat.push(secondFormatter);
    } else if (dateDifferences.millisecond) {
      resultFormat.push('millisecond');
    }
    if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
      resultFormat.unshift(this.getTimeFormat(dateDifferences.second));
    }
    if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
      if (intervalFormat && intervalFormat === 'month') {
        return 'monthandyear';
      } else {
        resultFormat.unshift('shortdate');
        return this._normalizeFormat(resultFormat);
      }
    }
    if (dateDifferences.year && dateDifferences.month) {
      return 'monthandyear';
    }
    if (dateDifferences.year && dateDifferences.quarter) {
      return 'quarterandyear';
    }
    if (dateDifferences.year) {
      return 'year';
    }
    if (dateDifferences.quarter) {
      return 'quarter';
    }
    if (dateDifferences.month && dateDifferences.day) {
      if (intervalFormat) {
        var monthDayFormatter = function monthDayFormatter(date) {
          return _date2.default.getMonthNames('abbreviated')[date.getMonth()] + ' ' + _date2.default.format(date, 'day');
        };
        resultFormat.unshift(monthDayFormatter);
      } else {
        resultFormat.unshift('monthandday');
      }
      return this._normalizeFormat(resultFormat);
    }
    if (dateDifferences.month) {
      return 'month';
    }
    if (dateDifferences.day) {
      if (intervalFormat) {
        resultFormat.unshift('day');
      } else {
        var dayFormatter = function dayFormatter(date) {
          return _date2.default.format(date, 'dayofweek') + ', ' + _date2.default.format(date, 'day');
        };
        resultFormat.unshift(dayFormatter);
      }
      return this._normalizeFormat(resultFormat);
    }
    return this._normalizeFormat(resultFormat);
  },
  getDateFormatByTicks: function getDateFormatByTicks(ticks) {
    var maxDiff;
    var currentDiff;
    var i;
    if (ticks.length > 1) {
      maxDiff = _date.default.getDatesDifferences(ticks[0], ticks[1]);
      for (i = 1; i < ticks.length - 1; i++) {
        currentDiff = _date.default.getDatesDifferences(ticks[i], ticks[i + 1]);
        if (maxDiff.count < currentDiff.count) {
          maxDiff = currentDiff;
        }
      }
    } else {
      maxDiff = {
        year: true,
        month: true,
        day: true,
        hour: ticks[0].getHours() > 0,
        minute: ticks[0].getMinutes() > 0,
        second: ticks[0].getSeconds() > 0,
        millisecond: ticks[0].getMilliseconds() > 0
      };
    }
    var resultFormat = this.getDateFormatByDifferences(maxDiff);
    return resultFormat;
  },
  getDateFormatByTickInterval: function getDateFormatByTickInterval(startValue, endValue, tickInterval) {
    var dateUnitInterval;
    var dateDifferencesConverter = {
      week: 'day'
    };
    var correctDateDifferences = function correctDateDifferences(dateDifferences, tickInterval, value) {
      switch (tickInterval) {
        case 'year':
        case 'quarter':
          dateDifferences.month = value;
        /* falls through */
        case 'month':
          dateDifferences.day = value;
        /* falls through */
        case 'week':
        case 'day':
          dateDifferences.hour = value;
        /* falls through */
        case 'hour':
          dateDifferences.minute = value;
        /* falls through */
        case 'minute':
          dateDifferences.second = value;
        /* falls through */
        case 'second':
          dateDifferences.millisecond = value;
      }
    };
    var correctDifferencesByMaxDate = function correctDifferencesByMaxDate(differences, minDate, maxDate) {
      if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
        if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
          differences.millisecond = true;
          differences.second = false;
        }
      } else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
        if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
          differences.second = true;
          differences.minute = false;
        }
      } else if (!maxDate.getMinutes() && maxDate.getHours()) {
        if (maxDate.getHours() - minDate.getHours() === 1) {
          differences.minute = true;
          differences.hour = false;
        }
      } else if (!maxDate.getHours() && maxDate.getDate() > 1) {
        if (maxDate.getDate() - minDate.getDate() === 1) {
          differences.hour = true;
          differences.day = false;
        }
      } else if (maxDate.getDate() === 1 && maxDate.getMonth()) {
        if (maxDate.getMonth() - minDate.getMonth() === 1) {
          differences.day = true;
          differences.month = false;
        }
      } else if (!maxDate.getMonth() && maxDate.getFullYear()) {
        if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
          differences.month = true;
          differences.year = false;
        }
      }
    };
    tickInterval = (0, _type.isString)(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
    var dateDifferences = _date.default.getDatesDifferences(startValue, endValue);
    if (startValue !== endValue) {
      correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
    }
    dateUnitInterval = _date.default.getDateUnitInterval(dateDifferences);
    correctDateDifferences(dateDifferences, dateUnitInterval, true);
    dateUnitInterval = _date.default.getDateUnitInterval(tickInterval || 'second');
    correctDateDifferences(dateDifferences, dateUnitInterval, false);
    dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
    var resultFormat = this.getDateFormatByDifferences(dateDifferences);
    return resultFormat;
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 71582:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(78475);
__webpack_require__(38971);
__webpack_require__(12993);
__webpack_require__(11579);
__webpack_require__(21298);

/***/ }),

/***/ 21298:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _action = _interopRequireDefault(__webpack_require__(62414));
var _angular = _interopRequireDefault(__webpack_require__(62387));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_angular.default) {
  _action.default.registerExecutor({
    'ngExpression': {
      execute: function execute(e) {
        if (typeof e.action === 'string') {
          e.context.$eval(e.action);
        }
      }
    }
  });
}

/***/ }),

/***/ 38971:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _angular = _interopRequireDefault(__webpack_require__(62387));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _config = _interopRequireDefault(__webpack_require__(80209));
var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(5554));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _locker = _interopRequireDefault(__webpack_require__(88933));
var _editor = _interopRequireDefault(__webpack_require__(96452));
var _template = __webpack_require__(76165);
var _module = _interopRequireDefault(__webpack_require__(69155));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(11050));
var _data = __webpack_require__(47617);
var _extend = __webpack_require__(13306);
var _comparator = __webpack_require__(49036);
var _inflector = __webpack_require__(78008);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var ITEM_ALIAS_ATTRIBUTE_NAME = 'dxItemAlias';
var SKIP_APPLY_ACTION_CATEGORY = 'rendering';
var NG_MODEL_OPTION = 'value';
if (_angular.default) {
  var safeApply = function safeApply(func, scope) {
    if (scope.$root.$$phase) {
      return func(scope);
    } else {
      return scope.$apply(function () {
        return func(scope);
      });
    }
  };
  var getClassMethod = function getClassMethod(initClass, methodName) {
    var hasParentProperty = Object.prototype.hasOwnProperty.bind(initClass)('parent');
    var isES6Class = !hasParentProperty && initClass.parent;
    if (isES6Class) {
      var baseClass = Object.getPrototypeOf(initClass);
      return baseClass.prototype[methodName] ? function () {
        return baseClass.prototype[methodName]();
      } : getClassMethod(baseClass, methodName);
    } else {
      var method = initClass.parent.prototype[methodName];
      if (method) {
        return function () {
          return method();
        };
      }
      if (!method || !initClass.parent.subclassOf) {
        return function () {
          return undefined;
        };
      }
      return getClassMethod(initClass.parent, methodName);
    }
  };
  var ComponentBuilder = _class.default.inherit({
    ctor(options) {
      this._componentDisposing = (0, _callbacks.default)();
      this._optionChangedCallbacks = (0, _callbacks.default)();
      this._ngLocker = new _locker.default();
      this._scope = options.scope;
      this._$element = options.$element;
      this._$templates = options.$templates;
      this._componentClass = options.componentClass;
      this._parse = options.parse;
      this._compile = options.compile;
      this._itemAlias = options.itemAlias;
      this._transcludeFn = options.transcludeFn;
      this._digestCallbacks = options.dxDigestCallbacks;
      this._normalizeOptions(options.ngOptions);
      this._initComponentBindings();
      this._initComponent(this._scope);
      if (!options.ngOptions) {
        this._addOptionsStringWatcher(options.ngOptionsString);
      }
    },
    _addOptionsStringWatcher(optionsString) {
      var _this = this;
      var clearOptionsStringWatcher = this._scope.$watch(optionsString, function (newOptions) {
        if (!newOptions) {
          return;
        }
        clearOptionsStringWatcher();
        _this._normalizeOptions(newOptions);
        _this._initComponentBindings();
        _this._component.option(_this._evalOptions(_this._scope));
      });
      this._componentDisposing.add(clearOptionsStringWatcher);
    },
    _normalizeOptions(options) {
      var _this2 = this;
      this._ngOptions = (0, _extend.extendFromObject)({}, options);
      if (!options) {
        return;
      }
      if (!Object.prototype.hasOwnProperty.call(options, 'bindingOptions') && options.bindingOptions) {
        this._ngOptions.bindingOptions = options.bindingOptions;
      }
      if (options.bindingOptions) {
        (0, _iterator.each)(options.bindingOptions, function (key, value) {
          if ((0, _type.type)(value) === 'string') {
            _this2._ngOptions.bindingOptions[key] = {
              dataPath: value
            };
          }
        });
      }
    },
    _initComponent(scope) {
      this._component = new this._componentClass(this._$element, this._evalOptions(scope));
      this._component._isHidden = true;
      this._handleDigestPhase();
    },
    _handleDigestPhase() {
      var _this3 = this;
      var beginUpdate = function beginUpdate() {
        _this3._component.beginUpdate();
      };
      var endUpdate = function endUpdate() {
        _this3._component.endUpdate();
      };
      this._digestCallbacks.begin.add(beginUpdate);
      this._digestCallbacks.end.add(endUpdate);
      this._componentDisposing.add(function () {
        _this3._digestCallbacks.begin.remove(beginUpdate);
        _this3._digestCallbacks.end.remove(endUpdate);
      });
    },
    _initComponentBindings() {
      var _this4 = this;
      var optionDependencies = {};
      if (!this._ngOptions.bindingOptions) {
        return;
      }
      (0, _iterator.each)(this._ngOptions.bindingOptions, function (optionPath, value) {
        var separatorIndex = optionPath.search(/\[|\./);
        var optionForSubscribe = separatorIndex > -1 ? optionPath.substring(0, separatorIndex) : optionPath;
        var prevWatchMethod;
        var clearWatcher;
        var valuePath = value.dataPath;
        var deepWatch = true;
        var forcePlainWatchMethod = false;
        if (value.deep !== undefined) {
          forcePlainWatchMethod = deepWatch = !!value.deep;
        }
        if (!optionDependencies[optionForSubscribe]) {
          optionDependencies[optionForSubscribe] = {};
        }
        optionDependencies[optionForSubscribe][optionPath] = valuePath;
        var updateWatcher = function updateWatcher() {
          var watchCallback = function watchCallback(newValue, oldValue) {
            if (_this4._ngLocker.locked(optionPath)) {
              return;
            }
            _this4._ngLocker.obtain(optionPath);
            _this4._component.option(optionPath, newValue);
            updateWatcher();
            if ((0, _comparator.equals)(oldValue, newValue) && _this4._ngLocker.locked(optionPath)) {
              _this4._ngLocker.release(optionPath);
            }
          };
          var watchMethod = Array.isArray(_this4._scope.$eval(valuePath)) && !forcePlainWatchMethod ? '$watchCollection' : '$watch';
          if (prevWatchMethod !== watchMethod) {
            if (clearWatcher) {
              clearWatcher();
            }
            clearWatcher = _this4._scope[watchMethod](valuePath, watchCallback, deepWatch);
            prevWatchMethod = watchMethod;
          }
        };
        updateWatcher();
        _this4._componentDisposing.add(clearWatcher);
      });
      this._optionChangedCallbacks.add(function (args) {
        var optionName = args.name;
        var fullName = args.fullName;
        var component = args.component;
        if (_this4._ngLocker.locked(fullName)) {
          _this4._ngLocker.release(fullName);
          return;
        }
        if (!optionDependencies || !optionDependencies[optionName]) {
          return;
        }
        var isActivePhase = _this4._scope.$root.$$phase;
        var obtainOption = function obtainOption() {
          _this4._ngLocker.obtain(fullName);
        };
        if (isActivePhase) {
          _this4._digestCallbacks.begin.add(obtainOption);
        } else {
          obtainOption();
        }
        safeApply(function () {
          (0, _iterator.each)(optionDependencies[optionName], function (optionPath, valuePath) {
            if (!_this4._optionsAreLinked(fullName, optionPath)) {
              return;
            }
            var value = component.option(optionPath);
            _this4._parse(valuePath).assign(_this4._scope, value);
            var scopeValue = _this4._parse(valuePath)(_this4._scope);
            if (scopeValue !== value) {
              args.component.option(optionPath, scopeValue);
            }
          });
        }, _this4._scope);
        var releaseOption = function releaseOption() {
          if (_this4._ngLocker.locked(fullName)) {
            _this4._ngLocker.release(fullName);
          }
          _this4._digestCallbacks.begin.remove(obtainOption);
          _this4._digestCallbacks.end.remove(releaseOption);
        };
        if (isActivePhase) {
          _this4._digestCallbacks.end.addPrioritized(releaseOption);
        } else {
          releaseOption();
        }
      });
    },
    _optionsAreNested(optionPath1, optionPath2) {
      var parentSeparator = optionPath1[optionPath2.length];
      return optionPath1.indexOf(optionPath2) === 0 && (parentSeparator === '.' || parentSeparator === '[');
    },
    _optionsAreLinked(optionPath1, optionPath2) {
      if (optionPath1 === optionPath2) return true;
      return optionPath1.length > optionPath2.length ? this._optionsAreNested(optionPath1, optionPath2) : this._optionsAreNested(optionPath2, optionPath1);
    },
    _compilerByTemplate(template) {
      var _this5 = this;
      var scopeItemsPath = this._getScopeItemsPath();
      return function (options) {
        var $resultMarkup = (0, _renderer.default)(template).clone();
        var dataIsScope = options.model && options.model.constructor === _this5._scope.$root.constructor;
        var templateScope = dataIsScope ? options.model : options.noModel ? _this5._scope : _this5._createScopeWithData(options);
        if (scopeItemsPath) {
          _this5._synchronizeScopes(templateScope, scopeItemsPath, options.index);
        }
        $resultMarkup.appendTo(options.container);
        if (!options.noModel) {
          _events_engine.default.on($resultMarkup, '$destroy', function () {
            var destroyAlreadyCalled = !templateScope.$parent;
            if (destroyAlreadyCalled) {
              return;
            }
            templateScope.$destroy();
          });
        }
        var ngTemplate = _this5._compile($resultMarkup, _this5._transcludeFn);
        _this5._applyAsync(function (scope) {
          ngTemplate(scope, null, {
            parentBoundTranscludeFn: _this5._transcludeFn
          });
        }, templateScope);
        return $resultMarkup;
      };
    },
    _applyAsync(func, scope) {
      var _this6 = this;
      func(scope);
      if (!scope.$root.$$phase) {
        if (!this._renderingTimer) {
          var clearRenderingTimer = function clearRenderingTimer() {
            clearTimeout(_this6._renderingTimer);
          };
          this._renderingTimer = setTimeout(function () {
            scope.$apply();
            _this6._renderingTimer = null;
            _this6._componentDisposing.remove(clearRenderingTimer);
          });
          this._componentDisposing.add(clearRenderingTimer);
        }
      }
    },
    _getScopeItemsPath() {
      if (this._componentClass.subclassOf(_uiCollection_widget.default) && this._ngOptions.bindingOptions && this._ngOptions.bindingOptions.items) {
        return this._ngOptions.bindingOptions.items.dataPath;
      }
    },
    _createScopeWithData(options) {
      var newScope = this._scope.$new();
      if (this._itemAlias) {
        newScope[this._itemAlias] = options.model;
      }
      if ((0, _type.isDefined)(options.index)) {
        newScope.$index = options.index;
      }
      return newScope;
    },
    _synchronizeScopes(itemScope, parentPrefix, itemIndex) {
      if (this._itemAlias && typeof itemScope[this._itemAlias] !== 'object') {
        this._synchronizeScopeField({
          parentScope: this._scope,
          childScope: itemScope,
          fieldPath: this._itemAlias,
          parentPrefix,
          itemIndex
        });
      }
    },
    _synchronizeScopeField(args) {
      var parentScope = args.parentScope;
      var childScope = args.childScope;
      var fieldPath = args.fieldPath;
      var parentPrefix = args.parentPrefix;
      var itemIndex = args.itemIndex;
      var innerPathSuffix = fieldPath === this._itemAlias ? '' : '.' + fieldPath;
      var collectionField = itemIndex !== undefined;
      var optionOuterBag = [parentPrefix];
      if (collectionField) {
        if (!(0, _type.isNumeric)(itemIndex)) return;
        optionOuterBag.push('[', itemIndex, ']');
      }
      optionOuterBag.push(innerPathSuffix);
      var optionOuterPath = optionOuterBag.join('');
      var clearParentWatcher = parentScope.$watch(optionOuterPath, function (newValue, oldValue) {
        if (newValue !== oldValue) {
          (0, _data.compileSetter)(fieldPath)(childScope, newValue);
        }
      });
      var clearItemWatcher = childScope.$watch(fieldPath, function (newValue, oldValue) {
        if (newValue !== oldValue) {
          if (collectionField && !(0, _data.compileGetter)(parentPrefix)(parentScope)[itemIndex]) {
            clearItemWatcher();
            return;
          }
          (0, _data.compileSetter)(optionOuterPath)(parentScope, newValue);
        }
      });
      this._componentDisposing.add([clearParentWatcher, clearItemWatcher]); // TODO: test
    },

    _evalOptions(scope) {
      var _this8 = this;
      var result = (0, _extend.extendFromObject)({}, this._ngOptions);
      delete result.bindingOptions;
      if (this._ngOptions.bindingOptions) {
        (0, _iterator.each)(this._ngOptions.bindingOptions, function (key, value) {
          result[key] = scope.$eval(value.dataPath);
        });
      }
      result._optionChangedCallbacks = this._optionChangedCallbacks;
      result._disposingCallbacks = this._componentDisposing;
      result.onActionCreated = function (component, action, config) {
        if (config && config.category === SKIP_APPLY_ACTION_CATEGORY) {
          return action;
        }
        var wrappedAction = function wrappedAction() {
          var _this7 = this;
          var args = arguments;
          if (!scope || !scope.$root || scope.$root.$$phase) {
            return action.apply(this, args);
          }
          return safeApply(function () {
            return action.apply(_this7, args);
          }, scope);
        };
        return wrappedAction;
      };
      result.beforeActionExecute = result.onActionCreated;
      result.nestedComponentOptions = function (component) {
        return {
          templatesRenderAsynchronously: component.option('templatesRenderAsynchronously'),
          forceApplyBindings: component.option('forceApplyBindings'),
          modelByElement: component.option('modelByElement'),
          onActionCreated: component.option('onActionCreated'),
          beforeActionExecute: component.option('beforeActionExecute'),
          nestedComponentOptions: component.option('nestedComponentOptions')
        };
      };
      result.templatesRenderAsynchronously = true;
      if ((0, _config.default)().wrapActionsBeforeExecute) {
        result.forceApplyBindings = function () {
          safeApply(function () {}, scope);
        };
      }
      result.integrationOptions = {
        createTemplate: function createTemplate(element) {
          return new _template.NgTemplate(element, _this8._compilerByTemplate.bind(_this8));
        },
        watchMethod: function watchMethod(fn, callback, options) {
          options = options || {};
          var immediateValue;
          var skipCallback = options.skipImmediate;
          var disposeWatcher = scope.$watch(function () {
            var value = fn();
            if (value instanceof Date) {
              value = value.valueOf();
            }
            return value;
          }, function (newValue) {
            var isSameValue = immediateValue === newValue;
            if (!skipCallback && (!isSameValue || isSameValue && options.deep)) {
              callback(newValue);
            }
            skipCallback = false;
          }, options.deep);
          if (!skipCallback) {
            immediateValue = fn();
            callback(immediateValue);
          }
          if ((0, _config.default)().wrapActionsBeforeExecute) {
            _this8._applyAsync(function () {}, scope);
          }
          return disposeWatcher;
        },
        templates: {
          'dx-polymorph-widget': {
            render: function render(options) {
              var widgetName = options.model.widget;
              if (!widgetName) {
                return;
              }
              var markup = (0, _renderer.default)('<div>').attr((0, _inflector.dasherize)(widgetName), 'options').get(0);
              var newScope = _this8._scope.$new();
              newScope.options = options.model.options;
              options.container.append(markup);
              _this8._compile(markup)(newScope);
            }
          }
        }
      };
      result.modelByElement = function () {
        return scope;
      };
      return result;
    }
  });
  ComponentBuilder = ComponentBuilder.inherit({
    ctor(options) {
      this._componentName = options.componentName;
      this._ngModel = options.ngModel;
      this._ngModelController = options.ngModelController;
      this.callBase.apply(this, arguments);
    },
    _isNgModelRequired() {
      return _editor.default.isEditor(this._componentClass.prototype) && this._ngModel;
    },
    _initComponentBindings() {
      this.callBase.apply(this, arguments);
      this._initNgModelBinding();
    },
    _initNgModelBinding() {
      var _this9 = this;
      if (!this._isNgModelRequired()) {
        return;
      }
      var clearNgModelWatcher = this._scope.$watch(this._ngModel, function (newValue, oldValue) {
        if (_this9._ngLocker.locked(NG_MODEL_OPTION)) {
          return;
        }
        if (newValue === oldValue) {
          return;
        }
        _this9._component.option(NG_MODEL_OPTION, newValue);
      });
      this._optionChangedCallbacks.add(function (args) {
        _this9._ngLocker.obtain(NG_MODEL_OPTION);
        try {
          if (args.name !== NG_MODEL_OPTION) {
            return;
          }
          _this9._ngModelController.$setViewValue(args.value);
        } finally {
          if (_this9._ngLocker.locked(NG_MODEL_OPTION)) {
            _this9._ngLocker.release(NG_MODEL_OPTION);
          }
        }
      });
      this._componentDisposing.add(clearNgModelWatcher);
    },
    _evalOptions() {
      if (!this._isNgModelRequired()) {
        return this.callBase.apply(this, arguments);
      }
      var result = this.callBase.apply(this, arguments);
      result[NG_MODEL_OPTION] = this._parse(this._ngModel)(this._scope);
      return result;
    }
  });
  var registeredComponents = {};
  var registerComponentDirective = function registerComponentDirective(name) {
    var priority = name !== 'dxValidator' ? 1 : 10;
    _module.default.directive(name, ['$compile', '$parse', 'dxDigestCallbacks', function ($compile, $parse, dxDigestCallbacks) {
      return {
        restrict: 'A',
        require: '^?ngModel',
        priority,
        compile($element) {
          var componentClass = registeredComponents[name];
          var useTemplates = componentClass.prototype._useTemplates ? componentClass.prototype._useTemplates() : getClassMethod(componentClass, '_useTemplates')();
          var $content = useTemplates ? $element.contents().detach() : null;
          return function (scope, $element, attrs, ngModelController, transcludeFn) {
            $element.append($content);
            safeApply(function () {
              new ComponentBuilder({
                componentClass,
                componentName: name,
                compile: $compile,
                parse: $parse,
                $element,
                scope,
                ngOptionsString: attrs[name],
                ngOptions: attrs[name] ? scope.$eval(attrs[name]) : {},
                ngModel: attrs.ngModel,
                ngModelController,
                transcludeFn,
                itemAlias: attrs[ITEM_ALIAS_ATTRIBUTE_NAME],
                dxDigestCallbacks
              });
            }, scope);
          };
        }
      };
    }]);
  };
  _component_registrator_callbacks.default.add(function (name, componentClass) {
    if (!registeredComponents[name]) {
      registerComponentDirective(name);
    }
    registeredComponents[name] = componentClass;
  });
}

/***/ }),

/***/ 11579:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _module = _interopRequireDefault(__webpack_require__(69155));
var _angular = _interopRequireDefault(__webpack_require__(62387));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_angular.default) {
  _module.default.service('dxDigestCallbacks', ['$rootScope', function ($rootScope) {
    var begin = (0, _callbacks.default)();
    var prioritizedEnd = (0, _callbacks.default)();
    var end = (0, _callbacks.default)();
    var digestPhase = false;
    $rootScope.$watch(function () {
      if (digestPhase) {
        return;
      }
      digestPhase = true;
      begin.fire();
      $rootScope.$$postDigest(function () {
        digestPhase = false;
        prioritizedEnd.fire();
        end.fire();
      });
    });
    return {
      begin: {
        add: function add(callback) {
          if (digestPhase) {
            callback();
          }
          begin.add(callback);
        },
        remove: begin.remove.bind(begin)
      },
      end: {
        add: end.add.bind(end),
        addPrioritized: prioritizedEnd.add.bind(prioritizedEnd),
        remove: end.remove.bind(end)
      }
    };
  }]);
}

/***/ }),

/***/ 12993:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _module = _interopRequireDefault(__webpack_require__(69155));
var _angular = _interopRequireDefault(__webpack_require__(62387));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_angular.default) {
  _event_registrator_callbacks.default.add(function (name) {
    var ngEventName = name.slice(0, 2) + name.charAt(2).toUpperCase() + name.slice(3);
    _module.default.directive(ngEventName, ['$parse', function ($parse) {
      return function (scope, element, attr) {
        var attrValue = attr[ngEventName].trim();
        var handler;
        var eventOptions = {};
        if (attrValue.charAt(0) === '{') {
          eventOptions = scope.$eval(attrValue);
          handler = $parse(eventOptions.execute);
        } else {
          handler = $parse(attr[ngEventName]);
        }
        _events_engine.default.on(element, name, eventOptions, function (e) {
          scope.$apply(function () {
            handler(scope, {
              $event: e
            });
          });
        });
      };
    }]);
  });
}

/***/ }),

/***/ 69155:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _angular = _interopRequireDefault(__webpack_require__(62387));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var ngModule = {};
if (_angular.default) {
  ngModule = _angular.default.module('dx', []);
}
var _default = ngModule;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 76165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.NgTemplate = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _template_base = __webpack_require__(81033);
var _type = __webpack_require__(35922);
var _dom = __webpack_require__(3532);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var NgTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(NgTemplate, _TemplateBase);
  function NgTemplate(element, templateCompiler) {
    var _this;
    _this = _TemplateBase.call(this) || this;
    _this._element = element;
    _this._compiledTemplate = templateCompiler((0, _dom.normalizeTemplateElement)(_this._element));
    return _this;
  }
  var _proto = NgTemplate.prototype;
  _proto._renderCore = function _renderCore(options) {
    var compiledTemplate = this._compiledTemplate;
    return (0, _type.isFunction)(compiledTemplate) ? compiledTemplate(options) : compiledTemplate;
  };
  _proto.source = function source() {
    return (0, _renderer.default)(this._element).clone();
  };
  return NgTemplate;
}(_template_base.TemplateBase);
exports.NgTemplate = NgTemplate;

/***/ }),

/***/ 78475:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _version = __webpack_require__(58020);
var _error = _interopRequireDefault(__webpack_require__(95640));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
__webpack_require__(17394);
__webpack_require__(59228);
__webpack_require__(66809);
__webpack_require__(32185);
__webpack_require__(711);
__webpack_require__(27387);
__webpack_require__(95063);
__webpack_require__(63200);
__webpack_require__(87481);
__webpack_require__(30829);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _use_jquery.default)();
if (useJQuery && (0, _version.compare)(_jquery.default.fn.jquery, [1, 10]) < 0) {
  throw _error.default.Error('E0012');
}

/***/ }),

/***/ 30829:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _ajax = _interopRequireDefault(__webpack_require__(37208));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  _ajax.default.inject({
    sendRequest: function sendRequest(options) {
      if (!options.responseType && !options.upload) {
        return _jquery.default.ajax(options);
      }
      return this.callBase.apply(this, [options]);
    }
  });
}

/***/ }),

/***/ 87481:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(5554));
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_jquery.default) {
  var registerJQueryComponent = function registerJQueryComponent(name, componentClass) {
    _jquery.default.fn[name] = function (options) {
      var isMemberInvoke = typeof options === 'string';
      var result;
      if (isMemberInvoke) {
        var memberName = options;
        var memberArgs = [].slice.call(arguments).slice(1);
        this.each(function () {
          var instance = componentClass.getInstance(this);
          if (!instance) {
            throw _errors.default.Error('E0009', name);
          }
          var member = instance[memberName];
          var memberValue = member.apply(instance, memberArgs);
          if (result === undefined) {
            result = memberValue;
          }
        });
      } else {
        this.each(function () {
          var instance = componentClass.getInstance(this);
          if (instance) {
            instance.option(options);
          } else {
            new componentClass(this, options);
          }
        });
        result = this;
      }
      return result;
    };
  };
  _component_registrator_callbacks.default.add(registerJQueryComponent);
}

/***/ }),

/***/ 66809:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _deferred = __webpack_require__(62754);
var _version = __webpack_require__(58020);
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  var Deferred = _jquery.default.Deferred;
  var strategy = {
    Deferred: Deferred
  };
  strategy.when = (0, _version.compare)(_jquery.default.fn.jquery, [3]) < 0 ? _jquery.default.when : function (singleArg) {
    if (arguments.length === 0) {
      return new Deferred().resolve();
    } else if (arguments.length === 1) {
      return singleArg && singleArg.then ? singleArg : new Deferred().resolve(singleArg);
    } else {
      return _jquery.default.when.apply(_jquery.default, arguments);
    }
  };
  (0, _deferred.setStrategy)(strategy);
}

/***/ }),

/***/ 27387:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _easing = __webpack_require__(23908);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_jquery.default) {
  (0, _easing.setEasing)(_jquery.default.easing);
}

/***/ }),

/***/ 63200:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _element = __webpack_require__(6415);
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var useJQuery = (0, _use_jquery.default)();
var getPublicElement = function getPublicElement($element) {
  return $element;
};
if (useJQuery) {
  (0, _element.setPublicElementWrapper)(getPublicElement);
}

/***/ }),

/***/ 95063:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _element_data = __webpack_require__(97906);
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  (0, _element_data.setDataStrategy)(_jquery.default);
}

/***/ }),

/***/ 711:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  _event_registrator_callbacks.default.add(function (name, eventObject) {
    _jquery.default.event.special[name] = eventObject;
  });
  if (_events_engine.default.passiveEventHandlersSupported()) {
    _events_engine.default.forcePassiveFalseEventNames.forEach(function (eventName) {
      _jquery.default.event.special[eventName] = {
        setup: function setup(data, namespaces, handler) {
          _dom_adapter.default.listen(this, eventName, handler, {
            passive: false
          });
        }
      };
    });
  }
  _events_engine.default.set({
    on: function on(element) {
      (0, _jquery.default)(element).on.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    one: function one(element) {
      (0, _jquery.default)(element).one.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    off: function off(element) {
      (0, _jquery.default)(element).off.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    trigger: function trigger(element) {
      (0, _jquery.default)(element).trigger.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    triggerHandler: function triggerHandler(element) {
      (0, _jquery.default)(element).triggerHandler.apply((0, _jquery.default)(element), Array.prototype.slice.call(arguments, 1));
    },
    Event: _jquery.default.Event
  });
}

/***/ }),

/***/ 32185:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _themes_callback = __webpack_require__(89729);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_jquery.default && !_themes_callback.themeReadyCallback.fired()) {
  var holdReady = _jquery.default.holdReady || _jquery.default.fn.holdReady;
  holdReady(true);
  _themes_callback.themeReadyCallback.add(function () {
    _ready_callbacks.default.add(function () {
      holdReady(false);
    });
  });
}

/***/ }),

/***/ 59228:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
var _version = __webpack_require__(58020);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _index = __webpack_require__(39611);
var _event_registrator = _interopRequireDefault(__webpack_require__(85788));
var _hook_touch_props = _interopRequireDefault(__webpack_require__(2418));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  if ((0, _version.compare)(_jquery.default.fn.jquery, [3]) < 0) {
    var POINTER_TYPE_MAP = {
      2: 'touch',
      3: 'pen',
      4: 'mouse'
    };
    (0, _iterator.each)(['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel', 'MSPointerOver', 'MSPointerOut', 'mouseenter', 'mouseleave', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'pointerenter', 'pointerleave'], function () {
      _jquery.default.event.fixHooks[this] = {
        filter: function filter(event, originalEvent) {
          var pointerType = originalEvent.pointerType;
          if ((0, _type.isNumeric)(pointerType)) {
            event.pointerType = POINTER_TYPE_MAP[pointerType];
          }
          return event;
        },
        props: _jquery.default.event.mouseHooks.props.concat(['pointerId', 'pointerType', 'originalTarget', 'width', 'height', 'pressure', 'result', 'tiltX', 'charCode', 'tiltY', 'detail', 'isPrimary', 'prevValue'])
      };
    });
    (0, _iterator.each)(['touchstart', 'touchmove', 'touchend', 'touchcancel'], function () {
      _jquery.default.event.fixHooks[this] = {
        filter: function filter(event, originalEvent) {
          (0, _hook_touch_props.default)(function (name, hook) {
            event[name] = hook(originalEvent);
          });
          return event;
        },
        props: _jquery.default.event.mouseHooks.props.concat(['touches', 'changedTouches', 'targetTouches', 'detail', 'result', 'originalTarget', 'charCode', 'prevValue'])
      };
    });
    _jquery.default.event.fixHooks['wheel'] = _jquery.default.event.mouseHooks;
    var DX_EVENT_HOOKS = {
      props: _jquery.default.event.mouseHooks.props.concat(['pointerType', 'pointerId', 'pointers'])
    };
    _event_registrator.default.callbacks.add(function (name) {
      _jquery.default.event.fixHooks[name] = DX_EVENT_HOOKS;
    });
    var fix = function fix(event, originalEvent) {
      var fixHook = _jquery.default.event.fixHooks[originalEvent.type] || _jquery.default.event.mouseHooks;
      var props = fixHook.props ? _jquery.default.event.props.concat(fixHook.props) : _jquery.default.event.props;
      var propIndex = props.length;
      while (propIndex--) {
        var prop = props[propIndex];
        event[prop] = originalEvent[prop];
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    };
    (0, _index.setEventFixMethod)(fix);
  } else {
    (0, _hook_touch_props.default)(function (name, hook) {
      _jquery.default.event.addProp(name, hook);
    });
  }
}

/***/ }),

/***/ 17394:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _renderer_base = _interopRequireDefault(__webpack_require__(82981));
var _use_jquery = _interopRequireDefault(__webpack_require__(72722));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _use_jquery.default)();
if (useJQuery) {
  _renderer_base.default.set(_jquery.default);
}

/***/ }),

/***/ 72722:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _jquery = _interopRequireDefault(__webpack_require__(96073));
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var useJQuery = (0, _config.default)().useJQuery;
if (_jquery.default && useJQuery !== false) {
  (0, _config.default)({
    useJQuery: true
  });
}
function _default() {
  return _jquery.default && (0, _config.default)().useJQuery;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49281:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _version = __webpack_require__(58020);
__webpack_require__(89135);
__webpack_require__(70883);
__webpack_require__(89620);
__webpack_require__(24935);
__webpack_require__(74942);
__webpack_require__(27521);
__webpack_require__(61823);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

// Check availability in global environment
if (_knockout.default) {
  if ((0, _version.compare)(_knockout.default.version, [2, 3]) < 0) {
    throw _errors.default.Error('E0013');
  }
}

/***/ }),

/***/ 27521:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _element_data = __webpack_require__(97906);
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _version = __webpack_require__(58020);
var _utils = __webpack_require__(45994);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  var originalKOCleanExternalData = _knockout.default.utils.domNodeDisposal.cleanExternalData;
  var patchCleanData = function patchCleanData() {
    (0, _element_data.afterCleanData)(function (nodes) {
      var i;
      for (i = 0; i < nodes.length; i++) {
        nodes[i].cleanedByJquery = true;
      }
      for (i = 0; i < nodes.length; i++) {
        if (!nodes[i].cleanedByKo) {
          _knockout.default.cleanNode(nodes[i]);
        }
        delete nodes[i].cleanedByKo;
      }
      for (i = 0; i < nodes.length; i++) {
        delete nodes[i].cleanedByJquery;
      }
    });
    _knockout.default.utils.domNodeDisposal.cleanExternalData = function (node) {
      node.cleanedByKo = true;
      if ((0, _utils.getClosestNodeWithKoCreation)(node)) {
        if (!node.cleanedByJquery) {
          (0, _element_data.cleanData)([node]);
        }
      }
    };
  };
  var restoreOriginCleanData = function restoreOriginCleanData() {
    (0, _element_data.afterCleanData)(function () {});
    _knockout.default.utils.domNodeDisposal.cleanExternalData = originalKOCleanExternalData;
  };
  patchCleanData();
  _element_data.strategyChanging.add(function (strategy) {
    var isJQuery = !!strategy.fn;
    if (isJQuery && (0, _version.compare)(strategy.fn.jquery, [2, 0]) < 0) {
      restoreOriginCleanData();
    }
  });
}

/***/ }),

/***/ 61823:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _version = __webpack_require__(58020);
var _element_data = __webpack_require__(97906);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  var patchCleanData = function patchCleanData(jQuery) {
    var cleanKoData = function cleanKoData(element, andSelf) {
      var cleanNode = function cleanNode() {
        _knockout.default.cleanNode(this);
      };
      if (andSelf) {
        element.each(cleanNode);
      } else {
        element.find('*').each(cleanNode);
      }
    };
    var originalEmpty = jQuery.fn.empty;
    jQuery.fn.empty = function () {
      cleanKoData(this, false);
      return originalEmpty.apply(this, arguments);
    };
    var originalRemove = jQuery.fn.remove;
    jQuery.fn.remove = function (selector, keepData) {
      if (!keepData) {
        var subject = this;
        if (selector) {
          subject = subject.filter(selector);
        }
        cleanKoData(subject, true);
      }
      return originalRemove.call(this, selector, keepData);
    };
    var originalHtml = jQuery.fn.html;
    jQuery.fn.html = function (value) {
      if (typeof value === 'string') {
        cleanKoData(this, false);
      }
      return originalHtml.apply(this, arguments);
    };
    var originalReplaceWith = jQuery.fn.replaceWith;
    jQuery.fn.replaceWith = function () {
      var result = originalReplaceWith.apply(this, arguments);
      if (!this.parent().length) {
        cleanKoData(this, true);
      }
      return result;
    };
  };
  _element_data.strategyChanging.add(function (strategy) {
    var isJQuery = !!strategy.fn;
    if (isJQuery && (0, _version.compare)(strategy.fn.jquery, [2, 0]) < 0) {
      patchCleanData(strategy);
    }
  });
}

/***/ }),

/***/ 89135:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _type = __webpack_require__(35922);
var _component_registrator_callbacks = _interopRequireDefault(__webpack_require__(5554));
var _ui = _interopRequireDefault(__webpack_require__(14390));
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component = _interopRequireDefault(__webpack_require__(27135));
var _draggable = _interopRequireDefault(__webpack_require__(42160));
var _scroll_view = _interopRequireDefault(__webpack_require__(4741));
var _template = __webpack_require__(1129);
var _editor = _interopRequireDefault(__webpack_require__(96452));
var _locker = _interopRequireDefault(__webpack_require__(88933));
var _utils = __webpack_require__(45994);
var _config = _interopRequireDefault(__webpack_require__(80209));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  var LOCKS_DATA_KEY = 'dxKoLocks';
  var CREATED_WITH_KO_DATA_KEY = 'dxKoCreation';
  var editorsBindingHandlers = [];
  var registerComponentKoBinding = function registerComponentKoBinding(componentName, componentClass) {
    if (_editor.default.isEditor(componentClass.prototype)) {
      editorsBindingHandlers.push(componentName);
    }
    _knockout.default.bindingHandlers[componentName] = {
      init: function init(domNode, valueAccessor) {
        var $element = (0, _renderer.default)(domNode);
        var optionChangedCallbacks = (0, _callbacks.default)();
        var optionsByReference = {};
        var component;
        var knockoutConfig = (0, _config.default)().knockout;
        var isBindingPropertyPredicateName = knockoutConfig && knockoutConfig.isBindingPropertyPredicateName;
        var isBindingPropertyPredicate;
        var ctorOptions = {
          onInitializing: function onInitializing(options) {
            var _this = this;
            optionsByReference = this._getOptionsByReference();
            _knockout.default.computed(function () {
              var model = _knockout.default.unwrap(valueAccessor());
              if (component) {
                component.beginUpdate();
              }
              isBindingPropertyPredicate = isBindingPropertyPredicateName && model && model[isBindingPropertyPredicateName];
              unwrapModel(model);
              if (component) {
                component.endUpdate();
              } else {
                var _model$onInitializing;
                model === null || model === void 0 ? void 0 : (_model$onInitializing = model.onInitializing) === null || _model$onInitializing === void 0 ? void 0 : _model$onInitializing.call(_this, options);
              }
            }, null, {
              disposeWhenNodeIsRemoved: domNode
            });
            component = this;
          },
          modelByElement: function modelByElement($element) {
            if ($element.length) {
              var node = (0, _utils.getClosestNodeWithContext)($element.get(0));
              return _knockout.default.dataFor(node);
            }
          },
          nestedComponentOptions: function nestedComponentOptions(component) {
            return {
              modelByElement: component.option('modelByElement'),
              nestedComponentOptions: component.option('nestedComponentOptions')
            };
          },
          _optionChangedCallbacks: optionChangedCallbacks,
          integrationOptions: {
            watchMethod: function watchMethod(fn, callback, options) {
              options = options || {};
              var skipCallback = options.skipImmediate;
              var watcher = _knockout.default.computed(function () {
                var newValue = _knockout.default.unwrap(fn());
                if (!skipCallback) {
                  callback(newValue);
                }
                skipCallback = false;
              });
              return function () {
                watcher.dispose();
              };
            },
            templates: {
              'dx-polymorph-widget': {
                render: function render(options) {
                  var widgetName = _knockout.default.utils.unwrapObservable(options.model.widget);
                  if (!widgetName) {
                    return;
                  }
                  var markup = (0, _renderer.default)('<div>').attr('data-bind', widgetName + ': options').get(0);
                  (0, _renderer.default)(options.container).append(markup);
                  _knockout.default.applyBindings(options.model, markup);
                }
              }
            },
            createTemplate: function createTemplate(element) {
              return new _template.KoTemplate(element);
            }
          }
        };
        var optionNameToModelMap = {};
        var applyModelValueToOption = function applyModelValueToOption(optionName, modelValue, unwrap) {
          var locks = $element.data(LOCKS_DATA_KEY);
          var optionValue = unwrap ? _knockout.default.unwrap(modelValue) : modelValue;
          if (_knockout.default.isWriteableObservable(modelValue)) {
            optionNameToModelMap[optionName] = modelValue;
          }
          if (component) {
            if (locks.locked(optionName)) {
              return;
            }
            locks.obtain(optionName);
            try {
              if (_knockout.default.ignoreDependencies) {
                _knockout.default.ignoreDependencies(component.option, component, [optionName, optionValue]);
              } else {
                component.option(optionName, optionValue);
              }
            } finally {
              locks.release(optionName);
            }
          } else {
            ctorOptions[optionName] = optionValue;
          }
        };
        var handleOptionChanged = function handleOptionChanged(args) {
          var optionName = args.fullName;
          var optionValue = args.value;
          if (!(optionName in optionNameToModelMap)) {
            return;
          }
          var $element = this._$element;
          var locks = $element.data(LOCKS_DATA_KEY);
          if (locks.locked(optionName)) {
            return;
          }
          locks.obtain(optionName);
          try {
            optionNameToModelMap[optionName](optionValue);
          } finally {
            locks.release(optionName);
          }
        };
        var createComponent = function createComponent() {
          optionChangedCallbacks.add(handleOptionChanged);
          $element.data(CREATED_WITH_KO_DATA_KEY, true).data(LOCKS_DATA_KEY, new _locker.default());
          new componentClass($element, ctorOptions);
          ctorOptions = null;
        };
        var unwrapModelValue = function unwrapModelValue(currentModel, propertyName, propertyPath) {
          if (propertyPath === isBindingPropertyPredicateName) {
            return;
          }
          if (!isBindingPropertyPredicate || isBindingPropertyPredicate(propertyPath, propertyName, currentModel)) {
            var unwrappedPropertyValue;
            _knockout.default.computed(function () {
              var propertyValue = currentModel[propertyName];
              applyModelValueToOption(propertyPath, propertyValue, true);
              unwrappedPropertyValue = _knockout.default.unwrap(propertyValue);
            }, null, {
              disposeWhenNodeIsRemoved: domNode
            });
            if ((0, _type.isPlainObject)(unwrappedPropertyValue)) {
              if (!optionsByReference[propertyPath]) {
                unwrapModel(unwrappedPropertyValue, propertyPath);
              }
            }
          } else {
            applyModelValueToOption(propertyPath, currentModel[propertyName], false);
          }
        };
        function unwrapModel(model, propertyPath) {
          for (var propertyName in model) {
            if (Object.prototype.hasOwnProperty.call(model, propertyName)) {
              unwrapModelValue(model, propertyName, propertyPath ? [propertyPath, propertyName].join('.') : propertyName);
            }
          }
        }
        createComponent();
        return {
          controlsDescendantBindings: componentClass.subclassOf(_ui.default) || componentClass.subclassOf(_m_base_widget.default) || componentClass.subclassOf(_component.default) && !(component instanceof _scroll_view.default) || component instanceof _draggable.default
        };
      }
    };
    if (componentName === 'dxValidator') {
      _knockout.default.bindingHandlers['dxValidator'].after = editorsBindingHandlers;
    }
  };
  _component_registrator_callbacks.default.add(function (name, componentClass) {
    registerComponentKoBinding(name, componentClass);
  });
}

/***/ }),

/***/ 89620:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _icon = __webpack_require__(44899);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  _knockout.default.bindingHandlers.dxControlsDescendantBindings = {
    init: function init(_, valueAccessor) {
      return {
        controlsDescendantBindings: _knockout.default.unwrap(valueAccessor())
      };
    }
  };
  _knockout.default.bindingHandlers.dxIcon = {
    init: function init(element, valueAccessor) {
      var options = _knockout.default.utils.unwrapObservable(valueAccessor()) || {};
      var iconElement = (0, _icon.getImageContainer)(options);
      _knockout.default.virtualElements.emptyNode(element);
      if (iconElement) {
        _knockout.default.virtualElements.prepend(element, iconElement.get(0));
      }
    },
    update: function update(element, valueAccessor) {
      var options = _knockout.default.utils.unwrapObservable(valueAccessor()) || {};
      var iconElement = (0, _icon.getImageContainer)(options);
      _knockout.default.virtualElements.emptyNode(element);
      if (iconElement) {
        _knockout.default.virtualElements.prepend(element, iconElement.get(0));
      }
    }
  };
  _knockout.default.virtualElements.allowedBindings.dxIcon = true;
}

/***/ }),

/***/ 70883:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _type = __webpack_require__(35922);
var _event_registrator_callbacks = _interopRequireDefault(__webpack_require__(94553));
var _index = __webpack_require__(39611);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  _event_registrator_callbacks.default.add(function (name) {
    var koBindingEventName = (0, _index.addNamespace)(name, name + 'Binding');
    _knockout.default.bindingHandlers[name] = {
      update: function update(element, valueAccessor, allBindingsAccessor, viewModel) {
        var $element = (0, _renderer.default)(element);
        var unwrappedValue = _knockout.default.utils.unwrapObservable(valueAccessor());
        var eventSource = unwrappedValue.execute ? unwrappedValue.execute : unwrappedValue;
        _events_engine.default.off($element, koBindingEventName);
        _events_engine.default.on($element, koBindingEventName, (0, _type.isPlainObject)(unwrappedValue) ? unwrappedValue : {}, function (e) {
          eventSource.call(viewModel, viewModel, e);
        });
      }
    };
  });
}

/***/ }),

/***/ 1129:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.KoTemplate = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _type = __webpack_require__(35922);
var _template_base = __webpack_require__(81033);
var _dom = __webpack_require__(3532);
var _utils = __webpack_require__(45994);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } // eslint-disable-next-line no-restricted-imports
var getParentContext = function getParentContext(data) {
  var parentNode = _dom_adapter.default.createElement('div');
  _knockout.default.applyBindingsToNode(parentNode, null, data);
  var parentContext = _knockout.default.contextFor(parentNode);
  _knockout.default.cleanNode(parentNode);
  return parentContext;
};
var KoTemplate = /*#__PURE__*/function (_TemplateBase) {
  _inheritsLoose(KoTemplate, _TemplateBase);
  function KoTemplate(element) {
    var _this;
    _this = _TemplateBase.call(this) || this;
    _this._element = element;
    _this._template = (0, _renderer.default)('<div>').append((0, _dom.normalizeTemplateElement)(element));
    _this._registerKoTemplate();
    return _this;
  }
  var _proto = KoTemplate.prototype;
  _proto._registerKoTemplate = function _registerKoTemplate() {
    var template = this._template.get(0);
    new _knockout.default.templateSources.anonymousTemplate(template)['nodes'](template);
  };
  _proto._prepareDataForContainer = function _prepareDataForContainer(data, container) {
    if (container && container.length) {
      var node = (0, _utils.getClosestNodeWithContext)(container.get(0));
      var containerContext = _knockout.default.contextFor(node);
      data = data !== undefined ? data : _knockout.default.dataFor(node) || {};
      if (containerContext) {
        return data === containerContext.$data ? containerContext : containerContext.createChildContext(data);
      }
    }

    // workaround for https://github.com/knockout/knockout/pull/651
    return getParentContext(data).createChildContext(data);
  };
  _proto._renderCore = function _renderCore(options) {
    var model = this._prepareDataForContainer(options.model, (0, _renderer.default)(options.container));
    if ((0, _type.isDefined)(options.index)) {
      model.$index = options.index;
    }
    var $placeholder = (0, _renderer.default)('<div>').appendTo(options.container);
    var $result;
    _knockout.default.renderTemplate(this._template.get(0), model, {
      afterRender: function afterRender(nodes) {
        $result = (0, _renderer.default)(nodes);
      }
    }, $placeholder.get(0), 'replaceNode');
    return $result;
  };
  _proto.source = function source() {
    return (0, _renderer.default)(this._element).clone();
  };
  _proto.dispose = function dispose() {
    this._template.remove();
  };
  return KoTemplate;
}(_template_base.TemplateBase);
exports.KoTemplate = KoTemplate;

/***/ }),

/***/ 45994:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getClosestNodeWithKoCreation = exports.getClosestNodeWithContext = void 0;
var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

var getClosestNodeWithContext = function getClosestNodeWithContext(node) {
  var context = _knockout.default.contextFor(node);
  if (!context && node.parentNode) {
    return getClosestNodeWithContext(node.parentNode);
  }
  return node;
};
exports.getClosestNodeWithContext = getClosestNodeWithContext;
var getClosestNodeWithKoCreation = function getClosestNodeWithKoCreation(node) {
  var $el = (0, _renderer.default)(node);
  var data = $el.data();
  var hasFlag = data && data['dxKoCreation'];
  if (hasFlag) {
    return node;
  }
  if (node.parentNode) {
    return getClosestNodeWithKoCreation(node.parentNode);
  }
  return null;
};
exports.getClosestNodeWithKoCreation = getClosestNodeWithKoCreation;

/***/ }),

/***/ 24935:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _events_strategy = __webpack_require__(80566);
var _validation_engine = _interopRequireDefault(__webpack_require__(90964));
var _deferred = __webpack_require__(62754);
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _knockout = _interopRequireDefault(__webpack_require__(76130));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  var VALIDATION_STATUS_VALID = 'valid';
  var VALIDATION_STATUS_PENDING = 'pending';
  var koDxValidator = _class.default.inherit({
    ctor(target, _ref) {
      var _this = this;
      var name = _ref.name,
        validationRules = _ref.validationRules;
      this.target = target;
      this.name = name;
      this.isValid = _knockout.default.observable(true);
      this.validationError = _knockout.default.observable();
      this.validationErrors = _knockout.default.observable();
      this.validationStatus = _knockout.default.observable(VALIDATION_STATUS_VALID);
      this._eventsStrategy = new _events_strategy.EventsStrategy(this);
      this.validationRules = (0, _iterator.map)(validationRules, function (rule, index) {
        return (0, _extend.extend)({}, rule, {
          validator: _this,
          index: index
        });
      });
      this._validationInfo = {
        result: null,
        deferred: null
      };
    },
    _updateValidationResult(result) {
      if (!this._validationInfo.result || this._validationInfo.result.id !== result.id) {
        var complete = this._validationInfo.deferred && this._validationInfo.result.complete;
        this._validationInfo.result = (0, _extend.extend)({}, result, {
          complete
        });
      } else {
        for (var prop in result) {
          if (prop !== 'id' && prop !== 'complete') {
            this._validationInfo.result[prop] = result[prop];
          }
        }
      }
    },
    validate() {
      var _this2 = this;
      var currentResult = this._validationInfo && this._validationInfo.result;
      var value = this.target();
      if (currentResult && currentResult.status === VALIDATION_STATUS_PENDING && currentResult.value === value) {
        return (0, _extend.extend)({}, currentResult);
      }
      var result = _validation_engine.default.validate(value, this.validationRules, this.name);
      result.id = new _guid.default().toString();
      this._applyValidationResult(result);
      result.complete && result.complete.then(function (res) {
        if (res.id === _this2._validationInfo.result.id) {
          _this2._applyValidationResult(res);
        }
      });
      return (0, _extend.extend)({}, this._validationInfo.result);
    },
    reset() {
      this.target(null);
      var result = {
        id: null,
        isValid: true,
        brokenRule: null,
        pendingRules: null,
        status: VALIDATION_STATUS_VALID,
        complete: null
      };
      this._applyValidationResult(result);
      return result;
    },
    _applyValidationResult(result) {
      result.validator = this;
      this._updateValidationResult(result);
      this.target.dxValidator.isValid(this._validationInfo.result.isValid);
      this.target.dxValidator.validationError(this._validationInfo.result.brokenRule);
      this.target.dxValidator.validationErrors(this._validationInfo.result.brokenRules);
      this.target.dxValidator.validationStatus(this._validationInfo.result.status);
      if (result.status === VALIDATION_STATUS_PENDING) {
        if (!this._validationInfo.deferred) {
          this._validationInfo.deferred = new _deferred.Deferred();
          this._validationInfo.result.complete = this._validationInfo.deferred.promise();
        }
        this._eventsStrategy.fireEvent('validating', [this._validationInfo.result]);
        return;
      }
      if (result.status !== VALIDATION_STATUS_PENDING) {
        this._eventsStrategy.fireEvent('validated', [result]);
        if (this._validationInfo.deferred) {
          this._validationInfo.deferred.resolve(result);
          this._validationInfo.deferred = null;
        }
      }
    },
    on(eventName, eventHandler) {
      this._eventsStrategy.on(eventName, eventHandler);
      return this;
    },
    off(eventName, eventHandler) {
      this._eventsStrategy.off(eventName, eventHandler);
      return this;
    }
  });
  _knockout.default.extenders.dxValidator = function (target, option) {
    target.dxValidator = new koDxValidator(target, option);
    target.subscribe(target.dxValidator.validate.bind(target.dxValidator));
    return target;
  };

  // TODO: MODULARITY: Move this to another place?

  _validation_engine.default.registerModelForValidation = function (model) {
    (0, _iterator.each)(model, function (name, member) {
      if (_knockout.default.isObservable(member) && member.dxValidator) {
        _validation_engine.default.registerValidatorInGroup(model, member.dxValidator);
      }
    });
  };
  _validation_engine.default.unregisterModelForValidation = function (model) {
    (0, _iterator.each)(model, function (name, member) {
      if (_knockout.default.isObservable(member) && member.dxValidator) {
        _validation_engine.default.removeRegisteredValidator(model, member.dxValidator);
      }
    });
  };
  _validation_engine.default.validateModel = _validation_engine.default.validateGroup;
}

/***/ }),

/***/ 74942:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _knockout = _interopRequireDefault(__webpack_require__(76130));
var _variable_wrapper = _interopRequireDefault(__webpack_require__(26974));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_knockout.default) {
  _variable_wrapper.default.inject({
    isWrapped: _knockout.default.isObservable,
    isWritableWrapped: _knockout.default.isWritableObservable,
    wrap: _knockout.default.observable,
    unwrap: function unwrap(value) {
      if (_knockout.default.isObservable(value)) {
        return _knockout.default.utils.unwrapObservable(value);
      }
      return this.callBase(value);
    },
    assign: function assign(variable, value) {
      if (_knockout.default.isObservable(variable)) {
        variable(value);
      } else {
        this.callBase(variable, value);
      }
    }
  });
}

/***/ }),

/***/ 94484:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "date", ({
  enumerable: true,
  get: function get() {
    return _date.default;
  }
}));
exports.disableIntl = disableIntl;
exports.locale = exports.loadMessages = exports.formatNumber = exports.formatMessage = exports.formatDate = void 0;
Object.defineProperty(exports, "message", ({
  enumerable: true,
  get: function get() {
    return _message.default;
  }
}));
Object.defineProperty(exports, "number", ({
  enumerable: true,
  get: function get() {
    return _number.default;
  }
}));
exports.parseNumber = exports.parseDate = void 0;
var _core = _interopRequireDefault(__webpack_require__(91331));
var _message = _interopRequireDefault(__webpack_require__(28109));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date = _interopRequireDefault(__webpack_require__(91500));
__webpack_require__(89740);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @name localization
 */

var locale = _core.default.locale.bind(_core.default);
exports.locale = locale;
var loadMessages = _message.default.load.bind(_message.default);
exports.loadMessages = loadMessages;
var formatMessage = _message.default.format.bind(_message.default);
exports.formatMessage = formatMessage;
var formatNumber = _number.default.format.bind(_number.default);
exports.formatNumber = formatNumber;
var parseNumber = _number.default.parse.bind(_number.default);
exports.parseNumber = parseNumber;
var formatDate = _date.default.format.bind(_date.default);
exports.formatDate = formatDate;
var parseDate = _date.default.parse.bind(_date.default);
exports.parseDate = parseDate;
function disableIntl() {
  if (_number.default.engine() === 'intl') {
    _number.default.resetInjection();
  }
  if (_date.default.engine() === 'intl') {
    _date.default.resetInjection();
  }
}

/***/ }),

/***/ 71868:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = {
  "af": "#,##0.00;(#,##0.00)",
  "af-NA": "#,##0.00;(#,##0.00)",
  "agq": "#,##0.00",
  "ak": "#,##0.00",
  "am": "#,##0.00;(#,##0.00)",
  "ar": "#,##0.00;(#,##0.00)",
  "ar-AE": "#,##0.00;(#,##0.00)",
  "ar-BH": "#,##0.00;(#,##0.00)",
  "ar-DJ": "#,##0.00;(#,##0.00)",
  "ar-DZ": "#,##0.00;(#,##0.00)",
  "ar-EG": "#,##0.00;(#,##0.00)",
  "ar-EH": "#,##0.00;(#,##0.00)",
  "ar-ER": "#,##0.00;(#,##0.00)",
  "ar-IL": "#,##0.00;(#,##0.00)",
  "ar-IQ": "#,##0.00;(#,##0.00)",
  "ar-JO": "#,##0.00;(#,##0.00)",
  "ar-KM": "#,##0.00;(#,##0.00)",
  "ar-KW": "#,##0.00;(#,##0.00)",
  "ar-LB": "#,##0.00;(#,##0.00)",
  "ar-LY": "#,##0.00;(#,##0.00)",
  "ar-MA": "#,##0.00;(#,##0.00)",
  "ar-MR": "#,##0.00;(#,##0.00)",
  "ar-OM": "#,##0.00;(#,##0.00)",
  "ar-PS": "#,##0.00;(#,##0.00)",
  "ar-QA": "#,##0.00;(#,##0.00)",
  "ar-SA": "#,##0.00;(#,##0.00)",
  "ar-SD": "#,##0.00;(#,##0.00)",
  "ar-SO": "#,##0.00;(#,##0.00)",
  "ar-SS": "#,##0.00;(#,##0.00)",
  "ar-SY": "#,##0.00;(#,##0.00)",
  "ar-TD": "#,##0.00;(#,##0.00)",
  "ar-TN": "#,##0.00;(#,##0.00)",
  "ar-YE": "#,##0.00;(#,##0.00)",
  "as": "#,##,##0.00",
  "asa": "#,##0.00",
  "ast": "#,##0.00",
  "az": "#,##0.00",
  "az-Cyrl": "#,##0.00",
  "az-Latn": "#,##0.00",
  "bas": "#,##0.00",
  "be": "#,##0.00",
  "be-tarask": "#,##0.00",
  "bem": "#,##0.00;(#,##0.00)",
  "bez": "#,##0.00",
  "bg": "0.00;(0.00)",
  "bm": "#,##0.00;(#,##0.00)",
  "bn": "#,##,##0.00;(#,##,##0.00)",
  "bn-IN": "#,##,##0.00;(#,##,##0.00)",
  "bo": "#,##0.00",
  "bo-IN": "#,##0.00",
  "br": "#,##0.00",
  "brx": "#,##,##0.00",
  "bs": "#,##0.00",
  "bs-Cyrl": "#,##0.00",
  "bs-Latn": "#,##0.00",
  "ca": "#,##0.00;(#,##0.00)",
  "ca-AD": "#,##0.00;(#,##0.00)",
  "ca-ES-valencia": "#,##0.00;(#,##0.00)",
  "ca-FR": "#,##0.00;(#,##0.00)",
  "ca-IT": "#,##0.00;(#,##0.00)",
  "ccp": "#,##,##0.00;(#,##,##0.00)",
  "ccp-IN": "#,##,##0.00;(#,##,##0.00)",
  "ce": "#,##0.00",
  "ceb": "#,##0.00;(#,##0.00)",
  "cgg": "#,##0.00",
  "chr": "#,##0.00;(#,##0.00)",
  "ckb": "#,##0.00",
  "ckb-IR": "#,##0.00",
  "cs": "#,##0.00",
  "cy": "#,##0.00;(#,##0.00)",
  "da": "#,##0.00",
  "da-GL": "#,##0.00",
  "dav": "#,##0.00;(#,##0.00)",
  "de": "#,##0.00",
  "de-AT": "#,##0.00",
  "de-BE": "#,##0.00",
  "de-CH": "#,##0.00",
  "de-IT": "#,##0.00",
  "de-LI": "#,##0.00",
  "de-LU": "#,##0.00",
  "dje": "#,##0.00",
  "doi": "#,##0.00",
  "dsb": "#,##0.00",
  "dua": "#,##0.00",
  "dyo": "#,##0.00",
  "dz": "#,##,##0.00",
  "ebu": "#,##0.00;(#,##0.00)",
  "ee": "#,##0.00;(#,##0.00)",
  "ee-TG": "#,##0.00;(#,##0.00)",
  "el": "#,##0.00",
  "el-CY": "#,##0.00",
  "en": "#,##0.00;(#,##0.00)",
  "en-001": "#,##0.00;(#,##0.00)",
  "en-150": "#,##0.00",
  "en-AE": "#,##0.00;(#,##0.00)",
  "en-AG": "#,##0.00;(#,##0.00)",
  "en-AI": "#,##0.00;(#,##0.00)",
  "en-AS": "#,##0.00;(#,##0.00)",
  "en-AT": "#,##0.00",
  "en-AU": "#,##0.00;(#,##0.00)",
  "en-BB": "#,##0.00;(#,##0.00)",
  "en-BE": "#,##0.00",
  "en-BI": "#,##0.00;(#,##0.00)",
  "en-BM": "#,##0.00;(#,##0.00)",
  "en-BS": "#,##0.00;(#,##0.00)",
  "en-BW": "#,##0.00;(#,##0.00)",
  "en-BZ": "#,##0.00;(#,##0.00)",
  "en-CA": "#,##0.00;(#,##0.00)",
  "en-CC": "#,##0.00;(#,##0.00)",
  "en-CH": "#,##0.00;-#,##0.00",
  "en-CK": "#,##0.00;(#,##0.00)",
  "en-CM": "#,##0.00;(#,##0.00)",
  "en-CX": "#,##0.00;(#,##0.00)",
  "en-CY": "#,##0.00;(#,##0.00)",
  "en-DE": "#,##0.00",
  "en-DG": "#,##0.00;(#,##0.00)",
  "en-DK": "#,##0.00",
  "en-DM": "#,##0.00;(#,##0.00)",
  "en-ER": "#,##0.00;(#,##0.00)",
  "en-FI": "#,##0.00",
  "en-FJ": "#,##0.00;(#,##0.00)",
  "en-FK": "#,##0.00;(#,##0.00)",
  "en-FM": "#,##0.00;(#,##0.00)",
  "en-GB": "#,##0.00;(#,##0.00)",
  "en-GD": "#,##0.00;(#,##0.00)",
  "en-GG": "#,##0.00;(#,##0.00)",
  "en-GH": "#,##0.00;(#,##0.00)",
  "en-GI": "#,##0.00;(#,##0.00)",
  "en-GM": "#,##0.00;(#,##0.00)",
  "en-GU": "#,##0.00;(#,##0.00)",
  "en-GY": "#,##0.00;(#,##0.00)",
  "en-HK": "#,##0.00;(#,##0.00)",
  "en-IE": "#,##0.00;(#,##0.00)",
  "en-IL": "#,##0.00;(#,##0.00)",
  "en-IM": "#,##0.00;(#,##0.00)",
  "en-IN": "#,##0.00;(#,##0.00)",
  "en-IO": "#,##0.00;(#,##0.00)",
  "en-JE": "#,##0.00;(#,##0.00)",
  "en-JM": "#,##0.00;(#,##0.00)",
  "en-KE": "#,##0.00;(#,##0.00)",
  "en-KI": "#,##0.00;(#,##0.00)",
  "en-KN": "#,##0.00;(#,##0.00)",
  "en-KY": "#,##0.00;(#,##0.00)",
  "en-LC": "#,##0.00;(#,##0.00)",
  "en-LR": "#,##0.00;(#,##0.00)",
  "en-LS": "#,##0.00;(#,##0.00)",
  "en-MG": "#,##0.00;(#,##0.00)",
  "en-MH": "#,##0.00;(#,##0.00)",
  "en-MO": "#,##0.00;(#,##0.00)",
  "en-MP": "#,##0.00;(#,##0.00)",
  "en-MS": "#,##0.00;(#,##0.00)",
  "en-MT": "#,##0.00;(#,##0.00)",
  "en-MU": "#,##0.00;(#,##0.00)",
  "en-MV": "#,##0.00",
  "en-MW": "#,##0.00;(#,##0.00)",
  "en-MY": "#,##0.00;(#,##0.00)",
  "en-NA": "#,##0.00;(#,##0.00)",
  "en-NF": "#,##0.00;(#,##0.00)",
  "en-NG": "#,##0.00;(#,##0.00)",
  "en-NL": "#,##0.00;(#,##0.00)",
  "en-NR": "#,##0.00;(#,##0.00)",
  "en-NU": "#,##0.00;(#,##0.00)",
  "en-NZ": "#,##0.00;(#,##0.00)",
  "en-PG": "#,##0.00;(#,##0.00)",
  "en-PH": "#,##0.00;(#,##0.00)",
  "en-PK": "#,##0.00;(#,##0.00)",
  "en-PN": "#,##0.00;(#,##0.00)",
  "en-PR": "#,##0.00;(#,##0.00)",
  "en-PW": "#,##0.00;(#,##0.00)",
  "en-RW": "#,##0.00;(#,##0.00)",
  "en-SB": "#,##0.00;(#,##0.00)",
  "en-SC": "#,##0.00;(#,##0.00)",
  "en-SD": "#,##0.00;(#,##0.00)",
  "en-SE": "#,##0.00",
  "en-SG": "#,##0.00;(#,##0.00)",
  "en-SH": "#,##0.00;(#,##0.00)",
  "en-SI": "#,##0.00;(#,##0.00)",
  "en-SL": "#,##0.00;(#,##0.00)",
  "en-SS": "#,##0.00;(#,##0.00)",
  "en-SX": "#,##0.00;(#,##0.00)",
  "en-SZ": "#,##0.00;(#,##0.00)",
  "en-TC": "#,##0.00;(#,##0.00)",
  "en-TK": "#,##0.00;(#,##0.00)",
  "en-TO": "#,##0.00;(#,##0.00)",
  "en-TT": "#,##0.00;(#,##0.00)",
  "en-TV": "#,##0.00;(#,##0.00)",
  "en-TZ": "#,##0.00;(#,##0.00)",
  "en-UG": "#,##0.00;(#,##0.00)",
  "en-UM": "#,##0.00;(#,##0.00)",
  "en-VC": "#,##0.00;(#,##0.00)",
  "en-VG": "#,##0.00;(#,##0.00)",
  "en-VI": "#,##0.00;(#,##0.00)",
  "en-VU": "#,##0.00;(#,##0.00)",
  "en-WS": "#,##0.00;(#,##0.00)",
  "en-ZA": "#,##0.00;(#,##0.00)",
  "en-ZM": "#,##0.00;(#,##0.00)",
  "en-ZW": "#,##0.00;(#,##0.00)",
  "eo": "#,##0.00",
  "es": "#,##0.00",
  "es-419": "#,##0.00",
  "es-AR": "#,##0.00;(#,##0.00)",
  "es-BO": "#,##0.00",
  "es-BR": "#,##0.00",
  "es-BZ": "#,##0.00",
  "es-CL": "#,##0.00",
  "es-CO": "#,##0.00",
  "es-CR": "#,##0.00",
  "es-CU": "#,##0.00",
  "es-DO": "#,##0.00;(#,##0.00)",
  "es-EA": "#,##0.00",
  "es-EC": "#,##0.00",
  "es-GQ": "#,##0.00",
  "es-GT": "#,##0.00",
  "es-HN": "#,##0.00",
  "es-IC": "#,##0.00",
  "es-MX": "#,##0.00",
  "es-NI": "#,##0.00",
  "es-PA": "#,##0.00",
  "es-PE": "#,##0.00",
  "es-PH": "#,##0.00",
  "es-PR": "#,##0.00",
  "es-PY": "#,##0.00",
  "es-SV": "#,##0.00",
  "es-US": "#,##0.00",
  "es-UY": "#,##0.00;(#,##0.00)",
  "es-VE": "#,##0.00",
  "et": "#,##0.00;(#,##0.00)",
  "eu": "#,##0.00;(#,##0.00)",
  "ewo": "#,##0.00",
  "fa": "#,##0.00;(#,##0.00)",
  "fa-AF": "#,##0.00;(#,##0.00)",
  "ff": "#,##0.00",
  "ff-Adlm": "#,##0.00",
  "ff-Adlm-BF": "#,##0.00",
  "ff-Adlm-CM": "#,##0.00",
  "ff-Adlm-GH": "#,##0.00",
  "ff-Adlm-GM": "#,##0.00",
  "ff-Adlm-GW": "#,##0.00",
  "ff-Adlm-LR": "#,##0.00",
  "ff-Adlm-MR": "#,##0.00",
  "ff-Adlm-NE": "#,##0.00",
  "ff-Adlm-NG": "#,##0.00",
  "ff-Adlm-SL": "#,##0.00",
  "ff-Adlm-SN": "#,##0.00",
  "ff-Latn": "#,##0.00",
  "ff-Latn-BF": "#,##0.00",
  "ff-Latn-CM": "#,##0.00",
  "ff-Latn-GH": "#,##0.00",
  "ff-Latn-GM": "#,##0.00",
  "ff-Latn-GN": "#,##0.00",
  "ff-Latn-GW": "#,##0.00",
  "ff-Latn-LR": "#,##0.00",
  "ff-Latn-MR": "#,##0.00",
  "ff-Latn-NE": "#,##0.00",
  "ff-Latn-NG": "#,##0.00",
  "ff-Latn-SL": "#,##0.00",
  "fi": "#,##0.00",
  "fil": "#,##0.00;(#,##0.00)",
  "fo": "#,##0.00;(#,##0.00)",
  "fo-DK": "#,##0.00;(#,##0.00)",
  "fr": "#,##0.00;(#,##0.00)",
  "fr-BE": "#,##0.00;(#,##0.00)",
  "fr-BF": "#,##0.00;(#,##0.00)",
  "fr-BI": "#,##0.00;(#,##0.00)",
  "fr-BJ": "#,##0.00;(#,##0.00)",
  "fr-BL": "#,##0.00;(#,##0.00)",
  "fr-CA": "#,##0.00;(#,##0.00)",
  "fr-CD": "#,##0.00;(#,##0.00)",
  "fr-CF": "#,##0.00;(#,##0.00)",
  "fr-CG": "#,##0.00;(#,##0.00)",
  "fr-CH": "#,##0.00;(#,##0.00)",
  "fr-CI": "#,##0.00;(#,##0.00)",
  "fr-CM": "#,##0.00;(#,##0.00)",
  "fr-DJ": "#,##0.00;(#,##0.00)",
  "fr-DZ": "#,##0.00;(#,##0.00)",
  "fr-GA": "#,##0.00;(#,##0.00)",
  "fr-GF": "#,##0.00;(#,##0.00)",
  "fr-GN": "#,##0.00;(#,##0.00)",
  "fr-GP": "#,##0.00;(#,##0.00)",
  "fr-GQ": "#,##0.00;(#,##0.00)",
  "fr-HT": "#,##0.00;(#,##0.00)",
  "fr-KM": "#,##0.00;(#,##0.00)",
  "fr-LU": "#,##0.00;(#,##0.00)",
  "fr-MA": "#,##0.00;(#,##0.00)",
  "fr-MC": "#,##0.00;(#,##0.00)",
  "fr-MF": "#,##0.00;(#,##0.00)",
  "fr-MG": "#,##0.00;(#,##0.00)",
  "fr-ML": "#,##0.00;(#,##0.00)",
  "fr-MQ": "#,##0.00;(#,##0.00)",
  "fr-MR": "#,##0.00;(#,##0.00)",
  "fr-MU": "#,##0.00;(#,##0.00)",
  "fr-NC": "#,##0.00;(#,##0.00)",
  "fr-NE": "#,##0.00;(#,##0.00)",
  "fr-PF": "#,##0.00;(#,##0.00)",
  "fr-PM": "#,##0.00;(#,##0.00)",
  "fr-RE": "#,##0.00;(#,##0.00)",
  "fr-RW": "#,##0.00;(#,##0.00)",
  "fr-SC": "#,##0.00;(#,##0.00)",
  "fr-SN": "#,##0.00;(#,##0.00)",
  "fr-SY": "#,##0.00;(#,##0.00)",
  "fr-TD": "#,##0.00;(#,##0.00)",
  "fr-TG": "#,##0.00;(#,##0.00)",
  "fr-TN": "#,##0.00;(#,##0.00)",
  "fr-VU": "#,##0.00;(#,##0.00)",
  "fr-WF": "#,##0.00;(#,##0.00)",
  "fr-YT": "#,##0.00;(#,##0.00)",
  "fur": "#,##0.00",
  "fy": "#,##0.00;(#,##0.00)",
  "ga": "#,##0.00;(#,##0.00)",
  "ga-GB": "#,##0.00;(#,##0.00)",
  "gd": "#,##0.00;(#,##0.00)",
  "gl": "#,##0.00",
  "gsw": "#,##0.00",
  "gsw-FR": "#,##0.00",
  "gsw-LI": "#,##0.00",
  "gu": "#,##,##0.00;(#,##,##0.00)",
  "guz": "#,##0.00;(#,##0.00)",
  "gv": "#,##0.00",
  "ha": "#,##0.00",
  "ha-GH": "#,##0.00",
  "ha-NE": "#,##0.00",
  "haw": "#,##0.00;(#,##0.00)",
  "he": "#,##0.00",
  "hi": "#,##,##0.00",
  "hi-Latn": "#,##,##0.00",
  "hr": "#,##0.00",
  "hr-BA": "#,##0.00",
  "hsb": "#,##0.00",
  "hu": "#,##0.00",
  "hy": "#,##0.00",
  "ia": "#,##0.00;(#,##0.00)",
  "id": "#,##0.00",
  "ig": "#,##0.00;(#,##0.00)",
  "ii": "#,##0.00",
  "is": "#,##0.00",
  "it": "#,##0.00",
  "it-CH": "#,##0.00",
  "it-SM": "#,##0.00",
  "it-VA": "#,##0.00",
  "ja": "#,##0.00;(#,##0.00)",
  "jgo": "#,##0.00",
  "jmc": "#,##0.00",
  "jv": "#,##0.00",
  "ka": "#,##0.00",
  "kab": "#,##0.00",
  "kam": "#,##0.00;(#,##0.00)",
  "kde": "#,##0.00;(#,##0.00)",
  "kea": "#,##0.00;(#,##0.00)",
  "kgp": "#,##0.00",
  "khq": "#,##0.00",
  "ki": "#,##0.00;(#,##0.00)",
  "kk": "#,##0.00",
  "kkj": "#,##0.00",
  "kl": "#,##0.00;-#,##0.00",
  "kln": "#,##0.00;(#,##0.00)",
  "km": "#,##0.00;(#,##0.00)",
  "kn": "#,##0.00;(#,##0.00)",
  "ko": "#,##0.00;(#,##0.00)",
  "ko-KP": "#,##0.00;(#,##0.00)",
  "kok": "#,##0.00;(#,##0.00)",
  "ks": "#,##0.00",
  "ks-Arab": "#,##0.00",
  "ks-Deva": "#,##0.00",
  "ksb": "#,##0.00",
  "ksf": "#,##0.00",
  "ksh": "#,##0.00",
  "ku": "#,##0.00;(#,##0.00)",
  "kw": "#,##0.00",
  "ky": "#,##0.00",
  "lag": "#,##0.00",
  "lb": "#,##0.00",
  "lg": "#,##0.00",
  "lkt": "#,##0.00",
  "ln": "#,##0.00",
  "ln-AO": "#,##0.00",
  "ln-CF": "#,##0.00",
  "ln-CG": "#,##0.00",
  "lo": "#,##0.00;-#,##0.00",
  "lrc": "#,##0.00",
  "lrc-IQ": "#,##0.00",
  "lt": "#,##0.00",
  "lu": "#,##0.00",
  "luo": "#,##0.00",
  "luy": "#,##0.00;-#,##0.00",
  "lv": "#,##0.00",
  "mai": "#,##0.00",
  "mas": "#,##0.00;(#,##0.00)",
  "mas-TZ": "#,##0.00;(#,##0.00)",
  "mer": "#,##0.00;(#,##0.00)",
  "mfe": "#,##0.00",
  "mg": "#,##0.00",
  "mgh": "#,##0.00",
  "mgo": "#,##0.00",
  "mi": "#,##0.00",
  "mk": "#,##0.00",
  "ml": "#,##0.00;(#,##0.00)",
  "mn": "#,##0.00",
  "mni": "#,##0.00",
  "mni-Beng": "#,##0.00",
  "mr": "#,##0.00;(#,##0.00)",
  "ms": "#,##0.00;(#,##0.00)",
  "ms-BN": "#,##0.00;(#,##0.00)",
  "ms-ID": "#,##0.00",
  "ms-SG": "#,##0.00;(#,##0.00)",
  "mt": "#,##0.00",
  "mua": "#,##0.00;(#,##0.00)",
  "my": "#,##0.00",
  "mzn": "#,##0.00",
  "naq": "#,##0.00",
  "nb": "#,##0.00;(#,##0.00)",
  "nb-SJ": "#,##0.00;(#,##0.00)",
  "nd": "#,##0.00;(#,##0.00)",
  "nds": "#,##0.00",
  "nds-NL": "#,##0.00",
  "ne": "#,##,##0.00",
  "ne-IN": "#,##,##0.00",
  "nl": "#,##0.00;(#,##0.00)",
  "nl-AW": "#,##0.00;(#,##0.00)",
  "nl-BE": "#,##0.00;(#,##0.00)",
  "nl-BQ": "#,##0.00;(#,##0.00)",
  "nl-CW": "#,##0.00;(#,##0.00)",
  "nl-SR": "#,##0.00;(#,##0.00)",
  "nl-SX": "#,##0.00;(#,##0.00)",
  "nmg": "#,##0.00",
  "nn": "#,##0.00",
  "nnh": "#,##0.00",
  "no": "#,##0.00;(#,##0.00)",
  "nus": "#,##0.00;(#,##0.00)",
  "nyn": "#,##0.00",
  "om": "#,##0.00",
  "om-KE": "#,##0.00",
  "or": "#,##0.00;(#,##0.00)",
  "os": "#,##0.00",
  "os-RU": "#,##0.00",
  "pa": "#,##0.00",
  "pa-Arab": "#,##0.00",
  "pa-Guru": "#,##0.00",
  "pcm": "#,##0.00",
  "pl": "#,##0.00;(#,##0.00)",
  "ps": "#,##0.00;(#,##0.00)",
  "ps-PK": "#,##0.00;(#,##0.00)",
  "pt": "#,##0.00",
  "pt-AO": "#,##0.00;(#,##0.00)",
  "pt-CH": "#,##0.00;(#,##0.00)",
  "pt-CV": "#,##0.00;(#,##0.00)",
  "pt-GQ": "#,##0.00;(#,##0.00)",
  "pt-GW": "#,##0.00;(#,##0.00)",
  "pt-LU": "#,##0.00;(#,##0.00)",
  "pt-MO": "#,##0.00;(#,##0.00)",
  "pt-MZ": "#,##0.00;(#,##0.00)",
  "pt-PT": "#,##0.00;(#,##0.00)",
  "pt-ST": "#,##0.00;(#,##0.00)",
  "pt-TL": "#,##0.00;(#,##0.00)",
  "qu": "#,##0.00",
  "qu-BO": "#,##0.00",
  "qu-EC": "#,##0.00",
  "rm": "#,##0.00",
  "rn": "#,##0.00",
  "ro": "#,##0.00;(#,##0.00)",
  "ro-MD": "#,##0.00;(#,##0.00)",
  "rof": "#,##0.00",
  "ru": "#,##0.00",
  "ru-BY": "#,##0.00",
  "ru-KG": "#,##0.00",
  "ru-KZ": "#,##0.00",
  "ru-MD": "#,##0.00",
  "ru-UA": "#,##0.00",
  "rw": "#,##0.00",
  "rwk": "#,##0.00",
  "sa": "#,##0.00",
  "sah": "#,##0.00",
  "saq": "#,##0.00;(#,##0.00)",
  "sat": "#,##0.00",
  "sat-Olck": "#,##0.00",
  "sbp": "#,##0.00",
  "sc": "#,##0.00",
  "sd": "#,##0.00",
  "sd-Arab": "#,##0.00",
  "sd-Deva": "#,##0.00",
  "se": "#,##0.00",
  "se-FI": "#,##0.00",
  "se-SE": "#,##0.00",
  "seh": "#,##0.00",
  "ses": "#,##0.00",
  "sg": "#,##0.00;-#,##0.00",
  "shi": "#,##0.00",
  "shi-Latn": "#,##0.00",
  "shi-Tfng": "#,##0.00",
  "si": "#,##0.00;(#,##0.00)",
  "sk": "#,##0.00;(#,##0.00)",
  "sl": "#,##0.00;(#,##0.00)",
  "smn": "#,##0.00",
  "sn": "#,##0.00;(#,##0.00)",
  "so": "#,##0.00;(#,##0.00)",
  "so-DJ": "#,##0.00;(#,##0.00)",
  "so-ET": "#,##0.00;(#,##0.00)",
  "so-KE": "#,##0.00;(#,##0.00)",
  "sq": "#,##0.00;(#,##0.00)",
  "sq-MK": "#,##0.00;(#,##0.00)",
  "sq-XK": "#,##0.00;(#,##0.00)",
  "sr": "#,##0.00;(#,##0.00)",
  "sr-Cyrl": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-BA": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-ME": "#,##0.00;(#,##0.00)",
  "sr-Cyrl-XK": "#,##0.00;(#,##0.00)",
  "sr-Latn": "#,##0.00;(#,##0.00)",
  "sr-Latn-BA": "#,##0.00;(#,##0.00)",
  "sr-Latn-ME": "#,##0.00;(#,##0.00)",
  "sr-Latn-XK": "#,##0.00;(#,##0.00)",
  "su": "#,##0.00",
  "su-Latn": "#,##0.00",
  "sv": "#,##0.00",
  "sv-AX": "#,##0.00",
  "sv-FI": "#,##0.00",
  "sw": "#,##0.00",
  "sw-CD": "#,##0.00",
  "sw-KE": "#,##0.00",
  "sw-UG": "#,##0.00",
  "ta": "#,##0.00;(#,##0.00)",
  "ta-LK": "#,##0.00;(#,##0.00)",
  "ta-MY": "#,##0.00;(#,##0.00)",
  "ta-SG": "#,##0.00;(#,##0.00)",
  "te": "#,##0.00;(#,##0.00)",
  "teo": "#,##0.00;(#,##0.00)",
  "teo-KE": "#,##0.00;(#,##0.00)",
  "tg": "#,##0.00",
  "th": "#,##0.00;(#,##0.00)",
  "ti": "#,##0.00",
  "ti-ER": "#,##0.00",
  "tk": "#,##0.00",
  "to": "#,##0.00",
  "tr": "#,##0.00;(#,##0.00)",
  "tr-CY": "#,##0.00;(#,##0.00)",
  "tt": "#,##0.00",
  "twq": "#,##0.00",
  "tzm": "#,##0.00",
  "ug": "#,##0.00;(#,##0.00)",
  "uk": "#,##0.00",
  "und": "#,##0.00",
  "ur": "#,##0.00;(#,##0.00)",
  "ur-IN": "#,##0.00;(#,##0.00)",
  "uz": "#,##0.00",
  "uz-Arab": "#,##0.00",
  "uz-Cyrl": "#,##0.00",
  "uz-Latn": "#,##0.00",
  "vai": "#,##0.00;(#,##0.00)",
  "vai-Latn": "#,##0.00;(#,##0.00)",
  "vai-Vaii": "#,##0.00;(#,##0.00)",
  "vi": "#,##0.00",
  "vun": "#,##0.00",
  "wae": "#,##0.00",
  "wo": "#,##0.00",
  "xh": "#,##0.00",
  "xog": "#,##0.00",
  "yav": "#,##0.00;(#,##0.00)",
  "yi": "#,##0.00",
  "yo": "#,##0.00;(#,##0.00)",
  "yo-BJ": "#,##0.00;(#,##0.00)",
  "yrl": "#,##0.00",
  "yrl-CO": "#,##0.00",
  "yrl-VE": "#,##0.00",
  "yue": "#,##0.00;(#,##0.00)",
  "yue-Hans": "#,##0.00;(#,##0.00)",
  "yue-Hant": "#,##0.00;(#,##0.00)",
  "zgh": "#,##0.00",
  "zh": "#,##0.00;(#,##0.00)",
  "zh-Hans": "#,##0.00;(#,##0.00)",
  "zh-Hans-HK": "#,##0.00;(#,##0.00)",
  "zh-Hans-MO": "#,##0.00;(#,##0.00)",
  "zh-Hans-SG": "#,##0.00;(#,##0.00)",
  "zh-Hant": "#,##0.00;(#,##0.00)",
  "zh-Hant-HK": "#,##0.00;(#,##0.00)",
  "zh-Hant-MO": "#,##0.00;(#,##0.00)",
  "zu": "#,##0.00;(#,##0.00)"
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 35608:
/***/ (function(__unused_webpack_module, exports) {



exports.enCldr = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var enCldr = {
  "main": {
    "en": {
      "identity": {
        "version": {
          "_cldrVersion": "36"
        }
      },
      "dates": {
        "calendars": {
          "gregorian": {
            "months": {
              "format": {
                "abbreviated": {
                  "1": "Jan",
                  "2": "Feb",
                  "3": "Mar",
                  "4": "Apr",
                  "5": "May",
                  "6": "Jun",
                  "7": "Jul",
                  "8": "Aug",
                  "9": "Sep",
                  "10": "Oct",
                  "11": "Nov",
                  "12": "Dec"
                },
                "narrow": {
                  "1": "J",
                  "2": "F",
                  "3": "M",
                  "4": "A",
                  "5": "M",
                  "6": "J",
                  "7": "J",
                  "8": "A",
                  "9": "S",
                  "10": "O",
                  "11": "N",
                  "12": "D"
                },
                "wide": {
                  "1": "January",
                  "2": "February",
                  "3": "March",
                  "4": "April",
                  "5": "May",
                  "6": "June",
                  "7": "July",
                  "8": "August",
                  "9": "September",
                  "10": "October",
                  "11": "November",
                  "12": "December"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "1": "Jan",
                  "2": "Feb",
                  "3": "Mar",
                  "4": "Apr",
                  "5": "May",
                  "6": "Jun",
                  "7": "Jul",
                  "8": "Aug",
                  "9": "Sep",
                  "10": "Oct",
                  "11": "Nov",
                  "12": "Dec"
                },
                "narrow": {
                  "1": "J",
                  "2": "F",
                  "3": "M",
                  "4": "A",
                  "5": "M",
                  "6": "J",
                  "7": "J",
                  "8": "A",
                  "9": "S",
                  "10": "O",
                  "11": "N",
                  "12": "D"
                },
                "wide": {
                  "1": "January",
                  "2": "February",
                  "3": "March",
                  "4": "April",
                  "5": "May",
                  "6": "June",
                  "7": "July",
                  "8": "August",
                  "9": "September",
                  "10": "October",
                  "11": "November",
                  "12": "December"
                }
              }
            },
            "days": {
              "format": {
                "abbreviated": {
                  "sun": "Sun",
                  "mon": "Mon",
                  "tue": "Tue",
                  "wed": "Wed",
                  "thu": "Thu",
                  "fri": "Fri",
                  "sat": "Sat"
                },
                "narrow": {
                  "sun": "S",
                  "mon": "M",
                  "tue": "T",
                  "wed": "W",
                  "thu": "T",
                  "fri": "F",
                  "sat": "S"
                },
                "short": {
                  "sun": "Su",
                  "mon": "Mo",
                  "tue": "Tu",
                  "wed": "We",
                  "thu": "Th",
                  "fri": "Fr",
                  "sat": "Sa"
                },
                "wide": {
                  "sun": "Sunday",
                  "mon": "Monday",
                  "tue": "Tuesday",
                  "wed": "Wednesday",
                  "thu": "Thursday",
                  "fri": "Friday",
                  "sat": "Saturday"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "sun": "Sun",
                  "mon": "Mon",
                  "tue": "Tue",
                  "wed": "Wed",
                  "thu": "Thu",
                  "fri": "Fri",
                  "sat": "Sat"
                },
                "narrow": {
                  "sun": "S",
                  "mon": "M",
                  "tue": "T",
                  "wed": "W",
                  "thu": "T",
                  "fri": "F",
                  "sat": "S"
                },
                "short": {
                  "sun": "Su",
                  "mon": "Mo",
                  "tue": "Tu",
                  "wed": "We",
                  "thu": "Th",
                  "fri": "Fr",
                  "sat": "Sa"
                },
                "wide": {
                  "sun": "Sunday",
                  "mon": "Monday",
                  "tue": "Tuesday",
                  "wed": "Wednesday",
                  "thu": "Thursday",
                  "fri": "Friday",
                  "sat": "Saturday"
                }
              }
            },
            "quarters": {
              "format": {
                "abbreviated": {
                  "1": "Q1",
                  "2": "Q2",
                  "3": "Q3",
                  "4": "Q4"
                },
                "narrow": {
                  "1": "1",
                  "2": "2",
                  "3": "3",
                  "4": "4"
                },
                "wide": {
                  "1": "1st quarter",
                  "2": "2nd quarter",
                  "3": "3rd quarter",
                  "4": "4th quarter"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "1": "Q1",
                  "2": "Q2",
                  "3": "Q3",
                  "4": "Q4"
                },
                "narrow": {
                  "1": "1",
                  "2": "2",
                  "3": "3",
                  "4": "4"
                },
                "wide": {
                  "1": "1st quarter",
                  "2": "2nd quarter",
                  "3": "3rd quarter",
                  "4": "4th quarter"
                }
              }
            },
            "dayPeriods": {
              "format": {
                "abbreviated": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "in the morning",
                  "afternoon1": "in the afternoon",
                  "evening1": "in the evening",
                  "night1": "at night"
                },
                "narrow": {
                  "midnight": "mi",
                  "am": "a",
                  "am-alt-variant": "am",
                  "noon": "n",
                  "pm": "p",
                  "pm-alt-variant": "pm",
                  "morning1": "in the morning",
                  "afternoon1": "in the afternoon",
                  "evening1": "in the evening",
                  "night1": "at night"
                },
                "wide": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "in the morning",
                  "afternoon1": "in the afternoon",
                  "evening1": "in the evening",
                  "night1": "at night"
                }
              },
              "stand-alone": {
                "abbreviated": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "morning",
                  "afternoon1": "afternoon",
                  "evening1": "evening",
                  "night1": "night"
                },
                "narrow": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "morning",
                  "afternoon1": "afternoon",
                  "evening1": "evening",
                  "night1": "night"
                },
                "wide": {
                  "midnight": "midnight",
                  "am": "AM",
                  "am-alt-variant": "am",
                  "noon": "noon",
                  "pm": "PM",
                  "pm-alt-variant": "pm",
                  "morning1": "morning",
                  "afternoon1": "afternoon",
                  "evening1": "evening",
                  "night1": "night"
                }
              }
            },
            "eras": {
              "eraNames": {
                "0": "Before Christ",
                "1": "Anno Domini",
                "0-alt-variant": "Before Common Era",
                "1-alt-variant": "Common Era"
              },
              "eraAbbr": {
                "0": "BC",
                "1": "AD",
                "0-alt-variant": "BCE",
                "1-alt-variant": "CE"
              },
              "eraNarrow": {
                "0": "B",
                "1": "A",
                "0-alt-variant": "BCE",
                "1-alt-variant": "CE"
              }
            },
            "dateFormats": {
              "full": "EEEE, MMMM d, y",
              "long": "MMMM d, y",
              "medium": "MMM d, y",
              "short": "M/d/yy"
            },
            "timeFormats": {
              "full": "h:mm:ss a zzzz",
              "long": "h:mm:ss a z",
              "medium": "h:mm:ss a",
              "short": "h:mm a"
            },
            "dateTimeFormats": {
              "full": "{1} 'at' {0}",
              "long": "{1} 'at' {0}",
              "medium": "{1}, {0}",
              "short": "{1}, {0}",
              "availableFormats": {
                "Bh": "h B",
                "Bhm": "h:mm B",
                "Bhms": "h:mm:ss B",
                "d": "d",
                "E": "ccc",
                "EBhm": "E h:mm B",
                "EBhms": "E h:mm:ss B",
                "Ed": "d E",
                "Ehm": "E h:mm a",
                "EHm": "E HH:mm",
                "Ehms": "E h:mm:ss a",
                "EHms": "E HH:mm:ss",
                "Gy": "y G",
                "GyMMM": "MMM y G",
                "GyMMMd": "MMM d, y G",
                "GyMMMEd": "E, MMM d, y G",
                "h": "h a",
                "H": "HH",
                "hm": "h:mm a",
                "Hm": "HH:mm",
                "hms": "h:mm:ss a",
                "Hms": "HH:mm:ss",
                "hmsv": "h:mm:ss a v",
                "Hmsv": "HH:mm:ss v",
                "hmv": "h:mm a v",
                "Hmv": "HH:mm v",
                "M": "L",
                "Md": "M/d",
                "MEd": "E, M/d",
                "MMM": "LLL",
                "MMMd": "MMM d",
                "MMMEd": "E, MMM d",
                "MMMMd": "MMMM d",
                "MMMMW-count-one": "'week' W 'of' MMMM",
                "MMMMW-count-other": "'week' W 'of' MMMM",
                "ms": "mm:ss",
                "y": "y",
                "yM": "M/y",
                "yMd": "M/d/y",
                "yMEd": "E, M/d/y",
                "yMMM": "MMM y",
                "yMMMd": "MMM d, y",
                "yMMMEd": "E, MMM d, y",
                "yMMMM": "MMMM y",
                "yQQQ": "QQQ y",
                "yQQQQ": "QQQQ y",
                "yw-count-one": "'week' w 'of' Y",
                "yw-count-other": "'week' w 'of' Y"
              }
            }
          }
        }
      },
      "numbers": {
        "defaultNumberingSystem": "latn",
        "otherNumberingSystems": {
          "native": "latn"
        },
        "minimumGroupingDigits": "1",
        "symbols-numberSystem-latn": {
          "decimal": ".",
          "group": ",",
          "list": ";",
          "percentSign": "%",
          "plusSign": "+",
          "minusSign": "-",
          "exponential": "E",
          "superscriptingExponent": "",
          "perMille": "",
          "infinity": "",
          "nan": "NaN",
          "timeSeparator": ":"
        },
        "decimalFormats-numberSystem-latn": {
          "standard": "#,##0.###"
        },
        "scientificFormats-numberSystem-latn": {
          "standard": "#E0"
        },
        "percentFormats-numberSystem-latn": {
          "standard": "#,##0%"
        },
        "currencyFormats-numberSystem-latn": {
          "currencySpacing": {
            "beforeCurrency": {
              "currencyMatch": "[:^S:]",
              "surroundingMatch": "[:digit:]",
              "insertBetween": ""
            },
            "afterCurrency": {
              "currencyMatch": "[:^S:]",
              "surroundingMatch": "[:digit:]",
              "insertBetween": ""
            }
          },
          "standard": "#,##0.00",
          "accounting": "#,##0.00;(#,##0.00)"
        },
        "currencies": {
          "ADP": {
            "symbol": "ADP"
          },
          "AED": {
            "symbol": "AED"
          },
          "AFA": {
            "symbol": "AFA"
          },
          "AFN": {
            "symbol": "AFN"
          },
          "ALK": {
            "symbol": "ALK"
          },
          "ALL": {
            "symbol": "ALL"
          },
          "AMD": {
            "symbol": "AMD"
          },
          "ANG": {
            "symbol": "ANG"
          },
          "AOA": {
            "symbol": "AOA",
            "symbol-alt-narrow": "Kz"
          },
          "AOK": {
            "symbol": "AOK"
          },
          "AON": {
            "symbol": "AON"
          },
          "AOR": {
            "symbol": "AOR"
          },
          "ARA": {
            "symbol": "ARA"
          },
          "ARL": {
            "symbol": "ARL"
          },
          "ARM": {
            "symbol": "ARM"
          },
          "ARP": {
            "symbol": "ARP"
          },
          "ARS": {
            "symbol": "ARS",
            "symbol-alt-narrow": "$"
          },
          "ATS": {
            "symbol": "ATS"
          },
          "AUD": {
            "symbol": "A$",
            "symbol-alt-narrow": "$"
          },
          "AWG": {
            "symbol": "AWG"
          },
          "AZM": {
            "symbol": "AZM"
          },
          "AZN": {
            "symbol": "AZN"
          },
          "BAD": {
            "symbol": "BAD"
          },
          "BAM": {
            "symbol": "BAM",
            "symbol-alt-narrow": "KM"
          },
          "BAN": {
            "symbol": "BAN"
          },
          "BBD": {
            "symbol": "BBD",
            "symbol-alt-narrow": "$"
          },
          "BDT": {
            "symbol": "BDT",
            "symbol-alt-narrow": ""
          },
          "BEC": {
            "symbol": "BEC"
          },
          "BEF": {
            "symbol": "BEF"
          },
          "BEL": {
            "symbol": "BEL"
          },
          "BGL": {
            "symbol": "BGL"
          },
          "BGM": {
            "symbol": "BGM"
          },
          "BGN": {
            "symbol": "BGN"
          },
          "BGO": {
            "symbol": "BGO"
          },
          "BHD": {
            "symbol": "BHD"
          },
          "BIF": {
            "symbol": "BIF"
          },
          "BMD": {
            "symbol": "BMD",
            "symbol-alt-narrow": "$"
          },
          "BND": {
            "symbol": "BND",
            "symbol-alt-narrow": "$"
          },
          "BOB": {
            "symbol": "BOB",
            "symbol-alt-narrow": "Bs"
          },
          "BOL": {
            "symbol": "BOL"
          },
          "BOP": {
            "symbol": "BOP"
          },
          "BOV": {
            "symbol": "BOV"
          },
          "BRB": {
            "symbol": "BRB"
          },
          "BRC": {
            "symbol": "BRC"
          },
          "BRE": {
            "symbol": "BRE"
          },
          "BRL": {
            "symbol": "R$",
            "symbol-alt-narrow": "R$"
          },
          "BRN": {
            "symbol": "BRN"
          },
          "BRR": {
            "symbol": "BRR"
          },
          "BRZ": {
            "symbol": "BRZ"
          },
          "BSD": {
            "symbol": "BSD",
            "symbol-alt-narrow": "$"
          },
          "BTN": {
            "symbol": "BTN"
          },
          "BUK": {
            "symbol": "BUK"
          },
          "BWP": {
            "symbol": "BWP",
            "symbol-alt-narrow": "P"
          },
          "BYB": {
            "symbol": "BYB"
          },
          "BYN": {
            "symbol": "BYN",
            "symbol-alt-narrow": "."
          },
          "BYR": {
            "symbol": "BYR"
          },
          "BZD": {
            "symbol": "BZD",
            "symbol-alt-narrow": "$"
          },
          "CAD": {
            "symbol": "CA$",
            "symbol-alt-narrow": "$"
          },
          "CDF": {
            "symbol": "CDF"
          },
          "CHE": {
            "symbol": "CHE"
          },
          "CHF": {
            "symbol": "CHF"
          },
          "CHW": {
            "symbol": "CHW"
          },
          "CLE": {
            "symbol": "CLE"
          },
          "CLF": {
            "symbol": "CLF"
          },
          "CLP": {
            "symbol": "CLP",
            "symbol-alt-narrow": "$"
          },
          "CNH": {
            "symbol": "CNH"
          },
          "CNX": {
            "symbol": "CNX"
          },
          "CNY": {
            "symbol": "CN",
            "symbol-alt-narrow": ""
          },
          "COP": {
            "symbol": "COP",
            "symbol-alt-narrow": "$"
          },
          "COU": {
            "symbol": "COU"
          },
          "CRC": {
            "symbol": "CRC",
            "symbol-alt-narrow": ""
          },
          "CSD": {
            "symbol": "CSD"
          },
          "CSK": {
            "symbol": "CSK"
          },
          "CUC": {
            "symbol": "CUC",
            "symbol-alt-narrow": "$"
          },
          "CUP": {
            "symbol": "CUP",
            "symbol-alt-narrow": "$"
          },
          "CVE": {
            "symbol": "CVE"
          },
          "CYP": {
            "symbol": "CYP"
          },
          "CZK": {
            "symbol": "CZK",
            "symbol-alt-narrow": "K"
          },
          "DDM": {
            "symbol": "DDM"
          },
          "DEM": {
            "symbol": "DEM"
          },
          "DJF": {
            "symbol": "DJF"
          },
          "DKK": {
            "symbol": "DKK",
            "symbol-alt-narrow": "kr"
          },
          "DOP": {
            "symbol": "DOP",
            "symbol-alt-narrow": "$"
          },
          "DZD": {
            "symbol": "DZD"
          },
          "ECS": {
            "symbol": "ECS"
          },
          "ECV": {
            "symbol": "ECV"
          },
          "EEK": {
            "symbol": "EEK"
          },
          "EGP": {
            "symbol": "EGP",
            "symbol-alt-narrow": "E"
          },
          "ERN": {
            "symbol": "ERN"
          },
          "ESA": {
            "symbol": "ESA"
          },
          "ESB": {
            "symbol": "ESB"
          },
          "ESP": {
            "symbol": "ESP",
            "symbol-alt-narrow": ""
          },
          "ETB": {
            "symbol": "ETB"
          },
          "EUR": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "FIM": {
            "symbol": "FIM"
          },
          "FJD": {
            "symbol": "FJD",
            "symbol-alt-narrow": "$"
          },
          "FKP": {
            "symbol": "FKP",
            "symbol-alt-narrow": ""
          },
          "FRF": {
            "symbol": "FRF"
          },
          "GBP": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "GEK": {
            "symbol": "GEK"
          },
          "GEL": {
            "symbol": "GEL",
            "symbol-alt-narrow": ""
          },
          "GHC": {
            "symbol": "GHC"
          },
          "GHS": {
            "symbol": "GHS"
          },
          "GIP": {
            "symbol": "GIP",
            "symbol-alt-narrow": ""
          },
          "GMD": {
            "symbol": "GMD"
          },
          "GNF": {
            "symbol": "GNF",
            "symbol-alt-narrow": "FG"
          },
          "GNS": {
            "symbol": "GNS"
          },
          "GQE": {
            "symbol": "GQE"
          },
          "GRD": {
            "symbol": "GRD"
          },
          "GTQ": {
            "symbol": "GTQ",
            "symbol-alt-narrow": "Q"
          },
          "GWE": {
            "symbol": "GWE"
          },
          "GWP": {
            "symbol": "GWP"
          },
          "GYD": {
            "symbol": "GYD",
            "symbol-alt-narrow": "$"
          },
          "HKD": {
            "symbol": "HK$",
            "symbol-alt-narrow": "$"
          },
          "HNL": {
            "symbol": "HNL",
            "symbol-alt-narrow": "L"
          },
          "HRD": {
            "symbol": "HRD"
          },
          "HRK": {
            "symbol": "HRK",
            "symbol-alt-narrow": "kn"
          },
          "HTG": {
            "symbol": "HTG"
          },
          "HUF": {
            "symbol": "HUF",
            "symbol-alt-narrow": "Ft"
          },
          "IDR": {
            "symbol": "IDR",
            "symbol-alt-narrow": "Rp"
          },
          "IEP": {
            "symbol": "IEP"
          },
          "ILP": {
            "symbol": "ILP"
          },
          "ILR": {
            "symbol": "ILR"
          },
          "ILS": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "INR": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "IQD": {
            "symbol": "IQD"
          },
          "IRR": {
            "symbol": "IRR"
          },
          "ISJ": {
            "symbol": "ISJ"
          },
          "ISK": {
            "symbol": "ISK",
            "symbol-alt-narrow": "kr"
          },
          "ITL": {
            "symbol": "ITL"
          },
          "JMD": {
            "symbol": "JMD",
            "symbol-alt-narrow": "$"
          },
          "JOD": {
            "symbol": "JOD"
          },
          "JPY": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "KES": {
            "symbol": "KES"
          },
          "KGS": {
            "symbol": "KGS"
          },
          "KHR": {
            "symbol": "KHR",
            "symbol-alt-narrow": ""
          },
          "KMF": {
            "symbol": "KMF",
            "symbol-alt-narrow": "CF"
          },
          "KPW": {
            "symbol": "KPW",
            "symbol-alt-narrow": ""
          },
          "KRH": {
            "symbol": "KRH"
          },
          "KRO": {
            "symbol": "KRO"
          },
          "KRW": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "KWD": {
            "symbol": "KWD"
          },
          "KYD": {
            "symbol": "KYD",
            "symbol-alt-narrow": "$"
          },
          "KZT": {
            "symbol": "KZT",
            "symbol-alt-narrow": ""
          },
          "LAK": {
            "symbol": "LAK",
            "symbol-alt-narrow": ""
          },
          "LBP": {
            "symbol": "LBP",
            "symbol-alt-narrow": "L"
          },
          "LKR": {
            "symbol": "LKR",
            "symbol-alt-narrow": "Rs"
          },
          "LRD": {
            "symbol": "LRD",
            "symbol-alt-narrow": "$"
          },
          "LSL": {
            "symbol": "LSL"
          },
          "LTL": {
            "symbol": "LTL",
            "symbol-alt-narrow": "Lt"
          },
          "LTT": {
            "symbol": "LTT"
          },
          "LUC": {
            "symbol": "LUC"
          },
          "LUF": {
            "symbol": "LUF"
          },
          "LUL": {
            "symbol": "LUL"
          },
          "LVL": {
            "symbol": "LVL",
            "symbol-alt-narrow": "Ls"
          },
          "LVR": {
            "symbol": "LVR"
          },
          "LYD": {
            "symbol": "LYD"
          },
          "MAD": {
            "symbol": "MAD"
          },
          "MAF": {
            "symbol": "MAF"
          },
          "MCF": {
            "symbol": "MCF"
          },
          "MDC": {
            "symbol": "MDC"
          },
          "MDL": {
            "symbol": "MDL"
          },
          "MGA": {
            "symbol": "MGA",
            "symbol-alt-narrow": "Ar"
          },
          "MGF": {
            "symbol": "MGF"
          },
          "MKD": {
            "symbol": "MKD"
          },
          "MKN": {
            "symbol": "MKN"
          },
          "MLF": {
            "symbol": "MLF"
          },
          "MMK": {
            "symbol": "MMK",
            "symbol-alt-narrow": "K"
          },
          "MNT": {
            "symbol": "MNT",
            "symbol-alt-narrow": ""
          },
          "MOP": {
            "symbol": "MOP"
          },
          "MRO": {
            "symbol": "MRO"
          },
          "MRU": {
            "symbol": "MRU"
          },
          "MTL": {
            "symbol": "MTL"
          },
          "MTP": {
            "symbol": "MTP"
          },
          "MUR": {
            "symbol": "MUR",
            "symbol-alt-narrow": "Rs"
          },
          "MVP": {
            "symbol": "MVP"
          },
          "MVR": {
            "symbol": "MVR"
          },
          "MWK": {
            "symbol": "MWK"
          },
          "MXN": {
            "symbol": "MX$",
            "symbol-alt-narrow": "$"
          },
          "MXP": {
            "symbol": "MXP"
          },
          "MXV": {
            "symbol": "MXV"
          },
          "MYR": {
            "symbol": "MYR",
            "symbol-alt-narrow": "RM"
          },
          "MZE": {
            "symbol": "MZE"
          },
          "MZM": {
            "symbol": "MZM"
          },
          "MZN": {
            "symbol": "MZN"
          },
          "NAD": {
            "symbol": "NAD",
            "symbol-alt-narrow": "$"
          },
          "NGN": {
            "symbol": "NGN",
            "symbol-alt-narrow": ""
          },
          "NIC": {
            "symbol": "NIC"
          },
          "NIO": {
            "symbol": "NIO",
            "symbol-alt-narrow": "C$"
          },
          "NLG": {
            "symbol": "NLG"
          },
          "NOK": {
            "symbol": "NOK",
            "symbol-alt-narrow": "kr"
          },
          "NPR": {
            "symbol": "NPR",
            "symbol-alt-narrow": "Rs"
          },
          "NZD": {
            "symbol": "NZ$",
            "symbol-alt-narrow": "$"
          },
          "OMR": {
            "symbol": "OMR"
          },
          "PAB": {
            "symbol": "PAB"
          },
          "PEI": {
            "symbol": "PEI"
          },
          "PEN": {
            "symbol": "PEN"
          },
          "PES": {
            "symbol": "PES"
          },
          "PGK": {
            "symbol": "PGK"
          },
          "PHP": {
            "symbol": "PHP",
            "symbol-alt-narrow": ""
          },
          "PKR": {
            "symbol": "PKR",
            "symbol-alt-narrow": "Rs"
          },
          "PLN": {
            "symbol": "PLN",
            "symbol-alt-narrow": "z"
          },
          "PLZ": {
            "symbol": "PLZ"
          },
          "PTE": {
            "symbol": "PTE"
          },
          "PYG": {
            "symbol": "PYG",
            "symbol-alt-narrow": ""
          },
          "QAR": {
            "symbol": "QAR"
          },
          "RHD": {
            "symbol": "RHD"
          },
          "ROL": {
            "symbol": "ROL"
          },
          "RON": {
            "symbol": "RON",
            "symbol-alt-narrow": "lei"
          },
          "RSD": {
            "symbol": "RSD"
          },
          "RUB": {
            "symbol": "RUB",
            "symbol-alt-narrow": ""
          },
          "RUR": {
            "symbol": "RUR",
            "symbol-alt-narrow": "."
          },
          "RWF": {
            "symbol": "RWF",
            "symbol-alt-narrow": "RF"
          },
          "SAR": {
            "symbol": "SAR"
          },
          "SBD": {
            "symbol": "SBD",
            "symbol-alt-narrow": "$"
          },
          "SCR": {
            "symbol": "SCR"
          },
          "SDD": {
            "symbol": "SDD"
          },
          "SDG": {
            "symbol": "SDG"
          },
          "SDP": {
            "symbol": "SDP"
          },
          "SEK": {
            "symbol": "SEK",
            "symbol-alt-narrow": "kr"
          },
          "SGD": {
            "symbol": "SGD",
            "symbol-alt-narrow": "$"
          },
          "SHP": {
            "symbol": "SHP",
            "symbol-alt-narrow": ""
          },
          "SIT": {
            "symbol": "SIT"
          },
          "SKK": {
            "symbol": "SKK"
          },
          "SLL": {
            "symbol": "SLL"
          },
          "SOS": {
            "symbol": "SOS"
          },
          "SRD": {
            "symbol": "SRD",
            "symbol-alt-narrow": "$"
          },
          "SRG": {
            "symbol": "SRG"
          },
          "SSP": {
            "symbol": "SSP",
            "symbol-alt-narrow": ""
          },
          "STD": {
            "symbol": "STD"
          },
          "STN": {
            "symbol": "STN",
            "symbol-alt-narrow": "Db"
          },
          "SUR": {
            "symbol": "SUR"
          },
          "SVC": {
            "symbol": "SVC"
          },
          "SYP": {
            "symbol": "SYP",
            "symbol-alt-narrow": ""
          },
          "SZL": {
            "symbol": "SZL"
          },
          "THB": {
            "symbol": "THB",
            "symbol-alt-narrow": ""
          },
          "TJR": {
            "symbol": "TJR"
          },
          "TJS": {
            "symbol": "TJS"
          },
          "TMM": {
            "symbol": "TMM"
          },
          "TMT": {
            "symbol": "TMT"
          },
          "TND": {
            "symbol": "TND"
          },
          "TOP": {
            "symbol": "TOP",
            "symbol-alt-narrow": "T$"
          },
          "TPE": {
            "symbol": "TPE"
          },
          "TRL": {
            "symbol": "TRL"
          },
          "TRY": {
            "symbol": "TRY",
            "symbol-alt-narrow": ""
          },
          "TTD": {
            "symbol": "TTD",
            "symbol-alt-narrow": "$"
          },
          "TWD": {
            "symbol": "NT$",
            "symbol-alt-narrow": "$"
          },
          "TZS": {
            "symbol": "TZS"
          },
          "UAH": {
            "symbol": "UAH",
            "symbol-alt-narrow": ""
          },
          "UAK": {
            "symbol": "UAK"
          },
          "UGS": {
            "symbol": "UGS"
          },
          "UGX": {
            "symbol": "UGX"
          },
          "USD": {
            "symbol": "$",
            "symbol-alt-narrow": "$"
          },
          "USN": {
            "symbol": "USN"
          },
          "USS": {
            "symbol": "USS"
          },
          "UYI": {
            "symbol": "UYI"
          },
          "UYP": {
            "symbol": "UYP"
          },
          "UYU": {
            "symbol": "UYU",
            "symbol-alt-narrow": "$"
          },
          "UYW": {
            "symbol": "UYW"
          },
          "UZS": {
            "symbol": "UZS"
          },
          "VEB": {
            "symbol": "VEB"
          },
          "VEF": {
            "symbol": "VEF",
            "symbol-alt-narrow": "Bs"
          },
          "VES": {
            "symbol": "VES"
          },
          "VND": {
            "symbol": "",
            "symbol-alt-narrow": ""
          },
          "VNN": {
            "symbol": "VNN"
          },
          "VUV": {
            "symbol": "VUV"
          },
          "WST": {
            "symbol": "WST"
          },
          "XAF": {
            "symbol": "FCFA"
          },
          "XAG": {
            "symbol": "XAG"
          },
          "XAU": {
            "symbol": "XAU"
          },
          "XBA": {
            "symbol": "XBA"
          },
          "XBB": {
            "symbol": "XBB"
          },
          "XBC": {
            "symbol": "XBC"
          },
          "XBD": {
            "symbol": "XBD"
          },
          "XCD": {
            "symbol": "EC$",
            "symbol-alt-narrow": "$"
          },
          "XDR": {
            "symbol": "XDR"
          },
          "XEU": {
            "symbol": "XEU"
          },
          "XFO": {
            "symbol": "XFO"
          },
          "XFU": {
            "symbol": "XFU"
          },
          "XOF": {
            "symbol": "CFA"
          },
          "XPD": {
            "symbol": "XPD"
          },
          "XPF": {
            "symbol": "CFPF"
          },
          "XPT": {
            "symbol": "XPT"
          },
          "XRE": {
            "symbol": "XRE"
          },
          "XSU": {
            "symbol": "XSU"
          },
          "XTS": {
            "symbol": "XTS"
          },
          "XUA": {
            "symbol": "XUA"
          },
          "XXX": {
            "symbol": ""
          },
          "YDD": {
            "symbol": "YDD"
          },
          "YER": {
            "symbol": "YER"
          },
          "YUD": {
            "symbol": "YUD"
          },
          "YUM": {
            "symbol": "YUM"
          },
          "YUN": {
            "symbol": "YUN"
          },
          "YUR": {
            "symbol": "YUR"
          },
          "ZAL": {
            "symbol": "ZAL"
          },
          "ZAR": {
            "symbol": "ZAR",
            "symbol-alt-narrow": "R"
          },
          "ZMK": {
            "symbol": "ZMK"
          },
          "ZMW": {
            "symbol": "ZMW",
            "symbol-alt-narrow": "ZK"
          },
          "ZRN": {
            "symbol": "ZRN"
          },
          "ZRZ": {
            "symbol": "ZRZ"
          },
          "ZWD": {
            "symbol": "ZWD"
          },
          "ZWL": {
            "symbol": "ZWL"
          },
          "ZWR": {
            "symbol": "ZWR"
          }
        }
      }
    }
  }
};
exports.enCldr = enCldr;

/***/ }),

/***/ 92286:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = {
  "af-NA": 1,
  "agq": 1,
  "ak": 1,
  "ar": 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  "asa": 1,
  "ast": 1,
  "az": 1,
  "az-Cyrl": 1,
  "bas": 1,
  "be": 1,
  "bem": 1,
  "bez": 1,
  "bg": 1,
  "bm": 1,
  "br": 1,
  "bs": 1,
  "bs-Cyrl": 1,
  "ca": 1,
  "ce": 1,
  "cgg": 1,
  "ckb": 6,
  "cs": 1,
  "cy": 1,
  "da": 1,
  "de": 1,
  "dje": 1,
  "dsb": 1,
  "dua": 1,
  "dyo": 1,
  "ee": 1,
  "el": 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-MV": 5,
  "en-SD": 6,
  "eo": 1,
  "es": 1,
  "et": 1,
  "eu": 1,
  "ewo": 1,
  "fa": 6,
  "ff": 1,
  "ff-Adlm": 1,
  "fi": 1,
  "fo": 1,
  "fr": 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  "fur": 1,
  "fy": 1,
  "ga": 1,
  "gd": 1,
  "gl": 1,
  "gsw": 1,
  "gv": 1,
  "ha": 1,
  "hr": 1,
  "hsb": 1,
  "hu": 1,
  "hy": 1,
  "ia": 1,
  "ig": 1,
  "is": 1,
  "it": 1,
  "jgo": 1,
  "jmc": 1,
  "ka": 1,
  "kab": 6,
  "kde": 1,
  "kea": 1,
  "khq": 1,
  "kk": 1,
  "kkj": 1,
  "kl": 1,
  "ko-KP": 1,
  "ksb": 1,
  "ksf": 1,
  "ksh": 1,
  "ku": 1,
  "kw": 1,
  "ky": 1,
  "lag": 1,
  "lb": 1,
  "lg": 1,
  "ln": 1,
  "lrc": 6,
  "lt": 1,
  "lu": 1,
  "lv": 1,
  "mas-TZ": 1,
  "mfe": 1,
  "mg": 1,
  "mgo": 1,
  "mi": 1,
  "mk": 1,
  "mn": 1,
  "ms": 1,
  "mua": 1,
  "mzn": 6,
  "naq": 1,
  "nds": 1,
  "nl": 1,
  "nmg": 1,
  "nnh": 1,
  "no": 1,
  "nus": 1,
  "nyn": 1,
  "os": 1,
  "pcm": 1,
  "pl": 1,
  "ps": 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  "rm": 1,
  "rn": 1,
  "ro": 1,
  "rof": 1,
  "ru": 1,
  "rw": 1,
  "rwk": 1,
  "sah": 1,
  "sbp": 1,
  "sc": 1,
  "se": 1,
  "ses": 1,
  "sg": 1,
  "shi": 1,
  "shi-Latn": 1,
  "si": 1,
  "sk": 1,
  "sl": 1,
  "smn": 1,
  "so": 1,
  "so-DJ": 6,
  "sq": 1,
  "sr": 1,
  "sr-Latn": 1,
  "sv": 1,
  "sw": 1,
  "ta-LK": 1,
  "ta-MY": 1,
  "teo": 1,
  "tg": 1,
  "ti-ER": 1,
  "tk": 1,
  "to": 1,
  "tr": 1,
  "tt": 1,
  "twq": 1,
  "tzm": 1,
  "uk": 1,
  "uz": 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  "vai": 1,
  "vai-Latn": 1,
  "vi": 1,
  "vun": 1,
  "wae": 1,
  "wo": 1,
  "xog": 1,
  "yav": 1,
  "yi": 1,
  "yo": 1,
  "zgh": 1
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 73806:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var _default = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MV": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "hi-Latn": "en-IN",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  "nb": "no",
  "nn": "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "und",
  "az-Cyrl": "und",
  "bal-Latn": "und",
  "blt-Latn": "und",
  "bm-Nkoo": "und",
  "bs-Cyrl": "und",
  "byn-Latn": "und",
  "cu-Glag": "und",
  "dje-Arab": "und",
  "dyo-Arab": "und",
  "en-Dsrt": "und",
  "en-Shaw": "und",
  "ff-Adlm": "und",
  "ff-Arab": "und",
  "ha-Arab": "und",
  "iu-Latn": "und",
  "kk-Arab": "und",
  "ks-Deva": "und",
  "ku-Arab": "und",
  "ky-Arab": "und",
  "ky-Latn": "und",
  "ml-Arab": "und",
  "mn-Mong": "und",
  "mni-Mtei": "und",
  "ms-Arab": "und",
  "pa-Arab": "und",
  "sat-Deva": "und",
  "sd-Deva": "und",
  "sd-Khoj": "und",
  "sd-Sind": "und",
  "shi-Latn": "und",
  "so-Arab": "und",
  "sr-Latn": "und",
  "sw-Arab": "und",
  "tg-Arab": "und",
  "ug-Cyrl": "und",
  "uz-Arab": "und",
  "uz-Cyrl": "und",
  "vai-Latn": "und",
  "wo-Arab": "und",
  "yo-Arab": "und",
  "yue-Hans": "und",
  "zh-Hant": "und",
  "zh-Hant-MO": "zh-Hant-HK"
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57421:
/***/ (function(__unused_webpack_module, exports) {



exports.supplementalCldr = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var supplementalCldr = {
  "supplemental": {
    "version": {
      "_unicodeVersion": "12.1.0",
      "_cldrVersion": "36"
    },
    "likelySubtags": {
      "aa": "aa-Latn-ET",
      "aai": "aai-Latn-ZZ",
      "aak": "aak-Latn-ZZ",
      "aau": "aau-Latn-ZZ",
      "ab": "ab-Cyrl-GE",
      "abi": "abi-Latn-ZZ",
      "abq": "abq-Cyrl-ZZ",
      "abr": "abr-Latn-GH",
      "abt": "abt-Latn-ZZ",
      "aby": "aby-Latn-ZZ",
      "acd": "acd-Latn-ZZ",
      "ace": "ace-Latn-ID",
      "ach": "ach-Latn-UG",
      "ada": "ada-Latn-GH",
      "ade": "ade-Latn-ZZ",
      "adj": "adj-Latn-ZZ",
      "adp": "adp-Tibt-BT",
      "ady": "ady-Cyrl-RU",
      "adz": "adz-Latn-ZZ",
      "ae": "ae-Avst-IR",
      "aeb": "aeb-Arab-TN",
      "aey": "aey-Latn-ZZ",
      "af": "af-Latn-ZA",
      "agc": "agc-Latn-ZZ",
      "agd": "agd-Latn-ZZ",
      "agg": "agg-Latn-ZZ",
      "agm": "agm-Latn-ZZ",
      "ago": "ago-Latn-ZZ",
      "agq": "agq-Latn-CM",
      "aha": "aha-Latn-ZZ",
      "ahl": "ahl-Latn-ZZ",
      "aho": "aho-Ahom-IN",
      "ajg": "ajg-Latn-ZZ",
      "ak": "ak-Latn-GH",
      "akk": "akk-Xsux-IQ",
      "ala": "ala-Latn-ZZ",
      "ali": "ali-Latn-ZZ",
      "aln": "aln-Latn-XK",
      "alt": "alt-Cyrl-RU",
      "am": "am-Ethi-ET",
      "amm": "amm-Latn-ZZ",
      "amn": "amn-Latn-ZZ",
      "amo": "amo-Latn-NG",
      "amp": "amp-Latn-ZZ",
      "an": "an-Latn-ES",
      "anc": "anc-Latn-ZZ",
      "ank": "ank-Latn-ZZ",
      "ann": "ann-Latn-ZZ",
      "any": "any-Latn-ZZ",
      "aoj": "aoj-Latn-ZZ",
      "aom": "aom-Latn-ZZ",
      "aoz": "aoz-Latn-ID",
      "apc": "apc-Arab-ZZ",
      "apd": "apd-Arab-TG",
      "ape": "ape-Latn-ZZ",
      "apr": "apr-Latn-ZZ",
      "aps": "aps-Latn-ZZ",
      "apz": "apz-Latn-ZZ",
      "ar": "ar-Arab-EG",
      "arc": "arc-Armi-IR",
      "arc-Nbat": "arc-Nbat-JO",
      "arc-Palm": "arc-Palm-SY",
      "arh": "arh-Latn-ZZ",
      "arn": "arn-Latn-CL",
      "aro": "aro-Latn-BO",
      "arq": "arq-Arab-DZ",
      "ars": "ars-Arab-SA",
      "ary": "ary-Arab-MA",
      "arz": "arz-Arab-EG",
      "as": "as-Beng-IN",
      "asa": "asa-Latn-TZ",
      "ase": "ase-Sgnw-US",
      "asg": "asg-Latn-ZZ",
      "aso": "aso-Latn-ZZ",
      "ast": "ast-Latn-ES",
      "ata": "ata-Latn-ZZ",
      "atg": "atg-Latn-ZZ",
      "atj": "atj-Latn-CA",
      "auy": "auy-Latn-ZZ",
      "av": "av-Cyrl-RU",
      "avl": "avl-Arab-ZZ",
      "avn": "avn-Latn-ZZ",
      "avt": "avt-Latn-ZZ",
      "avu": "avu-Latn-ZZ",
      "awa": "awa-Deva-IN",
      "awb": "awb-Latn-ZZ",
      "awo": "awo-Latn-ZZ",
      "awx": "awx-Latn-ZZ",
      "ay": "ay-Latn-BO",
      "ayb": "ayb-Latn-ZZ",
      "az": "az-Latn-AZ",
      "az-Arab": "az-Arab-IR",
      "az-IQ": "az-Arab-IQ",
      "az-IR": "az-Arab-IR",
      "az-RU": "az-Cyrl-RU",
      "ba": "ba-Cyrl-RU",
      "bal": "bal-Arab-PK",
      "ban": "ban-Latn-ID",
      "bap": "bap-Deva-NP",
      "bar": "bar-Latn-AT",
      "bas": "bas-Latn-CM",
      "bav": "bav-Latn-ZZ",
      "bax": "bax-Bamu-CM",
      "bba": "bba-Latn-ZZ",
      "bbb": "bbb-Latn-ZZ",
      "bbc": "bbc-Latn-ID",
      "bbd": "bbd-Latn-ZZ",
      "bbj": "bbj-Latn-CM",
      "bbp": "bbp-Latn-ZZ",
      "bbr": "bbr-Latn-ZZ",
      "bcf": "bcf-Latn-ZZ",
      "bch": "bch-Latn-ZZ",
      "bci": "bci-Latn-CI",
      "bcm": "bcm-Latn-ZZ",
      "bcn": "bcn-Latn-ZZ",
      "bco": "bco-Latn-ZZ",
      "bcq": "bcq-Ethi-ZZ",
      "bcu": "bcu-Latn-ZZ",
      "bdd": "bdd-Latn-ZZ",
      "be": "be-Cyrl-BY",
      "bef": "bef-Latn-ZZ",
      "beh": "beh-Latn-ZZ",
      "bej": "bej-Arab-SD",
      "bem": "bem-Latn-ZM",
      "bet": "bet-Latn-ZZ",
      "bew": "bew-Latn-ID",
      "bex": "bex-Latn-ZZ",
      "bez": "bez-Latn-TZ",
      "bfd": "bfd-Latn-CM",
      "bfq": "bfq-Taml-IN",
      "bft": "bft-Arab-PK",
      "bfy": "bfy-Deva-IN",
      "bg": "bg-Cyrl-BG",
      "bgc": "bgc-Deva-IN",
      "bgn": "bgn-Arab-PK",
      "bgx": "bgx-Grek-TR",
      "bhb": "bhb-Deva-IN",
      "bhg": "bhg-Latn-ZZ",
      "bhi": "bhi-Deva-IN",
      "bhl": "bhl-Latn-ZZ",
      "bho": "bho-Deva-IN",
      "bhy": "bhy-Latn-ZZ",
      "bi": "bi-Latn-VU",
      "bib": "bib-Latn-ZZ",
      "big": "big-Latn-ZZ",
      "bik": "bik-Latn-PH",
      "bim": "bim-Latn-ZZ",
      "bin": "bin-Latn-NG",
      "bio": "bio-Latn-ZZ",
      "biq": "biq-Latn-ZZ",
      "bjh": "bjh-Latn-ZZ",
      "bji": "bji-Ethi-ZZ",
      "bjj": "bjj-Deva-IN",
      "bjn": "bjn-Latn-ID",
      "bjo": "bjo-Latn-ZZ",
      "bjr": "bjr-Latn-ZZ",
      "bjt": "bjt-Latn-SN",
      "bjz": "bjz-Latn-ZZ",
      "bkc": "bkc-Latn-ZZ",
      "bkm": "bkm-Latn-CM",
      "bkq": "bkq-Latn-ZZ",
      "bku": "bku-Latn-PH",
      "bkv": "bkv-Latn-ZZ",
      "blt": "blt-Tavt-VN",
      "bm": "bm-Latn-ML",
      "bmh": "bmh-Latn-ZZ",
      "bmk": "bmk-Latn-ZZ",
      "bmq": "bmq-Latn-ML",
      "bmu": "bmu-Latn-ZZ",
      "bn": "bn-Beng-BD",
      "bng": "bng-Latn-ZZ",
      "bnm": "bnm-Latn-ZZ",
      "bnp": "bnp-Latn-ZZ",
      "bo": "bo-Tibt-CN",
      "boj": "boj-Latn-ZZ",
      "bom": "bom-Latn-ZZ",
      "bon": "bon-Latn-ZZ",
      "bpy": "bpy-Beng-IN",
      "bqc": "bqc-Latn-ZZ",
      "bqi": "bqi-Arab-IR",
      "bqp": "bqp-Latn-ZZ",
      "bqv": "bqv-Latn-CI",
      "br": "br-Latn-FR",
      "bra": "bra-Deva-IN",
      "brh": "brh-Arab-PK",
      "brx": "brx-Deva-IN",
      "brz": "brz-Latn-ZZ",
      "bs": "bs-Latn-BA",
      "bsj": "bsj-Latn-ZZ",
      "bsq": "bsq-Bass-LR",
      "bss": "bss-Latn-CM",
      "bst": "bst-Ethi-ZZ",
      "bto": "bto-Latn-PH",
      "btt": "btt-Latn-ZZ",
      "btv": "btv-Deva-PK",
      "bua": "bua-Cyrl-RU",
      "buc": "buc-Latn-YT",
      "bud": "bud-Latn-ZZ",
      "bug": "bug-Latn-ID",
      "buk": "buk-Latn-ZZ",
      "bum": "bum-Latn-CM",
      "buo": "buo-Latn-ZZ",
      "bus": "bus-Latn-ZZ",
      "buu": "buu-Latn-ZZ",
      "bvb": "bvb-Latn-GQ",
      "bwd": "bwd-Latn-ZZ",
      "bwr": "bwr-Latn-ZZ",
      "bxh": "bxh-Latn-ZZ",
      "bye": "bye-Latn-ZZ",
      "byn": "byn-Ethi-ER",
      "byr": "byr-Latn-ZZ",
      "bys": "bys-Latn-ZZ",
      "byv": "byv-Latn-CM",
      "byx": "byx-Latn-ZZ",
      "bza": "bza-Latn-ZZ",
      "bze": "bze-Latn-ML",
      "bzf": "bzf-Latn-ZZ",
      "bzh": "bzh-Latn-ZZ",
      "bzw": "bzw-Latn-ZZ",
      "ca": "ca-Latn-ES",
      "can": "can-Latn-ZZ",
      "cbj": "cbj-Latn-ZZ",
      "cch": "cch-Latn-NG",
      "ccp": "ccp-Cakm-BD",
      "ce": "ce-Cyrl-RU",
      "ceb": "ceb-Latn-PH",
      "cfa": "cfa-Latn-ZZ",
      "cgg": "cgg-Latn-UG",
      "ch": "ch-Latn-GU",
      "chk": "chk-Latn-FM",
      "chm": "chm-Cyrl-RU",
      "cho": "cho-Latn-US",
      "chp": "chp-Latn-CA",
      "chr": "chr-Cher-US",
      "cic": "cic-Latn-US",
      "cja": "cja-Arab-KH",
      "cjm": "cjm-Cham-VN",
      "cjv": "cjv-Latn-ZZ",
      "ckb": "ckb-Arab-IQ",
      "ckl": "ckl-Latn-ZZ",
      "cko": "cko-Latn-ZZ",
      "cky": "cky-Latn-ZZ",
      "cla": "cla-Latn-ZZ",
      "cme": "cme-Latn-ZZ",
      "cmg": "cmg-Soyo-MN",
      "co": "co-Latn-FR",
      "cop": "cop-Copt-EG",
      "cps": "cps-Latn-PH",
      "cr": "cr-Cans-CA",
      "crh": "crh-Cyrl-UA",
      "crj": "crj-Cans-CA",
      "crk": "crk-Cans-CA",
      "crl": "crl-Cans-CA",
      "crm": "crm-Cans-CA",
      "crs": "crs-Latn-SC",
      "cs": "cs-Latn-CZ",
      "csb": "csb-Latn-PL",
      "csw": "csw-Cans-CA",
      "ctd": "ctd-Pauc-MM",
      "cu": "cu-Cyrl-RU",
      "cu-Glag": "cu-Glag-BG",
      "cv": "cv-Cyrl-RU",
      "cy": "cy-Latn-GB",
      "da": "da-Latn-DK",
      "dad": "dad-Latn-ZZ",
      "daf": "daf-Latn-ZZ",
      "dag": "dag-Latn-ZZ",
      "dah": "dah-Latn-ZZ",
      "dak": "dak-Latn-US",
      "dar": "dar-Cyrl-RU",
      "dav": "dav-Latn-KE",
      "dbd": "dbd-Latn-ZZ",
      "dbq": "dbq-Latn-ZZ",
      "dcc": "dcc-Arab-IN",
      "ddn": "ddn-Latn-ZZ",
      "de": "de-Latn-DE",
      "ded": "ded-Latn-ZZ",
      "den": "den-Latn-CA",
      "dga": "dga-Latn-ZZ",
      "dgh": "dgh-Latn-ZZ",
      "dgi": "dgi-Latn-ZZ",
      "dgl": "dgl-Arab-ZZ",
      "dgr": "dgr-Latn-CA",
      "dgz": "dgz-Latn-ZZ",
      "dia": "dia-Latn-ZZ",
      "dje": "dje-Latn-NE",
      "dnj": "dnj-Latn-CI",
      "dob": "dob-Latn-ZZ",
      "doi": "doi-Arab-IN",
      "dop": "dop-Latn-ZZ",
      "dow": "dow-Latn-ZZ",
      "drh": "drh-Mong-CN",
      "dri": "dri-Latn-ZZ",
      "drs": "drs-Ethi-ZZ",
      "dsb": "dsb-Latn-DE",
      "dtm": "dtm-Latn-ML",
      "dtp": "dtp-Latn-MY",
      "dts": "dts-Latn-ZZ",
      "dty": "dty-Deva-NP",
      "dua": "dua-Latn-CM",
      "duc": "duc-Latn-ZZ",
      "dud": "dud-Latn-ZZ",
      "dug": "dug-Latn-ZZ",
      "dv": "dv-Thaa-MV",
      "dva": "dva-Latn-ZZ",
      "dww": "dww-Latn-ZZ",
      "dyo": "dyo-Latn-SN",
      "dyu": "dyu-Latn-BF",
      "dz": "dz-Tibt-BT",
      "dzg": "dzg-Latn-ZZ",
      "ebu": "ebu-Latn-KE",
      "ee": "ee-Latn-GH",
      "efi": "efi-Latn-NG",
      "egl": "egl-Latn-IT",
      "egy": "egy-Egyp-EG",
      "eka": "eka-Latn-ZZ",
      "eky": "eky-Kali-MM",
      "el": "el-Grek-GR",
      "ema": "ema-Latn-ZZ",
      "emi": "emi-Latn-ZZ",
      "en": "en-Latn-US",
      "en-Shaw": "en-Shaw-GB",
      "enn": "enn-Latn-ZZ",
      "enq": "enq-Latn-ZZ",
      "eo": "eo-Latn-001",
      "eri": "eri-Latn-ZZ",
      "es": "es-Latn-ES",
      "esg": "esg-Gonm-IN",
      "esu": "esu-Latn-US",
      "et": "et-Latn-EE",
      "etr": "etr-Latn-ZZ",
      "ett": "ett-Ital-IT",
      "etu": "etu-Latn-ZZ",
      "etx": "etx-Latn-ZZ",
      "eu": "eu-Latn-ES",
      "ewo": "ewo-Latn-CM",
      "ext": "ext-Latn-ES",
      "fa": "fa-Arab-IR",
      "faa": "faa-Latn-ZZ",
      "fab": "fab-Latn-ZZ",
      "fag": "fag-Latn-ZZ",
      "fai": "fai-Latn-ZZ",
      "fan": "fan-Latn-GQ",
      "ff": "ff-Latn-SN",
      "ff-Adlm": "ff-Adlm-GN",
      "ffi": "ffi-Latn-ZZ",
      "ffm": "ffm-Latn-ML",
      "fi": "fi-Latn-FI",
      "fia": "fia-Arab-SD",
      "fil": "fil-Latn-PH",
      "fit": "fit-Latn-SE",
      "fj": "fj-Latn-FJ",
      "flr": "flr-Latn-ZZ",
      "fmp": "fmp-Latn-ZZ",
      "fo": "fo-Latn-FO",
      "fod": "fod-Latn-ZZ",
      "fon": "fon-Latn-BJ",
      "for": "for-Latn-ZZ",
      "fpe": "fpe-Latn-ZZ",
      "fqs": "fqs-Latn-ZZ",
      "fr": "fr-Latn-FR",
      "frc": "frc-Latn-US",
      "frp": "frp-Latn-FR",
      "frr": "frr-Latn-DE",
      "frs": "frs-Latn-DE",
      "fub": "fub-Arab-CM",
      "fud": "fud-Latn-WF",
      "fue": "fue-Latn-ZZ",
      "fuf": "fuf-Latn-GN",
      "fuh": "fuh-Latn-ZZ",
      "fuq": "fuq-Latn-NE",
      "fur": "fur-Latn-IT",
      "fuv": "fuv-Latn-NG",
      "fuy": "fuy-Latn-ZZ",
      "fvr": "fvr-Latn-SD",
      "fy": "fy-Latn-NL",
      "ga": "ga-Latn-IE",
      "gaa": "gaa-Latn-GH",
      "gaf": "gaf-Latn-ZZ",
      "gag": "gag-Latn-MD",
      "gah": "gah-Latn-ZZ",
      "gaj": "gaj-Latn-ZZ",
      "gam": "gam-Latn-ZZ",
      "gan": "gan-Hans-CN",
      "gaw": "gaw-Latn-ZZ",
      "gay": "gay-Latn-ID",
      "gba": "gba-Latn-ZZ",
      "gbf": "gbf-Latn-ZZ",
      "gbm": "gbm-Deva-IN",
      "gby": "gby-Latn-ZZ",
      "gbz": "gbz-Arab-IR",
      "gcr": "gcr-Latn-GF",
      "gd": "gd-Latn-GB",
      "gde": "gde-Latn-ZZ",
      "gdn": "gdn-Latn-ZZ",
      "gdr": "gdr-Latn-ZZ",
      "geb": "geb-Latn-ZZ",
      "gej": "gej-Latn-ZZ",
      "gel": "gel-Latn-ZZ",
      "gez": "gez-Ethi-ET",
      "gfk": "gfk-Latn-ZZ",
      "ggn": "ggn-Deva-NP",
      "ghs": "ghs-Latn-ZZ",
      "gil": "gil-Latn-KI",
      "gim": "gim-Latn-ZZ",
      "gjk": "gjk-Arab-PK",
      "gjn": "gjn-Latn-ZZ",
      "gju": "gju-Arab-PK",
      "gkn": "gkn-Latn-ZZ",
      "gkp": "gkp-Latn-ZZ",
      "gl": "gl-Latn-ES",
      "glk": "glk-Arab-IR",
      "gmm": "gmm-Latn-ZZ",
      "gmv": "gmv-Ethi-ZZ",
      "gn": "gn-Latn-PY",
      "gnd": "gnd-Latn-ZZ",
      "gng": "gng-Latn-ZZ",
      "god": "god-Latn-ZZ",
      "gof": "gof-Ethi-ZZ",
      "goi": "goi-Latn-ZZ",
      "gom": "gom-Deva-IN",
      "gon": "gon-Telu-IN",
      "gor": "gor-Latn-ID",
      "gos": "gos-Latn-NL",
      "got": "got-Goth-UA",
      "grb": "grb-Latn-ZZ",
      "grc": "grc-Cprt-CY",
      "grc-Linb": "grc-Linb-GR",
      "grt": "grt-Beng-IN",
      "grw": "grw-Latn-ZZ",
      "gsw": "gsw-Latn-CH",
      "gu": "gu-Gujr-IN",
      "gub": "gub-Latn-BR",
      "guc": "guc-Latn-CO",
      "gud": "gud-Latn-ZZ",
      "gur": "gur-Latn-GH",
      "guw": "guw-Latn-ZZ",
      "gux": "gux-Latn-ZZ",
      "guz": "guz-Latn-KE",
      "gv": "gv-Latn-IM",
      "gvf": "gvf-Latn-ZZ",
      "gvr": "gvr-Deva-NP",
      "gvs": "gvs-Latn-ZZ",
      "gwc": "gwc-Arab-ZZ",
      "gwi": "gwi-Latn-CA",
      "gwt": "gwt-Arab-ZZ",
      "gyi": "gyi-Latn-ZZ",
      "ha": "ha-Latn-NG",
      "ha-CM": "ha-Arab-CM",
      "ha-SD": "ha-Arab-SD",
      "hag": "hag-Latn-ZZ",
      "hak": "hak-Hans-CN",
      "ham": "ham-Latn-ZZ",
      "haw": "haw-Latn-US",
      "haz": "haz-Arab-AF",
      "hbb": "hbb-Latn-ZZ",
      "hdy": "hdy-Ethi-ZZ",
      "he": "he-Hebr-IL",
      "hhy": "hhy-Latn-ZZ",
      "hi": "hi-Deva-IN",
      "hia": "hia-Latn-ZZ",
      "hif": "hif-Latn-FJ",
      "hig": "hig-Latn-ZZ",
      "hih": "hih-Latn-ZZ",
      "hil": "hil-Latn-PH",
      "hla": "hla-Latn-ZZ",
      "hlu": "hlu-Hluw-TR",
      "hmd": "hmd-Plrd-CN",
      "hmt": "hmt-Latn-ZZ",
      "hnd": "hnd-Arab-PK",
      "hne": "hne-Deva-IN",
      "hnj": "hnj-Hmng-LA",
      "hnn": "hnn-Latn-PH",
      "hno": "hno-Arab-PK",
      "ho": "ho-Latn-PG",
      "hoc": "hoc-Deva-IN",
      "hoj": "hoj-Deva-IN",
      "hot": "hot-Latn-ZZ",
      "hr": "hr-Latn-HR",
      "hsb": "hsb-Latn-DE",
      "hsn": "hsn-Hans-CN",
      "ht": "ht-Latn-HT",
      "hu": "hu-Latn-HU",
      "hui": "hui-Latn-ZZ",
      "hy": "hy-Armn-AM",
      "hz": "hz-Latn-NA",
      "ia": "ia-Latn-001",
      "ian": "ian-Latn-ZZ",
      "iar": "iar-Latn-ZZ",
      "iba": "iba-Latn-MY",
      "ibb": "ibb-Latn-NG",
      "iby": "iby-Latn-ZZ",
      "ica": "ica-Latn-ZZ",
      "ich": "ich-Latn-ZZ",
      "id": "id-Latn-ID",
      "idd": "idd-Latn-ZZ",
      "idi": "idi-Latn-ZZ",
      "idu": "idu-Latn-ZZ",
      "ife": "ife-Latn-TG",
      "ig": "ig-Latn-NG",
      "igb": "igb-Latn-ZZ",
      "ige": "ige-Latn-ZZ",
      "ii": "ii-Yiii-CN",
      "ijj": "ijj-Latn-ZZ",
      "ik": "ik-Latn-US",
      "ikk": "ikk-Latn-ZZ",
      "ikt": "ikt-Latn-CA",
      "ikw": "ikw-Latn-ZZ",
      "ikx": "ikx-Latn-ZZ",
      "ilo": "ilo-Latn-PH",
      "imo": "imo-Latn-ZZ",
      "in": "in-Latn-ID",
      "inh": "inh-Cyrl-RU",
      "io": "io-Latn-001",
      "iou": "iou-Latn-ZZ",
      "iri": "iri-Latn-ZZ",
      "is": "is-Latn-IS",
      "it": "it-Latn-IT",
      "iu": "iu-Cans-CA",
      "iw": "iw-Hebr-IL",
      "iwm": "iwm-Latn-ZZ",
      "iws": "iws-Latn-ZZ",
      "izh": "izh-Latn-RU",
      "izi": "izi-Latn-ZZ",
      "ja": "ja-Jpan-JP",
      "jab": "jab-Latn-ZZ",
      "jam": "jam-Latn-JM",
      "jbo": "jbo-Latn-001",
      "jbu": "jbu-Latn-ZZ",
      "jen": "jen-Latn-ZZ",
      "jgk": "jgk-Latn-ZZ",
      "jgo": "jgo-Latn-CM",
      "ji": "ji-Hebr-UA",
      "jib": "jib-Latn-ZZ",
      "jmc": "jmc-Latn-TZ",
      "jml": "jml-Deva-NP",
      "jra": "jra-Latn-ZZ",
      "jut": "jut-Latn-DK",
      "jv": "jv-Latn-ID",
      "jw": "jw-Latn-ID",
      "ka": "ka-Geor-GE",
      "kaa": "kaa-Cyrl-UZ",
      "kab": "kab-Latn-DZ",
      "kac": "kac-Latn-MM",
      "kad": "kad-Latn-ZZ",
      "kai": "kai-Latn-ZZ",
      "kaj": "kaj-Latn-NG",
      "kam": "kam-Latn-KE",
      "kao": "kao-Latn-ML",
      "kbd": "kbd-Cyrl-RU",
      "kbm": "kbm-Latn-ZZ",
      "kbp": "kbp-Latn-ZZ",
      "kbq": "kbq-Latn-ZZ",
      "kbx": "kbx-Latn-ZZ",
      "kby": "kby-Arab-NE",
      "kcg": "kcg-Latn-NG",
      "kck": "kck-Latn-ZW",
      "kcl": "kcl-Latn-ZZ",
      "kct": "kct-Latn-ZZ",
      "kde": "kde-Latn-TZ",
      "kdh": "kdh-Arab-TG",
      "kdl": "kdl-Latn-ZZ",
      "kdt": "kdt-Thai-TH",
      "kea": "kea-Latn-CV",
      "ken": "ken-Latn-CM",
      "kez": "kez-Latn-ZZ",
      "kfo": "kfo-Latn-CI",
      "kfr": "kfr-Deva-IN",
      "kfy": "kfy-Deva-IN",
      "kg": "kg-Latn-CD",
      "kge": "kge-Latn-ID",
      "kgf": "kgf-Latn-ZZ",
      "kgp": "kgp-Latn-BR",
      "kha": "kha-Latn-IN",
      "khb": "khb-Talu-CN",
      "khn": "khn-Deva-IN",
      "khq": "khq-Latn-ML",
      "khs": "khs-Latn-ZZ",
      "kht": "kht-Mymr-IN",
      "khw": "khw-Arab-PK",
      "khz": "khz-Latn-ZZ",
      "ki": "ki-Latn-KE",
      "kij": "kij-Latn-ZZ",
      "kiu": "kiu-Latn-TR",
      "kiw": "kiw-Latn-ZZ",
      "kj": "kj-Latn-NA",
      "kjd": "kjd-Latn-ZZ",
      "kjg": "kjg-Laoo-LA",
      "kjs": "kjs-Latn-ZZ",
      "kjy": "kjy-Latn-ZZ",
      "kk": "kk-Cyrl-KZ",
      "kk-AF": "kk-Arab-AF",
      "kk-Arab": "kk-Arab-CN",
      "kk-CN": "kk-Arab-CN",
      "kk-IR": "kk-Arab-IR",
      "kk-MN": "kk-Arab-MN",
      "kkc": "kkc-Latn-ZZ",
      "kkj": "kkj-Latn-CM",
      "kl": "kl-Latn-GL",
      "kln": "kln-Latn-KE",
      "klq": "klq-Latn-ZZ",
      "klt": "klt-Latn-ZZ",
      "klx": "klx-Latn-ZZ",
      "km": "km-Khmr-KH",
      "kmb": "kmb-Latn-AO",
      "kmh": "kmh-Latn-ZZ",
      "kmo": "kmo-Latn-ZZ",
      "kms": "kms-Latn-ZZ",
      "kmu": "kmu-Latn-ZZ",
      "kmw": "kmw-Latn-ZZ",
      "kn": "kn-Knda-IN",
      "knf": "knf-Latn-GW",
      "knp": "knp-Latn-ZZ",
      "ko": "ko-Kore-KR",
      "koi": "koi-Cyrl-RU",
      "kok": "kok-Deva-IN",
      "kol": "kol-Latn-ZZ",
      "kos": "kos-Latn-FM",
      "koz": "koz-Latn-ZZ",
      "kpe": "kpe-Latn-LR",
      "kpf": "kpf-Latn-ZZ",
      "kpo": "kpo-Latn-ZZ",
      "kpr": "kpr-Latn-ZZ",
      "kpx": "kpx-Latn-ZZ",
      "kqb": "kqb-Latn-ZZ",
      "kqf": "kqf-Latn-ZZ",
      "kqs": "kqs-Latn-ZZ",
      "kqy": "kqy-Ethi-ZZ",
      "kr": "kr-Latn-ZZ",
      "krc": "krc-Cyrl-RU",
      "kri": "kri-Latn-SL",
      "krj": "krj-Latn-PH",
      "krl": "krl-Latn-RU",
      "krs": "krs-Latn-ZZ",
      "kru": "kru-Deva-IN",
      "ks": "ks-Arab-IN",
      "ksb": "ksb-Latn-TZ",
      "ksd": "ksd-Latn-ZZ",
      "ksf": "ksf-Latn-CM",
      "ksh": "ksh-Latn-DE",
      "ksj": "ksj-Latn-ZZ",
      "ksr": "ksr-Latn-ZZ",
      "ktb": "ktb-Ethi-ZZ",
      "ktm": "ktm-Latn-ZZ",
      "kto": "kto-Latn-ZZ",
      "ktr": "ktr-Latn-MY",
      "ku": "ku-Latn-TR",
      "ku-Arab": "ku-Arab-IQ",
      "ku-LB": "ku-Arab-LB",
      "kub": "kub-Latn-ZZ",
      "kud": "kud-Latn-ZZ",
      "kue": "kue-Latn-ZZ",
      "kuj": "kuj-Latn-ZZ",
      "kum": "kum-Cyrl-RU",
      "kun": "kun-Latn-ZZ",
      "kup": "kup-Latn-ZZ",
      "kus": "kus-Latn-ZZ",
      "kv": "kv-Cyrl-RU",
      "kvg": "kvg-Latn-ZZ",
      "kvr": "kvr-Latn-ID",
      "kvx": "kvx-Arab-PK",
      "kw": "kw-Latn-GB",
      "kwj": "kwj-Latn-ZZ",
      "kwo": "kwo-Latn-ZZ",
      "kwq": "kwq-Latn-ZZ",
      "kxa": "kxa-Latn-ZZ",
      "kxc": "kxc-Ethi-ZZ",
      "kxe": "kxe-Latn-ZZ",
      "kxm": "kxm-Thai-TH",
      "kxp": "kxp-Arab-PK",
      "kxw": "kxw-Latn-ZZ",
      "kxz": "kxz-Latn-ZZ",
      "ky": "ky-Cyrl-KG",
      "ky-Arab": "ky-Arab-CN",
      "ky-CN": "ky-Arab-CN",
      "ky-Latn": "ky-Latn-TR",
      "ky-TR": "ky-Latn-TR",
      "kye": "kye-Latn-ZZ",
      "kyx": "kyx-Latn-ZZ",
      "kzj": "kzj-Latn-MY",
      "kzr": "kzr-Latn-ZZ",
      "kzt": "kzt-Latn-MY",
      "la": "la-Latn-VA",
      "lab": "lab-Lina-GR",
      "lad": "lad-Hebr-IL",
      "lag": "lag-Latn-TZ",
      "lah": "lah-Arab-PK",
      "laj": "laj-Latn-UG",
      "las": "las-Latn-ZZ",
      "lb": "lb-Latn-LU",
      "lbe": "lbe-Cyrl-RU",
      "lbu": "lbu-Latn-ZZ",
      "lbw": "lbw-Latn-ID",
      "lcm": "lcm-Latn-ZZ",
      "lcp": "lcp-Thai-CN",
      "ldb": "ldb-Latn-ZZ",
      "led": "led-Latn-ZZ",
      "lee": "lee-Latn-ZZ",
      "lem": "lem-Latn-ZZ",
      "lep": "lep-Lepc-IN",
      "leq": "leq-Latn-ZZ",
      "leu": "leu-Latn-ZZ",
      "lez": "lez-Cyrl-RU",
      "lg": "lg-Latn-UG",
      "lgg": "lgg-Latn-ZZ",
      "li": "li-Latn-NL",
      "lia": "lia-Latn-ZZ",
      "lid": "lid-Latn-ZZ",
      "lif": "lif-Deva-NP",
      "lif-Limb": "lif-Limb-IN",
      "lig": "lig-Latn-ZZ",
      "lih": "lih-Latn-ZZ",
      "lij": "lij-Latn-IT",
      "lis": "lis-Lisu-CN",
      "ljp": "ljp-Latn-ID",
      "lki": "lki-Arab-IR",
      "lkt": "lkt-Latn-US",
      "lle": "lle-Latn-ZZ",
      "lln": "lln-Latn-ZZ",
      "lmn": "lmn-Telu-IN",
      "lmo": "lmo-Latn-IT",
      "lmp": "lmp-Latn-ZZ",
      "ln": "ln-Latn-CD",
      "lns": "lns-Latn-ZZ",
      "lnu": "lnu-Latn-ZZ",
      "lo": "lo-Laoo-LA",
      "loj": "loj-Latn-ZZ",
      "lok": "lok-Latn-ZZ",
      "lol": "lol-Latn-CD",
      "lor": "lor-Latn-ZZ",
      "los": "los-Latn-ZZ",
      "loz": "loz-Latn-ZM",
      "lrc": "lrc-Arab-IR",
      "lt": "lt-Latn-LT",
      "ltg": "ltg-Latn-LV",
      "lu": "lu-Latn-CD",
      "lua": "lua-Latn-CD",
      "luo": "luo-Latn-KE",
      "luy": "luy-Latn-KE",
      "luz": "luz-Arab-IR",
      "lv": "lv-Latn-LV",
      "lwl": "lwl-Thai-TH",
      "lzh": "lzh-Hans-CN",
      "lzz": "lzz-Latn-TR",
      "mad": "mad-Latn-ID",
      "maf": "maf-Latn-CM",
      "mag": "mag-Deva-IN",
      "mai": "mai-Deva-IN",
      "mak": "mak-Latn-ID",
      "man": "man-Latn-GM",
      "man-GN": "man-Nkoo-GN",
      "man-Nkoo": "man-Nkoo-GN",
      "mas": "mas-Latn-KE",
      "maw": "maw-Latn-ZZ",
      "maz": "maz-Latn-MX",
      "mbh": "mbh-Latn-ZZ",
      "mbo": "mbo-Latn-ZZ",
      "mbq": "mbq-Latn-ZZ",
      "mbu": "mbu-Latn-ZZ",
      "mbw": "mbw-Latn-ZZ",
      "mci": "mci-Latn-ZZ",
      "mcp": "mcp-Latn-ZZ",
      "mcq": "mcq-Latn-ZZ",
      "mcr": "mcr-Latn-ZZ",
      "mcu": "mcu-Latn-ZZ",
      "mda": "mda-Latn-ZZ",
      "mde": "mde-Arab-ZZ",
      "mdf": "mdf-Cyrl-RU",
      "mdh": "mdh-Latn-PH",
      "mdj": "mdj-Latn-ZZ",
      "mdr": "mdr-Latn-ID",
      "mdx": "mdx-Ethi-ZZ",
      "med": "med-Latn-ZZ",
      "mee": "mee-Latn-ZZ",
      "mek": "mek-Latn-ZZ",
      "men": "men-Latn-SL",
      "mer": "mer-Latn-KE",
      "met": "met-Latn-ZZ",
      "meu": "meu-Latn-ZZ",
      "mfa": "mfa-Arab-TH",
      "mfe": "mfe-Latn-MU",
      "mfn": "mfn-Latn-ZZ",
      "mfo": "mfo-Latn-ZZ",
      "mfq": "mfq-Latn-ZZ",
      "mg": "mg-Latn-MG",
      "mgh": "mgh-Latn-MZ",
      "mgl": "mgl-Latn-ZZ",
      "mgo": "mgo-Latn-CM",
      "mgp": "mgp-Deva-NP",
      "mgy": "mgy-Latn-TZ",
      "mh": "mh-Latn-MH",
      "mhi": "mhi-Latn-ZZ",
      "mhl": "mhl-Latn-ZZ",
      "mi": "mi-Latn-NZ",
      "mif": "mif-Latn-ZZ",
      "min": "min-Latn-ID",
      "mis": "mis-Hatr-IQ",
      "mis-Medf": "mis-Medf-NG",
      "miw": "miw-Latn-ZZ",
      "mk": "mk-Cyrl-MK",
      "mki": "mki-Arab-ZZ",
      "mkl": "mkl-Latn-ZZ",
      "mkp": "mkp-Latn-ZZ",
      "mkw": "mkw-Latn-ZZ",
      "ml": "ml-Mlym-IN",
      "mle": "mle-Latn-ZZ",
      "mlp": "mlp-Latn-ZZ",
      "mls": "mls-Latn-SD",
      "mmo": "mmo-Latn-ZZ",
      "mmu": "mmu-Latn-ZZ",
      "mmx": "mmx-Latn-ZZ",
      "mn": "mn-Cyrl-MN",
      "mn-CN": "mn-Mong-CN",
      "mn-Mong": "mn-Mong-CN",
      "mna": "mna-Latn-ZZ",
      "mnf": "mnf-Latn-ZZ",
      "mni": "mni-Beng-IN",
      "mnw": "mnw-Mymr-MM",
      "mo": "mo-Latn-RO",
      "moa": "moa-Latn-ZZ",
      "moe": "moe-Latn-CA",
      "moh": "moh-Latn-CA",
      "mos": "mos-Latn-BF",
      "mox": "mox-Latn-ZZ",
      "mpp": "mpp-Latn-ZZ",
      "mps": "mps-Latn-ZZ",
      "mpt": "mpt-Latn-ZZ",
      "mpx": "mpx-Latn-ZZ",
      "mql": "mql-Latn-ZZ",
      "mr": "mr-Deva-IN",
      "mrd": "mrd-Deva-NP",
      "mrj": "mrj-Cyrl-RU",
      "mro": "mro-Mroo-BD",
      "ms": "ms-Latn-MY",
      "ms-CC": "ms-Arab-CC",
      "ms-ID": "ms-Arab-ID",
      "mt": "mt-Latn-MT",
      "mtc": "mtc-Latn-ZZ",
      "mtf": "mtf-Latn-ZZ",
      "mti": "mti-Latn-ZZ",
      "mtr": "mtr-Deva-IN",
      "mua": "mua-Latn-CM",
      "mur": "mur-Latn-ZZ",
      "mus": "mus-Latn-US",
      "mva": "mva-Latn-ZZ",
      "mvn": "mvn-Latn-ZZ",
      "mvy": "mvy-Arab-PK",
      "mwk": "mwk-Latn-ML",
      "mwr": "mwr-Deva-IN",
      "mwv": "mwv-Latn-ID",
      "mww": "mww-Hmnp-US",
      "mxc": "mxc-Latn-ZW",
      "mxm": "mxm-Latn-ZZ",
      "my": "my-Mymr-MM",
      "myk": "myk-Latn-ZZ",
      "mym": "mym-Ethi-ZZ",
      "myv": "myv-Cyrl-RU",
      "myw": "myw-Latn-ZZ",
      "myx": "myx-Latn-UG",
      "myz": "myz-Mand-IR",
      "mzk": "mzk-Latn-ZZ",
      "mzm": "mzm-Latn-ZZ",
      "mzn": "mzn-Arab-IR",
      "mzp": "mzp-Latn-ZZ",
      "mzw": "mzw-Latn-ZZ",
      "mzz": "mzz-Latn-ZZ",
      "na": "na-Latn-NR",
      "nac": "nac-Latn-ZZ",
      "naf": "naf-Latn-ZZ",
      "nak": "nak-Latn-ZZ",
      "nan": "nan-Hans-CN",
      "nap": "nap-Latn-IT",
      "naq": "naq-Latn-NA",
      "nas": "nas-Latn-ZZ",
      "nb": "nb-Latn-NO",
      "nca": "nca-Latn-ZZ",
      "nce": "nce-Latn-ZZ",
      "ncf": "ncf-Latn-ZZ",
      "nch": "nch-Latn-MX",
      "nco": "nco-Latn-ZZ",
      "ncu": "ncu-Latn-ZZ",
      "nd": "nd-Latn-ZW",
      "ndc": "ndc-Latn-MZ",
      "nds": "nds-Latn-DE",
      "ne": "ne-Deva-NP",
      "neb": "neb-Latn-ZZ",
      "new": "new-Deva-NP",
      "nex": "nex-Latn-ZZ",
      "nfr": "nfr-Latn-ZZ",
      "ng": "ng-Latn-NA",
      "nga": "nga-Latn-ZZ",
      "ngb": "ngb-Latn-ZZ",
      "ngl": "ngl-Latn-MZ",
      "nhb": "nhb-Latn-ZZ",
      "nhe": "nhe-Latn-MX",
      "nhw": "nhw-Latn-MX",
      "nif": "nif-Latn-ZZ",
      "nii": "nii-Latn-ZZ",
      "nij": "nij-Latn-ID",
      "nin": "nin-Latn-ZZ",
      "niu": "niu-Latn-NU",
      "niy": "niy-Latn-ZZ",
      "niz": "niz-Latn-ZZ",
      "njo": "njo-Latn-IN",
      "nkg": "nkg-Latn-ZZ",
      "nko": "nko-Latn-ZZ",
      "nl": "nl-Latn-NL",
      "nmg": "nmg-Latn-CM",
      "nmz": "nmz-Latn-ZZ",
      "nn": "nn-Latn-NO",
      "nnf": "nnf-Latn-ZZ",
      "nnh": "nnh-Latn-CM",
      "nnk": "nnk-Latn-ZZ",
      "nnm": "nnm-Latn-ZZ",
      "nnp": "nnp-Wcho-IN",
      "no": "no-Latn-NO",
      "nod": "nod-Lana-TH",
      "noe": "noe-Deva-IN",
      "non": "non-Runr-SE",
      "nop": "nop-Latn-ZZ",
      "nou": "nou-Latn-ZZ",
      "nqo": "nqo-Nkoo-GN",
      "nr": "nr-Latn-ZA",
      "nrb": "nrb-Latn-ZZ",
      "nsk": "nsk-Cans-CA",
      "nsn": "nsn-Latn-ZZ",
      "nso": "nso-Latn-ZA",
      "nss": "nss-Latn-ZZ",
      "ntm": "ntm-Latn-ZZ",
      "ntr": "ntr-Latn-ZZ",
      "nui": "nui-Latn-ZZ",
      "nup": "nup-Latn-ZZ",
      "nus": "nus-Latn-SS",
      "nuv": "nuv-Latn-ZZ",
      "nux": "nux-Latn-ZZ",
      "nv": "nv-Latn-US",
      "nwb": "nwb-Latn-ZZ",
      "nxq": "nxq-Latn-CN",
      "nxr": "nxr-Latn-ZZ",
      "ny": "ny-Latn-MW",
      "nym": "nym-Latn-TZ",
      "nyn": "nyn-Latn-UG",
      "nzi": "nzi-Latn-GH",
      "oc": "oc-Latn-FR",
      "ogc": "ogc-Latn-ZZ",
      "okr": "okr-Latn-ZZ",
      "okv": "okv-Latn-ZZ",
      "om": "om-Latn-ET",
      "ong": "ong-Latn-ZZ",
      "onn": "onn-Latn-ZZ",
      "ons": "ons-Latn-ZZ",
      "opm": "opm-Latn-ZZ",
      "or": "or-Orya-IN",
      "oro": "oro-Latn-ZZ",
      "oru": "oru-Arab-ZZ",
      "os": "os-Cyrl-GE",
      "osa": "osa-Osge-US",
      "ota": "ota-Arab-ZZ",
      "otk": "otk-Orkh-MN",
      "ozm": "ozm-Latn-ZZ",
      "pa": "pa-Guru-IN",
      "pa-Arab": "pa-Arab-PK",
      "pa-PK": "pa-Arab-PK",
      "pag": "pag-Latn-PH",
      "pal": "pal-Phli-IR",
      "pal-Phlp": "pal-Phlp-CN",
      "pam": "pam-Latn-PH",
      "pap": "pap-Latn-AW",
      "pau": "pau-Latn-PW",
      "pbi": "pbi-Latn-ZZ",
      "pcd": "pcd-Latn-FR",
      "pcm": "pcm-Latn-NG",
      "pdc": "pdc-Latn-US",
      "pdt": "pdt-Latn-CA",
      "ped": "ped-Latn-ZZ",
      "peo": "peo-Xpeo-IR",
      "pex": "pex-Latn-ZZ",
      "pfl": "pfl-Latn-DE",
      "phl": "phl-Arab-ZZ",
      "phn": "phn-Phnx-LB",
      "pil": "pil-Latn-ZZ",
      "pip": "pip-Latn-ZZ",
      "pka": "pka-Brah-IN",
      "pko": "pko-Latn-KE",
      "pl": "pl-Latn-PL",
      "pla": "pla-Latn-ZZ",
      "pms": "pms-Latn-IT",
      "png": "png-Latn-ZZ",
      "pnn": "pnn-Latn-ZZ",
      "pnt": "pnt-Grek-GR",
      "pon": "pon-Latn-FM",
      "ppa": "ppa-Deva-IN",
      "ppo": "ppo-Latn-ZZ",
      "pra": "pra-Khar-PK",
      "prd": "prd-Arab-IR",
      "prg": "prg-Latn-001",
      "ps": "ps-Arab-AF",
      "pss": "pss-Latn-ZZ",
      "pt": "pt-Latn-BR",
      "ptp": "ptp-Latn-ZZ",
      "puu": "puu-Latn-GA",
      "pwa": "pwa-Latn-ZZ",
      "qu": "qu-Latn-PE",
      "quc": "quc-Latn-GT",
      "qug": "qug-Latn-EC",
      "rai": "rai-Latn-ZZ",
      "raj": "raj-Deva-IN",
      "rao": "rao-Latn-ZZ",
      "rcf": "rcf-Latn-RE",
      "rej": "rej-Latn-ID",
      "rel": "rel-Latn-ZZ",
      "res": "res-Latn-ZZ",
      "rgn": "rgn-Latn-IT",
      "rhg": "rhg-Arab-MM",
      "ria": "ria-Latn-IN",
      "rif": "rif-Tfng-MA",
      "rif-NL": "rif-Latn-NL",
      "rjs": "rjs-Deva-NP",
      "rkt": "rkt-Beng-BD",
      "rm": "rm-Latn-CH",
      "rmf": "rmf-Latn-FI",
      "rmo": "rmo-Latn-CH",
      "rmt": "rmt-Arab-IR",
      "rmu": "rmu-Latn-SE",
      "rn": "rn-Latn-BI",
      "rna": "rna-Latn-ZZ",
      "rng": "rng-Latn-MZ",
      "ro": "ro-Latn-RO",
      "rob": "rob-Latn-ID",
      "rof": "rof-Latn-TZ",
      "roo": "roo-Latn-ZZ",
      "rro": "rro-Latn-ZZ",
      "rtm": "rtm-Latn-FJ",
      "ru": "ru-Cyrl-RU",
      "rue": "rue-Cyrl-UA",
      "rug": "rug-Latn-SB",
      "rw": "rw-Latn-RW",
      "rwk": "rwk-Latn-TZ",
      "rwo": "rwo-Latn-ZZ",
      "ryu": "ryu-Kana-JP",
      "sa": "sa-Deva-IN",
      "saf": "saf-Latn-GH",
      "sah": "sah-Cyrl-RU",
      "saq": "saq-Latn-KE",
      "sas": "sas-Latn-ID",
      "sat": "sat-Latn-IN",
      "sav": "sav-Latn-SN",
      "saz": "saz-Saur-IN",
      "sba": "sba-Latn-ZZ",
      "sbe": "sbe-Latn-ZZ",
      "sbp": "sbp-Latn-TZ",
      "sc": "sc-Latn-IT",
      "sck": "sck-Deva-IN",
      "scl": "scl-Arab-ZZ",
      "scn": "scn-Latn-IT",
      "sco": "sco-Latn-GB",
      "scs": "scs-Latn-CA",
      "sd": "sd-Arab-PK",
      "sd-Deva": "sd-Deva-IN",
      "sd-Khoj": "sd-Khoj-IN",
      "sd-Sind": "sd-Sind-IN",
      "sdc": "sdc-Latn-IT",
      "sdh": "sdh-Arab-IR",
      "se": "se-Latn-NO",
      "sef": "sef-Latn-CI",
      "seh": "seh-Latn-MZ",
      "sei": "sei-Latn-MX",
      "ses": "ses-Latn-ML",
      "sg": "sg-Latn-CF",
      "sga": "sga-Ogam-IE",
      "sgs": "sgs-Latn-LT",
      "sgw": "sgw-Ethi-ZZ",
      "sgz": "sgz-Latn-ZZ",
      "shi": "shi-Tfng-MA",
      "shk": "shk-Latn-ZZ",
      "shn": "shn-Mymr-MM",
      "shu": "shu-Arab-ZZ",
      "si": "si-Sinh-LK",
      "sid": "sid-Latn-ET",
      "sig": "sig-Latn-ZZ",
      "sil": "sil-Latn-ZZ",
      "sim": "sim-Latn-ZZ",
      "sjr": "sjr-Latn-ZZ",
      "sk": "sk-Latn-SK",
      "skc": "skc-Latn-ZZ",
      "skr": "skr-Arab-PK",
      "sks": "sks-Latn-ZZ",
      "sl": "sl-Latn-SI",
      "sld": "sld-Latn-ZZ",
      "sli": "sli-Latn-PL",
      "sll": "sll-Latn-ZZ",
      "sly": "sly-Latn-ID",
      "sm": "sm-Latn-WS",
      "sma": "sma-Latn-SE",
      "smj": "smj-Latn-SE",
      "smn": "smn-Latn-FI",
      "smp": "smp-Samr-IL",
      "smq": "smq-Latn-ZZ",
      "sms": "sms-Latn-FI",
      "sn": "sn-Latn-ZW",
      "snc": "snc-Latn-ZZ",
      "snk": "snk-Latn-ML",
      "snp": "snp-Latn-ZZ",
      "snx": "snx-Latn-ZZ",
      "sny": "sny-Latn-ZZ",
      "so": "so-Latn-SO",
      "sog": "sog-Sogd-UZ",
      "sok": "sok-Latn-ZZ",
      "soq": "soq-Latn-ZZ",
      "sou": "sou-Thai-TH",
      "soy": "soy-Latn-ZZ",
      "spd": "spd-Latn-ZZ",
      "spl": "spl-Latn-ZZ",
      "sps": "sps-Latn-ZZ",
      "sq": "sq-Latn-AL",
      "sr": "sr-Cyrl-RS",
      "sr-ME": "sr-Latn-ME",
      "sr-RO": "sr-Latn-RO",
      "sr-RU": "sr-Latn-RU",
      "sr-TR": "sr-Latn-TR",
      "srb": "srb-Sora-IN",
      "srn": "srn-Latn-SR",
      "srr": "srr-Latn-SN",
      "srx": "srx-Deva-IN",
      "ss": "ss-Latn-ZA",
      "ssd": "ssd-Latn-ZZ",
      "ssg": "ssg-Latn-ZZ",
      "ssy": "ssy-Latn-ER",
      "st": "st-Latn-ZA",
      "stk": "stk-Latn-ZZ",
      "stq": "stq-Latn-DE",
      "su": "su-Latn-ID",
      "sua": "sua-Latn-ZZ",
      "sue": "sue-Latn-ZZ",
      "suk": "suk-Latn-TZ",
      "sur": "sur-Latn-ZZ",
      "sus": "sus-Latn-GN",
      "sv": "sv-Latn-SE",
      "sw": "sw-Latn-TZ",
      "swb": "swb-Arab-YT",
      "swc": "swc-Latn-CD",
      "swg": "swg-Latn-DE",
      "swp": "swp-Latn-ZZ",
      "swv": "swv-Deva-IN",
      "sxn": "sxn-Latn-ID",
      "sxw": "sxw-Latn-ZZ",
      "syl": "syl-Beng-BD",
      "syr": "syr-Syrc-IQ",
      "szl": "szl-Latn-PL",
      "ta": "ta-Taml-IN",
      "taj": "taj-Deva-NP",
      "tal": "tal-Latn-ZZ",
      "tan": "tan-Latn-ZZ",
      "taq": "taq-Latn-ZZ",
      "tbc": "tbc-Latn-ZZ",
      "tbd": "tbd-Latn-ZZ",
      "tbf": "tbf-Latn-ZZ",
      "tbg": "tbg-Latn-ZZ",
      "tbo": "tbo-Latn-ZZ",
      "tbw": "tbw-Latn-PH",
      "tbz": "tbz-Latn-ZZ",
      "tci": "tci-Latn-ZZ",
      "tcy": "tcy-Knda-IN",
      "tdd": "tdd-Tale-CN",
      "tdg": "tdg-Deva-NP",
      "tdh": "tdh-Deva-NP",
      "tdu": "tdu-Latn-MY",
      "te": "te-Telu-IN",
      "ted": "ted-Latn-ZZ",
      "tem": "tem-Latn-SL",
      "teo": "teo-Latn-UG",
      "tet": "tet-Latn-TL",
      "tfi": "tfi-Latn-ZZ",
      "tg": "tg-Cyrl-TJ",
      "tg-Arab": "tg-Arab-PK",
      "tg-PK": "tg-Arab-PK",
      "tgc": "tgc-Latn-ZZ",
      "tgo": "tgo-Latn-ZZ",
      "tgu": "tgu-Latn-ZZ",
      "th": "th-Thai-TH",
      "thl": "thl-Deva-NP",
      "thq": "thq-Deva-NP",
      "thr": "thr-Deva-NP",
      "ti": "ti-Ethi-ET",
      "tif": "tif-Latn-ZZ",
      "tig": "tig-Ethi-ER",
      "tik": "tik-Latn-ZZ",
      "tim": "tim-Latn-ZZ",
      "tio": "tio-Latn-ZZ",
      "tiv": "tiv-Latn-NG",
      "tk": "tk-Latn-TM",
      "tkl": "tkl-Latn-TK",
      "tkr": "tkr-Latn-AZ",
      "tkt": "tkt-Deva-NP",
      "tl": "tl-Latn-PH",
      "tlf": "tlf-Latn-ZZ",
      "tlx": "tlx-Latn-ZZ",
      "tly": "tly-Latn-AZ",
      "tmh": "tmh-Latn-NE",
      "tmy": "tmy-Latn-ZZ",
      "tn": "tn-Latn-ZA",
      "tnh": "tnh-Latn-ZZ",
      "to": "to-Latn-TO",
      "tof": "tof-Latn-ZZ",
      "tog": "tog-Latn-MW",
      "toq": "toq-Latn-ZZ",
      "tpi": "tpi-Latn-PG",
      "tpm": "tpm-Latn-ZZ",
      "tpz": "tpz-Latn-ZZ",
      "tqo": "tqo-Latn-ZZ",
      "tr": "tr-Latn-TR",
      "tru": "tru-Latn-TR",
      "trv": "trv-Latn-TW",
      "trw": "trw-Arab-ZZ",
      "ts": "ts-Latn-ZA",
      "tsd": "tsd-Grek-GR",
      "tsf": "tsf-Deva-NP",
      "tsg": "tsg-Latn-PH",
      "tsj": "tsj-Tibt-BT",
      "tsw": "tsw-Latn-ZZ",
      "tt": "tt-Cyrl-RU",
      "ttd": "ttd-Latn-ZZ",
      "tte": "tte-Latn-ZZ",
      "ttj": "ttj-Latn-UG",
      "ttr": "ttr-Latn-ZZ",
      "tts": "tts-Thai-TH",
      "ttt": "ttt-Latn-AZ",
      "tuh": "tuh-Latn-ZZ",
      "tul": "tul-Latn-ZZ",
      "tum": "tum-Latn-MW",
      "tuq": "tuq-Latn-ZZ",
      "tvd": "tvd-Latn-ZZ",
      "tvl": "tvl-Latn-TV",
      "tvu": "tvu-Latn-ZZ",
      "twh": "twh-Latn-ZZ",
      "twq": "twq-Latn-NE",
      "txg": "txg-Tang-CN",
      "ty": "ty-Latn-PF",
      "tya": "tya-Latn-ZZ",
      "tyv": "tyv-Cyrl-RU",
      "tzm": "tzm-Latn-MA",
      "ubu": "ubu-Latn-ZZ",
      "udm": "udm-Cyrl-RU",
      "ug": "ug-Arab-CN",
      "ug-Cyrl": "ug-Cyrl-KZ",
      "ug-KZ": "ug-Cyrl-KZ",
      "ug-MN": "ug-Cyrl-MN",
      "uga": "uga-Ugar-SY",
      "uk": "uk-Cyrl-UA",
      "uli": "uli-Latn-FM",
      "umb": "umb-Latn-AO",
      "und": "en-Latn-US",
      "und-002": "en-Latn-NG",
      "und-003": "en-Latn-US",
      "und-005": "pt-Latn-BR",
      "und-009": "en-Latn-AU",
      "und-011": "en-Latn-NG",
      "und-013": "es-Latn-MX",
      "und-014": "sw-Latn-TZ",
      "und-015": "ar-Arab-EG",
      "und-017": "sw-Latn-CD",
      "und-018": "en-Latn-ZA",
      "und-019": "en-Latn-US",
      "und-021": "en-Latn-US",
      "und-029": "es-Latn-CU",
      "und-030": "zh-Hans-CN",
      "und-034": "hi-Deva-IN",
      "und-035": "id-Latn-ID",
      "und-039": "it-Latn-IT",
      "und-053": "en-Latn-AU",
      "und-054": "en-Latn-PG",
      "und-057": "en-Latn-GU",
      "und-061": "sm-Latn-WS",
      "und-142": "zh-Hans-CN",
      "und-143": "uz-Latn-UZ",
      "und-145": "ar-Arab-SA",
      "und-150": "ru-Cyrl-RU",
      "und-151": "ru-Cyrl-RU",
      "und-154": "en-Latn-GB",
      "und-155": "de-Latn-DE",
      "und-202": "en-Latn-NG",
      "und-419": "es-Latn-419",
      "und-AD": "ca-Latn-AD",
      "und-Adlm": "ff-Adlm-GN",
      "und-AE": "ar-Arab-AE",
      "und-AF": "fa-Arab-AF",
      "und-Aghb": "lez-Aghb-RU",
      "und-Ahom": "aho-Ahom-IN",
      "und-AL": "sq-Latn-AL",
      "und-AM": "hy-Armn-AM",
      "und-AO": "pt-Latn-AO",
      "und-AQ": "und-Latn-AQ",
      "und-AR": "es-Latn-AR",
      "und-Arab": "ar-Arab-EG",
      "und-Arab-CC": "ms-Arab-CC",
      "und-Arab-CN": "ug-Arab-CN",
      "und-Arab-GB": "ks-Arab-GB",
      "und-Arab-ID": "ms-Arab-ID",
      "und-Arab-IN": "ur-Arab-IN",
      "und-Arab-KH": "cja-Arab-KH",
      "und-Arab-MM": "rhg-Arab-MM",
      "und-Arab-MN": "kk-Arab-MN",
      "und-Arab-MU": "ur-Arab-MU",
      "und-Arab-NG": "ha-Arab-NG",
      "und-Arab-PK": "ur-Arab-PK",
      "und-Arab-TG": "apd-Arab-TG",
      "und-Arab-TH": "mfa-Arab-TH",
      "und-Arab-TJ": "fa-Arab-TJ",
      "und-Arab-TR": "az-Arab-TR",
      "und-Arab-YT": "swb-Arab-YT",
      "und-Armi": "arc-Armi-IR",
      "und-Armn": "hy-Armn-AM",
      "und-AS": "sm-Latn-AS",
      "und-AT": "de-Latn-AT",
      "und-Avst": "ae-Avst-IR",
      "und-AW": "nl-Latn-AW",
      "und-AX": "sv-Latn-AX",
      "und-AZ": "az-Latn-AZ",
      "und-BA": "bs-Latn-BA",
      "und-Bali": "ban-Bali-ID",
      "und-Bamu": "bax-Bamu-CM",
      "und-Bass": "bsq-Bass-LR",
      "und-Batk": "bbc-Batk-ID",
      "und-BD": "bn-Beng-BD",
      "und-BE": "nl-Latn-BE",
      "und-Beng": "bn-Beng-BD",
      "und-BF": "fr-Latn-BF",
      "und-BG": "bg-Cyrl-BG",
      "und-BH": "ar-Arab-BH",
      "und-Bhks": "sa-Bhks-IN",
      "und-BI": "rn-Latn-BI",
      "und-BJ": "fr-Latn-BJ",
      "und-BL": "fr-Latn-BL",
      "und-BN": "ms-Latn-BN",
      "und-BO": "es-Latn-BO",
      "und-Bopo": "zh-Bopo-TW",
      "und-BQ": "pap-Latn-BQ",
      "und-BR": "pt-Latn-BR",
      "und-Brah": "pka-Brah-IN",
      "und-Brai": "fr-Brai-FR",
      "und-BT": "dz-Tibt-BT",
      "und-Bugi": "bug-Bugi-ID",
      "und-Buhd": "bku-Buhd-PH",
      "und-BV": "und-Latn-BV",
      "und-BY": "be-Cyrl-BY",
      "und-Cakm": "ccp-Cakm-BD",
      "und-Cans": "cr-Cans-CA",
      "und-Cari": "xcr-Cari-TR",
      "und-CD": "sw-Latn-CD",
      "und-CF": "fr-Latn-CF",
      "und-CG": "fr-Latn-CG",
      "und-CH": "de-Latn-CH",
      "und-Cham": "cjm-Cham-VN",
      "und-Cher": "chr-Cher-US",
      "und-CI": "fr-Latn-CI",
      "und-CL": "es-Latn-CL",
      "und-CM": "fr-Latn-CM",
      "und-CN": "zh-Hans-CN",
      "und-CO": "es-Latn-CO",
      "und-Copt": "cop-Copt-EG",
      "und-CP": "und-Latn-CP",
      "und-Cprt": "grc-Cprt-CY",
      "und-CR": "es-Latn-CR",
      "und-CU": "es-Latn-CU",
      "und-CV": "pt-Latn-CV",
      "und-CW": "pap-Latn-CW",
      "und-CY": "el-Grek-CY",
      "und-Cyrl": "ru-Cyrl-RU",
      "und-Cyrl-AL": "mk-Cyrl-AL",
      "und-Cyrl-BA": "sr-Cyrl-BA",
      "und-Cyrl-GE": "ab-Cyrl-GE",
      "und-Cyrl-GR": "mk-Cyrl-GR",
      "und-Cyrl-MD": "uk-Cyrl-MD",
      "und-Cyrl-RO": "bg-Cyrl-RO",
      "und-Cyrl-SK": "uk-Cyrl-SK",
      "und-Cyrl-TR": "kbd-Cyrl-TR",
      "und-Cyrl-XK": "sr-Cyrl-XK",
      "und-CZ": "cs-Latn-CZ",
      "und-DE": "de-Latn-DE",
      "und-Deva": "hi-Deva-IN",
      "und-Deva-BT": "ne-Deva-BT",
      "und-Deva-FJ": "hif-Deva-FJ",
      "und-Deva-MU": "bho-Deva-MU",
      "und-Deva-PK": "btv-Deva-PK",
      "und-DJ": "aa-Latn-DJ",
      "und-DK": "da-Latn-DK",
      "und-DO": "es-Latn-DO",
      "und-Dogr": "doi-Dogr-IN",
      "und-Dupl": "fr-Dupl-FR",
      "und-DZ": "ar-Arab-DZ",
      "und-EA": "es-Latn-EA",
      "und-EC": "es-Latn-EC",
      "und-EE": "et-Latn-EE",
      "und-EG": "ar-Arab-EG",
      "und-Egyp": "egy-Egyp-EG",
      "und-EH": "ar-Arab-EH",
      "und-Elba": "sq-Elba-AL",
      "und-Elym": "arc-Elym-IR",
      "und-ER": "ti-Ethi-ER",
      "und-ES": "es-Latn-ES",
      "und-ET": "am-Ethi-ET",
      "und-Ethi": "am-Ethi-ET",
      "und-EU": "en-Latn-GB",
      "und-EZ": "de-Latn-EZ",
      "und-FI": "fi-Latn-FI",
      "und-FO": "fo-Latn-FO",
      "und-FR": "fr-Latn-FR",
      "und-GA": "fr-Latn-GA",
      "und-GE": "ka-Geor-GE",
      "und-Geor": "ka-Geor-GE",
      "und-GF": "fr-Latn-GF",
      "und-GH": "ak-Latn-GH",
      "und-GL": "kl-Latn-GL",
      "und-Glag": "cu-Glag-BG",
      "und-GN": "fr-Latn-GN",
      "und-Gong": "wsg-Gong-IN",
      "und-Gonm": "esg-Gonm-IN",
      "und-Goth": "got-Goth-UA",
      "und-GP": "fr-Latn-GP",
      "und-GQ": "es-Latn-GQ",
      "und-GR": "el-Grek-GR",
      "und-Gran": "sa-Gran-IN",
      "und-Grek": "el-Grek-GR",
      "und-Grek-TR": "bgx-Grek-TR",
      "und-GS": "und-Latn-GS",
      "und-GT": "es-Latn-GT",
      "und-Gujr": "gu-Gujr-IN",
      "und-Guru": "pa-Guru-IN",
      "und-GW": "pt-Latn-GW",
      "und-Hanb": "zh-Hanb-TW",
      "und-Hang": "ko-Hang-KR",
      "und-Hani": "zh-Hani-CN",
      "und-Hano": "hnn-Hano-PH",
      "und-Hans": "zh-Hans-CN",
      "und-Hant": "zh-Hant-TW",
      "und-Hatr": "mis-Hatr-IQ",
      "und-Hebr": "he-Hebr-IL",
      "und-Hebr-CA": "yi-Hebr-CA",
      "und-Hebr-GB": "yi-Hebr-GB",
      "und-Hebr-SE": "yi-Hebr-SE",
      "und-Hebr-UA": "yi-Hebr-UA",
      "und-Hebr-US": "yi-Hebr-US",
      "und-Hira": "ja-Hira-JP",
      "und-HK": "zh-Hant-HK",
      "und-Hluw": "hlu-Hluw-TR",
      "und-HM": "und-Latn-HM",
      "und-Hmng": "hnj-Hmng-LA",
      "und-Hmnp": "mww-Hmnp-US",
      "und-HN": "es-Latn-HN",
      "und-HR": "hr-Latn-HR",
      "und-HT": "ht-Latn-HT",
      "und-HU": "hu-Latn-HU",
      "und-Hung": "hu-Hung-HU",
      "und-IC": "es-Latn-IC",
      "und-ID": "id-Latn-ID",
      "und-IL": "he-Hebr-IL",
      "und-IN": "hi-Deva-IN",
      "und-IQ": "ar-Arab-IQ",
      "und-IR": "fa-Arab-IR",
      "und-IS": "is-Latn-IS",
      "und-IT": "it-Latn-IT",
      "und-Ital": "ett-Ital-IT",
      "und-Jamo": "ko-Jamo-KR",
      "und-Java": "jv-Java-ID",
      "und-JO": "ar-Arab-JO",
      "und-JP": "ja-Jpan-JP",
      "und-Jpan": "ja-Jpan-JP",
      "und-Kali": "eky-Kali-MM",
      "und-Kana": "ja-Kana-JP",
      "und-KE": "sw-Latn-KE",
      "und-KG": "ky-Cyrl-KG",
      "und-KH": "km-Khmr-KH",
      "und-Khar": "pra-Khar-PK",
      "und-Khmr": "km-Khmr-KH",
      "und-Khoj": "sd-Khoj-IN",
      "und-KM": "ar-Arab-KM",
      "und-Knda": "kn-Knda-IN",
      "und-Kore": "ko-Kore-KR",
      "und-KP": "ko-Kore-KP",
      "und-KR": "ko-Kore-KR",
      "und-Kthi": "bho-Kthi-IN",
      "und-KW": "ar-Arab-KW",
      "und-KZ": "ru-Cyrl-KZ",
      "und-LA": "lo-Laoo-LA",
      "und-Lana": "nod-Lana-TH",
      "und-Laoo": "lo-Laoo-LA",
      "und-Latn-AF": "tk-Latn-AF",
      "und-Latn-AM": "ku-Latn-AM",
      "und-Latn-CN": "za-Latn-CN",
      "und-Latn-CY": "tr-Latn-CY",
      "und-Latn-DZ": "fr-Latn-DZ",
      "und-Latn-ET": "en-Latn-ET",
      "und-Latn-GE": "ku-Latn-GE",
      "und-Latn-IR": "tk-Latn-IR",
      "und-Latn-KM": "fr-Latn-KM",
      "und-Latn-MA": "fr-Latn-MA",
      "und-Latn-MK": "sq-Latn-MK",
      "und-Latn-MM": "kac-Latn-MM",
      "und-Latn-MO": "pt-Latn-MO",
      "und-Latn-MR": "fr-Latn-MR",
      "und-Latn-RU": "krl-Latn-RU",
      "und-Latn-SY": "fr-Latn-SY",
      "und-Latn-TN": "fr-Latn-TN",
      "und-Latn-TW": "trv-Latn-TW",
      "und-Latn-UA": "pl-Latn-UA",
      "und-LB": "ar-Arab-LB",
      "und-Lepc": "lep-Lepc-IN",
      "und-LI": "de-Latn-LI",
      "und-Limb": "lif-Limb-IN",
      "und-Lina": "lab-Lina-GR",
      "und-Linb": "grc-Linb-GR",
      "und-Lisu": "lis-Lisu-CN",
      "und-LK": "si-Sinh-LK",
      "und-LS": "st-Latn-LS",
      "und-LT": "lt-Latn-LT",
      "und-LU": "fr-Latn-LU",
      "und-LV": "lv-Latn-LV",
      "und-LY": "ar-Arab-LY",
      "und-Lyci": "xlc-Lyci-TR",
      "und-Lydi": "xld-Lydi-TR",
      "und-MA": "ar-Arab-MA",
      "und-Mahj": "hi-Mahj-IN",
      "und-Maka": "mak-Maka-ID",
      "und-Mand": "myz-Mand-IR",
      "und-Mani": "xmn-Mani-CN",
      "und-Marc": "bo-Marc-CN",
      "und-MC": "fr-Latn-MC",
      "und-MD": "ro-Latn-MD",
      "und-ME": "sr-Latn-ME",
      "und-Medf": "mis-Medf-NG",
      "und-Mend": "men-Mend-SL",
      "und-Merc": "xmr-Merc-SD",
      "und-Mero": "xmr-Mero-SD",
      "und-MF": "fr-Latn-MF",
      "und-MG": "mg-Latn-MG",
      "und-MK": "mk-Cyrl-MK",
      "und-ML": "bm-Latn-ML",
      "und-Mlym": "ml-Mlym-IN",
      "und-MM": "my-Mymr-MM",
      "und-MN": "mn-Cyrl-MN",
      "und-MO": "zh-Hant-MO",
      "und-Modi": "mr-Modi-IN",
      "und-Mong": "mn-Mong-CN",
      "und-MQ": "fr-Latn-MQ",
      "und-MR": "ar-Arab-MR",
      "und-Mroo": "mro-Mroo-BD",
      "und-MT": "mt-Latn-MT",
      "und-Mtei": "mni-Mtei-IN",
      "und-MU": "mfe-Latn-MU",
      "und-Mult": "skr-Mult-PK",
      "und-MV": "dv-Thaa-MV",
      "und-MX": "es-Latn-MX",
      "und-MY": "ms-Latn-MY",
      "und-Mymr": "my-Mymr-MM",
      "und-Mymr-IN": "kht-Mymr-IN",
      "und-Mymr-TH": "mnw-Mymr-TH",
      "und-MZ": "pt-Latn-MZ",
      "und-NA": "af-Latn-NA",
      "und-Nand": "sa-Nand-IN",
      "und-Narb": "xna-Narb-SA",
      "und-Nbat": "arc-Nbat-JO",
      "und-NC": "fr-Latn-NC",
      "und-NE": "ha-Latn-NE",
      "und-Newa": "new-Newa-NP",
      "und-NI": "es-Latn-NI",
      "und-Nkoo": "man-Nkoo-GN",
      "und-NL": "nl-Latn-NL",
      "und-NO": "nb-Latn-NO",
      "und-NP": "ne-Deva-NP",
      "und-Nshu": "zhx-Nshu-CN",
      "und-Ogam": "sga-Ogam-IE",
      "und-Olck": "sat-Olck-IN",
      "und-OM": "ar-Arab-OM",
      "und-Orkh": "otk-Orkh-MN",
      "und-Orya": "or-Orya-IN",
      "und-Osge": "osa-Osge-US",
      "und-Osma": "so-Osma-SO",
      "und-PA": "es-Latn-PA",
      "und-Palm": "arc-Palm-SY",
      "und-Pauc": "ctd-Pauc-MM",
      "und-PE": "es-Latn-PE",
      "und-Perm": "kv-Perm-RU",
      "und-PF": "fr-Latn-PF",
      "und-PG": "tpi-Latn-PG",
      "und-PH": "fil-Latn-PH",
      "und-Phag": "lzh-Phag-CN",
      "und-Phli": "pal-Phli-IR",
      "und-Phlp": "pal-Phlp-CN",
      "und-Phnx": "phn-Phnx-LB",
      "und-PK": "ur-Arab-PK",
      "und-PL": "pl-Latn-PL",
      "und-Plrd": "hmd-Plrd-CN",
      "und-PM": "fr-Latn-PM",
      "und-PR": "es-Latn-PR",
      "und-Prti": "xpr-Prti-IR",
      "und-PS": "ar-Arab-PS",
      "und-PT": "pt-Latn-PT",
      "und-PW": "pau-Latn-PW",
      "und-PY": "gn-Latn-PY",
      "und-QA": "ar-Arab-QA",
      "und-QO": "en-Latn-DG",
      "und-RE": "fr-Latn-RE",
      "und-Rjng": "rej-Rjng-ID",
      "und-RO": "ro-Latn-RO",
      "und-Rohg": "rhg-Rohg-MM",
      "und-RS": "sr-Cyrl-RS",
      "und-RU": "ru-Cyrl-RU",
      "und-Runr": "non-Runr-SE",
      "und-RW": "rw-Latn-RW",
      "und-SA": "ar-Arab-SA",
      "und-Samr": "smp-Samr-IL",
      "und-Sarb": "xsa-Sarb-YE",
      "und-Saur": "saz-Saur-IN",
      "und-SC": "fr-Latn-SC",
      "und-SD": "ar-Arab-SD",
      "und-SE": "sv-Latn-SE",
      "und-Sgnw": "ase-Sgnw-US",
      "und-Shaw": "en-Shaw-GB",
      "und-Shrd": "sa-Shrd-IN",
      "und-SI": "sl-Latn-SI",
      "und-Sidd": "sa-Sidd-IN",
      "und-Sind": "sd-Sind-IN",
      "und-Sinh": "si-Sinh-LK",
      "und-SJ": "nb-Latn-SJ",
      "und-SK": "sk-Latn-SK",
      "und-SM": "it-Latn-SM",
      "und-SN": "fr-Latn-SN",
      "und-SO": "so-Latn-SO",
      "und-Sogd": "sog-Sogd-UZ",
      "und-Sogo": "sog-Sogo-UZ",
      "und-Sora": "srb-Sora-IN",
      "und-Soyo": "cmg-Soyo-MN",
      "und-SR": "nl-Latn-SR",
      "und-ST": "pt-Latn-ST",
      "und-Sund": "su-Sund-ID",
      "und-SV": "es-Latn-SV",
      "und-SY": "ar-Arab-SY",
      "und-Sylo": "syl-Sylo-BD",
      "und-Syrc": "syr-Syrc-IQ",
      "und-Tagb": "tbw-Tagb-PH",
      "und-Takr": "doi-Takr-IN",
      "und-Tale": "tdd-Tale-CN",
      "und-Talu": "khb-Talu-CN",
      "und-Taml": "ta-Taml-IN",
      "und-Tang": "txg-Tang-CN",
      "und-Tavt": "blt-Tavt-VN",
      "und-TD": "fr-Latn-TD",
      "und-Telu": "te-Telu-IN",
      "und-TF": "fr-Latn-TF",
      "und-Tfng": "zgh-Tfng-MA",
      "und-TG": "fr-Latn-TG",
      "und-Tglg": "fil-Tglg-PH",
      "und-TH": "th-Thai-TH",
      "und-Thaa": "dv-Thaa-MV",
      "und-Thai": "th-Thai-TH",
      "und-Thai-CN": "lcp-Thai-CN",
      "und-Thai-KH": "kdt-Thai-KH",
      "und-Thai-LA": "kdt-Thai-LA",
      "und-Tibt": "bo-Tibt-CN",
      "und-Tirh": "mai-Tirh-IN",
      "und-TJ": "tg-Cyrl-TJ",
      "und-TK": "tkl-Latn-TK",
      "und-TL": "pt-Latn-TL",
      "und-TM": "tk-Latn-TM",
      "und-TN": "ar-Arab-TN",
      "und-TO": "to-Latn-TO",
      "und-TR": "tr-Latn-TR",
      "und-TV": "tvl-Latn-TV",
      "und-TW": "zh-Hant-TW",
      "und-TZ": "sw-Latn-TZ",
      "und-UA": "uk-Cyrl-UA",
      "und-UG": "sw-Latn-UG",
      "und-Ugar": "uga-Ugar-SY",
      "und-UY": "es-Latn-UY",
      "und-UZ": "uz-Latn-UZ",
      "und-VA": "it-Latn-VA",
      "und-Vaii": "vai-Vaii-LR",
      "und-VE": "es-Latn-VE",
      "und-VN": "vi-Latn-VN",
      "und-VU": "bi-Latn-VU",
      "und-Wara": "hoc-Wara-IN",
      "und-Wcho": "nnp-Wcho-IN",
      "und-WF": "fr-Latn-WF",
      "und-WS": "sm-Latn-WS",
      "und-XK": "sq-Latn-XK",
      "und-Xpeo": "peo-Xpeo-IR",
      "und-Xsux": "akk-Xsux-IQ",
      "und-YE": "ar-Arab-YE",
      "und-Yiii": "ii-Yiii-CN",
      "und-YT": "fr-Latn-YT",
      "und-Zanb": "cmg-Zanb-MN",
      "und-ZW": "sn-Latn-ZW",
      "unr": "unr-Beng-IN",
      "unr-Deva": "unr-Deva-NP",
      "unr-NP": "unr-Deva-NP",
      "unx": "unx-Beng-IN",
      "uok": "uok-Latn-ZZ",
      "ur": "ur-Arab-PK",
      "uri": "uri-Latn-ZZ",
      "urt": "urt-Latn-ZZ",
      "urw": "urw-Latn-ZZ",
      "usa": "usa-Latn-ZZ",
      "utr": "utr-Latn-ZZ",
      "uvh": "uvh-Latn-ZZ",
      "uvl": "uvl-Latn-ZZ",
      "uz": "uz-Latn-UZ",
      "uz-AF": "uz-Arab-AF",
      "uz-Arab": "uz-Arab-AF",
      "uz-CN": "uz-Cyrl-CN",
      "vag": "vag-Latn-ZZ",
      "vai": "vai-Vaii-LR",
      "van": "van-Latn-ZZ",
      "ve": "ve-Latn-ZA",
      "vec": "vec-Latn-IT",
      "vep": "vep-Latn-RU",
      "vi": "vi-Latn-VN",
      "vic": "vic-Latn-SX",
      "viv": "viv-Latn-ZZ",
      "vls": "vls-Latn-BE",
      "vmf": "vmf-Latn-DE",
      "vmw": "vmw-Latn-MZ",
      "vo": "vo-Latn-001",
      "vot": "vot-Latn-RU",
      "vro": "vro-Latn-EE",
      "vun": "vun-Latn-TZ",
      "vut": "vut-Latn-ZZ",
      "wa": "wa-Latn-BE",
      "wae": "wae-Latn-CH",
      "waj": "waj-Latn-ZZ",
      "wal": "wal-Ethi-ET",
      "wan": "wan-Latn-ZZ",
      "war": "war-Latn-PH",
      "wbp": "wbp-Latn-AU",
      "wbq": "wbq-Telu-IN",
      "wbr": "wbr-Deva-IN",
      "wci": "wci-Latn-ZZ",
      "wer": "wer-Latn-ZZ",
      "wgi": "wgi-Latn-ZZ",
      "whg": "whg-Latn-ZZ",
      "wib": "wib-Latn-ZZ",
      "wiu": "wiu-Latn-ZZ",
      "wiv": "wiv-Latn-ZZ",
      "wja": "wja-Latn-ZZ",
      "wji": "wji-Latn-ZZ",
      "wls": "wls-Latn-WF",
      "wmo": "wmo-Latn-ZZ",
      "wnc": "wnc-Latn-ZZ",
      "wni": "wni-Arab-KM",
      "wnu": "wnu-Latn-ZZ",
      "wo": "wo-Latn-SN",
      "wob": "wob-Latn-ZZ",
      "wos": "wos-Latn-ZZ",
      "wrs": "wrs-Latn-ZZ",
      "wsg": "wsg-Gong-IN",
      "wsk": "wsk-Latn-ZZ",
      "wtm": "wtm-Deva-IN",
      "wuu": "wuu-Hans-CN",
      "wuv": "wuv-Latn-ZZ",
      "wwa": "wwa-Latn-ZZ",
      "xav": "xav-Latn-BR",
      "xbi": "xbi-Latn-ZZ",
      "xcr": "xcr-Cari-TR",
      "xes": "xes-Latn-ZZ",
      "xh": "xh-Latn-ZA",
      "xla": "xla-Latn-ZZ",
      "xlc": "xlc-Lyci-TR",
      "xld": "xld-Lydi-TR",
      "xmf": "xmf-Geor-GE",
      "xmn": "xmn-Mani-CN",
      "xmr": "xmr-Merc-SD",
      "xna": "xna-Narb-SA",
      "xnr": "xnr-Deva-IN",
      "xog": "xog-Latn-UG",
      "xon": "xon-Latn-ZZ",
      "xpr": "xpr-Prti-IR",
      "xrb": "xrb-Latn-ZZ",
      "xsa": "xsa-Sarb-YE",
      "xsi": "xsi-Latn-ZZ",
      "xsm": "xsm-Latn-ZZ",
      "xsr": "xsr-Deva-NP",
      "xwe": "xwe-Latn-ZZ",
      "yam": "yam-Latn-ZZ",
      "yao": "yao-Latn-MZ",
      "yap": "yap-Latn-FM",
      "yas": "yas-Latn-ZZ",
      "yat": "yat-Latn-ZZ",
      "yav": "yav-Latn-CM",
      "yay": "yay-Latn-ZZ",
      "yaz": "yaz-Latn-ZZ",
      "yba": "yba-Latn-ZZ",
      "ybb": "ybb-Latn-CM",
      "yby": "yby-Latn-ZZ",
      "yer": "yer-Latn-ZZ",
      "ygr": "ygr-Latn-ZZ",
      "ygw": "ygw-Latn-ZZ",
      "yi": "yi-Hebr-001",
      "yko": "yko-Latn-ZZ",
      "yle": "yle-Latn-ZZ",
      "ylg": "ylg-Latn-ZZ",
      "yll": "yll-Latn-ZZ",
      "yml": "yml-Latn-ZZ",
      "yo": "yo-Latn-NG",
      "yon": "yon-Latn-ZZ",
      "yrb": "yrb-Latn-ZZ",
      "yre": "yre-Latn-ZZ",
      "yrl": "yrl-Latn-BR",
      "yss": "yss-Latn-ZZ",
      "yua": "yua-Latn-MX",
      "yue": "yue-Hant-HK",
      "yue-CN": "yue-Hans-CN",
      "yue-Hans": "yue-Hans-CN",
      "yuj": "yuj-Latn-ZZ",
      "yut": "yut-Latn-ZZ",
      "yuw": "yuw-Latn-ZZ",
      "za": "za-Latn-CN",
      "zag": "zag-Latn-SD",
      "zdj": "zdj-Arab-KM",
      "zea": "zea-Latn-NL",
      "zgh": "zgh-Tfng-MA",
      "zh": "zh-Hans-CN",
      "zh-AU": "zh-Hant-AU",
      "zh-BN": "zh-Hant-BN",
      "zh-Bopo": "zh-Bopo-TW",
      "zh-GB": "zh-Hant-GB",
      "zh-GF": "zh-Hant-GF",
      "zh-Hanb": "zh-Hanb-TW",
      "zh-Hant": "zh-Hant-TW",
      "zh-HK": "zh-Hant-HK",
      "zh-ID": "zh-Hant-ID",
      "zh-MO": "zh-Hant-MO",
      "zh-MY": "zh-Hant-MY",
      "zh-PA": "zh-Hant-PA",
      "zh-PF": "zh-Hant-PF",
      "zh-PH": "zh-Hant-PH",
      "zh-SR": "zh-Hant-SR",
      "zh-TH": "zh-Hant-TH",
      "zh-TW": "zh-Hant-TW",
      "zh-US": "zh-Hant-US",
      "zh-VN": "zh-Hant-VN",
      "zhx": "zhx-Nshu-CN",
      "zia": "zia-Latn-ZZ",
      "zlm": "zlm-Latn-TG",
      "zmi": "zmi-Latn-MY",
      "zne": "zne-Latn-ZZ",
      "zu": "zu-Latn-ZA",
      "zza": "zza-Latn-TR"
    },
    "timeData": {
      "AX": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "BQ": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "CP": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "CZ": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "DK": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "FI": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "ID": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "IS": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "ML": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "NE": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "RU": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "SE": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "SJ": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "SK": {
        "_allowed": "H",
        "_preferred": "H"
      },
      "AS": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "BT": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "DJ": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "ER": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "GH": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "IN": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "LS": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "PG": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "PW": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "SO": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "TO": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "VU": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "WS": {
        "_allowed": "h H",
        "_preferred": "h"
      },
      "001": {
        "_allowed": "H h",
        "_preferred": "H"
      },
      "AL": {
        "_allowed": "h H hB",
        "_preferred": "h"
      },
      "TD": {
        "_allowed": "h H hB",
        "_preferred": "h"
      },
      "ca_ES": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "CF": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "CM": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "fr_CA": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "gl_ES": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "it_CH": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "it_IT": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "LU": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "NP": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "PF": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "SC": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "SM": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "SN": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "TF": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "VA": {
        "_allowed": "H h hB",
        "_preferred": "H"
      },
      "CY": {
        "_allowed": "h H hb hB",
        "_preferred": "h"
      },
      "GR": {
        "_allowed": "h H hb hB",
        "_preferred": "h"
      },
      "CO": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "DO": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "KP": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "KR": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "NA": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "PA": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "PR": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "VE": {
        "_allowed": "h H hB hb",
        "_preferred": "h"
      },
      "AC": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "AI": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "BW": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "BZ": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "CC": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "CK": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "CX": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "DG": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "FK": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "GB": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "GG": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "GI": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "IE": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "IM": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "IO": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "JE": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "LT": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "MK": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "MN": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "MS": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NF": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NG": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NR": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "NU": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "PN": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "SH": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "SX": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "TA": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "ZA": {
        "_allowed": "H h hb hB",
        "_preferred": "H"
      },
      "af_ZA": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "AR": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "CL": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "CR": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "CU": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "EA": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_BO": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_BR": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_EC": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_ES": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_GQ": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "es_PE": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "GT": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "HN": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "IC": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "KG": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "KM": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "LK": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "MA": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "MX": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "NI": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "PY": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "SV": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "UY": {
        "_allowed": "H h hB hb",
        "_preferred": "H"
      },
      "JP": {
        "_allowed": "H h K",
        "_preferred": "H"
      },
      "AD": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AM": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AO": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "AW": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BJ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BL": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "CG": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "CI": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "CV": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "DE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "EE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "FR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GA": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GN": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GP": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "GW": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "HR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "IL": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "IT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "KZ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MC": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MD": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MQ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "MZ": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "NC": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "NL": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "PM": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "PT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "RE": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "RO": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "SI": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "SR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "ST": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "TG": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "TR": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "WF": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "YT": {
        "_allowed": "H hB",
        "_preferred": "H"
      },
      "BD": {
        "_allowed": "h hB H",
        "_preferred": "h"
      },
      "PK": {
        "_allowed": "h hB H",
        "_preferred": "h"
      },
      "AZ": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "BA": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "BG": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "CH": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "GE": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "LI": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "ME": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "RS": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "UA": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "UZ": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "XK": {
        "_allowed": "H hB h",
        "_preferred": "H"
      },
      "AG": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "AU": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BB": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BS": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "CA": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "DM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "en_001": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "FJ": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "FM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GD": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GU": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "GY": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "JM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "KI": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "KN": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "KY": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "LC": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "LR": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "MH": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "MP": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "MW": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "NZ": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SB": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SG": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SL": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SS": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "SZ": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "TC": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "TT": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "UM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "US": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "VC": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "VG": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "VI": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "ZM": {
        "_allowed": "h hb H hB",
        "_preferred": "h"
      },
      "BO": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "EC": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "ES": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "GQ": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "PE": {
        "_allowed": "H hB h hb",
        "_preferred": "H"
      },
      "AE": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "ar_001": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "BH": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "DZ": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "EG": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "EH": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "IQ": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "JO": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "KW": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "LB": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "LY": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "MR": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "OM": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "PH": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "PS": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "QA": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "SA": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "SD": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "SY": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "TN": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "YE": {
        "_allowed": "h hB hb H",
        "_preferred": "h"
      },
      "AF": {
        "_allowed": "H hb hB h",
        "_preferred": "H"
      },
      "LA": {
        "_allowed": "H hb hB h",
        "_preferred": "H"
      },
      "LV": {
        "_allowed": "H hB hb h",
        "_preferred": "H"
      },
      "TL": {
        "_allowed": "H hB hb h",
        "_preferred": "H"
      },
      "zu_ZA": {
        "_allowed": "H hB hb h",
        "_preferred": "H"
      },
      "CD": {
        "_allowed": "hB H",
        "_preferred": "H"
      },
      "IR": {
        "_allowed": "hB H",
        "_preferred": "H"
      },
      "hi_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "kn_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "ml_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "te_IN": {
        "_allowed": "hB h H",
        "_preferred": "h"
      },
      "KH": {
        "_allowed": "hB h H hb",
        "_preferred": "h"
      },
      "ta_IN": {
        "_allowed": "hB h hb H",
        "_preferred": "h"
      },
      "BN": {
        "_allowed": "hb hB h H",
        "_preferred": "h"
      },
      "MY": {
        "_allowed": "hb hB h H",
        "_preferred": "h"
      },
      "CN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "ET": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "gu_IN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "HK": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "MO": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "mr_IN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "pa_IN": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "TW": {
        "_allowed": "hB hb h H",
        "_preferred": "h"
      },
      "KE": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      },
      "MM": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      },
      "TZ": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      },
      "UG": {
        "_allowed": "hB hb H h",
        "_preferred": "H"
      }
    },
    "weekData": {
      "minDays": {
        "001": "1",
        "AD": "4",
        "AN": "4",
        "AT": "4",
        "AX": "4",
        "BE": "4",
        "BG": "4",
        "CH": "4",
        "CZ": "4",
        "DE": "4",
        "DK": "4",
        "EE": "4",
        "ES": "4",
        "FI": "4",
        "FJ": "4",
        "FO": "4",
        "FR": "4",
        "GB": "4",
        "GF": "4",
        "GG": "4",
        "GI": "4",
        "GP": "4",
        "GR": "4",
        "GU": "1",
        "HU": "4",
        "IE": "4",
        "IM": "4",
        "IS": "4",
        "IT": "4",
        "JE": "4",
        "LI": "4",
        "LT": "4",
        "LU": "4",
        "MC": "4",
        "MQ": "4",
        "NL": "4",
        "NO": "4",
        "PL": "4",
        "PT": "4",
        "RE": "4",
        "RU": "4",
        "SE": "4",
        "SJ": "4",
        "SK": "4",
        "SM": "4",
        "UM": "1",
        "US": "1",
        "VA": "4",
        "VI": "1"
      },
      "firstDay": {
        "001": "mon",
        "AD": "mon",
        "AE": "sat",
        "AF": "sat",
        "AG": "sun",
        "AI": "mon",
        "AL": "mon",
        "AM": "mon",
        "AN": "mon",
        "AR": "mon",
        "AS": "sun",
        "AT": "mon",
        "AU": "sun",
        "AX": "mon",
        "AZ": "mon",
        "BA": "mon",
        "BD": "sun",
        "BE": "mon",
        "BG": "mon",
        "BH": "sat",
        "BM": "mon",
        "BN": "mon",
        "BR": "sun",
        "BS": "sun",
        "BT": "sun",
        "BW": "sun",
        "BY": "mon",
        "BZ": "sun",
        "CA": "sun",
        "CH": "mon",
        "CL": "mon",
        "CM": "mon",
        "CN": "sun",
        "CO": "sun",
        "CR": "mon",
        "CY": "mon",
        "CZ": "mon",
        "DE": "mon",
        "DJ": "sat",
        "DK": "mon",
        "DM": "sun",
        "DO": "sun",
        "DZ": "sat",
        "EC": "mon",
        "EE": "mon",
        "EG": "sat",
        "ES": "mon",
        "ET": "sun",
        "FI": "mon",
        "FJ": "mon",
        "FO": "mon",
        "FR": "mon",
        "GB": "mon",
        "GB-alt-variant": "sun",
        "GE": "mon",
        "GF": "mon",
        "GP": "mon",
        "GR": "mon",
        "GT": "sun",
        "GU": "sun",
        "HK": "sun",
        "HN": "sun",
        "HR": "mon",
        "HU": "mon",
        "ID": "sun",
        "IE": "mon",
        "IL": "sun",
        "IN": "sun",
        "IQ": "sat",
        "IR": "sat",
        "IS": "mon",
        "IT": "mon",
        "JM": "sun",
        "JO": "sat",
        "JP": "sun",
        "KE": "sun",
        "KG": "mon",
        "KH": "sun",
        "KR": "sun",
        "KW": "sat",
        "KZ": "mon",
        "LA": "sun",
        "LB": "mon",
        "LI": "mon",
        "LK": "mon",
        "LT": "mon",
        "LU": "mon",
        "LV": "mon",
        "LY": "sat",
        "MC": "mon",
        "MD": "mon",
        "ME": "mon",
        "MH": "sun",
        "MK": "mon",
        "MM": "sun",
        "MN": "mon",
        "MO": "sun",
        "MQ": "mon",
        "MT": "sun",
        "MV": "fri",
        "MX": "sun",
        "MY": "mon",
        "MZ": "sun",
        "NI": "sun",
        "NL": "mon",
        "NO": "mon",
        "NP": "sun",
        "NZ": "mon",
        "OM": "sat",
        "PA": "sun",
        "PE": "sun",
        "PH": "sun",
        "PK": "sun",
        "PL": "mon",
        "PR": "sun",
        "PT": "sun",
        "PY": "sun",
        "QA": "sat",
        "RE": "mon",
        "RO": "mon",
        "RS": "mon",
        "RU": "mon",
        "SA": "sun",
        "SD": "sat",
        "SE": "mon",
        "SG": "sun",
        "SI": "mon",
        "SK": "mon",
        "SM": "mon",
        "SV": "sun",
        "SY": "sat",
        "TH": "sun",
        "TJ": "mon",
        "TM": "mon",
        "TR": "mon",
        "TT": "sun",
        "TW": "sun",
        "UA": "mon",
        "UM": "sun",
        "US": "sun",
        "UY": "mon",
        "UZ": "mon",
        "VA": "mon",
        "VE": "sun",
        "VI": "sun",
        "VN": "mon",
        "WS": "sun",
        "XK": "mon",
        "YE": "sun",
        "ZA": "sun",
        "ZW": "sun"
      },
      "weekendStart": {
        "001": "sat",
        "AE": "fri",
        "AF": "thu",
        "BH": "fri",
        "DZ": "fri",
        "EG": "fri",
        "IL": "fri",
        "IN": "sun",
        "IQ": "fri",
        "IR": "fri",
        "JO": "fri",
        "KW": "fri",
        "LY": "fri",
        "OM": "fri",
        "QA": "fri",
        "SA": "fri",
        "SD": "fri",
        "SY": "fri",
        "UG": "sun",
        "YE": "fri"
      },
      "weekendEnd": {
        "001": "sun",
        "AE": "sat",
        "AF": "fri",
        "BH": "sat",
        "DZ": "sat",
        "EG": "sat",
        "IL": "sat",
        "IQ": "sat",
        "IR": "fri",
        "JO": "sat",
        "KW": "sat",
        "LY": "sat",
        "OM": "sat",
        "QA": "sat",
        "SA": "sat",
        "SD": "sat",
        "SY": "sat",
        "YE": "sat"
      },
      "af": {
        "_ordering": "weekOfDate weekOfInterval weekOfMonth"
      },
      "am az bs cs cy da el et hi ky lt mk sk ta th": {
        "_ordering": "weekOfYear weekOfMonth"
      },
      "ar fil gu hu hy id kk ko": {
        "_ordering": "weekOfMonth"
      },
      "be ro ru": {
        "_ordering": "weekOfInterval weekOfMonth"
      },
      "bg de iw pt ur zh": {
        "_ordering": "weekOfDate weekOfMonth weekOfInterval"
      },
      "ca es fr gl": {
        "_ordering": "weekOfDate"
      },
      "en bn ja ka": {
        "_ordering": "weekOfDate weekOfMonth"
      },
      "eu": {
        "_ordering": "weekOfMonth weekOfDate"
      },
      "fa hr it lv pl si sr uk uz": {
        "_ordering": "weekOfMonth weekOfInterval"
      },
      "fi zh-TW": {
        "_ordering": "weekOfYear weekOfDate weekOfMonth"
      },
      "is mn no sv vi": {
        "_ordering": "weekOfYear weekOfMonth weekOfInterval"
      },
      "km mr": {
        "_ordering": "weekOfMonth weekOfYear"
      },
      "kn ml pa": {
        "_ordering": "weekOfMonth weekOfDate weekOfYear"
      },
      "lo sq": {
        "_ordering": "weekOfMonth weekOfInterval weekOfDate weekOfYear"
      },
      "ms tr": {
        "_ordering": "weekOfMonth weekOfYear weekOfInterval weekOfDate"
      },
      "nl": {
        "_ordering": "weekOfDate weekOfYear weekOfMonth"
      },
      "sl": {
        "_ordering": "weekOfInterval"
      },
      "sw te": {
        "_ordering": "weekOfMonth weekOfInterval weekOfYear"
      },
      "und": {
        "_ordering": "weekOfYear"
      },
      "zu": {
        "_ordering": "weekOfYear weekOfInterval"
      }
    },
    "currencyData": {
      "fractions": {
        "ADP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "AFN": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ALL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "AMD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "BHD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "BIF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "BYN": {
          "_rounding": "0",
          "_digits": "2"
        },
        "BYR": {
          "_rounding": "0",
          "_digits": "0"
        },
        "CAD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "5"
        },
        "CHF": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "5"
        },
        "CLF": {
          "_rounding": "0",
          "_digits": "4"
        },
        "CLP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "COP": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "CRC": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "CZK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "DEFAULT": {
          "_rounding": "0",
          "_digits": "2"
        },
        "DJF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "DKK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "50"
        },
        "ESP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "GNF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "GYD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "HUF": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "IDR": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "IQD": {
          "_rounding": "0",
          "_digits": "0"
        },
        "IRR": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ISK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ITL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "JOD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "JPY": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KMF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KPW": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KRW": {
          "_rounding": "0",
          "_digits": "0"
        },
        "KWD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "LAK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "LBP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "LUF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "LYD": {
          "_rounding": "0",
          "_digits": "3"
        },
        "MGA": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MGF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MMK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MNT": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "MRO": {
          "_rounding": "0",
          "_digits": "0"
        },
        "MUR": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "NOK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "OMR": {
          "_rounding": "0",
          "_digits": "3"
        },
        "PKR": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "PYG": {
          "_rounding": "0",
          "_digits": "0"
        },
        "RSD": {
          "_rounding": "0",
          "_digits": "0"
        },
        "RWF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "SEK": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "SLL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "SOS": {
          "_rounding": "0",
          "_digits": "0"
        },
        "STD": {
          "_rounding": "0",
          "_digits": "0"
        },
        "SYP": {
          "_rounding": "0",
          "_digits": "0"
        },
        "TMM": {
          "_rounding": "0",
          "_digits": "0"
        },
        "TND": {
          "_rounding": "0",
          "_digits": "3"
        },
        "TRL": {
          "_rounding": "0",
          "_digits": "0"
        },
        "TWD": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "TZS": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "UGX": {
          "_rounding": "0",
          "_digits": "0"
        },
        "UYI": {
          "_rounding": "0",
          "_digits": "0"
        },
        "UYW": {
          "_rounding": "0",
          "_digits": "4"
        },
        "UZS": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "VEF": {
          "_rounding": "0",
          "_digits": "2",
          "_cashRounding": "0",
          "_cashDigits": "0"
        },
        "VND": {
          "_rounding": "0",
          "_digits": "0"
        },
        "VUV": {
          "_rounding": "0",
          "_digits": "0"
        },
        "XAF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "XOF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "XPF": {
          "_rounding": "0",
          "_digits": "0"
        },
        "YER": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ZMK": {
          "_rounding": "0",
          "_digits": "0"
        },
        "ZWD": {
          "_rounding": "0",
          "_digits": "0"
        }
      },
      "region": {
        "AC": [{
          "SHP": {
            "_from": "1976-01-01"
          }
        }],
        "AD": [{
          "ESP": {
            "_from": "1873-01-01",
            "_to": "2002-02-28"
          }
        }, {
          "ADP": {
            "_from": "1936-01-01",
            "_to": "2001-12-31"
          }
        }, {
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "AE": [{
          "AED": {
            "_from": "1973-05-19"
          }
        }],
        "AF": [{
          "AFA": {
            "_from": "1927-03-14",
            "_to": "2002-12-31"
          }
        }, {
          "AFN": {
            "_from": "2002-10-07"
          }
        }],
        "AG": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "AI": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "AL": [{
          "ALK": {
            "_from": "1946-11-01",
            "_to": "1965-08-16"
          }
        }, {
          "ALL": {
            "_from": "1965-08-16"
          }
        }],
        "AM": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-11-22"
          }
        }, {
          "AMD": {
            "_from": "1993-11-22"
          }
        }],
        "AO": [{
          "AOK": {
            "_from": "1977-01-08",
            "_to": "1991-03-01"
          }
        }, {
          "AON": {
            "_from": "1990-09-25",
            "_to": "2000-02-01"
          }
        }, {
          "AOR": {
            "_from": "1995-07-01",
            "_to": "2000-02-01"
          }
        }, {
          "AOA": {
            "_from": "1999-12-13"
          }
        }],
        "AQ": [{
          "XXX": {
            "_tender": "false"
          }
        }],
        "AR": [{
          "ARM": {
            "_from": "1881-11-05",
            "_to": "1970-01-01"
          }
        }, {
          "ARL": {
            "_from": "1970-01-01",
            "_to": "1983-06-01"
          }
        }, {
          "ARP": {
            "_from": "1983-06-01",
            "_to": "1985-06-14"
          }
        }, {
          "ARA": {
            "_from": "1985-06-14",
            "_to": "1992-01-01"
          }
        }, {
          "ARS": {
            "_from": "1992-01-01"
          }
        }],
        "AS": [{
          "USD": {
            "_from": "1904-07-16"
          }
        }],
        "AT": [{
          "ATS": {
            "_from": "1947-12-04",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "AU": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "AW": [{
          "ANG": {
            "_from": "1940-05-10",
            "_to": "1986-01-01"
          }
        }, {
          "AWG": {
            "_from": "1986-01-01"
          }
        }],
        "AX": [{
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "AZ": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1994-01-01"
          }
        }, {
          "AZM": {
            "_from": "1993-11-22",
            "_to": "2006-12-31"
          }
        }, {
          "AZN": {
            "_from": "2006-01-01"
          }
        }],
        "BA": [{
          "YUD": {
            "_from": "1966-01-01",
            "_to": "1990-01-01"
          }
        }, {
          "YUN": {
            "_from": "1990-01-01",
            "_to": "1992-07-01"
          }
        }, {
          "YUR": {
            "_from": "1992-07-01",
            "_to": "1993-10-01"
          }
        }, {
          "BAD": {
            "_from": "1992-07-01",
            "_to": "1994-08-15"
          }
        }, {
          "BAN": {
            "_from": "1994-08-15",
            "_to": "1997-07-01"
          }
        }, {
          "BAM": {
            "_from": "1995-01-01"
          }
        }],
        "BB": [{
          "XCD": {
            "_from": "1965-10-06",
            "_to": "1973-12-03"
          }
        }, {
          "BBD": {
            "_from": "1973-12-03"
          }
        }],
        "BD": [{
          "INR": {
            "_from": "1835-08-17",
            "_to": "1948-04-01"
          }
        }, {
          "PKR": {
            "_from": "1948-04-01",
            "_to": "1972-01-01"
          }
        }, {
          "BDT": {
            "_from": "1972-01-01"
          }
        }],
        "BE": [{
          "NLG": {
            "_from": "1816-12-15",
            "_to": "1831-02-07"
          }
        }, {
          "BEF": {
            "_from": "1831-02-07",
            "_to": "2002-02-28"
          }
        }, {
          "BEC": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "BEL": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "BF": [{
          "XOF": {
            "_from": "1984-08-04"
          }
        }],
        "BG": [{
          "BGO": {
            "_from": "1879-07-08",
            "_to": "1952-05-12"
          }
        }, {
          "BGM": {
            "_from": "1952-05-12",
            "_to": "1962-01-01"
          }
        }, {
          "BGL": {
            "_from": "1962-01-01",
            "_to": "1999-07-05"
          }
        }, {
          "BGN": {
            "_from": "1999-07-05"
          }
        }],
        "BH": [{
          "BHD": {
            "_from": "1965-10-16"
          }
        }],
        "BI": [{
          "BIF": {
            "_from": "1964-05-19"
          }
        }],
        "BJ": [{
          "XOF": {
            "_from": "1975-11-30"
          }
        }],
        "BL": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "BM": [{
          "BMD": {
            "_from": "1970-02-06"
          }
        }],
        "BN": [{
          "MYR": {
            "_from": "1963-09-16",
            "_to": "1967-06-12"
          }
        }, {
          "BND": {
            "_from": "1967-06-12"
          }
        }],
        "BO": [{
          "BOV": {
            "_tender": "false"
          }
        }, {
          "BOL": {
            "_from": "1863-06-23",
            "_to": "1963-01-01"
          }
        }, {
          "BOP": {
            "_from": "1963-01-01",
            "_to": "1986-12-31"
          }
        }, {
          "BOB": {
            "_from": "1987-01-01"
          }
        }],
        "BQ": [{
          "ANG": {
            "_from": "2010-10-10",
            "_to": "2011-01-01"
          }
        }, {
          "USD": {
            "_from": "2011-01-01"
          }
        }],
        "BR": [{
          "BRZ": {
            "_from": "1942-11-01",
            "_to": "1967-02-13"
          }
        }, {
          "BRB": {
            "_from": "1967-02-13",
            "_to": "1986-02-28"
          }
        }, {
          "BRC": {
            "_from": "1986-02-28",
            "_to": "1989-01-15"
          }
        }, {
          "BRN": {
            "_from": "1989-01-15",
            "_to": "1990-03-16"
          }
        }, {
          "BRE": {
            "_from": "1990-03-16",
            "_to": "1993-08-01"
          }
        }, {
          "BRR": {
            "_from": "1993-08-01",
            "_to": "1994-07-01"
          }
        }, {
          "BRL": {
            "_from": "1994-07-01"
          }
        }],
        "BS": [{
          "BSD": {
            "_from": "1966-05-25"
          }
        }],
        "BT": [{
          "INR": {
            "_from": "1907-01-01"
          }
        }, {
          "BTN": {
            "_from": "1974-04-16"
          }
        }],
        "BU": [{
          "BUK": {
            "_from": "1952-07-01",
            "_to": "1989-06-18"
          }
        }],
        "BV": [{
          "NOK": {
            "_from": "1905-06-07"
          }
        }],
        "BW": [{
          "ZAR": {
            "_from": "1961-02-14",
            "_to": "1976-08-23"
          }
        }, {
          "BWP": {
            "_from": "1976-08-23"
          }
        }],
        "BY": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1994-11-08"
          }
        }, {
          "BYB": {
            "_from": "1994-08-01",
            "_to": "2000-12-31"
          }
        }, {
          "BYR": {
            "_from": "2000-01-01",
            "_to": "2017-01-01"
          }
        }, {
          "BYN": {
            "_from": "2016-07-01"
          }
        }],
        "BZ": [{
          "BZD": {
            "_from": "1974-01-01"
          }
        }],
        "CA": [{
          "CAD": {
            "_from": "1858-01-01"
          }
        }],
        "CC": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "CD": [{
          "ZRZ": {
            "_from": "1971-10-27",
            "_to": "1993-11-01"
          }
        }, {
          "ZRN": {
            "_from": "1993-11-01",
            "_to": "1998-07-01"
          }
        }, {
          "CDF": {
            "_from": "1998-07-01"
          }
        }],
        "CF": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "CG": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "CH": [{
          "CHE": {
            "_tender": "false"
          }
        }, {
          "CHW": {
            "_tender": "false"
          }
        }, {
          "CHF": {
            "_from": "1799-03-17"
          }
        }],
        "CI": [{
          "XOF": {
            "_from": "1958-12-04"
          }
        }],
        "CK": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "CL": [{
          "CLF": {
            "_tender": "false"
          }
        }, {
          "CLE": {
            "_from": "1960-01-01",
            "_to": "1975-09-29"
          }
        }, {
          "CLP": {
            "_from": "1975-09-29"
          }
        }],
        "CM": [{
          "XAF": {
            "_from": "1973-04-01"
          }
        }],
        "CN": [{
          "CNY": {
            "_from": "1953-03-01"
          }
        }, {
          "CNX": {
            "_tender": "false",
            "_from": "1979-01-01",
            "_to": "1998-12-31"
          }
        }, {
          "CNH": {
            "_tender": "false",
            "_from": "2010-07-19"
          }
        }],
        "CO": [{
          "COU": {
            "_tender": "false"
          }
        }, {
          "COP": {
            "_from": "1905-01-01"
          }
        }],
        "CP": [{
          "XXX": {
            "_tender": "false"
          }
        }],
        "CR": [{
          "CRC": {
            "_from": "1896-10-26"
          }
        }],
        "CS": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }, {
          "CSD": {
            "_from": "2002-05-15",
            "_to": "2006-06-03"
          }
        }, {
          "EUR": {
            "_from": "2003-02-04",
            "_to": "2006-06-03"
          }
        }],
        "CU": [{
          "CUP": {
            "_from": "1859-01-01"
          }
        }, {
          "USD": {
            "_from": "1899-01-01",
            "_to": "1959-01-01"
          }
        }, {
          "CUC": {
            "_from": "1994-01-01"
          }
        }],
        "CV": [{
          "PTE": {
            "_from": "1911-05-22",
            "_to": "1975-07-05"
          }
        }, {
          "CVE": {
            "_from": "1914-01-01"
          }
        }],
        "CW": [{
          "ANG": {
            "_from": "2010-10-10"
          }
        }],
        "CX": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "CY": [{
          "CYP": {
            "_from": "1914-09-10",
            "_to": "2008-01-31"
          }
        }, {
          "EUR": {
            "_from": "2008-01-01"
          }
        }],
        "CZ": [{
          "CSK": {
            "_from": "1953-06-01",
            "_to": "1993-03-01"
          }
        }, {
          "CZK": {
            "_from": "1993-01-01"
          }
        }],
        "DD": [{
          "DDM": {
            "_from": "1948-07-20",
            "_to": "1990-10-02"
          }
        }],
        "DE": [{
          "DEM": {
            "_from": "1948-06-20",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "DG": [{
          "USD": {
            "_from": "1965-11-08"
          }
        }],
        "DJ": [{
          "DJF": {
            "_from": "1977-06-27"
          }
        }],
        "DK": [{
          "DKK": {
            "_from": "1873-05-27"
          }
        }],
        "DM": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "DO": [{
          "USD": {
            "_from": "1905-06-21",
            "_to": "1947-10-01"
          }
        }, {
          "DOP": {
            "_from": "1947-10-01"
          }
        }],
        "DZ": [{
          "DZD": {
            "_from": "1964-04-01"
          }
        }],
        "EA": [{
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "EC": [{
          "ECS": {
            "_from": "1884-04-01",
            "_to": "2000-10-02"
          }
        }, {
          "ECV": {
            "_tender": "false",
            "_from": "1993-05-23",
            "_to": "2000-01-09"
          }
        }, {
          "USD": {
            "_from": "2000-10-02"
          }
        }],
        "EE": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1992-06-20"
          }
        }, {
          "EEK": {
            "_from": "1992-06-21",
            "_to": "2010-12-31"
          }
        }, {
          "EUR": {
            "_from": "2011-01-01"
          }
        }],
        "EG": [{
          "EGP": {
            "_from": "1885-11-14"
          }
        }],
        "EH": [{
          "MAD": {
            "_from": "1976-02-26"
          }
        }],
        "ER": [{
          "ETB": {
            "_from": "1993-05-24",
            "_to": "1997-11-08"
          }
        }, {
          "ERN": {
            "_from": "1997-11-08"
          }
        }],
        "ES": [{
          "ESP": {
            "_from": "1868-10-19",
            "_to": "2002-02-28"
          }
        }, {
          "ESB": {
            "_tender": "false",
            "_from": "1975-01-01",
            "_to": "1994-12-31"
          }
        }, {
          "ESA": {
            "_tender": "false",
            "_from": "1978-01-01",
            "_to": "1981-12-31"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "ET": [{
          "ETB": {
            "_from": "1976-09-15"
          }
        }],
        "EU": [{
          "XEU": {
            "_tender": "false",
            "_from": "1979-01-01",
            "_to": "1998-12-31"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "FI": [{
          "FIM": {
            "_from": "1963-01-01",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "FJ": [{
          "FJD": {
            "_from": "1969-01-13"
          }
        }],
        "FK": [{
          "FKP": {
            "_from": "1901-01-01"
          }
        }],
        "FM": [{
          "JPY": {
            "_from": "1914-10-03",
            "_to": "1944-01-01"
          }
        }, {
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "FO": [{
          "DKK": {
            "_from": "1948-01-01"
          }
        }],
        "FR": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "GA": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "GB": [{
          "GBP": {
            "_from": "1694-07-27"
          }
        }],
        "GD": [{
          "XCD": {
            "_from": "1967-02-27"
          }
        }],
        "GE": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-06-11"
          }
        }, {
          "GEK": {
            "_from": "1993-04-05",
            "_to": "1995-09-25"
          }
        }, {
          "GEL": {
            "_from": "1995-09-23"
          }
        }],
        "GF": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "GG": [{
          "GBP": {
            "_from": "1830-01-01"
          }
        }],
        "GH": [{
          "GHC": {
            "_from": "1979-03-09",
            "_to": "2007-12-31"
          }
        }, {
          "GHS": {
            "_from": "2007-07-03"
          }
        }],
        "GI": [{
          "GIP": {
            "_from": "1713-01-01"
          }
        }],
        "GL": [{
          "DKK": {
            "_from": "1873-05-27"
          }
        }],
        "GM": [{
          "GMD": {
            "_from": "1971-07-01"
          }
        }],
        "GN": [{
          "GNS": {
            "_from": "1972-10-02",
            "_to": "1986-01-06"
          }
        }, {
          "GNF": {
            "_from": "1986-01-06"
          }
        }],
        "GP": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "GQ": [{
          "GQE": {
            "_from": "1975-07-07",
            "_to": "1986-06-01"
          }
        }, {
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "GR": [{
          "GRD": {
            "_from": "1954-05-01",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "2001-01-01"
          }
        }],
        "GS": [{
          "GBP": {
            "_from": "1908-01-01"
          }
        }],
        "GT": [{
          "GTQ": {
            "_from": "1925-05-27"
          }
        }],
        "GU": [{
          "USD": {
            "_from": "1944-08-21"
          }
        }],
        "GW": [{
          "GWE": {
            "_from": "1914-01-01",
            "_to": "1976-02-28"
          }
        }, {
          "GWP": {
            "_from": "1976-02-28",
            "_to": "1997-03-31"
          }
        }, {
          "XOF": {
            "_from": "1997-03-31"
          }
        }],
        "GY": [{
          "GYD": {
            "_from": "1966-05-26"
          }
        }],
        "HK": [{
          "HKD": {
            "_from": "1895-02-02"
          }
        }],
        "HM": [{
          "AUD": {
            "_from": "1967-02-16"
          }
        }],
        "HN": [{
          "HNL": {
            "_from": "1926-04-03"
          }
        }],
        "HR": [{
          "YUD": {
            "_from": "1966-01-01",
            "_to": "1990-01-01"
          }
        }, {
          "YUN": {
            "_from": "1990-01-01",
            "_to": "1991-12-23"
          }
        }, {
          "HRD": {
            "_from": "1991-12-23",
            "_to": "1995-01-01"
          }
        }, {
          "HRK": {
            "_from": "1994-05-30"
          }
        }],
        "HT": [{
          "HTG": {
            "_from": "1872-08-26"
          }
        }, {
          "USD": {
            "_from": "1915-01-01"
          }
        }],
        "HU": [{
          "HUF": {
            "_from": "1946-07-23"
          }
        }],
        "IC": [{
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "ID": [{
          "IDR": {
            "_from": "1965-12-13"
          }
        }],
        "IE": [{
          "GBP": {
            "_from": "1800-01-01",
            "_to": "1922-01-01"
          }
        }, {
          "IEP": {
            "_from": "1922-01-01",
            "_to": "2002-02-09"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "IL": [{
          "ILP": {
            "_from": "1948-08-16",
            "_to": "1980-02-22"
          }
        }, {
          "ILR": {
            "_from": "1980-02-22",
            "_to": "1985-09-04"
          }
        }, {
          "ILS": {
            "_from": "1985-09-04"
          }
        }],
        "IM": [{
          "GBP": {
            "_from": "1840-01-03"
          }
        }],
        "IN": [{
          "INR": {
            "_from": "1835-08-17"
          }
        }],
        "IO": [{
          "USD": {
            "_from": "1965-11-08"
          }
        }],
        "IQ": [{
          "EGP": {
            "_from": "1920-11-11",
            "_to": "1931-04-19"
          }
        }, {
          "INR": {
            "_from": "1920-11-11",
            "_to": "1931-04-19"
          }
        }, {
          "IQD": {
            "_from": "1931-04-19"
          }
        }],
        "IR": [{
          "IRR": {
            "_from": "1932-05-13"
          }
        }],
        "IS": [{
          "DKK": {
            "_from": "1873-05-27",
            "_to": "1918-12-01"
          }
        }, {
          "ISJ": {
            "_from": "1918-12-01",
            "_to": "1981-01-01"
          }
        }, {
          "ISK": {
            "_from": "1981-01-01"
          }
        }],
        "IT": [{
          "ITL": {
            "_from": "1862-08-24",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "JE": [{
          "GBP": {
            "_from": "1837-01-01"
          }
        }],
        "JM": [{
          "JMD": {
            "_from": "1969-09-08"
          }
        }],
        "JO": [{
          "JOD": {
            "_from": "1950-07-01"
          }
        }],
        "JP": [{
          "JPY": {
            "_from": "1871-06-01"
          }
        }],
        "KE": [{
          "KES": {
            "_from": "1966-09-14"
          }
        }],
        "KG": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-05-10"
          }
        }, {
          "KGS": {
            "_from": "1993-05-10"
          }
        }],
        "KH": [{
          "KHR": {
            "_from": "1980-03-20"
          }
        }],
        "KI": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "KM": [{
          "KMF": {
            "_from": "1975-07-06"
          }
        }],
        "KN": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "KP": [{
          "KPW": {
            "_from": "1959-04-17"
          }
        }],
        "KR": [{
          "KRO": {
            "_from": "1945-08-15",
            "_to": "1953-02-15"
          }
        }, {
          "KRH": {
            "_from": "1953-02-15",
            "_to": "1962-06-10"
          }
        }, {
          "KRW": {
            "_from": "1962-06-10"
          }
        }],
        "KW": [{
          "KWD": {
            "_from": "1961-04-01"
          }
        }],
        "KY": [{
          "JMD": {
            "_from": "1969-09-08",
            "_to": "1971-01-01"
          }
        }, {
          "KYD": {
            "_from": "1971-01-01"
          }
        }],
        "KZ": [{
          "KZT": {
            "_from": "1993-11-05"
          }
        }],
        "LA": [{
          "LAK": {
            "_from": "1979-12-10"
          }
        }],
        "LB": [{
          "LBP": {
            "_from": "1948-02-02"
          }
        }],
        "LC": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "LI": [{
          "CHF": {
            "_from": "1921-02-01"
          }
        }],
        "LK": [{
          "LKR": {
            "_from": "1978-05-22"
          }
        }],
        "LR": [{
          "LRD": {
            "_from": "1944-01-01"
          }
        }],
        "LS": [{
          "ZAR": {
            "_from": "1961-02-14"
          }
        }, {
          "LSL": {
            "_from": "1980-01-22"
          }
        }],
        "LT": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1992-10-01"
          }
        }, {
          "LTT": {
            "_from": "1992-10-01",
            "_to": "1993-06-25"
          }
        }, {
          "LTL": {
            "_from": "1993-06-25",
            "_to": "2014-12-31"
          }
        }, {
          "EUR": {
            "_from": "2015-01-01"
          }
        }],
        "LU": [{
          "LUF": {
            "_from": "1944-09-04",
            "_to": "2002-02-28"
          }
        }, {
          "LUC": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "LUL": {
            "_tender": "false",
            "_from": "1970-01-01",
            "_to": "1990-03-05"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "LV": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1992-07-20"
          }
        }, {
          "LVR": {
            "_from": "1992-05-07",
            "_to": "1993-10-17"
          }
        }, {
          "LVL": {
            "_from": "1993-06-28",
            "_to": "2013-12-31"
          }
        }, {
          "EUR": {
            "_from": "2014-01-01"
          }
        }],
        "LY": [{
          "LYD": {
            "_from": "1971-09-01"
          }
        }],
        "MA": [{
          "MAF": {
            "_from": "1881-01-01",
            "_to": "1959-10-17"
          }
        }, {
          "MAD": {
            "_from": "1959-10-17"
          }
        }],
        "MC": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "MCF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "MD": [{
          "MDC": {
            "_from": "1992-06-01",
            "_to": "1993-11-29"
          }
        }, {
          "MDL": {
            "_from": "1993-11-29"
          }
        }],
        "ME": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }, {
          "DEM": {
            "_from": "1999-10-02",
            "_to": "2002-05-15"
          }
        }, {
          "EUR": {
            "_from": "2002-01-01"
          }
        }],
        "MF": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "MG": [{
          "MGF": {
            "_from": "1963-07-01",
            "_to": "2004-12-31"
          }
        }, {
          "MGA": {
            "_from": "1983-11-01"
          }
        }],
        "MH": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "MK": [{
          "MKN": {
            "_from": "1992-04-26",
            "_to": "1993-05-20"
          }
        }, {
          "MKD": {
            "_from": "1993-05-20"
          }
        }],
        "ML": [{
          "XOF": {
            "_from": "1958-11-24",
            "_to": "1962-07-02"
          }
        }, {
          "MLF": {
            "_from": "1962-07-02",
            "_to": "1984-08-31"
          }
        }, {
          "XOF": {
            "_from": "1984-06-01"
          }
        }],
        "MM": [{
          "BUK": {
            "_from": "1952-07-01",
            "_to": "1989-06-18"
          }
        }, {
          "MMK": {
            "_from": "1989-06-18"
          }
        }],
        "MN": [{
          "MNT": {
            "_from": "1915-03-01"
          }
        }],
        "MO": [{
          "MOP": {
            "_from": "1901-01-01"
          }
        }],
        "MP": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "MQ": [{
          "FRF": {
            "_from": "1960-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "MR": [{
          "XOF": {
            "_from": "1958-11-28",
            "_to": "1973-06-29"
          }
        }, {
          "MRO": {
            "_from": "1973-06-29",
            "_to": "2018-06-30"
          }
        }, {
          "MRU": {
            "_from": "2018-01-01"
          }
        }],
        "MS": [{
          "XCD": {
            "_from": "1967-02-27"
          }
        }],
        "MT": [{
          "MTP": {
            "_from": "1914-08-13",
            "_to": "1968-06-07"
          }
        }, {
          "MTL": {
            "_from": "1968-06-07",
            "_to": "2008-01-31"
          }
        }, {
          "EUR": {
            "_from": "2008-01-01"
          }
        }],
        "MU": [{
          "MUR": {
            "_from": "1934-04-01"
          }
        }],
        "MV": [{
          "MVP": {
            "_from": "1947-01-01",
            "_to": "1981-07-01"
          }
        }, {
          "MVR": {
            "_from": "1981-07-01"
          }
        }],
        "MW": [{
          "MWK": {
            "_from": "1971-02-15"
          }
        }],
        "MX": [{
          "MXV": {
            "_tender": "false"
          }
        }, {
          "MXP": {
            "_from": "1822-01-01",
            "_to": "1992-12-31"
          }
        }, {
          "MXN": {
            "_from": "1993-01-01"
          }
        }],
        "MY": [{
          "MYR": {
            "_from": "1963-09-16"
          }
        }],
        "MZ": [{
          "MZE": {
            "_from": "1975-06-25",
            "_to": "1980-06-16"
          }
        }, {
          "MZM": {
            "_from": "1980-06-16",
            "_to": "2006-12-31"
          }
        }, {
          "MZN": {
            "_from": "2006-07-01"
          }
        }],
        "NA": [{
          "ZAR": {
            "_from": "1961-02-14"
          }
        }, {
          "NAD": {
            "_from": "1993-01-01"
          }
        }],
        "NC": [{
          "XPF": {
            "_from": "1985-01-01"
          }
        }],
        "NE": [{
          "XOF": {
            "_from": "1958-12-19"
          }
        }],
        "NF": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "NG": [{
          "NGN": {
            "_from": "1973-01-01"
          }
        }],
        "NI": [{
          "NIC": {
            "_from": "1988-02-15",
            "_to": "1991-04-30"
          }
        }, {
          "NIO": {
            "_from": "1991-04-30"
          }
        }],
        "NL": [{
          "NLG": {
            "_from": "1813-01-01",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "NO": [{
          "SEK": {
            "_from": "1873-05-27",
            "_to": "1905-06-07"
          }
        }, {
          "NOK": {
            "_from": "1905-06-07"
          }
        }],
        "NP": [{
          "INR": {
            "_from": "1870-01-01",
            "_to": "1966-10-17"
          }
        }, {
          "NPR": {
            "_from": "1933-01-01"
          }
        }],
        "NR": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "NU": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "NZ": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "OM": [{
          "OMR": {
            "_from": "1972-11-11"
          }
        }],
        "PA": [{
          "PAB": {
            "_from": "1903-11-04"
          }
        }, {
          "USD": {
            "_from": "1903-11-18"
          }
        }],
        "PE": [{
          "PES": {
            "_from": "1863-02-14",
            "_to": "1985-02-01"
          }
        }, {
          "PEI": {
            "_from": "1985-02-01",
            "_to": "1991-07-01"
          }
        }, {
          "PEN": {
            "_from": "1991-07-01"
          }
        }],
        "PF": [{
          "XPF": {
            "_from": "1945-12-26"
          }
        }],
        "PG": [{
          "AUD": {
            "_from": "1966-02-14",
            "_to": "1975-09-16"
          }
        }, {
          "PGK": {
            "_from": "1975-09-16"
          }
        }],
        "PH": [{
          "PHP": {
            "_from": "1946-07-04"
          }
        }],
        "PK": [{
          "INR": {
            "_from": "1835-08-17",
            "_to": "1947-08-15"
          }
        }, {
          "PKR": {
            "_from": "1948-04-01"
          }
        }],
        "PL": [{
          "PLZ": {
            "_from": "1950-10-28",
            "_to": "1994-12-31"
          }
        }, {
          "PLN": {
            "_from": "1995-01-01"
          }
        }],
        "PM": [{
          "FRF": {
            "_from": "1972-12-21",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "PN": [{
          "NZD": {
            "_from": "1969-01-13"
          }
        }],
        "PR": [{
          "ESP": {
            "_from": "1800-01-01",
            "_to": "1898-12-10"
          }
        }, {
          "USD": {
            "_from": "1898-12-10"
          }
        }],
        "PS": [{
          "JOD": {
            "_from": "1950-07-01",
            "_to": "1967-06-01"
          }
        }, {
          "ILP": {
            "_from": "1967-06-01",
            "_to": "1980-02-22"
          }
        }, {
          "ILS": {
            "_from": "1985-09-04"
          }
        }, {
          "JOD": {
            "_from": "1996-02-12"
          }
        }],
        "PT": [{
          "PTE": {
            "_from": "1911-05-22",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "PW": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "PY": [{
          "PYG": {
            "_from": "1943-11-01"
          }
        }],
        "QA": [{
          "QAR": {
            "_from": "1973-05-19"
          }
        }],
        "RE": [{
          "FRF": {
            "_from": "1975-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "RO": [{
          "ROL": {
            "_from": "1952-01-28",
            "_to": "2006-12-31"
          }
        }, {
          "RON": {
            "_from": "2005-07-01"
          }
        }],
        "RS": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }, {
          "CSD": {
            "_from": "2002-05-15",
            "_to": "2006-10-25"
          }
        }, {
          "RSD": {
            "_from": "2006-10-25"
          }
        }],
        "RU": [{
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1998-12-31"
          }
        }, {
          "RUB": {
            "_from": "1999-01-01"
          }
        }],
        "RW": [{
          "RWF": {
            "_from": "1964-05-19"
          }
        }],
        "SA": [{
          "SAR": {
            "_from": "1952-10-22"
          }
        }],
        "SB": [{
          "AUD": {
            "_from": "1966-02-14",
            "_to": "1978-06-30"
          }
        }, {
          "SBD": {
            "_from": "1977-10-24"
          }
        }],
        "SC": [{
          "SCR": {
            "_from": "1903-11-01"
          }
        }],
        "SD": [{
          "EGP": {
            "_from": "1889-01-19",
            "_to": "1958-01-01"
          }
        }, {
          "GBP": {
            "_from": "1889-01-19",
            "_to": "1958-01-01"
          }
        }, {
          "SDP": {
            "_from": "1957-04-08",
            "_to": "1998-06-01"
          }
        }, {
          "SDD": {
            "_from": "1992-06-08",
            "_to": "2007-06-30"
          }
        }, {
          "SDG": {
            "_from": "2007-01-10"
          }
        }],
        "SE": [{
          "SEK": {
            "_from": "1873-05-27"
          }
        }],
        "SG": [{
          "MYR": {
            "_from": "1963-09-16",
            "_to": "1967-06-12"
          }
        }, {
          "SGD": {
            "_from": "1967-06-12"
          }
        }],
        "SH": [{
          "SHP": {
            "_from": "1917-02-15"
          }
        }],
        "SI": [{
          "SIT": {
            "_from": "1992-10-07",
            "_to": "2007-01-14"
          }
        }, {
          "EUR": {
            "_from": "2007-01-01"
          }
        }],
        "SJ": [{
          "NOK": {
            "_from": "1905-06-07"
          }
        }],
        "SK": [{
          "CSK": {
            "_from": "1953-06-01",
            "_to": "1992-12-31"
          }
        }, {
          "SKK": {
            "_from": "1992-12-31",
            "_to": "2009-01-01"
          }
        }, {
          "EUR": {
            "_from": "2009-01-01"
          }
        }],
        "SL": [{
          "GBP": {
            "_from": "1808-11-30",
            "_to": "1966-02-04"
          }
        }, {
          "SLL": {
            "_from": "1964-08-04"
          }
        }],
        "SM": [{
          "ITL": {
            "_from": "1865-12-23",
            "_to": "2001-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "SN": [{
          "XOF": {
            "_from": "1959-04-04"
          }
        }],
        "SO": [{
          "SOS": {
            "_from": "1960-07-01"
          }
        }],
        "SR": [{
          "NLG": {
            "_from": "1815-11-20",
            "_to": "1940-05-10"
          }
        }, {
          "SRG": {
            "_from": "1940-05-10",
            "_to": "2003-12-31"
          }
        }, {
          "SRD": {
            "_from": "2004-01-01"
          }
        }],
        "SS": [{
          "SDG": {
            "_from": "2007-01-10",
            "_to": "2011-09-01"
          }
        }, {
          "SSP": {
            "_from": "2011-07-18"
          }
        }],
        "ST": [{
          "STD": {
            "_from": "1977-09-08",
            "_to": "2017-12-31"
          }
        }, {
          "STN": {
            "_from": "2018-01-01"
          }
        }],
        "SU": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }],
        "SV": [{
          "SVC": {
            "_from": "1919-11-11",
            "_to": "2001-01-01"
          }
        }, {
          "USD": {
            "_from": "2001-01-01"
          }
        }],
        "SX": [{
          "ANG": {
            "_from": "2010-10-10"
          }
        }],
        "SY": [{
          "SYP": {
            "_from": "1948-01-01"
          }
        }],
        "SZ": [{
          "SZL": {
            "_from": "1974-09-06"
          }
        }],
        "TA": [{
          "GBP": {
            "_from": "1938-01-12"
          }
        }],
        "TC": [{
          "USD": {
            "_from": "1969-09-08"
          }
        }],
        "TD": [{
          "XAF": {
            "_from": "1993-01-01"
          }
        }],
        "TF": [{
          "FRF": {
            "_from": "1959-01-01",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "TG": [{
          "XOF": {
            "_from": "1958-11-28"
          }
        }],
        "TH": [{
          "THB": {
            "_from": "1928-04-15"
          }
        }],
        "TJ": [{
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1995-05-10"
          }
        }, {
          "TJR": {
            "_from": "1995-05-10",
            "_to": "2000-10-25"
          }
        }, {
          "TJS": {
            "_from": "2000-10-26"
          }
        }],
        "TK": [{
          "NZD": {
            "_from": "1967-07-10"
          }
        }],
        "TL": [{
          "TPE": {
            "_from": "1959-01-02",
            "_to": "2002-05-20"
          }
        }, {
          "IDR": {
            "_from": "1975-12-07",
            "_to": "2002-05-20"
          }
        }, {
          "USD": {
            "_from": "1999-10-20"
          }
        }],
        "TM": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1993-11-01"
          }
        }, {
          "TMM": {
            "_from": "1993-11-01",
            "_to": "2009-01-01"
          }
        }, {
          "TMT": {
            "_from": "2009-01-01"
          }
        }],
        "TN": [{
          "TND": {
            "_from": "1958-11-01"
          }
        }],
        "TO": [{
          "TOP": {
            "_from": "1966-02-14"
          }
        }],
        "TP": [{
          "TPE": {
            "_from": "1959-01-02",
            "_to": "2002-05-20"
          }
        }, {
          "IDR": {
            "_from": "1975-12-07",
            "_to": "2002-05-20"
          }
        }],
        "TR": [{
          "TRL": {
            "_from": "1922-11-01",
            "_to": "2005-12-31"
          }
        }, {
          "TRY": {
            "_from": "2005-01-01"
          }
        }],
        "TT": [{
          "TTD": {
            "_from": "1964-01-01"
          }
        }],
        "TV": [{
          "AUD": {
            "_from": "1966-02-14"
          }
        }],
        "TW": [{
          "TWD": {
            "_from": "1949-06-15"
          }
        }],
        "TZ": [{
          "TZS": {
            "_from": "1966-06-14"
          }
        }],
        "UA": [{
          "SUR": {
            "_from": "1961-01-01",
            "_to": "1991-12-25"
          }
        }, {
          "RUR": {
            "_from": "1991-12-25",
            "_to": "1992-11-13"
          }
        }, {
          "UAK": {
            "_from": "1992-11-13",
            "_to": "1993-10-17"
          }
        }, {
          "UAH": {
            "_from": "1996-09-02"
          }
        }],
        "UG": [{
          "UGS": {
            "_from": "1966-08-15",
            "_to": "1987-05-15"
          }
        }, {
          "UGX": {
            "_from": "1987-05-15"
          }
        }],
        "UM": [{
          "USD": {
            "_from": "1944-01-01"
          }
        }],
        "US": [{
          "USN": {
            "_tender": "false"
          }
        }, {
          "USS": {
            "_tender": "false",
            "_to": "2014-03-01"
          }
        }, {
          "USD": {
            "_from": "1792-01-01"
          }
        }],
        "UY": [{
          "UYI": {
            "_tender": "false"
          }
        }, {
          "UYW": {
            "_tender": "false"
          }
        }, {
          "UYP": {
            "_from": "1975-07-01",
            "_to": "1993-03-01"
          }
        }, {
          "UYU": {
            "_from": "1993-03-01"
          }
        }],
        "UZ": [{
          "UZS": {
            "_from": "1994-07-01"
          }
        }],
        "VA": [{
          "ITL": {
            "_from": "1870-10-19",
            "_to": "2002-02-28"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "VC": [{
          "XCD": {
            "_from": "1965-10-06"
          }
        }],
        "VE": [{
          "VEB": {
            "_from": "1871-05-11",
            "_to": "2008-06-30"
          }
        }, {
          "VEF": {
            "_from": "2008-01-01",
            "_to": "2018-08-20"
          }
        }, {
          "VES": {
            "_from": "2018-08-20"
          }
        }],
        "VG": [{
          "USD": {
            "_from": "1833-01-01"
          }
        }, {
          "GBP": {
            "_from": "1833-01-01",
            "_to": "1959-01-01"
          }
        }],
        "VI": [{
          "USD": {
            "_from": "1837-01-01"
          }
        }],
        "VN": [{
          "VNN": {
            "_from": "1978-05-03",
            "_to": "1985-09-14"
          }
        }, {
          "VND": {
            "_from": "1985-09-14"
          }
        }],
        "VU": [{
          "VUV": {
            "_from": "1981-01-01"
          }
        }],
        "WF": [{
          "XPF": {
            "_from": "1961-07-30"
          }
        }],
        "WS": [{
          "WST": {
            "_from": "1967-07-10"
          }
        }],
        "XK": [{
          "YUM": {
            "_from": "1994-01-24",
            "_to": "1999-09-30"
          }
        }, {
          "DEM": {
            "_from": "1999-09-01",
            "_to": "2002-03-09"
          }
        }, {
          "EUR": {
            "_from": "2002-01-01"
          }
        }],
        "YD": [{
          "YDD": {
            "_from": "1965-04-01",
            "_to": "1996-01-01"
          }
        }],
        "YE": [{
          "YER": {
            "_from": "1990-05-22"
          }
        }],
        "YT": [{
          "KMF": {
            "_from": "1975-01-01",
            "_to": "1976-02-23"
          }
        }, {
          "FRF": {
            "_from": "1976-02-23",
            "_to": "2002-02-17"
          }
        }, {
          "EUR": {
            "_from": "1999-01-01"
          }
        }],
        "YU": [{
          "YUD": {
            "_from": "1966-01-01",
            "_to": "1990-01-01"
          }
        }, {
          "YUN": {
            "_from": "1990-01-01",
            "_to": "1992-07-24"
          }
        }, {
          "YUM": {
            "_from": "1994-01-24",
            "_to": "2002-05-15"
          }
        }],
        "ZA": [{
          "ZAR": {
            "_from": "1961-02-14"
          }
        }, {
          "ZAL": {
            "_tender": "false",
            "_from": "1985-09-01",
            "_to": "1995-03-13"
          }
        }],
        "ZM": [{
          "ZMK": {
            "_from": "1968-01-16",
            "_to": "2013-01-01"
          }
        }, {
          "ZMW": {
            "_from": "2013-01-01"
          }
        }],
        "ZR": [{
          "ZRZ": {
            "_from": "1971-10-27",
            "_to": "1993-11-01"
          }
        }, {
          "ZRN": {
            "_from": "1993-11-01",
            "_to": "1998-07-31"
          }
        }],
        "ZW": [{
          "RHD": {
            "_from": "1970-02-17",
            "_to": "1980-04-18"
          }
        }, {
          "ZWD": {
            "_from": "1980-04-18",
            "_to": "2008-08-01"
          }
        }, {
          "ZWR": {
            "_from": "2008-08-01",
            "_to": "2009-02-02"
          }
        }, {
          "ZWL": {
            "_from": "2009-02-02",
            "_to": "2009-04-12"
          }
        }, {
          "USD": {
            "_from": "2009-04-12"
          }
        }],
        "ZZ": [{
          "XAG": {
            "_tender": "false"
          }
        }, {
          "XAU": {
            "_tender": "false"
          }
        }, {
          "XBA": {
            "_tender": "false"
          }
        }, {
          "XBB": {
            "_tender": "false"
          }
        }, {
          "XBC": {
            "_tender": "false"
          }
        }, {
          "XBD": {
            "_tender": "false"
          }
        }, {
          "XDR": {
            "_tender": "false"
          }
        }, {
          "XPD": {
            "_tender": "false"
          }
        }, {
          "XPT": {
            "_tender": "false"
          }
        }, {
          "XSU": {
            "_tender": "false"
          }
        }, {
          "XTS": {
            "_tender": "false"
          }
        }, {
          "XUA": {
            "_tender": "false"
          }
        }, {
          "XXX": {
            "_tender": "false"
          }
        }, {
          "XRE": {
            "_tender": "false",
            "_to": "1999-11-30"
          }
        }, {
          "XFU": {
            "_tender": "false",
            "_to": "2013-11-30"
          }
        }, {
          "XFO": {
            "_tender": "false",
            "_from": "1930-01-01",
            "_to": "2003-04-01"
          }
        }]
      }
    },
    "numberingSystems": {
      "adlm": {
        "_digits": "",
        "_type": "numeric"
      },
      "ahom": {
        "_digits": "",
        "_type": "numeric"
      },
      "arab": {
        "_digits": "",
        "_type": "numeric"
      },
      "arabext": {
        "_digits": "",
        "_type": "numeric"
      },
      "armn": {
        "_rules": "armenian-upper",
        "_type": "algorithmic"
      },
      "armnlow": {
        "_rules": "armenian-lower",
        "_type": "algorithmic"
      },
      "bali": {
        "_digits": "",
        "_type": "numeric"
      },
      "beng": {
        "_digits": "",
        "_type": "numeric"
      },
      "bhks": {
        "_digits": "",
        "_type": "numeric"
      },
      "brah": {
        "_digits": "",
        "_type": "numeric"
      },
      "cakm": {
        "_digits": "",
        "_type": "numeric"
      },
      "cham": {
        "_digits": "",
        "_type": "numeric"
      },
      "cyrl": {
        "_rules": "cyrillic-lower",
        "_type": "algorithmic"
      },
      "deva": {
        "_digits": "",
        "_type": "numeric"
      },
      "ethi": {
        "_rules": "ethiopic",
        "_type": "algorithmic"
      },
      "fullwide": {
        "_digits": "",
        "_type": "numeric"
      },
      "geor": {
        "_rules": "georgian",
        "_type": "algorithmic"
      },
      "gong": {
        "_digits": "",
        "_type": "numeric"
      },
      "gonm": {
        "_digits": "",
        "_type": "numeric"
      },
      "grek": {
        "_rules": "greek-upper",
        "_type": "algorithmic"
      },
      "greklow": {
        "_rules": "greek-lower",
        "_type": "algorithmic"
      },
      "gujr": {
        "_digits": "",
        "_type": "numeric"
      },
      "guru": {
        "_digits": "",
        "_type": "numeric"
      },
      "hanidays": {
        "_rules": "zh/SpelloutRules/spellout-numbering-days",
        "_type": "algorithmic"
      },
      "hanidec": {
        "_digits": "",
        "_type": "numeric"
      },
      "hans": {
        "_rules": "zh/SpelloutRules/spellout-cardinal",
        "_type": "algorithmic"
      },
      "hansfin": {
        "_rules": "zh/SpelloutRules/spellout-cardinal-financial",
        "_type": "algorithmic"
      },
      "hant": {
        "_rules": "zh_Hant/SpelloutRules/spellout-cardinal",
        "_type": "algorithmic"
      },
      "hantfin": {
        "_rules": "zh_Hant/SpelloutRules/spellout-cardinal-financial",
        "_type": "algorithmic"
      },
      "hebr": {
        "_rules": "hebrew",
        "_type": "algorithmic"
      },
      "hmng": {
        "_digits": "",
        "_type": "numeric"
      },
      "hmnp": {
        "_digits": "",
        "_type": "numeric"
      },
      "java": {
        "_digits": "",
        "_type": "numeric"
      },
      "jpan": {
        "_rules": "ja/SpelloutRules/spellout-cardinal",
        "_type": "algorithmic"
      },
      "jpanfin": {
        "_rules": "ja/SpelloutRules/spellout-cardinal-financial",
        "_type": "algorithmic"
      },
      "jpanyear": {
        "_rules": "ja/SpelloutRules/spellout-numbering-year-latn",
        "_type": "algorithmic"
      },
      "kali": {
        "_digits": "",
        "_type": "numeric"
      },
      "khmr": {
        "_digits": "",
        "_type": "numeric"
      },
      "knda": {
        "_digits": "",
        "_type": "numeric"
      },
      "lana": {
        "_digits": "",
        "_type": "numeric"
      },
      "lanatham": {
        "_digits": "",
        "_type": "numeric"
      },
      "laoo": {
        "_digits": "",
        "_type": "numeric"
      },
      "latn": {
        "_digits": "0123456789",
        "_type": "numeric"
      },
      "lepc": {
        "_digits": "",
        "_type": "numeric"
      },
      "limb": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathbold": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathdbl": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathmono": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathsanb": {
        "_digits": "",
        "_type": "numeric"
      },
      "mathsans": {
        "_digits": "",
        "_type": "numeric"
      },
      "mlym": {
        "_digits": "",
        "_type": "numeric"
      },
      "modi": {
        "_digits": "",
        "_type": "numeric"
      },
      "mong": {
        "_digits": "",
        "_type": "numeric"
      },
      "mroo": {
        "_digits": "",
        "_type": "numeric"
      },
      "mtei": {
        "_digits": "",
        "_type": "numeric"
      },
      "mymr": {
        "_digits": "",
        "_type": "numeric"
      },
      "mymrshan": {
        "_digits": "",
        "_type": "numeric"
      },
      "mymrtlng": {
        "_digits": "",
        "_type": "numeric"
      },
      "newa": {
        "_digits": "",
        "_type": "numeric"
      },
      "nkoo": {
        "_digits": "",
        "_type": "numeric"
      },
      "olck": {
        "_digits": "",
        "_type": "numeric"
      },
      "orya": {
        "_digits": "",
        "_type": "numeric"
      },
      "osma": {
        "_digits": "",
        "_type": "numeric"
      },
      "rohg": {
        "_digits": "",
        "_type": "numeric"
      },
      "roman": {
        "_rules": "roman-upper",
        "_type": "algorithmic"
      },
      "romanlow": {
        "_rules": "roman-lower",
        "_type": "algorithmic"
      },
      "saur": {
        "_digits": "",
        "_type": "numeric"
      },
      "shrd": {
        "_digits": "",
        "_type": "numeric"
      },
      "sind": {
        "_digits": "",
        "_type": "numeric"
      },
      "sinh": {
        "_digits": "",
        "_type": "numeric"
      },
      "sora": {
        "_digits": "",
        "_type": "numeric"
      },
      "sund": {
        "_digits": "",
        "_type": "numeric"
      },
      "takr": {
        "_digits": "",
        "_type": "numeric"
      },
      "talu": {
        "_digits": "",
        "_type": "numeric"
      },
      "taml": {
        "_rules": "tamil",
        "_type": "algorithmic"
      },
      "tamldec": {
        "_digits": "",
        "_type": "numeric"
      },
      "telu": {
        "_digits": "",
        "_type": "numeric"
      },
      "thai": {
        "_digits": "",
        "_type": "numeric"
      },
      "tibt": {
        "_digits": "",
        "_type": "numeric"
      },
      "tirh": {
        "_digits": "",
        "_type": "numeric"
      },
      "vaii": {
        "_digits": "",
        "_type": "numeric"
      },
      "wara": {
        "_digits": "",
        "_type": "numeric"
      },
      "wcho": {
        "_digits": "",
        "_type": "numeric"
      }
    }
  }
};
exports.supplementalCldr = supplementalCldr;

/***/ }),

/***/ 91331:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _parent_locales = _interopRequireDefault(__webpack_require__(73806));
var _parentLocale = _interopRequireDefault(__webpack_require__(49198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DEFAULT_LOCALE = 'en';
var _default = (0, _dependency_injector.default)({
  locale: function () {
    var currentLocale = DEFAULT_LOCALE;
    return function (locale) {
      if (!locale) {
        return currentLocale;
      }
      currentLocale = locale;
    };
  }(),
  getValueByClosestLocale: function getValueByClosestLocale(getter) {
    var locale = this.locale();
    var value = getter(locale);
    var isRootLocale;
    while (!value && !isRootLocale) {
      locale = (0, _parentLocale.default)(_parent_locales.default, locale);
      if (locale) {
        value = getter(locale);
      } else {
        isRootLocale = true;
      }
    }
    if (value === undefined && locale !== DEFAULT_LOCALE) {
      return getter(DEFAULT_LOCALE);
    }
    return value;
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 89740:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _default = {
  _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
    if (format === 'currency') {
      formatConfig.precision = formatConfig.precision || 0;
      var result = this.format(value, (0, _extend.extend)({}, formatConfig, {
        type: 'fixedpoint'
      }));
      var currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, '$$$$');
      result = result.replace(/^(\D*)(\d.*)/, '$1' + currencyPart + '$2');
      return result;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function getCurrencySymbol() {
    return {
      symbol: '$'
    };
  },
  getOpenXmlCurrencyFormat: function getOpenXmlCurrencyFormat() {
    return '$#,##0{0}_);\\($#,##0{0}\\)';
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 91500:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _date = __webpack_require__(40594);
var _date2 = __webpack_require__(59937);
var _date3 = __webpack_require__(2892);
var _default_date_names = _interopRequireDefault(__webpack_require__(15564));
var _first_day_of_week_data = _interopRequireDefault(__webpack_require__(92286));
var _core = _interopRequireDefault(__webpack_require__(91331));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _date4 = _interopRequireDefault(__webpack_require__(13024));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DEFAULT_DAY_OF_WEEK_INDEX = 0;
var hasIntl = typeof Intl !== 'undefined';
var FORMATS_TO_PATTERN_MAP = {
  'shortdate': 'M/d/y',
  'shorttime': 'h:mm a',
  'longdate': 'EEEE, MMMM d, y',
  'longtime': 'h:mm:ss a',
  'monthandday': 'MMMM d',
  'monthandyear': 'MMMM y',
  'quarterandyear': 'QQQ y',
  'day': 'd',
  'year': 'y',
  'shortdateshorttime': 'M/d/y, h:mm a',
  'longdatelongtime': 'EEEE, MMMM d, y, h:mm:ss a',
  'month': 'LLLL',
  'shortyear': 'yy',
  'dayofweek': 'EEEE',
  'quarter': 'QQQ',
  'hour': 'HH',
  'minute': 'mm',
  'second': 'ss',
  'millisecond': 'SSS',
  'datetime-local': 'yyyy-MM-ddTHH\':\'mm\':\'ss'
};
var possiblePartPatterns = {
  year: ['y', 'yy', 'yyyy'],
  day: ['d', 'dd'],
  month: ['M', 'MM', 'MMM', 'MMMM'],
  hours: ['H', 'HH', 'h', 'hh', 'ah'],
  minutes: ['m', 'mm'],
  seconds: ['s', 'ss'],
  milliseconds: ['S', 'SS', 'SSS']
};
var dateLocalization = (0, _dependency_injector.default)({
  engine: function engine() {
    return 'base';
  },
  _getPatternByFormat: function _getPatternByFormat(format) {
    return FORMATS_TO_PATTERN_MAP[format.toLowerCase()];
  },
  _expandPattern: function _expandPattern(pattern) {
    return this._getPatternByFormat(pattern) || pattern;
  },
  formatUsesMonthName: function formatUsesMonthName(format) {
    return this._expandPattern(format).indexOf('MMMM') !== -1;
  },
  formatUsesDayName: function formatUsesDayName(format) {
    return this._expandPattern(format).indexOf('EEEE') !== -1;
  },
  getFormatParts: function getFormatParts(format) {
    var pattern = this._getPatternByFormat(format) || format;
    var result = [];
    (0, _iterator.each)(pattern.split(/\W+/), function (_, formatPart) {
      (0, _iterator.each)(possiblePartPatterns, function (partName, possiblePatterns) {
        if (possiblePatterns.includes(formatPart)) {
          result.push(partName);
        }
      });
    });
    return result;
  },
  getMonthNames: function getMonthNames(format) {
    return _default_date_names.default.getMonthNames(format);
  },
  getDayNames: function getDayNames(format) {
    return _default_date_names.default.getDayNames(format);
  },
  getQuarterNames: function getQuarterNames(format) {
    return _default_date_names.default.getQuarterNames(format);
  },
  getPeriodNames: function getPeriodNames(format) {
    return _default_date_names.default.getPeriodNames(format);
  },
  getTimeSeparator: function getTimeSeparator() {
    return ':';
  },
  is24HourFormat: function is24HourFormat(format) {
    var amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
    var pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
    var amTimeFormatted = this.format(amTime, format);
    var pmTimeFormatted = this.format(pmTime, format);
    for (var i = 0; i < amTimeFormatted.length; i++) {
      if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
        return !isNaN(parseInt(amTimeFormatted[i]));
      }
    }
  },
  format: function format(date, _format) {
    if (!date) {
      return;
    }
    if (!_format) {
      return date;
    }
    var formatter;
    if (typeof _format === 'function') {
      formatter = _format;
    } else if (_format.formatter) {
      formatter = _format.formatter;
    } else {
      _format = _format.type || _format;
      if ((0, _type.isString)(_format)) {
        _format = FORMATS_TO_PATTERN_MAP[_format.toLowerCase()] || _format;
        return _number.default.convertDigits((0, _date.getFormatter)(_format, this)(date));
      }
    }
    if (!formatter) {
      // TODO: log warning or error
      return;
    }
    return formatter(date);
  },
  parse: function parse(text, format) {
    var that = this;
    var ldmlFormat;
    var formatter;
    if (!text) {
      return;
    }
    if (!format) {
      return this.parse(text, 'shortdate');
    }
    if (format.parser) {
      return format.parser(text);
    }
    if (typeof format === 'string' && !FORMATS_TO_PATTERN_MAP[format.toLowerCase()]) {
      ldmlFormat = format;
    } else {
      formatter = function formatter(value) {
        var text = that.format(value, format);
        return _number.default.convertDigits(text, true);
      };
      try {
        ldmlFormat = (0, _date2.getFormat)(formatter);
      } catch (e) {}
    }
    if (ldmlFormat) {
      text = _number.default.convertDigits(text, true);
      return (0, _date3.getParser)(ldmlFormat, this)(text);
    }
    _errors.default.log('W0012');
    var result = new Date(text);
    if (!result || isNaN(result.getTime())) {
      return;
    }
    return result;
  },
  firstDayOfWeekIndex: function firstDayOfWeekIndex() {
    var index = _core.default.getValueByClosestLocale(function (locale) {
      return _first_day_of_week_data.default[locale];
    });
    return index === undefined ? DEFAULT_DAY_OF_WEEK_INDEX : index;
  }
});
if (hasIntl) {
  dateLocalization.inject(_date4.default);
}
var _default = dateLocalization;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 15564:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var DAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var PERIODS = ['AM', 'PM'];
var QUARTERS = ['Q1', 'Q2', 'Q3', 'Q4'];

// TODO: optimize
var cutCaptions = function cutCaptions(captions, format) {
  var lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return (0, _iterator.map)(captions, function (caption) {
    return caption.substr(0, lengthByFormat[format]);
  });
};
var _default = {
  getMonthNames: function getMonthNames(format) {
    return cutCaptions(MONTHS, format);
  },
  getDayNames: function getDayNames(format) {
    return cutCaptions(DAYS, format);
  },
  getQuarterNames: function getQuarterNames(format) {
    return QUARTERS;
  },
  getPeriodNames: function getPeriodNames(format) {
    return PERIODS;
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18121:
/***/ (function(__unused_webpack_module, exports) {



exports.defaultMessages = void 0;
/* eslint-disable node/no-unsupported-features/es-syntax */
// !!! AUTO-GENERATED FILE, DO NOT EDIT
var defaultMessages = {
  "en": {
    "Yes": "Yes",
    "No": "No",
    "Cancel": "Cancel",
    "Close": "Close",
    "Clear": "Clear",
    "Done": "Done",
    "Loading": "Loading...",
    "Select": "Select...",
    "Search": "Search",
    "Back": "Back",
    "OK": "OK",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxDateRangeBox-invalidStartDateMessage": "Start value must be a date",
    "dxDateRangeBox-invalidEndDateMessage": "End value must be a date",
    "dxDateRangeBox-startDateOutOfRangeMessage": "Start date is out of range",
    "dxDateRangeBox-endDateOutOfRangeMessage": "End date is out of range",
    "dxDateRangeBox-startDateLabel": "Start Date",
    "dxDateRangeBox-endDateLabel": "End Date",
    "dxFileUploader-selectFile": "Select a file",
    "dxFileUploader-dropFile": "or Drop a file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "kb",
    "dxFileUploader-Mb": "Mb",
    "dxFileUploader-Gb": "Gb",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-emptyHeaderWithColumnChooserText": "Use {0} to display columns",
    "dxDataGrid-emptyHeaderWithGroupPanelText": "Drag a column from the group panel here",
    "dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText": "Use {0} or drag a column from the group panel",
    "dxDataGrid-emptyHeaderColumnChooserText": "column chooser",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-ariaSearchBox": "Search box",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-ariaNotSortedColumn": "Not sorted column",
    "dxDataGrid-ariaSortedAscendingColumn": "Column sorted in ascending order",
    "dxDataGrid-ariaSortedDescendingColumn": "Column sorted in descending order",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Fix",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "To the left",
    "dxDataGrid-columnFixingRightPosition": "To the right",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows to {0}",
    "dxDataGrid-exportAll": "Export all data to {0}",
    "dxDataGrid-headerFilterLabel": "Filter options",
    "dxDataGrid-headerFilterIndicatorLabel": "Show filter options for column '{0}'",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaCollapsedRow": "Collapsed row",
    "dxDataGrid-ariaExpandedRow": "Expanded row",
    "dxDataGrid-ariaDataGrid": "Data grid with {0} rows and {1} columns",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-ariaEditForm": "Edit form",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxTreeList-ariaTreeList": "Tree list",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSize": "Items per page: {0}",
    "dxPager-pageSizesAllText": "All",
    "dxPager-page": "Page {0}",
    "dxPager-prevPage": "Previous Page",
    "dxPager-nextPage": "Next Page",
    "dxPager-ariaLabel": "Page Navigation",
    "dxPager-ariaPageSize": "Page size",
    "dxPager-ariaPageNumber": "Page number",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": "Sort \"{0}\" by This Column",
    "dxPivotGrid-sortRowBySummary": "Sort \"{0}\" by This Row",
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxCalendar-ariaHotKeysInfo": "To navigate between views, press Control, and then Left Arrow or Right Arrow. To zoom in on a view, press Control, and then Down Arrow. To zoom out, press Control, and then Up Arrow.",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-dialogUpdateImageCaption": "Update Image",
    "dxHtmlEditor-dialogImageUpdateButton": "Update",
    "dxHtmlEditor-dialogImageAddButton": "Add",
    "dxHtmlEditor-dialogImageSpecifyUrl": "From the Web",
    "dxHtmlEditor-dialogImageSelectFile": "From This Device",
    "dxHtmlEditor-dialogImageKeepAspectRatio": "Keep Aspect Ratio",
    "dxHtmlEditor-dialogImageEncodeToBase64": "Encode to Base64",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertHeaderRow": "Insert Header Row",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-cellProperties": "Cell Properties",
    "dxHtmlEditor-tableProperties": "Table Properties",
    "dxHtmlEditor-insert": "Insert",
    "dxHtmlEditor-delete": "Delete",
    "dxHtmlEditor-border": "Border",
    "dxHtmlEditor-style": "Style",
    "dxHtmlEditor-width": "Width",
    "dxHtmlEditor-height": "Height",
    "dxHtmlEditor-borderColor": "Color",
    "dxHtmlEditor-tableBackground": "Background",
    "dxHtmlEditor-dimensions": "Dimensions",
    "dxHtmlEditor-alignment": "Alignment",
    "dxHtmlEditor-horizontal": "Horizontal",
    "dxHtmlEditor-vertical": "Vertical",
    "dxHtmlEditor-paddingVertical": "Vertical Padding",
    "dxHtmlEditor-paddingHorizontal": "Horizontal Padding",
    "dxHtmlEditor-pixels": "Pixels",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-editingDownloadSingleItemErrorMessage": "Item was not downloaded",
    "dxFileManager-editingDownloadMultipleItemsErrorMessage": "{0} items were not downloaded",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-dialogConstraintCriticalViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. How would you like to proceed?",
    "dxGantt-dialogDeleteDependenciesMessage": "Delete the dependency relations",
    "dxGantt-dialogMoveTaskAndKeepDependenciesMessage": "Move the task and keep the dependencies",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}",
    "dxGantt-sortingAscendingText": "Sort Ascending",
    "dxGantt-sortingDescendingText": "Sort Descending",
    "dxGantt-sortingClearText": "Clear Sorting",
    "dxGantt-showResources": "Show Resources",
    "dxGantt-showDependencies": "Show Dependencies",
    "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
    "dxGantt-dialogEndDateValidation": "End date must be after {0}"
  }
};
exports.defaultMessages = defaultMessages;

/***/ }),

/***/ 74872:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _core = _interopRequireDefault(__webpack_require__(91331));
var _en = __webpack_require__(35608);
var _supplemental = __webpack_require__(57421);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

if (_globalize.default && _globalize.default.load) {
  if (!_globalize.default.locale()) {
    _globalize.default.load(_en.enCldr, _supplemental.supplementalCldr);
    _globalize.default.locale('en');
  }
  _core.default.inject({
    locale: function locale(_locale) {
      if (!_locale) {
        return _globalize.default.locale().locale;
      }
      _globalize.default.locale(_locale);
    }
  });
}

/***/ }),

/***/ 7239:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _open_xml_currency_format = _interopRequireDefault(__webpack_require__(44592));
__webpack_require__(74872);
__webpack_require__(908);
__webpack_require__(89740);
__webpack_require__(71272);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _config = _interopRequireDefault(__webpack_require__(80209));
var _number2 = _interopRequireDefault(__webpack_require__(18016));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports, import/no-unresolved

// eslint-disable-next-line no-restricted-imports

var CURRENCY_STYLES = ['symbol', 'accounting'];
if (_globalize.default && _globalize.default.formatCurrency) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.locale('en');
  }
  var formattersCache = {};
  var getFormatter = function getFormatter(currency, format) {
    var formatter;
    var formatCacheKey;
    if (typeof format === 'object') {
      formatCacheKey = _globalize.default.locale().locale + ':' + currency + ':' + JSON.stringify(format);
    } else {
      formatCacheKey = _globalize.default.locale().locale + ':' + currency + ':' + format;
    }
    formatter = formattersCache[formatCacheKey];
    if (!formatter) {
      formatter = formattersCache[formatCacheKey] = _globalize.default.currencyFormatter(currency, format);
    }
    return formatter;
  };
  var globalizeCurrencyLocalization = {
    _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
      if (format === 'currency') {
        var currency = formatConfig && formatConfig.currency || (0, _config.default)().defaultCurrency;
        return getFormatter(currency, this._normalizeFormatConfig(format, formatConfig, value))(value);
      }
      return this.callBase.apply(this, arguments);
    },
    _normalizeFormatConfig: function _normalizeFormatConfig(format, formatConfig, value) {
      var normalizedConfig = this.callBase(format, formatConfig, value);
      if (format === 'currency') {
        var _formatConfig$useCurr;
        var useAccountingStyle = (_formatConfig$useCurr = formatConfig.useCurrencyAccountingStyle) !== null && _formatConfig$useCurr !== void 0 ? _formatConfig$useCurr : (0, _config.default)().defaultUseCurrencyAccountingStyle;
        normalizedConfig.style = CURRENCY_STYLES[+useAccountingStyle];
      }
      return normalizedConfig;
    },
    format: function format(value, _format) {
      if (typeof value !== 'number') {
        return value;
      }
      _format = this._normalizeFormat(_format);
      if (_format) {
        if (_format.currency === 'default') {
          _format.currency = (0, _config.default)().defaultCurrency;
        }
        if (_format.type === 'currency') {
          return this._formatNumber(value, this._parseNumberFormatString('currency'), _format);
        } else if (!_format.type && _format.currency) {
          return getFormatter(_format.currency, _format)(value);
        }
      }
      return this.callBase.apply(this, arguments);
    },
    getCurrencySymbol: function getCurrencySymbol(currency) {
      if (!currency) {
        currency = (0, _config.default)().defaultCurrency;
      }
      return _globalize.default.cldr.main('numbers/currencies/' + currency);
    },
    getOpenXmlCurrencyFormat: function getOpenXmlCurrencyFormat(currency) {
      var currencySymbol = this.getCurrencySymbol(currency).symbol;
      var accountingFormat = _globalize.default.cldr.main('numbers/currencyFormats-numberSystem-latn').accounting;
      return (0, _open_xml_currency_format.default)(currencySymbol, accountingFormat);
    }
  };
  _number2.default.inject(globalizeCurrencyLocalization);
}

/***/ }),

/***/ 60316:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(74872);
__webpack_require__(908);
__webpack_require__(71272);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _date2 = _interopRequireDefault(__webpack_require__(91500));
var _type = __webpack_require__(35922);
var iteratorUtils = _interopRequireWildcard(__webpack_require__(95479));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports, import/no-unresolved

var ACCEPTABLE_JSON_FORMAT_PROPERTIES = ['skeleton', 'date', 'time', 'datetime', 'raw'];
var RTL_MARKS_REGEX = /[\u200E\u200F]/g;

// eslint-disable-next-line no-restricted-imports

if (_globalize.default && _globalize.default.formatDate) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.locale('en');
  }
  var formattersCache = {};
  var FORMATS_TO_GLOBALIZE_MAP = {
    'shortdate': {
      path: 'dateTimeFormats/availableFormats/yMd'
    },
    'shorttime': {
      path: 'timeFormats/short'
    },
    'longdate': {
      path: 'dateFormats/full'
    },
    'longtime': {
      path: 'timeFormats/medium'
    },
    'monthandday': {
      path: 'dateTimeFormats/availableFormats/MMMMd'
    },
    'monthandyear': {
      path: 'dateTimeFormats/availableFormats/yMMMM'
    },
    'quarterandyear': {
      path: 'dateTimeFormats/availableFormats/yQQQ'
    },
    'day': {
      path: 'dateTimeFormats/availableFormats/d'
    },
    'year': {
      path: 'dateTimeFormats/availableFormats/y'
    },
    'shortdateshorttime': {
      path: 'dateTimeFormats/short',
      parts: ['shorttime', 'shortdate']
    },
    'longdatelongtime': {
      path: 'dateTimeFormats/medium',
      parts: ['longtime', 'longdate']
    },
    'month': {
      pattern: 'LLLL'
    },
    'shortyear': {
      pattern: 'yy'
    },
    'dayofweek': {
      pattern: 'EEEE'
    },
    'quarter': {
      pattern: 'QQQ'
    },
    'millisecond': {
      pattern: 'SSS'
    },
    'hour': {
      pattern: 'HH'
    },
    'minute': {
      pattern: 'mm'
    },
    'second': {
      pattern: 'ss'
    }
  };
  var globalizeDateLocalization = {
    engine: function engine() {
      return 'globalize';
    },
    _getPatternByFormat: function _getPatternByFormat(format) {
      var that = this;
      var lowerFormat = format.toLowerCase();
      var globalizeFormat = FORMATS_TO_GLOBALIZE_MAP[lowerFormat];
      if (lowerFormat === 'datetime-local') {
        return 'yyyy-MM-ddTHH\':\'mm\':\'ss';
      }
      if (!globalizeFormat) {
        return;
      }
      var result = globalizeFormat.path && that._getFormatStringByPath(globalizeFormat.path) || globalizeFormat.pattern;
      if (globalizeFormat.parts) {
        iteratorUtils.each(globalizeFormat.parts, function (index, part) {
          result = result.replace('{' + index + '}', that._getPatternByFormat(part));
        });
      }
      return result;
    },
    _getFormatStringByPath: function _getFormatStringByPath(path) {
      return _globalize.default.locale().main('dates/calendars/gregorian/' + path);
    },
    getPeriodNames: function getPeriodNames(format, type) {
      format = format || 'wide';
      type = type === 'format' ? type : 'stand-alone';
      var json = _globalize.default.locale().main("dates/calendars/gregorian/dayPeriods/".concat(type, "/").concat(format));
      return [json['am'], json['pm']];
    },
    getMonthNames: function getMonthNames(format, type) {
      var months = _globalize.default.locale().main('dates/calendars/gregorian/months/' + (type === 'format' ? type : 'stand-alone') + '/' + (format || 'wide'));
      return iteratorUtils.map(months, function (month) {
        return month;
      });
    },
    getDayNames: function getDayNames(format) {
      var days = _globalize.default.locale().main('dates/calendars/gregorian/days/stand-alone/' + (format || 'wide'));
      return iteratorUtils.map(days, function (day) {
        return day;
      });
    },
    getTimeSeparator: function getTimeSeparator() {
      return _globalize.default.locale().main('numbers/symbols-numberSystem-latn/timeSeparator');
    },
    removeRtlMarks(text) {
      return text.replace(RTL_MARKS_REGEX, '');
    },
    format: function format(date, _format) {
      if (!date) {
        return;
      }
      if (!_format) {
        return date;
      }
      var formatter;
      var formatCacheKey;
      if (typeof _format === 'function') {
        return _format(date);
      }
      if (_format.formatter) {
        return _format.formatter(date);
      }
      _format = _format.type || _format;
      if (typeof _format === 'string') {
        formatCacheKey = _globalize.default.locale().locale + ':' + _format;
        formatter = formattersCache[formatCacheKey];
        if (!formatter) {
          _format = {
            raw: this._getPatternByFormat(_format) || _format
          };
          formatter = formattersCache[formatCacheKey] = _globalize.default.dateFormatter(_format);
        }
      } else {
        if (!this._isAcceptableFormat(_format)) {
          return;
        }
        formatter = _globalize.default.dateFormatter(_format);
      }
      return this.removeRtlMarks(formatter(date));
    },
    parse: function parse(text, format) {
      if (!text) {
        return;
      }
      if (!format || typeof format === 'function' || (0, _type.isObject)(format) && !this._isAcceptableFormat(format)) {
        if (format) {
          var parsedValue = this.callBase(text, format);
          if (parsedValue) {
            return parsedValue;
          }
        }
        return _globalize.default.parseDate(text);
      }
      if (format.parser) {
        return format.parser(text);
      }
      if (typeof format === 'string') {
        format = {
          raw: this._getPatternByFormat(format) || format
        };
      }
      var parsedDate = _globalize.default.parseDate(text, format);
      return parsedDate ? parsedDate : this.callBase(text, format);
    },
    _isAcceptableFormat: function _isAcceptableFormat(format) {
      if (format.parser) {
        return true;
      }
      for (var i = 0; i < ACCEPTABLE_JSON_FORMAT_PROPERTIES.length; i++) {
        if (Object.prototype.hasOwnProperty.call(format, ACCEPTABLE_JSON_FORMAT_PROPERTIES[i])) {
          return true;
        }
      }
    },
    firstDayOfWeekIndex: function firstDayOfWeekIndex() {
      var firstDay = _globalize.default.locale().supplemental.weekData.firstDay();
      return this._getDayKeys().indexOf(firstDay);
    },
    _getDayKeys: function _getDayKeys() {
      var days = _globalize.default.locale().main('dates/calendars/gregorian/days/format/short');
      return iteratorUtils.map(days, function (day, key) {
        return key;
      });
    }
  };
  _date2.default.resetInjection();
  _date2.default.inject(globalizeDateLocalization);
}

/***/ }),

/***/ 46949:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(74872);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _message = _interopRequireDefault(__webpack_require__(28109));
var _core2 = _interopRequireDefault(__webpack_require__(91331));
__webpack_require__(71272);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

// eslint-disable-next-line no-restricted-imports, import/no-unresolved

if (_globalize.default && _globalize.default.formatMessage) {
  var DEFAULT_LOCALE = 'en';
  var originalLoadMessages = _globalize.default.loadMessages;
  _globalize.default.loadMessages = function (messages) {
    _message.default.load(messages);
  };
  var globalizeMessageLocalization = {
    engine: function engine() {
      return 'globalize';
    },
    ctor: function ctor() {
      this.load(this._dictionary);
    },
    load: function load(messages) {
      this.callBase(messages);
      originalLoadMessages(messages);
    },
    getMessagesByLocales: function getMessagesByLocales() {
      return _globalize.default.cldr.get('globalize-messages');
    },
    getFormatter: function getFormatter(key, locale) {
      var currentLocale = locale || _core2.default.locale();
      var formatter = this._getFormatterBase(key, locale);
      if (!formatter) {
        formatter = this._formatterByGlobalize(key, locale);
      }
      if (!formatter && currentLocale !== DEFAULT_LOCALE) {
        formatter = this.getFormatter(key, DEFAULT_LOCALE);
      }
      return formatter;
    },
    _formatterByGlobalize: function _formatterByGlobalize(key, locale) {
      var currentGlobalize = !locale || locale === _core2.default.locale() ? _globalize.default : new _globalize.default(locale);
      var result;
      if (this._messageLoaded(key, locale)) {
        result = currentGlobalize.messageFormatter(key);
      }
      return result;
    },
    _messageLoaded: function _messageLoaded(key, locale) {
      var currentCldr = locale ? new _globalize.default(locale).cldr : _globalize.default.locale();
      var value = currentCldr.get(['globalize-messages/{bundle}', key]);
      return !!value;
    },
    _loadSingle: function _loadSingle(key, value, locale) {
      var data = {};
      data[locale] = {};
      data[locale][key] = value;
      this.load(data);
    }
  };
  _message.default.inject(globalizeMessageLocalization);
}

/***/ }),

/***/ 908:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



__webpack_require__(74872);
var _globalize = _interopRequireDefault(__webpack_require__(71272));
var _number = _interopRequireDefault(__webpack_require__(18016));
var _errors = _interopRequireDefault(__webpack_require__(17381));
__webpack_require__(71272);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// eslint-disable-next-line no-restricted-imports

// eslint-disable-next-line no-restricted-imports, import/no-unresolved

var MAX_FRACTION_DIGITS = 20;
if (_globalize.default && _globalize.default.formatNumber) {
  if (_globalize.default.locale().locale === 'en') {
    _globalize.default.locale('en');
  }
  var formattersCache = {};
  var getFormatter = function getFormatter(format) {
    var formatter;
    var formatCacheKey;
    if (typeof format === 'object') {
      formatCacheKey = _globalize.default.locale().locale + ':' + JSON.stringify(format);
    } else {
      formatCacheKey = _globalize.default.locale().locale + ':' + format;
    }
    formatter = formattersCache[formatCacheKey];
    if (!formatter) {
      formatter = formattersCache[formatCacheKey] = _globalize.default.numberFormatter(format);
    }
    return formatter;
  };
  var globalizeNumberLocalization = {
    engine: function engine() {
      return 'globalize';
    },
    _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
      if (format === 'exponential') {
        return this.callBase.apply(this, arguments);
      }
      return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value);
    },
    _normalizeFormatConfig: function _normalizeFormatConfig(format, formatConfig, value) {
      var config;
      if (format === 'decimal') {
        config = {
          minimumIntegerDigits: formatConfig.precision || 1,
          useGrouping: false,
          minimumFractionDigits: 0,
          maximumFractionDigits: MAX_FRACTION_DIGITS,
          round: value < 0 ? 'ceil' : 'floor'
        };
      } else {
        config = this._getPrecisionConfig(formatConfig.precision);
      }
      if (format === 'percent') {
        config.style = 'percent';
      }
      return config;
    },
    _getPrecisionConfig: function _getPrecisionConfig(precision) {
      var config;
      if (precision === null) {
        config = {
          minimumFractionDigits: 0,
          maximumFractionDigits: MAX_FRACTION_DIGITS
        };
      } else {
        config = {
          minimumFractionDigits: precision || 0,
          maximumFractionDigits: precision || 0
        };
      }
      return config;
    },
    format: function format(value, _format) {
      if (typeof value !== 'number') {
        return value;
      }
      _format = this._normalizeFormat(_format);
      if (!_format || typeof _format !== 'function' && !_format.type && !_format.formatter) {
        return getFormatter(_format)(value);
      }
      return this.callBase.apply(this, arguments);
    },
    parse: function parse(text, format) {
      if (!text) {
        return;
      }
      if (format && (format.parser || typeof format === 'string')) {
        return this.callBase.apply(this, arguments);
      }
      if (format) {
        // Current parser functionality provided as-is and is independent of the most of capabilities of formatter.
        _errors.default.log('W0011');
      }
      var result = _globalize.default.parseNumber(text);
      if (isNaN(result)) {
        result = this.callBase.apply(this, arguments);
      }
      return result;
    }
  };
  _number.default.resetInjection();
  _number.default.inject(globalizeNumberLocalization);
}

/***/ }),

/***/ 13024:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend = __webpack_require__(13306);
var _core = _interopRequireDefault(__webpack_require__(91331));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* globals Intl */

var SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
var NARROW_NO_BREAK_SPACE_REGEX = /[\u202F]/g;
var getIntlFormatter = function getIntlFormatter(format) {
  return function (date) {
    // NOTE: Intl in some browsers formates dates with timezone offset which was at the moment for this date.
    // But the method "new Date" creates date using current offset. So, we decided to format dates in the UTC timezone.
    if (!format.timeZoneName) {
      var year = date.getFullYear();
      // NOTE: new Date(99,0,1) will return 1999 year, but 99 expected
      var recognizableAsTwentyCentury = String(year).length < 3;
      var safeYearShift = 400;
      var temporaryYearValue = recognizableAsTwentyCentury ? year + safeYearShift : year;
      var utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      if (recognizableAsTwentyCentury) {
        utcDate.setFullYear(year);
      }
      var utcFormat = (0, _extend.extend)({
        timeZone: 'UTC'
      }, format);
      return formatDateTime(utcDate, utcFormat);
    }
    return formatDateTime(date, format);
  };
};
var formattersCache = {};
var getFormatter = function getFormatter(format) {
  var key = _core.default.locale() + '/' + JSON.stringify(format);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.DateTimeFormat(_core.default.locale(), format).format;
  }
  return formattersCache[key];
};
function formatDateTime(date, format) {
  return getFormatter(format)(date).replace(SYMBOLS_TO_REMOVE_REGEX, '').replace(NARROW_NO_BREAK_SPACE_REGEX, ' ');
}
var formatNumber = function formatNumber(number) {
  return new Intl.NumberFormat(_core.default.locale()).format(number);
};
var getAlternativeNumeralsMap = function () {
  var numeralsMapCache = {};
  return function (locale) {
    if (!(locale in numeralsMapCache)) {
      if (formatNumber(0) === '0') {
        numeralsMapCache[locale] = false;
        return false;
      }
      numeralsMapCache[locale] = {};
      for (var i = 0; i < 10; ++i) {
        numeralsMapCache[locale][formatNumber(i)] = i;
      }
    }
    return numeralsMapCache[locale];
  };
}();
var normalizeNumerals = function normalizeNumerals(dateString) {
  var alternativeNumeralsMap = getAlternativeNumeralsMap(_core.default.locale());
  if (!alternativeNumeralsMap) {
    return dateString;
  }
  return dateString.split('').map(function (sign) {
    return sign in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign]) : sign;
  }).join('');
};
var removeLeadingZeroes = function removeLeadingZeroes(str) {
  return str.replace(/(\D)0+(\d)/g, '$1$2');
};
var dateStringEquals = function dateStringEquals(actual, expected) {
  return removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
};
var normalizeMonth = function normalizeMonth(text) {
  return text.replace('d\u2019', 'de '); // NOTE: For "ca" locale
};

var intlFormats = {
  'day': {
    day: 'numeric'
  },
  'dayofweek': {
    weekday: 'long'
  },
  'longdate': {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  'longdatelongtime': {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric'
  },
  'longtime': {
    hour: 'numeric',
    minute: 'numeric',
    second: 'numeric'
  },
  'month': {
    month: 'long'
  },
  'monthandday': {
    month: 'long',
    day: 'numeric'
  },
  'monthandyear': {
    year: 'numeric',
    month: 'long'
  },
  'shortdate': {},
  'shorttime': {
    hour: 'numeric',
    minute: 'numeric'
  },
  'shortyear': {
    year: '2-digit'
  },
  'year': {
    year: 'numeric'
  }
};
Object.defineProperty(intlFormats, 'shortdateshorttime', {
  get: function get() {
    var defaultOptions = Intl.DateTimeFormat(_core.default.locale()).resolvedOptions();
    return {
      year: defaultOptions.year,
      month: defaultOptions.month,
      day: defaultOptions.day,
      hour: 'numeric',
      minute: 'numeric'
    };
  }
});
var getIntlFormat = function getIntlFormat(format) {
  return typeof format === 'string' && intlFormats[format.toLowerCase()];
};
var monthNameStrategies = {
  standalone: function standalone(monthIndex, monthFormat) {
    var date = new Date(1999, monthIndex, 13, 1);
    var dateString = getIntlFormatter({
      month: monthFormat
    })(date);
    return dateString;
  },
  format: function format(monthIndex, monthFormat) {
    var date = new Date(0, monthIndex, 13, 1);
    var dateString = normalizeMonth(getIntlFormatter({
      day: 'numeric',
      month: monthFormat
    })(date));
    var parts = dateString.split(' ').filter(function (part) {
      return part.indexOf('13') < 0;
    });
    if (parts.length === 1) {
      return parts[0];
    } else if (parts.length === 2) {
      return parts[0].length > parts[1].length ? parts[0] : parts[1]; // NOTE: For "lt" locale
    }

    return monthNameStrategies.standalone(monthIndex, monthFormat);
  }
};
var _default = {
  engine: function engine() {
    return 'intl';
  },
  getMonthNames: function getMonthNames(format, type) {
    var intlFormats = {
      wide: 'long',
      abbreviated: 'short',
      narrow: 'narrow'
    };
    var monthFormat = intlFormats[format || 'wide'];
    type = type === 'format' ? type : 'standalone';
    return Array.apply(null, new Array(12)).map(function (_, monthIndex) {
      return monthNameStrategies[type](monthIndex, monthFormat);
    });
  },
  getDayNames: function getDayNames(format) {
    var intlFormats = {
      wide: 'long',
      abbreviated: 'short',
      short: 'narrow',
      narrow: 'narrow'
    };
    var getIntlDayNames = function getIntlDayNames(format) {
      return Array.apply(null, new Array(7)).map(function (_, dayIndex) {
        return getIntlFormatter({
          weekday: format
        })(new Date(0, 0, dayIndex));
      });
    };
    var result = getIntlDayNames(intlFormats[format || 'wide']);
    return result;
  },
  getPeriodNames: function getPeriodNames() {
    var hour12Formatter = getIntlFormatter({
      hour: 'numeric',
      hour12: true
    });
    return [1, 13].map(function (hours) {
      var hourNumberText = formatNumber(1); // NOTE: For "bn" locale
      var timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
      if (timeParts.length !== 2) {
        return '';
      }
      var biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
      return biggerPart.trim();
    });
  },
  format: function format(date, _format) {
    if (!date) {
      return;
    }
    if (!_format) {
      return date;
    }

    // TODO: refactor (extract code form base)
    if (typeof _format !== 'function' && !_format.formatter) {
      _format = _format.type || _format;
    }
    var intlFormat = getIntlFormat(_format);
    if (intlFormat) {
      return getIntlFormatter(intlFormat)(date);
    }
    var formatType = typeof _format;
    if (_format.formatter || formatType === 'function' || formatType === 'string') {
      return this.callBase.apply(this, arguments);
    }
    return getIntlFormatter(_format)(date);
  },
  parse: function parse(dateString, format) {
    var _this = this;
    var formatter;
    if (format && !format.parser && typeof dateString === 'string') {
      dateString = normalizeMonth(dateString);
      formatter = function formatter(date) {
        return normalizeMonth(_this.format(date, format));
      };
    }
    return this.callBase(dateString, formatter || format);
  },
  _parseDateBySimpleFormat: function _parseDateBySimpleFormat(dateString, format) {
    var _this2 = this;
    dateString = normalizeNumerals(dateString);
    var formatParts = this.getFormatParts(format);
    var dateParts = dateString.split(/\D+/).filter(function (part) {
      return part.length > 0;
    });
    if (formatParts.length !== dateParts.length) {
      return;
    }
    var dateArgs = this._generateDateArgs(formatParts, dateParts);
    var constructDate = function constructDate(dateArgs, ampmShift) {
      var hoursShift = ampmShift ? 12 : 0;
      return new Date(dateArgs.year, dateArgs.month, dateArgs.day, (dateArgs.hours + hoursShift) % 24, dateArgs.minutes, dateArgs.seconds);
    };
    var constructValidDate = function constructValidDate(ampmShift) {
      var parsedDate = constructDate(dateArgs, ampmShift);
      if (dateStringEquals(normalizeNumerals(_this2.format(parsedDate, format)), dateString)) {
        return parsedDate;
      }
    };
    return constructValidDate(false) || constructValidDate(true);
  },
  _generateDateArgs: function _generateDateArgs(formatParts, dateParts) {
    var currentDate = new Date();
    var dateArgs = {
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(),
      day: currentDate.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    formatParts.forEach(function (formatPart, index) {
      var datePart = dateParts[index];
      var parsed = parseInt(datePart, 10);
      if (formatPart === 'month') {
        parsed = parsed - 1;
      }
      dateArgs[formatPart] = parsed;
    });
    return dateArgs;
  },
  formatUsesMonthName: function formatUsesMonthName(format) {
    if (typeof format === 'object' && !(format.type || format.format)) {
      return format.month === 'long';
    }
    return this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function formatUsesDayName(format) {
    if (typeof format === 'object' && !(format.type || format.format)) {
      return format.weekday === 'long';
    }
    return this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function getTimeSeparator() {
    var formatOptions = {
      hour: 'numeric',
      minute: 'numeric',
      hour12: false
    };
    return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), formatOptions)).replace(/\d/g, '');
  },
  getFormatParts: function getFormatParts(format) {
    if (typeof format === 'string') {
      return this.callBase(format);
    }
    var intlFormat = (0, _extend.extend)({}, intlFormats[format.toLowerCase()]);
    var date = new Date(2001, 2, 4, 5, 6, 7);
    var formattedDate = getIntlFormatter(intlFormat)(date);
    formattedDate = normalizeNumerals(formattedDate);
    var formatParts = [{
      name: 'year',
      value: 1
    }, {
      name: 'month',
      value: 3
    }, {
      name: 'day',
      value: 4
    }, {
      name: 'hours',
      value: 5
    }, {
      name: 'minutes',
      value: 6
    }, {
      name: 'seconds',
      value: 7
    }];
    return formatParts.map(function (part) {
      return {
        name: part.name,
        index: formattedDate.indexOf(part.value)
      };
    }).filter(function (part) {
      return part.index > -1;
    }).sort(function (a, b) {
      return a.index - b.index;
    }).map(function (part) {
      return part.name;
    });
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38702:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(80209));
var _core = _interopRequireDefault(__webpack_require__(91331));
var _open_xml_currency_format = _interopRequireDefault(__webpack_require__(44592));
var _accounting_formats = _interopRequireDefault(__webpack_require__(71868));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* globals Intl */

var CURRENCY_STYLES = ['standard', 'accounting'];
var MAX_FRACTION_DIGITS = 20;
var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
var formattersCache = {};
var getFormatter = function getFormatter(format) {
  var key = _core.default.locale() + '/' + JSON.stringify(format);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.NumberFormat(_core.default.locale(), format).format;
  }
  return formattersCache[key];
};
var getCurrencyFormatter = function getCurrencyFormatter(currency) {
  return new Intl.NumberFormat(_core.default.locale(), {
    style: 'currency',
    currency: currency
  });
};
var _default = {
  engine: function engine() {
    return 'intl';
  },
  _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
    if (format === 'exponential') {
      return this.callBase.apply(this, arguments);
    }
    return getFormatter(this._normalizeFormatConfig(format, formatConfig, value))(value);
  },
  _normalizeFormatConfig: function _normalizeFormatConfig(format, formatConfig, value) {
    var config;
    if (format === 'decimal') {
      var fractionDigits = String(value).split('.')[1];
      config = {
        minimumIntegerDigits: formatConfig.precision || undefined,
        useGrouping: false,
        maximumFractionDigits: fractionDigits && fractionDigits.length,
        round: value < 0 ? 'ceil' : 'floor'
      };
    } else {
      config = this._getPrecisionConfig(formatConfig.precision);
    }
    if (format === 'percent') {
      config.style = 'percent';
    } else if (format === 'currency') {
      var _formatConfig$useCurr;
      var useAccountingStyle = (_formatConfig$useCurr = formatConfig.useCurrencyAccountingStyle) !== null && _formatConfig$useCurr !== void 0 ? _formatConfig$useCurr : (0, _config.default)().defaultUseCurrencyAccountingStyle;
      config.style = 'currency';
      config.currency = formatConfig.currency || (0, _config.default)().defaultCurrency;
      config.currencySign = CURRENCY_STYLES[+useAccountingStyle];
    }
    return config;
  },
  _getPrecisionConfig: function _getPrecisionConfig(precision) {
    var config;
    if (precision === null) {
      config = {
        minimumFractionDigits: 0,
        maximumFractionDigits: MAX_FRACTION_DIGITS
      };
    } else {
      config = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }
    return config;
  },
  format: function format(value, _format) {
    if ('number' !== typeof value) {
      return value;
    }
    _format = this._normalizeFormat(_format);
    if (_format.currency === 'default') {
      _format.currency = (0, _config.default)().defaultCurrency;
    }
    if (!_format || 'function' !== typeof _format && !_format.type && !_format.formatter) {
      return getFormatter(_format)(value);
    }
    return this.callBase.apply(this, arguments);
  },
  _getCurrencySymbolInfo: function _getCurrencySymbolInfo(currency) {
    var formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function _extractCurrencySymbolInfo(currencyValueString) {
    var match = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    var position = match[1] ? 'before' : 'after';
    var symbol = match[1] || match[4] || '';
    var delimiter = match[2] || match[3] || '';
    return {
      position: position,
      symbol: symbol,
      delimiter: delimiter
    };
  },
  getCurrencySymbol: function getCurrencySymbol(currency) {
    if (!currency) {
      currency = (0, _config.default)().defaultCurrency;
    }
    var symbolInfo = this._getCurrencySymbolInfo(currency);
    return {
      'symbol': symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function getOpenXmlCurrencyFormat(currency) {
    var targetCurrency = currency || (0, _config.default)().defaultCurrency;
    var currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
    var closestAccountingFormat = _core.default.getValueByClosestLocale(function (locale) {
      return _accounting_formats.default[locale];
    });
    return (0, _open_xml_currency_format.default)(currencySymbol, closestAccountingFormat);
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 9821:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getLanguageId = getLanguageId;
var _core = _interopRequireDefault(__webpack_require__(91331));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var LANGUAGE_CODES = {
  'ar': 1,
  'bg': 2,
  'ca': 3,
  'zh-Hans': 4,
  'cs': 5,
  'da': 6,
  'de': 7,
  'el': 8,
  'en': 9,
  'es': 10,
  'fi': 11,
  'fr': 12,
  'he': 13,
  'hu': 14,
  'is': 15,
  'it': 16,
  'ja': 17,
  'ko': 18,
  'nl': 19,
  'no': 20,
  'pl': 21,
  'pt': 22,
  'rm': 23,
  'ro': 24,
  'ru': 25,
  'hr': 26,
  'sk': 27,
  'sq': 28,
  'sv': 29,
  'th': 30,
  'tr': 31,
  'ur': 32,
  'id': 33,
  'uk': 34,
  'be': 35,
  'sl': 36,
  'et': 37,
  'lv': 38,
  'lt': 39,
  'tg': 40,
  'fa': 41,
  'vi': 42,
  'hy': 43,
  'az': 44,
  'eu': 45,
  'hsb': 46,
  'mk': 47,
  'tn': 50,
  'xh': 52,
  'zu': 53,
  'af': 54,
  'ka': 55,
  'fo': 56,
  'hi': 57,
  'mt': 58,
  'se': 59,
  'ga': 60,
  'ms': 62,
  'kk': 63,
  'ky': 64,
  'sw': 65,
  'tk': 66,
  'uz': 67,
  'tt': 68,
  'bn': 69,
  'pa': 70,
  'gu': 71,
  'or': 72,
  'ta': 73,
  'te': 74,
  'kn': 75,
  'ml': 76,
  'as': 77,
  'mr': 78,
  'sa': 79,
  'mn': 80,
  'bo': 81,
  'cy': 82,
  'km': 83,
  'lo': 84,
  'gl': 86,
  'kok': 87,
  'syr': 90,
  'si': 91,
  'iu': 93,
  'am': 94,
  'tzm': 95,
  'ne': 97,
  'fy': 98,
  'ps': 99,
  'fil': 100,
  'dv': 101,
  'ha': 104,
  'yo': 106,
  'quz': 107,
  'nso': 108,
  'ba': 109,
  'lb': 110,
  'kl': 111,
  'ig': 112,
  'ii': 120,
  'arn': 122,
  'moh': 124,
  'br': 126,
  'ug': 128,
  'mi': 129,
  'oc': 130,
  'co': 131,
  'gsw': 132,
  'sah': 133,
  'qut': 134,
  'rw': 135,
  'wo': 136,
  'prs': 140,
  'gd': 145,
  'ar-SA': 1025,
  'bg-BG': 1026,
  'ca-ES': 1027,
  'zh-TW': 1028,
  'cs-CZ': 1029,
  'da-DK': 1030,
  'de-DE': 1031,
  'el-GR': 1032,
  'en-US': 1033,
  'fi-FI': 1035,
  'fr-FR': 1036,
  'he-IL': 1037,
  'hu-HU': 1038,
  'is-IS': 1039,
  'it-IT': 1040,
  'ja-JP': 1041,
  'ko-KR': 1042,
  'nl-NL': 1043,
  'nb-NO': 1044,
  'pl-PL': 1045,
  'pt-BR': 1046,
  'rm-CH': 1047,
  'ro-RO': 1048,
  'ru-RU': 1049,
  'hr-HR': 1050,
  'sk-SK': 1051,
  'sq-AL': 1052,
  'sv-SE': 1053,
  'th-TH': 1054,
  'tr-TR': 1055,
  'ur-PK': 1056,
  'id-ID': 1057,
  'uk-UA': 1058,
  'be-BY': 1059,
  'sl-SI': 1060,
  'et-EE': 1061,
  'lv-LV': 1062,
  'lt-LT': 1063,
  'tg-Cyrl-TJ': 1064,
  'fa-IR': 1065,
  'vi-VN': 1066,
  'hy-AM': 1067,
  'az-Latn-AZ': 1068,
  'eu-ES': 1069,
  'hsb-DE': 1070,
  'mk-MK': 1071,
  'tn-ZA': 1074,
  'xh-ZA': 1076,
  'zu-ZA': 1077,
  'af-ZA': 1078,
  'ka-GE': 1079,
  'fo-FO': 1080,
  'hi-IN': 1081,
  'mt-MT': 1082,
  'se-NO': 1083,
  'ms-MY': 1086,
  'kk-KZ': 1087,
  'ky-KG': 1088,
  'sw-KE': 1089,
  'tk-TM': 1090,
  'uz-Latn-UZ': 1091,
  'tt-RU': 1092,
  'bn-IN': 1093,
  'pa-IN': 1094,
  'gu-IN': 1095,
  'or-IN': 1096,
  'ta-IN': 1097,
  'te-IN': 1098,
  'kn-IN': 1099,
  'ml-IN': 1100,
  'as-IN': 1101,
  'mr-IN': 1102,
  'sa-IN': 1103,
  'mn-MN': 1104,
  'bo-CN': 1105,
  'cy-GB': 1106,
  'km-KH': 1107,
  'lo-LA': 1108,
  'gl-ES': 1110,
  'kok-IN': 1111,
  'syr-SY': 1114,
  'si-LK': 1115,
  'iu-Cans-CA': 1117,
  'am-ET': 1118,
  'ne-NP': 1121,
  'fy-NL': 1122,
  'ps-AF': 1123,
  'fil-PH': 1124,
  'dv-MV': 1125,
  'ha-Latn-NG': 1128,
  'yo-NG': 1130,
  'quz-BO': 1131,
  'nso-ZA': 1132,
  'ba-RU': 1133,
  'lb-LU': 1134,
  'kl-GL': 1135,
  'ig-NG': 1136,
  'ii-CN': 1144,
  'arn-CL': 1146,
  'moh-CA': 1148,
  'br-FR': 1150,
  'ug-CN': 1152,
  'mi-NZ': 1153,
  'oc-FR': 1154,
  'co-FR': 1155,
  'gsw-FR': 1156,
  'sah-RU': 1157,
  'qut-GT': 1158,
  'rw-RW': 1159,
  'wo-SN': 1160,
  'prs-AF': 1164,
  'gd-GB': 1169,
  'ar-IQ': 2049,
  'zh-CN': 2052,
  'de-CH': 2055,
  'en-GB': 2057,
  'es-MX': 2058,
  'fr-BE': 2060,
  'it-CH': 2064,
  'nl-BE': 2067,
  'nn-NO': 2068,
  'pt-PT': 2070,
  'sr-Latn-CS': 2074,
  'sv-FI': 2077,
  'az-Cyrl-AZ': 2092,
  'dsb-DE': 2094,
  'se-SE': 2107,
  'ga-IE': 2108,
  'ms-BN': 2110,
  'uz-Cyrl-UZ': 2115,
  'bn-BD': 2117,
  'mn-Mong-CN': 2128,
  'iu-Latn-CA': 2141,
  'tzm-Latn-DZ': 2143,
  'quz-EC': 2155,
  'ar-EG': 3073,
  'zh-HK': 3076,
  'de-AT': 3079,
  'en-AU': 3081,
  'es-ES': 3082,
  'fr-CA': 3084,
  'sr-Cyrl-CS': 3098,
  'se-FI': 3131,
  'quz-PE': 3179,
  'ar-LY': 4097,
  'zh-SG': 4100,
  'de-LU': 4103,
  'en-CA': 4105,
  'es-GT': 4106,
  'fr-CH': 4108,
  'hr-BA': 4122,
  'smj-NO': 4155,
  'ar-DZ': 5121,
  'zh-MO': 5124,
  'de-LI': 5127,
  'en-NZ': 5129,
  'es-CR': 5130,
  'fr-LU': 5132,
  'bs-Latn-BA': 5146,
  'smj-SE': 5179,
  'ar-MA': 6145,
  'en-IE': 6153,
  'es-PA': 6154,
  'fr-MC': 6156,
  'sr-Latn-BA': 6170,
  'sma-NO': 6203,
  'ar-TN': 7169,
  'en-ZA': 7177,
  'es-DO': 7178,
  'sr-Cyrl-BA': 7194,
  'sma-SE': 7227,
  'ar-OM': 8193,
  'en-JM': 8201,
  'es-VE': 8202,
  'bs-Cyrl-BA': 8218,
  'sms-FI': 8251,
  'ar-YE': 9217,
  'en-029': 9225,
  'es-CO': 9226,
  'sr-Latn-RS': 9242,
  'smn-FI': 9275,
  'ar-SY': 10241,
  'en-BZ': 10249,
  'es-PE': 10250,
  'sr-Cyrl-RS': 10266,
  'ar-JO': 11265,
  'en-TT': 11273,
  'es-AR': 11274,
  'sr-Latn-ME': 11290,
  'ar-LB': 12289,
  'en-ZW': 12297,
  'es-EC': 12298,
  'sr-Cyrl-ME': 12314,
  'ar-KW': 13313,
  'en-PH': 13321,
  'es-CL': 13322,
  'ar-AE': 14337,
  'es-UY': 14346,
  'ar-BH': 15361,
  'es-PY': 15370,
  'ar-QA': 16385,
  'en-IN': 16393,
  'es-BO': 16394,
  'en-MY': 17417,
  'es-SV': 17418,
  'en-SG': 18441,
  'es-HN': 18442,
  'es-NI': 19466,
  'es-PR': 20490,
  'es-US': 21514,
  'bs-Cyrl': 25626,
  'bs-Latn': 26650,
  'sr-Cyrl': 27674,
  'sr-Latn': 28698,
  'smn': 28731,
  'az-Cyrl': 29740,
  'sms': 29755,
  'zh': 30724,
  'nn': 30740,
  'bs': 30746,
  'az-Latn': 30764,
  'sma': 30779,
  'uz-Cyrl': 30787,
  'mn-Cyrl': 30800,
  'iu-Cans': 30813,
  'zh-Hant': 31748,
  'nb': 31764,
  'sr': 31770,
  'tg-Cyrl': 31784,
  'dsb': 31790,
  'smj': 31803,
  'uz-Latn': 31811,
  'mn-Mong': 31824,
  'iu-Latn': 31837,
  'tzm-Latn': 31839,
  'ha-Latn': 31848
};
function getLanguageId() {
  return LANGUAGE_CODES[_core.default.locale()];
}

/***/ }),

/***/ 59937:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getFormat = void 0;
var _number = _interopRequireDefault(__webpack_require__(18016));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ARABIC_COMMA = '\u060C';
var FORMAT_SEPARATORS = ' .,:;/\\<>()-[]' + ARABIC_COMMA;
var AM_PM_PATTERN = '. m.';
var checkDigit = function checkDigit(char) {
  var code = char && _number.default.convertDigits(char, false).charCodeAt(0);
  var zeroCode = _number.default.convertDigits('0', false).charCodeAt(0);
  return zeroCode <= code && code < zeroCode + 10;
};
var checkPatternContinue = function checkPatternContinue(text, patterns, index, isDigit) {
  var char = text[index];
  var nextChar = text[index + 1];
  if (!isDigit) {
    if (char === '.' || char === ' ' && text.slice(index - 1, index + 3) === AM_PM_PATTERN) {
      return true;
    }
    if (char === '-' && !checkDigit(nextChar)) {
      return true;
    }
  }
  var isDigitChanged = isDigit && patterns.some(function (pattern) {
    return text[index] !== pattern[index];
  });
  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
};
var getPatternStartIndex = function getPatternStartIndex(defaultPattern, index) {
  if (!checkDigit(defaultPattern[index])) {
    while (index > 0 && !checkDigit(defaultPattern[index - 1]) && (defaultPattern[index - 1] === '.' || FORMAT_SEPARATORS.indexOf(defaultPattern[index - 1]) < 0)) {
      index--;
    }
  }
  return index;
};
var getDifference = function getDifference(defaultPattern, patterns, processedIndexes, isDigit) {
  var i = 0;
  var result = [];
  var patternsFilter = function patternsFilter(pattern) {
    return defaultPattern[i] !== pattern[i] && (isDigit === undefined || checkDigit(defaultPattern[i]) === isDigit);
  };
  if (!Array.isArray(patterns)) {
    patterns = [patterns];
  }
  for (i = 0; i < defaultPattern.length; i++) {
    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
      i = getPatternStartIndex(defaultPattern, i);
      do {
        isDigit = checkDigit(defaultPattern[i]);
        if (!result.length && !isDigit && checkDigit(patterns[0][i])) {
          break;
        }
        result.push(i);
        processedIndexes.unshift(i);
        i++;
      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));
      break;
    }
  }
  if (result.length === 1 && (defaultPattern[processedIndexes[0] - 1] === '0' || defaultPattern[processedIndexes[0] - 1] === '')) {
    processedIndexes.unshift(processedIndexes[0] - 1);
  }
  return result;
};
var replaceCharsCore = function replaceCharsCore(pattern, indexes, char, patternPositions) {
  var baseCharIndex = indexes[0];
  var patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
  indexes.forEach(function (_, index) {
    pattern = pattern.substr(0, patternIndex + index) + (char.length > 1 ? char[index] : char) + pattern.substr(patternIndex + index + 1);
  });
  if (indexes.length === 1) {
    pattern = pattern.replace('0' + char, char + char);
    pattern = pattern.replace('' + char, char + char);
  }
  return pattern;
};
var replaceChars = function replaceChars(pattern, indexes, char, patternPositions) {
  var i;
  var index;
  var patternIndex;
  if (!checkDigit(pattern[indexes[0]] || '0')) {
    var letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
    while (indexes.length > letterCount) {
      index = indexes.pop();
      patternIndex = patternPositions[index];
      patternPositions[index] = -1;
      for (i = index + 1; i < patternPositions.length; i++) {
        patternPositions[i]--;
      }
      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
    }
    index = indexes[indexes.length - 1] + 1, patternIndex = index < patternPositions.length ? patternPositions[index] : index;
    while (indexes.length < letterCount) {
      indexes.push(indexes[indexes.length - 1] + 1);
      for (i = index; i < patternPositions.length; i++) {
        patternPositions[i]++;
      }
      pattern = pattern.substr(0, patternIndex) + ' ' + pattern.substr(patternIndex);
    }
  }
  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
  return pattern;
};
var formatValue = function formatValue(value, formatter) {
  if (Array.isArray(value)) {
    return value.map(function (value) {
      return (formatter(value) || '').toString();
    });
  }
  return (formatter(value) || '').toString();
};
var ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
var escapeChars = function escapeChars(pattern, defaultPattern, processedIndexes, patternPositions) {
  var escapeIndexes = defaultPattern.split('').map(function (char, index) {
    if (processedIndexes.indexOf(index) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || char === '\'')) {
      return patternPositions[index];
    }
    return -1;
  });
  pattern = pattern.split('').map(function (char, index) {
    var result = char;
    var isCurrentCharEscaped = escapeIndexes.indexOf(index) >= 0;
    var isPrevCharEscaped = index > 0 && escapeIndexes.indexOf(index - 1) >= 0;
    var isNextCharEscaped = escapeIndexes.indexOf(index + 1) >= 0;
    if (isCurrentCharEscaped) {
      if (!isPrevCharEscaped) {
        result = '\'' + result;
      }
      if (!isNextCharEscaped) {
        result = result + '\'';
      }
    }
    return result;
  }).join('');
  return pattern;
};
var getFormat = function getFormat(formatter) {
  var processedIndexes = [];
  var defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
  var patternPositions = defaultPattern.split('').map(function (_, index) {
    return index;
  });
  var result = defaultPattern;
  var replacedPatterns = {};
  var datePatterns = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: 'S'
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: 's'
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: 'm'
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: 'H',
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: 'h',
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: 'a',
    isDigit: false
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: 'd'
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: 'E'
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: 'M'
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: 'y'
  }];
  if (!result) return;
  datePatterns.forEach(function (test) {
    var diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
    var pattern = test.pattern === 'M' && !replacedPatterns['d'] ? 'L' : test.pattern;
    result = replaceChars(result, diff, pattern, patternPositions);
    replacedPatterns[pattern] = diff.length;
  });
  result = escapeChars(result, defaultPattern, processedIndexes, patternPositions);
  if (processedIndexes.length) {
    return result;
  }
};
exports.getFormat = getFormat;

/***/ }),

/***/ 40594:
/***/ (function(__unused_webpack_module, exports) {



exports.getFormatter = void 0;
function leftPad(text, length) {
  while (text.length < length) {
    text = '0' + text;
  }
  return text;
}
var FORMAT_TYPES = {
  '3': 'abbreviated',
  '4': 'wide',
  '5': 'narrow'
};
var LDML_FORMATTERS = {
  y: function y(date, count, useUtc) {
    var year = date[useUtc ? 'getUTCFullYear' : 'getFullYear']();
    if (count === 2) {
      year = year % 100;
    }
    return leftPad(year.toString(), count);
  },
  M: function M(date, count, useUtc, dateParts) {
    var month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    var formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, 'format')[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function L(date, count, useUtc, dateParts) {
    var month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    var formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, 'standalone')[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function Q(date, count, useUtc, dateParts) {
    var month = date[useUtc ? 'getUTCMonth' : 'getMonth']();
    var quarter = Math.floor(month / 3);
    var formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }
    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function E(date, count, useUtc, dateParts) {
    var day = date[useUtc ? 'getUTCDay' : 'getDay']();
    var formatType = FORMAT_TYPES[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function a(date, count, useUtc, dateParts) {
    var hours = date[useUtc ? 'getUTCHours' : 'getHours']();
    var period = hours < 12 ? 0 : 1;
    var formatType = FORMAT_TYPES[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function d(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCDate' : 'getDate']().toString(), Math.min(count, 2));
  },
  H: function H(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCHours' : 'getHours']().toString(), Math.min(count, 2));
  },
  h: function h(date, count, useUtc) {
    var hours = date[useUtc ? 'getUTCHours' : 'getHours']();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function m(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCMinutes' : 'getMinutes']().toString(), Math.min(count, 2));
  },
  s: function s(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCSeconds' : 'getSeconds']().toString(), Math.min(count, 2));
  },
  S: function S(date, count, useUtc) {
    return leftPad(date[useUtc ? 'getUTCMilliseconds' : 'getMilliseconds']().toString(), 3).substr(0, count);
  },
  x: function x(date, count, useUtc) {
    var timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    var signPart = timezoneOffset > 0 ? '-' : '+';
    var timezoneOffsetAbs = Math.abs(timezoneOffset);
    var hours = Math.floor(timezoneOffsetAbs / 60);
    var minutes = timezoneOffsetAbs % 60;
    var hoursPart = leftPad(hours.toString(), 2);
    var minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ':' : '') + (count > 1 || minutes ? minutesPart : '');
  },
  X: function X(date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return 'Z';
    }
    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function Z(date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};
var getFormatter = function getFormatter(format, dateParts) {
  return function (date) {
    var charIndex;
    var formatter;
    var char;
    var charCount = 0;
    var separator = '\'';
    var isEscaping = false;
    var isCurrentCharEqualsNext;
    var result = '';
    if (!date) return null;
    if (!format) return date;
    var useUtc = format[format.length - 1] === 'Z' || format.slice(-3) === '\'Z\'';
    for (charIndex = 0; charIndex < format.length; charIndex++) {
      char = format[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format[charIndex + 1];
      charCount++;
      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result += formatter(date, charCount, useUtc, dateParts);
        }
        charCount = 0;
      }
      if (char === separator && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result += char;
      }
      if (char === separator && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }
    return result;
  };
};
exports.getFormatter = getFormatter;

/***/ }),

/***/ 2892:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.isPossibleForParsingFormat = exports.getRegExpInfo = exports.getPatternSetters = exports.getParser = void 0;
var _common = __webpack_require__(20576);
var _console = __webpack_require__(30869);
var FORMAT_TYPES = {
  '3': 'abbreviated',
  '4': 'wide',
  '5': 'narrow'
};
var monthRegExpGenerator = function monthRegExpGenerator(count, dateParts) {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES).map(function (count) {
      return ['format', 'standalone'].map(function (type) {
        return dateParts.getMonthNames(FORMAT_TYPES[count], type).join('|');
      }).join('|');
    }).join('|');
  }
  return count === 2 ? '1[012]|0?[1-9]' : '0??[1-9]|1[012]';
};
var PATTERN_REGEXPS = {
  ':': function _(count, dateParts) {
    var countSuffix = count > 1 ? "{".concat(count, "}") : '';
    var timeSeparator = (0, _common.escapeRegExp)(dateParts.getTimeSeparator());
    timeSeparator !== ':' && (timeSeparator = "".concat(timeSeparator, "|:"));
    return "".concat(timeSeparator).concat(countSuffix);
  },
  y: function y(count) {
    return count === 2 ? "[0-9]{".concat(count, "}") : '[0-9]+?';
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q: function Q(count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').join('|');
    }
    return '0?[1-4]';
  },
  E: function E(count, dateParts) {
    return '\\D*';
  },
  a: function a(count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format').join('|');
  },
  d: function d(count) {
    return count === 2 ? '3[01]|[12][0-9]|0?[1-9]' : '0??[1-9]|[12][0-9]|3[01]';
  },
  H: function H(count) {
    return count === 2 ? '2[0-3]|1[0-9]|0?[0-9]' : '0??[0-9]|1[0-9]|2[0-3]';
  },
  h: function h(count) {
    return count === 2 ? '1[012]|0?[1-9]' : '0??[1-9]|1[012]';
  },
  m: function m(count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  s: function s(count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  },
  S: function S(count) {
    return "[0-9]{1,".concat(count, "}");
  },
  w: function w(count) {
    return count === 2 ? '[1-5][0-9]|0?[0-9]' : '0??[0-9]|[1-5][0-9]';
  }
};
var parseNumber = Number;
var caseInsensitiveIndexOf = function caseInsensitiveIndexOf(array, value) {
  return array.map(function (item) {
    return item.toLowerCase();
  }).indexOf(value.toLowerCase());
};
var monthPatternParser = function monthPatternParser(text, count, dateParts) {
  if (count > 2) {
    return ['format', 'standalone'].map(function (type) {
      return Object.keys(FORMAT_TYPES).map(function (count) {
        var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);
        return caseInsensitiveIndexOf(monthNames, text);
      });
    }).reduce(function (a, b) {
      return a.concat(b);
    }).filter(function (index) {
      return index >= 0;
    })[0];
  }
  return parseNumber(text) - 1;
};
var PATTERN_PARSERS = {
  y: function y(text, count) {
    var year = parseNumber(text);
    if (count === 2) {
      return year < 30 ? 2000 + year : 1900 + year;
    }
    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q: function Q(text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES[count], 'format').indexOf(text);
    }
    return parseNumber(text) - 1;
  },
  E: function E(text, count, dateParts) {
    var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a: function a(text, count, dateParts) {
    var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], 'format');
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S: function S(text, count) {
    count = Math.max(count, 3);
    text = text.slice(0, 3);
    while (count < 3) {
      text = text + '0';
      count++;
    }
    return parseNumber(text);
  }
};
var ORDERED_PATTERNS = ['y', 'M', 'd', 'h', 'm', 's', 'S'];
var PATTERN_SETTERS = {
  y: 'setFullYear',
  M: 'setMonth',
  L: 'setMonth',
  a: function a(date, value, datePartValues) {
    var hours = date.getHours();
    var hourPartValue = datePartValues['h'];
    if (hourPartValue !== undefined && hourPartValue !== hours) {
      hours--;
    }
    if (!value && hours === 12) {
      hours = 0;
    } else if (value && hours !== 12) {
      hours += 12;
    }
    date.setHours(hours);
  },
  d: 'setDate',
  H: 'setHours',
  h: 'setHours',
  m: 'setMinutes',
  s: 'setSeconds',
  S: 'setMilliseconds'
};
var getSameCharCount = function getSameCharCount(text, index) {
  var char = text[index];
  if (!char) {
    return 0;
  }
  var count = 0;
  do {
    index++;
    count++;
  } while (text[index] === char);
  return count;
};
var createPattern = function createPattern(char, count) {
  var result = '';
  for (var i = 0; i < count; i++) {
    result += char;
  }
  return result;
};
var getRegExpInfo = function getRegExpInfo(format, dateParts) {
  var regexpText = '';
  var stubText = '';
  var isEscaping;
  var patterns = [];
  var addPreviousStub = function addPreviousStub() {
    if (stubText) {
      patterns.push("'".concat(stubText, "'"));
      regexpText += "".concat((0, _common.escapeRegExp)(stubText), ")");
      stubText = '';
    }
  };
  for (var i = 0; i < format.length; i++) {
    var char = format[i];
    var isEscapeChar = char === '\'';
    var regexpPart = PATTERN_REGEXPS[char];
    if (isEscapeChar) {
      isEscaping = !isEscaping;
      if (format[i - 1] !== '\'') {
        continue;
      }
    }
    if (regexpPart && !isEscaping) {
      var count = getSameCharCount(format, i);
      var pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += "(".concat(regexpPart(count, dateParts), ")");
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += '(';
      }
      stubText += char;
    }
  }
  addPreviousStub();
  if (!isPossibleForParsingFormat(patterns)) {
    _console.logger.warn("The following format may be parsed incorrectly: ".concat(format, "."));
  }
  return {
    patterns: patterns,
    regexp: new RegExp("^".concat(regexpText, "$"), 'i')
  };
};
exports.getRegExpInfo = getRegExpInfo;
var digitFieldSymbols = ['d', 'H', 'h', 'm', 's', 'w', 'M', 'L', 'Q'];
var isPossibleForParsingFormat = function isPossibleForParsingFormat(patterns) {
  var isDigitPattern = function isDigitPattern(pattern) {
    if (!pattern) {
      return false;
    }
    var char = pattern[0];
    return ['y', 'S'].includes(char) || digitFieldSymbols.includes(char) && pattern.length < 3;
  };
  var isAmbiguousDigitPattern = function isAmbiguousDigitPattern(pattern) {
    return pattern[0] !== 'S' && pattern.length !== 2;
  };
  var possibleForParsing = true;
  var ambiguousDigitPatternsCount = 0;
  return patterns.every(function (pattern, index, patterns) {
    if (isDigitPattern(pattern)) {
      if (isAmbiguousDigitPattern(pattern)) {
        possibleForParsing = ++ambiguousDigitPatternsCount < 2;
      }
      if (!isDigitPattern(patterns[index + 1])) {
        ambiguousDigitPatternsCount = 0;
      }
    }
    return possibleForParsing;
  });
};
exports.isPossibleForParsingFormat = isPossibleForParsingFormat;
var getPatternSetters = function getPatternSetters() {
  return PATTERN_SETTERS;
};
exports.getPatternSetters = getPatternSetters;
var setPatternPart = function setPatternPart(date, pattern, text, dateParts, datePartValues) {
  var patternChar = pattern[0];
  var partSetter = PATTERN_SETTERS[patternChar];
  var partParser = PATTERN_PARSERS[patternChar];
  if (partSetter && partParser) {
    var value = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value;
    if (date[partSetter]) {
      date[partSetter](value);
    } else {
      partSetter(date, value, datePartValues);
    }
  }
};
var setPatternPartFromNow = function setPatternPartFromNow(date, pattern, now) {
  var setterName = PATTERN_SETTERS[pattern];
  var getterName = 'g' + setterName.substr(1);
  var value = now[getterName]();
  date[setterName](value);
};
var getShortPatterns = function getShortPatterns(fullPatterns) {
  return fullPatterns.map(function (pattern) {
    if (pattern[0] === '\'') {
      return '';
    } else {
      return pattern[0] === 'H' ? 'h' : pattern[0];
    }
  });
};
var getMaxOrderedPatternIndex = function getMaxOrderedPatternIndex(patterns) {
  var indexes = patterns.map(function (pattern) {
    return ORDERED_PATTERNS.indexOf(pattern);
  });
  return Math.max.apply(Math, indexes);
};
var getOrderedFormatPatterns = function getOrderedFormatPatterns(formatPatterns) {
  var otherPatterns = formatPatterns.filter(function (pattern) {
    return ORDERED_PATTERNS.indexOf(pattern) < 0;
  });
  return ORDERED_PATTERNS.concat(otherPatterns);
};
var getParser = function getParser(format, dateParts) {
  var regExpInfo = getRegExpInfo(format, dateParts);
  return function (text) {
    var regExpResult = regExpInfo.regexp.exec(text);
    if (regExpResult) {
      var now = new Date();
      var date = new Date(now.getFullYear(), 0, 1);
      var formatPatterns = getShortPatterns(regExpInfo.patterns);
      var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      var datePartValues = {};
      orderedFormatPatterns.forEach(function (pattern, index) {
        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {
          return;
        }
        var patternIndex = formatPatterns.indexOf(pattern);
        if (patternIndex >= 0) {
          var regExpPattern = regExpInfo.patterns[patternIndex];
          var regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }
    return null;
  };
};
exports.getParser = getParser;

/***/ }),

/***/ 70629:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getFormat = getFormat;
exports.getFormatter = getFormatter;
var _math = __webpack_require__(60810);
var _utils = __webpack_require__(97360);
var DEFAULT_CONFIG = {
  thousandsSeparator: ',',
  decimalSeparator: '.'
};
var ESCAPING_CHAR = '\'';
var MAXIMUM_NUMBER_LENGTH = 15;
var PERCENT_EXPONENT_SHIFT = 2; // '1e2'

function getGroupSizes(formatString) {
  return formatString.split(',').slice(1).map(function (str) {
    var singleQuotesLeft = 0;
    return str.split('').filter(function (char, index) {
      singleQuotesLeft += char === '\'';
      var isDigit = char === '#' || char === '0';
      var isInStub = singleQuotesLeft % 2;
      return isDigit && !isInStub;
    }).length;
  });
}
function getSignParts(format) {
  var signParts = format.split(';');
  if (signParts.length === 1) {
    signParts.push('-' + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split('').reverse().join('');
}
function isPercentFormat(format) {
  return format.indexOf('%') !== -1 && !format.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'.+'/g, '');
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) return 0;
  var format = removeStubs(floatFormat);
  return format.length - format.replace(/[#]/g, '').length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) return 0;
  var format = removeStubs(floatFormat);
  return format.length - format.replace(/[0]/g, '').length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) return '';
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && valuePart.slice(-1) === '0') {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += '0';
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) return valueString;
  var groups = [];
  var index = 0;
  while (valueString) {
    var groupSize = groupSizes[index];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index < groupSizes.length - 1) {
      index++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format, valueString) {
  return format.split(ESCAPING_CHAR).map(function (formatPart, escapeIndex) {
    var isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return ESCAPING_CHAR;
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join('');
}
function getFloatPointIndex(format) {
  var isEscape = false;
  for (var index = 0; index < format.length; index++) {
    if (format[index] === '\'') {
      isEscape = !isEscape;
    }
    if (format[index] === '.' && !isEscape) {
      return index;
    }
  }
  return format.length;
}
function getFormatter(format, config) {
  config = config || DEFAULT_CONFIG;
  return function (value) {
    if (typeof value !== 'number' || isNaN(value)) return '';
    var signFormatParts = getSignParts(format);
    var isPositiveZero = 1 / value === Infinity;
    var isPositive = value > 0 || isPositiveZero;
    var numberFormat = signFormatParts[isPositive ? 0 : 1];
    var floatPointIndex = getFloatPointIndex(numberFormat);
    var floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    var minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    var maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    if (isPercentFormat(numberFormat)) {
      value = (0, _math.multiplyInExponentialForm)(value, PERCENT_EXPONENT_SHIFT);
    }
    if (!isPositive) {
      value = -value;
    }
    var minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    var maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config.unlimitedIntegerDigits ? undefined : minIntegerPrecision;
    var integerLength = Math.floor(value).toString().length;
    var floatPrecision = (0, _math.fitIntoRange)(maxFloatPrecision, 0, MAXIMUM_NUMBER_LENGTH - integerLength);
    var groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    var valueParts = (0, _utils.toFixed)(value, floatPrecision < 0 ? 0 : floatPrecision).split('.');
    var valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    var valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config.thousandsSeparator);
    var integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    var floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : '';
    var result = integerString + (floatString.match(/\d/) ? config.decimalSeparator : '') + floatString;
    return result;
  };
}
function parseValue(text, isPercent, isNegative) {
  var value = (isPercent ? 0.01 : 1) * parseFloat(text) || 0;
  return isNegative ? -value : value;
}
function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
  var nextValueText = valueText;
  var char;
  var text;
  var nextText;
  do {
    if (nextText) {
      char = text.length === nextText.length ? '0' : '1';
      valueText = isIntegerPart ? char + valueText : valueText + char;
    }
    text = nextText || formatter(parseValue(nextValueText, isPercent));
    nextValueText = isIntegerPart ? '1' + nextValueText : nextValueText + '1';
    nextText = formatter(parseValue(nextValueText, isPercent));
  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));
  if (isIntegerPart && nextText.length > text.length) {
    var hasGroups = formatter(12345).indexOf('12345') === -1;
    do {
      valueText = '1' + valueText;
    } while (hasGroups && parseValue(valueText, isPercent) < 100000);
  }
  return valueText;
}
function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
  var format = formatter(parseValue(valueText, isPercent, isNegative));
  var valueTextParts = valueText.split('.');
  var valueTextWithModifiedFloat = valueTextParts[0] + '.3' + valueTextParts[1].slice(1);
  var valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
  var decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf('3') - 1;
  format = format.replace(/(\d)\D(\d)/g, '$1,$2');
  if (decimalSeparatorIndex >= 0) {
    format = format.slice(0, decimalSeparatorIndex) + '.' + format.slice(decimalSeparatorIndex + 1);
  }
  format = format.replace(/1+/, '1').replace(/1/g, '#');
  if (!isPercent) {
    format = format.replace('%', '\'%\''); // lgtm[js/incomplete-sanitization]
  }

  return format;
}
function getFormat(formatter) {
  var valueText = '.';
  var isPercent = formatter(1).indexOf('100') >= 0;
  valueText = prepareValueText(valueText, formatter, isPercent, true);
  valueText = prepareValueText(valueText, formatter, isPercent, false);
  var positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
  var negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
  return negativeFormat === '-' + positiveFormat ? positiveFormat : positiveFormat + ';' + negativeFormat;
}

/***/ }),

/***/ 28109:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _extend = __webpack_require__(13306);
var _string = __webpack_require__(68752);
var _inflector = __webpack_require__(78008);
var _core = _interopRequireDefault(__webpack_require__(91331));
var _default_messages = __webpack_require__(18121);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var baseDictionary = (0, _extend.extend)(true, {}, _default_messages.defaultMessages);
var getDataByLocale = function getDataByLocale(localeData, locale) {
  var _Object$entries$find;
  return localeData[locale] || (locale === null || locale === void 0 ? void 0 : locale.toLowerCase) && ((_Object$entries$find = Object.entries(localeData).find(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      key = _ref2[0];
    return key.toLowerCase() === locale.toLowerCase();
  })) === null || _Object$entries$find === void 0 ? void 0 : _Object$entries$find[1]) || {};
};
var newMessages = {};
var messageLocalization = (0, _dependency_injector.default)({
  engine: function engine() {
    return 'base';
  },
  _dictionary: baseDictionary,
  load: function load(messages) {
    (0, _extend.extend)(true, this._dictionary, messages);
  },
  _localizablePrefix: '@',
  setup: function setup(localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function localizeString(text) {
    var that = this;
    var regex = new RegExp('(^|[^a-zA-Z_0-9' + that._localizablePrefix + '-]+)(' + that._localizablePrefix + '{1,2})([a-zA-Z_0-9-]+)', 'g');
    var escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, function (str, prefix, escape, localizationKey) {
      var defaultResult = that._localizablePrefix + localizationKey;
      var result;
      if (escape !== escapeString) {
        result = that.format(localizationKey);
      }
      if (!result) {
        newMessages[localizationKey] = (0, _inflector.humanize)(localizationKey);
      }
      return prefix + (result || defaultResult);
    });
  },
  getMessagesByLocales: function getMessagesByLocales() {
    return this._dictionary;
  },
  getDictionary: function getDictionary(onlyNew) {
    if (onlyNew) {
      return newMessages;
    }
    return (0, _extend.extend)({}, newMessages, this.getMessagesByLocales()[_core.default.locale()]);
  },
  getFormatter: function getFormatter(key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, 'en');
  },
  _getFormatterBase: function _getFormatterBase(key, locale) {
    var _this = this;
    var message = _core.default.getValueByClosestLocale(function (locale) {
      return getDataByLocale(_this._dictionary, locale)[key];
    });
    if (message) {
      return function () {
        var args = arguments.length === 1 && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return _string.format.apply(this, args);
      };
    }
  },
  format: function format(key) {
    var formatter = this.getFormatter(key);
    var values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || '';
  }
});
var _default = messageLocalization;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18016:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _dependency_injector = _interopRequireDefault(__webpack_require__(20476));
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _number = __webpack_require__(70629);
var _config = _interopRequireDefault(__webpack_require__(80209));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _utils = __webpack_require__(97360);
var _currency = _interopRequireDefault(__webpack_require__(89740));
var _number2 = _interopRequireDefault(__webpack_require__(38702));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var hasIntl = typeof Intl !== 'undefined';
var MAX_LARGE_NUMBER_POWER = 4;
var DECIMAL_BASE = 10;
var NUMERIC_FORMATS = ['currency', 'fixedpoint', 'exponential', 'percent', 'decimal'];
var LargeNumberFormatPostfixes = {
  1: 'K',
  // kilo
  2: 'M',
  // mega
  3: 'B',
  // billions
  4: 'T' // tera
};

var LargeNumberFormatPowers = {
  'largenumber': 'auto',
  'thousands': 1,
  'millions': 2,
  'billions': 3,
  'trillions': 4
};
var numberLocalization = (0, _dependency_injector.default)({
  engine: function engine() {
    return 'base';
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function _parseNumberFormatString(formatType) {
    var formatObject = {};
    if (!formatType || typeof formatType !== 'string') return;
    var formatList = formatType.toLowerCase().split(' ');
    (0, _iterator.each)(formatList, function (index, value) {
      if (NUMERIC_FORMATS.includes(value)) {
        formatObject.formatType = value;
      } else if (value in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value];
      }
    });
    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = 'fixedpoint';
    }
    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function _calculateNumberPower(value, base, minPower, maxPower) {
    var number = Math.abs(value);
    var power = 0;
    if (number > 1) {
      while (number && number >= base && (maxPower === undefined || power < maxPower)) {
        power++;
        number = number / base;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (minPower === undefined || power > minPower)) {
        power--;
        number = number * base;
      }
    }
    return power;
  },
  _getNumberByPower: function _getNumberByPower(number, power, base) {
    var result = number;
    while (power > 0) {
      result = result / base;
      power--;
    }
    while (power < 0) {
      result = result * base;
      power++;
    }
    return result;
  },
  _formatNumber: function _formatNumber(value, formatObject, formatConfig) {
    if (formatObject.power === 'auto') {
      formatObject.power = this._calculateNumberPower(value, 1000, 0, MAX_LARGE_NUMBER_POWER);
    }
    if (formatObject.power) {
      value = this._getNumberByPower(value, formatObject.power, 1000);
    }
    var powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || '';
    var result = this._formatNumberCore(value, formatObject.formatType, formatConfig);
    result = result.replace(/(\d|.$)(\D*)$/, '$1' + powerPostfix + '$2');
    return result;
  },
  _formatNumberExponential: function _formatNumberExponential(value, formatConfig) {
    var power = this._calculateNumberPower(value, DECIMAL_BASE);
    var number = this._getNumberByPower(value, power, DECIMAL_BASE);
    if (formatConfig.precision === undefined) {
      formatConfig.precision = 1;
    }
    if (number.toFixed(formatConfig.precision || 0) >= DECIMAL_BASE) {
      power++;
      number = number / DECIMAL_BASE;
    }
    var powString = (power >= 0 ? '+' : '') + power.toString();
    return this._formatNumberCore(number, 'fixedpoint', formatConfig) + 'E' + powString;
  },
  _addZeroes: function _addZeroes(value, precision) {
    var multiplier = Math.pow(10, precision);
    var sign = value < 0 ? '-' : '';
    value = (Math.abs(value) * multiplier >>> 0) / multiplier;
    var result = value.toString();
    while (result.length < precision) {
      result = '0' + result;
    }
    return sign + result;
  },
  _addGroupSeparators: function _addGroupSeparators(value) {
    var parts = value.toString().split('.');
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, (0, _config.default)().thousandsSeparator) + (parts[1] ? (0, _config.default)().decimalSeparator + parts[1] : '');
  },
  _formatNumberCore: function _formatNumberCore(value, format, formatConfig) {
    if (format === 'exponential') {
      return this._formatNumberExponential(value, formatConfig);
    }
    if (format !== 'decimal' && formatConfig.precision !== null) {
      formatConfig.precision = formatConfig.precision || 0;
    }
    if (format === 'percent') {
      value = value * 100;
    }
    if (formatConfig.precision !== undefined) {
      if (format === 'decimal') {
        value = this._addZeroes(value, formatConfig.precision);
      } else {
        value = formatConfig.precision === null ? value.toPrecision() : (0, _utils.toFixed)(value, formatConfig.precision);
      }
    }
    if (format !== 'decimal') {
      value = this._addGroupSeparators(value);
    } else {
      value = value.toString().replace('.', (0, _config.default)().decimalSeparator);
    }
    if (format === 'percent') {
      value += '%';
    }
    return value;
  },
  _normalizeFormat: function _normalizeFormat(format) {
    if (!format) {
      return {};
    }
    if (typeof format === 'function') {
      return format;
    }
    if (!(0, _type.isPlainObject)(format)) {
      format = {
        type: format
      };
    }
    return format;
  },
  _getSeparators: function _getSeparators() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function getThousandsSeparator() {
    return this.format(10000, 'fixedPoint')[2];
  },
  getDecimalSeparator: function getDecimalSeparator() {
    return this.format(1.2, {
      type: 'fixedPoint',
      precision: 1
    })[1];
  },
  convertDigits: function convertDigits(value, toStandard) {
    var digits = this.format(90, 'decimal');
    if (typeof value !== 'string' || digits[1] === '0') {
      return value;
    }
    var fromFirstDigit = toStandard ? digits[1] : '0';
    var toFirstDigit = toStandard ? '0' : digits[1];
    var fromLastDigit = toStandard ? digits[0] : '9';
    var regExp = new RegExp('[' + fromFirstDigit + '-' + fromLastDigit + ']', 'g');
    return value.replace(regExp, function (char) {
      return String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0)));
    });
  },
  getNegativeEtalonRegExp: function getNegativeEtalonRegExp(format) {
    var separators = this._getSeparators();
    var digitalRegExp = new RegExp('[0-9' + (0, _common.escapeRegExp)(separators.decimalSeparator + separators.thousandsSeparator) + ']+', 'g');
    var specialCharacters = ['\\', '(', ')', '[', ']', '*', '+', '$', '^', '?', '|', '{', '}'];
    var negativeEtalon = this.format(-1, format).replace(digitalRegExp, '1');
    specialCharacters.forEach(function (char) {
      negativeEtalon = negativeEtalon.replace(new RegExp("\\".concat(char), 'g'), "\\".concat(char));
    });
    negativeEtalon = negativeEtalon.replace(/ /g, '\\s');
    negativeEtalon = negativeEtalon.replace(/1/g, '.*');
    return new RegExp(negativeEtalon, 'g');
  },
  getSign: function getSign(text, format) {
    if (!format) {
      if (text.replace(/[^0-9-]/g, '').charAt(0) === '-') {
        return -1;
      }
      return 1;
    }
    var negativeEtalon = this.getNegativeEtalonRegExp(format);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function format(value, _format) {
    if (typeof value !== 'number') {
      return value;
    }
    if (typeof _format === 'number') {
      return value;
    }
    _format = _format && _format.formatter || _format;
    if (typeof _format === 'function') {
      return _format(value);
    }
    _format = this._normalizeFormat(_format);
    if (!_format.type) {
      _format.type = 'decimal';
    }
    var numberConfig = this._parseNumberFormatString(_format.type);
    if (!numberConfig) {
      var formatterConfig = this._getSeparators();
      formatterConfig.unlimitedIntegerDigits = _format.unlimitedIntegerDigits;
      return this.convertDigits((0, _number.getFormatter)(_format.type, formatterConfig)(value));
    }
    return this._formatNumber(value, numberConfig, _format);
  },
  parse: function parse(text, format) {
    if (!text) {
      return;
    }
    if (format && format.parser) {
      return format.parser(text);
    }
    text = this.convertDigits(text, true);
    if (format && typeof format !== 'string') {
      // Current parser functionality provided as-is and is independent of the most of capabilities of formatter.
      _errors.default.log('W0011');
    }
    var decimalSeparator = this.getDecimalSeparator();
    var regExp = new RegExp('[^0-9' + (0, _common.escapeRegExp)(decimalSeparator) + ']', 'g');
    var cleanedText = text.replace(regExp, '').replace(decimalSeparator, '.').replace(/\.$/g, '');
    if (cleanedText === '.' || cleanedText === '') {
      return null;
    }
    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }
    var parsed = +cleanedText * this.getSign(text, format);
    format = this._normalizeFormat(format);
    var formatConfig = this._parseNumberFormatString(format.type);
    var power = formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.power;
    if (power) {
      if (power === 'auto') {
        var match = text.match(/\d(K|M|B|T)/);
        if (match) {
          power = Object.keys(LargeNumberFormatPostfixes).find(function (power) {
            return LargeNumberFormatPostfixes[power] === match[1];
          });
        }
      }
      parsed = parsed * Math.pow(10, 3 * power);
    }
    if ((formatConfig === null || formatConfig === void 0 ? void 0 : formatConfig.formatType) === 'percent') {
      parsed /= 100;
    }
    return parsed;
  },
  _calcSignificantDigits: function _calcSignificantDigits(text) {
    var _text$split = text.split('.'),
      _text$split2 = _slicedToArray(_text$split, 2),
      integer = _text$split2[0],
      fractional = _text$split2[1];
    var calcDigitsAfterLeadingZeros = function calcDigitsAfterLeadingZeros(digits) {
      var index = -1;
      for (var i = 0; i < digits.length; i++) {
        if (digits[i] !== '0') {
          index = i;
          break;
        }
      }
      return index > -1 ? digits.length - index : 0;
    };
    var result = 0;
    if (integer) {
      result += calcDigitsAfterLeadingZeros(integer.split(''));
    }
    if (fractional) {
      result += calcDigitsAfterLeadingZeros(fractional.split('').reverse());
    }
    return result;
  }
});
numberLocalization.inject(_currency.default);
if (hasIntl) {
  numberLocalization.inject(_number2.default);
}
var _default = numberLocalization;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44592:
/***/ (function(module, exports) {



exports["default"] = void 0;
var _default = function _default(currencySymbol, accountingFormat) {
  if (!accountingFormat) {
    return;
  }
  var encodedCurrencySymbol = currencySymbol;
  if (typeof currencySymbol === 'string') {
    encodedCurrencySymbol = '';
    for (var i = 0; i < currencySymbol.length; i++) {
      if (currencySymbol[i] !== '$') {
        encodedCurrencySymbol += '\\';
      }
      encodedCurrencySymbol += currencySymbol[i];
    }
  }
  var encodeSymbols = {
    '.00': '{0}',
    '\'': '\\\'',
    '\\(': '\\(',
    '\\)': '\\)',
    ' ': '\\ ',
    '"': '&quot;',
    '\\': encodedCurrencySymbol
  };
  var result = accountingFormat.split(';');
  for (var _i = 0; _i < result.length; _i++) {
    for (var symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result[_i] = result[_i].replace(new RegExp(symbol, 'g'), encodeSymbols[symbol]);
      }
    }
  }
  return result.length === 2 ? result[0] + '_);' + result[1] : result[0];
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49198:
/***/ (function(module, exports) {



exports["default"] = void 0;
/* eslint-disable import/no-commonjs */
var PARENT_LOCALE_SEPARATOR = '-';
var _default = function _default(parentLocales, locale) {
  var parentLocale = parentLocales[locale];
  if (parentLocale) {
    return parentLocale !== 'root' && parentLocale;
  }
  return locale.substr(0, locale.lastIndexOf(PARENT_LOCALE_SEPARATOR));
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97360:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.toFixed = toFixed;
var _math = __webpack_require__(60810);
var DECIMAL_BASE = 10;
function roundByAbs(value) {
  var valueSign = (0, _math.sign)(value);
  return valueSign * Math.round(Math.abs(value));
}
function adjustValue(value, precision) {
  var precisionMultiplier = Math.pow(DECIMAL_BASE, precision);
  var intermediateValue = (0, _math.multiplyInExponentialForm)(value, precision);
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value, precision) {
  var valuePrecision = precision || 0;
  var adjustedValue = valuePrecision > 0 ? adjustValue.apply(void 0, arguments) : value;
  return adjustedValue.toFixed(valuePrecision);
}

/***/ }),

/***/ 4928:
/***/ (function(__unused_webpack_module, exports) {



exports.hideCallback = void 0;
var hideCallback = function () {
  var callbacks = [];
  return {
    add: function add(callback) {
      if (!callbacks.includes(callback)) {
        callbacks.push(callback);
      }
    },
    remove: function remove(callback) {
      var indexOfCallback = callbacks.indexOf(callback);
      if (indexOfCallback !== -1) {
        callbacks.splice(indexOfCallback, 1);
      }
    },
    fire: function fire() {
      var callback = callbacks.pop();
      var result = !!callback;
      if (result) {
        callback();
      }
      return result;
    },
    hasCallback: function hasCallback() {
      return callbacks.length > 0;
    }
  };
}();
exports.hideCallback = hideCallback;

/***/ }),

/***/ 60628:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _hide_callback = __webpack_require__(4928);
function _default() {
  return _hide_callback.hideCallback.fire();
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88185:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.p = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _extend = __webpack_require__(13306);
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _support = __webpack_require__(60137);
var _style = __webpack_require__(80968);
var _devices = _interopRequireDefault(__webpack_require__(20530));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var initMobileViewport = function initMobileViewport(options) {
  options = (0, _extend.extend)({}, options);
  var realDevice = _devices.default.real();
  var allowZoom = options.allowZoom;
  var allowPan = options.allowPan;
  var allowSelection = 'allowSelection' in options ? options.allowSelection : realDevice.platform === 'generic';
  var metaSelector = 'meta[name=viewport]';
  if (!(0, _renderer.default)(metaSelector).length) {
    (0, _renderer.default)('<meta>').attr('name', 'viewport').appendTo('head');
  }
  var metaVerbs = ['width=device-width'];
  var msTouchVerbs = [];
  if (allowZoom) {
    msTouchVerbs.push('pinch-zoom');
  } else {
    metaVerbs.push('initial-scale=1.0', 'maximum-scale=1.0, user-scalable=no');
  }
  if (allowPan) {
    msTouchVerbs.push('pan-x', 'pan-y');
  }
  if (!allowPan && !allowZoom) {
    (0, _renderer.default)('html, body').css({
      'msContentZooming': 'none',
      'msUserSelect': 'none',
      'overflow': 'hidden'
    });
  } else {
    (0, _renderer.default)('html').css('msOverflowStyle', '-ms-autohiding-scrollbar');
  }
  if (!allowSelection && (0, _support.supportProp)('userSelect')) {
    (0, _renderer.default)('.dx-viewport').css((0, _style.styleProp)('userSelect'), 'none');
  }
  (0, _renderer.default)(metaSelector).attr('content', metaVerbs.join());
  (0, _renderer.default)('html').css('msTouchAction', msTouchVerbs.join(' ') || 'none');
  realDevice = _devices.default.real();
  if (_support.touch) {
    _events_engine.default.off(_dom_adapter.default.getDocument(), '.dxInitMobileViewport');
    _events_engine.default.on(_dom_adapter.default.getDocument(), 'dxpointermove.dxInitMobileViewport', function (e) {
      var count = e.pointers.length;
      var isTouchEvent = e.pointerType === 'touch';
      var zoomDisabled = !allowZoom && count > 1;
      var panDisabled = !allowPan && count === 1 && !e.isScrollingEvent;
      if (isTouchEvent && (zoomDisabled || panDisabled)) {
        e.preventDefault();
      }
    });
  }
  if (realDevice.ios) {
    var isPhoneGap = _dom_adapter.default.getLocation().protocol === 'file:';
    if (!isPhoneGap) {
      // NOTE: fix app size after device rotation in Safari when keyboard was shown
      _resize_callbacks.default.add(function () {
        var windowWidth = (0, _size.getWidth)(window);
        (0, _size.setWidth)((0, _renderer.default)('body'), windowWidth);
      });
    }
  }
  if (realDevice.android) {
    _resize_callbacks.default.add(function () {
      setTimeout(function () {
        var activeElement = _dom_adapter.default.getActiveElement();
        activeElement.scrollIntoViewIfNeeded ? activeElement.scrollIntoViewIfNeeded() : activeElement.scrollIntoView(false);
      });
    });
  }
};
exports.p = initMobileViewport;

/***/ }),

/***/ 44194:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "exportDataGrid", ({
  enumerable: true,
  get: function get() {
    return _export_data_grid.exportDataGrid;
  }
}));
Object.defineProperty(exports, "exportDataGridWithAutoTable", ({
  enumerable: true,
  get: function get() {
    return _export_data_grid2.exportDataGrid;
  }
}));
Object.defineProperty(exports, "exportGantt", ({
  enumerable: true,
  get: function get() {
    return _export_gantt.exportGantt;
  }
}));
var _export_data_grid = __webpack_require__(654);
var _export_data_grid2 = __webpack_require__(83152);
var _export_gantt = __webpack_require__(29982);

/***/ }),

/***/ 27135:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _inferno = __webpack_require__(65414);
var _keyboard_processor = _interopRequireDefault(__webpack_require__(51661));
var _inferno_renderer = _interopRequireDefault(__webpack_require__(15334));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _extend = __webpack_require__(13306);
var _element = __webpack_require__(6415);
var _type = __webpack_require__(35922);
var _template_wrapper = __webpack_require__(93407);
var _update_props_immutable = __webpack_require__(36583);
__webpack_require__(95429);
__webpack_require__(91633);
__webpack_require__(24028);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var setDefaultOptionValue = function setDefaultOptionValue(options, defaultValueGetter) {
  return function (name) {
    if (Object.prototype.hasOwnProperty.call(options, name) && options[name] === undefined) {
      options[name] = defaultValueGetter(name);
    }
  };
};
var ComponentWrapper = /*#__PURE__*/function (_DOMComponent) {
  _inheritsLoose(ComponentWrapper, _DOMComponent);
  function ComponentWrapper(element, options) {
    var _this;
    _this = _DOMComponent.call(this, element, options) || this;
    _this._shouldRaiseContentReady = false;
    _this.validateKeyDownHandler();
    return _this;
  }
  var _proto = ComponentWrapper.prototype;
  _proto.validateKeyDownHandler = function validateKeyDownHandler() {
    var supportedKeyNames = this.getSupportedKeyNames();
    var hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    var hasComponentKeyDownMethod = typeof this._viewComponent.prototype.keyDown === 'function';
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  };
  _proto._checkContentReadyOption = function _checkContentReadyOption(fullName) {
    var contentReadyOptions = this._getContentReadyOptions().reduce(function (options, name) {
      options[name] = true;
      return options;
    }, {});
    this._checkContentReadyOption = function (optionName) {
      return !!contentReadyOptions[optionName];
    };
    return this._checkContentReadyOption(fullName);
  };
  _proto._getContentReadyOptions = function _getContentReadyOptions() {
    return ['rtlEnabled'];
  };
  _proto._fireContentReady = function _fireContentReady() {
    this._actionsMap.onContentReady({});
  };
  _proto._getDefaultOptions = function _getDefaultOptions() {
    var _this2 = this;
    var viewDefaultProps = this._getViewComponentDefaultProps();
    return (0, _extend.extend)(true, _DOMComponent.prototype._getDefaultOptions.call(this), viewDefaultProps, this._propsInfo.twoWay.reduce(function (options, _ref) {
      var _ref2 = _slicedToArray(_ref, 3),
        name = _ref2[0],
        defaultName = _ref2[1],
        eventName = _ref2[2];
      return _extends({}, options, {
        [name]: viewDefaultProps[defaultName],
        [eventName]: function (value) {
          return _this2.option(name, value);
        }
      });
    }, {}), this._propsInfo.templates.reduce(function (options, name) {
      return _extends({}, options, {
        [name]: null
      });
    }, {}));
  };
  _proto._getUnwrappedOption = function _getUnwrappedOption() {
    var _this3 = this;
    var unwrappedProps = {};
    Object.keys(this.option()).forEach(function (key) {
      unwrappedProps[key] = _this3.option(key);
    });
    return unwrappedProps;
  };
  _proto._initializeComponent = function _initializeComponent() {
    var _this$_templateManage,
      _this4 = this;
    _DOMComponent.prototype._initializeComponent.call(this);
    (_this$_templateManage = this._templateManager) === null || _this$_templateManage === void 0 ? void 0 : _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    var optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach(function (template) {
      _this4._componentTemplates[template] = _this4._createTemplateComponent(_this4._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach(function (name) {
      return _this4._addAction(name);
    });
    this._viewRef = (0, _inferno.createRef)();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  };
  _proto._initMarkup = function _initMarkup() {
    var props = this.getProps();
    this._renderWrapper(props);
  };
  _proto._renderWrapper = function _renderWrapper(props) {
    var containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      _inferno_renderer.default.onPreRender();
    }
    _inferno_renderer.default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      _inferno_renderer.default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  };
  _proto._silent = function _silent(name, value) {
    this._options.silent(name, value);
  };
  _proto._render = function _render() {};
  _proto._removeWidget = function _removeWidget() {
    _inferno_renderer.default.remove(this.$element()[0]);
  };
  _proto._dispose = function _dispose() {
    this._removeWidget();
    _DOMComponent.prototype._dispose.call(this);
  };
  _proto._getAdditionalActionConfigs = function _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ['disabled', 'readOnly']
      }
    };
  };
  _proto._getAdditionalProps = function _getAdditionalProps() {
    return [];
  };
  _proto._patchOptionValues = function _patchOptionValues(options) {
    var _this5 = this;
    var _this$_propsInfo = this._propsInfo,
      allowNull = _this$_propsInfo.allowNull,
      elements = _this$_propsInfo.elements,
      props = _this$_propsInfo.props,
      twoWay = _this$_propsInfo.twoWay;
    var viewDefaultProps = this._getViewComponentDefaultProps();
    var defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    var defaultOptions = this._getDefaultOptions();
    var children = options.children,
      onKeyboardHandled = options.onKeyboardHandled,
      ref = options.ref;
    var onKeyDown = onKeyboardHandled ? function (_, event_options) {
      onKeyboardHandled(event_options);
    } : undefined;
    var widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [].concat(_toConsumableArray(props), _toConsumableArray(this._getAdditionalProps())).forEach(function (propName) {
      if (Object.prototype.hasOwnProperty.call(options, propName)) {
        widgetProps[propName] = options[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue(widgetProps, function () {
      return null;
    }));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, function (name) {
      return defaultOptions[name];
    }));
    twoWay.forEach(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        defaultName = _ref4[1];
      setDefaultOptionValue(widgetProps, function () {
        return defaultOptions[defaultName];
      })(name);
    });
    elements.forEach(function (name) {
      if (name in widgetProps) {
        var value = widgetProps[name];
        if ((0, _type.isRenderer)(value)) {
          widgetProps[name] = _this5._patchElementParam(value);
        }
      }
    });
    return widgetProps;
  };
  _proto.getSupportedKeyNames = function getSupportedKeyNames() {
    return [];
  };
  _proto.prepareStyleProp = function prepareStyleProp(props) {
    if (typeof props.style === 'string') {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  };
  _proto.getProps = function getProps() {
    var _this6 = this,
      _this$elementAttr$cla,
      _elementAttr$class;
    var _this$option = this.option(),
      elementAttr = _this$option.elementAttr;
    var options = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach(function (template) {
      options[template] = _this6._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options, this.elementAttr, elementAttr, {
      className: [].concat(_toConsumableArray(((_this$elementAttr$cla = this.elementAttr.class) !== null && _this$elementAttr$cla !== void 0 ? _this$elementAttr$cla : '').split(' ')), _toConsumableArray(((_elementAttr$class = elementAttr === null || elementAttr === void 0 ? void 0 : elementAttr.class) !== null && _elementAttr$class !== void 0 ? _elementAttr$class : '').split(' '))).filter(function (c, i, a) {
        return c && a.indexOf(c) === i;
      }).join(' ').trim(),
      class: ''
    }, this._actionsMap));
  };
  _proto._getActionConfigs = function _getActionConfigs() {
    return {};
  };
  _proto._getActionConfigsFull = function _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  };
  _proto.getDefaultTemplates = function getDefaultTemplates() {
    var defaultTemplates = Object.values(this._templatesInfo);
    var result = {};
    defaultTemplates.forEach(function (template) {
      result[template] = 'dx-renovation-template-mock';
    });
    return result;
  };
  _proto._optionsWithDefaultTemplates = function _optionsWithDefaultTemplates(options) {
    var templateOptions = Object.entries(this._templatesInfo).reduce(function (result, _ref5) {
      var _options$templateName;
      var _ref6 = _slicedToArray(_ref5, 2),
        templateName = _ref6[0],
        templateValue = _ref6[1];
      return _extends({}, result, {
        [templateName]: (_options$templateName = options[templateName]) !== null && _options$templateName !== void 0 ? _options$templateName : templateValue
      });
    }, {});
    return _extends({}, options, templateOptions);
  };
  _proto._init = function _init() {
    _DOMComponent.prototype._init.call(this);
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  };
  _proto._createDefaultKeyHandlers = function _createDefaultKeyHandlers() {
    var _this7 = this;
    var result = {};
    var keys = this.getSupportedKeyNames();
    keys.forEach(function (key) {
      result[key] = function (e) {
        return _this7.viewRef.keyDown(_keyboard_processor.default.createKeyDownOptions(e));
      };
    });
    return result;
  };
  _proto._addAction = function _addAction(event, actionToAdd) {
    var action = actionToAdd;
    if (!action) {
      var actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = function action(actArgs) {
        Object.keys(actArgs).forEach(function (name) {
          if ((0, _type.isDefined)(actArgs[name]) && _dom_adapter.default.isNode(actArgs[name])) {
            actArgs[name] = (0, _element.getPublicElement)((0, _renderer.default)(actArgs[name]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  };
  _proto._optionChanged = function _optionChanged(option) {
    var fullName = option.fullName,
      name = option.name,
      previousValue = option.previousValue,
      value = option.value;
    (0, _update_props_immutable.updatePropsImmutable)(this._props, this.option(), name, fullName);
    if (this._propsInfo.templates.includes(name) && value !== previousValue) {
      this._componentTemplates[name] = this._createTemplateComponent(value);
    }
    if (name && this._getActionConfigsFull()[name]) {
      this._addAction(name);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    _DOMComponent.prototype._optionChanged.call(this, option);
    this._invalidate();
  };
  _proto._extractDefaultSlot = function _extractDefaultSlot() {
    if (this.option('_hasAnonymousTemplateContent')) {
      return _inferno_renderer.default.createElement(_template_wrapper.TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  };
  _proto._createTemplateComponent = function _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return undefined;
    }
    var template = this._getTemplate(templateOption);
    if ((0, _type.isString)(template) && template === 'dx-renovation-template-mock') {
      return undefined;
    }
    var templateWrapper = function templateWrapper(model) {
      return _inferno_renderer.default.createElement(_template_wrapper.TemplateWrapper, (0, _template_wrapper.buildTemplateArgs)(model, template));
    };
    return templateWrapper;
  };
  _proto._wrapKeyDownHandler = function _wrapKeyDownHandler(initialHandler) {
    var _this8 = this;
    return function (options) {
      var keyName = options.keyName,
        originalEvent = options.originalEvent,
        which = options.which;
      var keys = _this8.customKeyHandlers;
      var func = keys[keyName] || keys[which];
      if (func !== undefined) {
        var handler = func.bind(_this8);
        var result = handler(originalEvent, options);
        if (!result) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return initialHandler === null || initialHandler === void 0 ? void 0 : initialHandler(originalEvent, options);
    };
  };
  _proto._toPublicElement = function _toPublicElement(element) {
    return (0, _element.getPublicElement)((0, _renderer.default)(element));
  };
  _proto._patchElementParam = function _patchElementParam(value) {
    try {
      var result = (0, _renderer.default)(value);
      var element = result === null || result === void 0 ? void 0 : result.get(0);
      return element !== null && element !== void 0 && element.nodeType ? element : value;
    } catch (error) {
      return value;
    }
  };
  _proto.repaint = function repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  };
  _proto._supportedKeys = function _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  };
  _proto.registerKeyHandler = function registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  };
  _proto.setAria = function setAria(name, value) {
    this._aria[name] = value;
    this._initMarkup();
  };
  _proto._getViewComponentDefaultProps = function _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  };
  _createClass(ComponentWrapper, [{
    key: "_propsInfo",
    get: function get() {
      return {
        allowNull: [],
        twoWay: [],
        elements: [],
        templates: [],
        props: []
      };
    }
  }, {
    key: "viewRef",
    get: function get() {
      var _this$_viewRef;
      return (_this$_viewRef = this._viewRef) === null || _this$_viewRef === void 0 ? void 0 : _this$_viewRef.current;
    }
  }, {
    key: "elementAttr",
    get: function get() {
      var _this9 = this;
      var element = this.$element()[0];
      if (!this._elementAttr) {
        var attributes = element.attributes;
        var attrs = Array.from(attributes).filter(function (attr) {
          var _attributes$attr$name;
          return !_this9._propsInfo.templates.includes(attr.name) && ((_attributes$attr$name = attributes[attr.name]) === null || _attributes$attr$name === void 0 ? void 0 : _attributes$attr$name.specified);
        }).reduce(function (result, _ref7) {
          var name = _ref7.name,
            value = _ref7.value;
          var updatedAttributes = result;
          var isDomAttr = (name in element);
          updatedAttributes[name] = value === '' && isDomAttr ? element[name] : value;
          return updatedAttributes;
        }, {});
        this._elementAttr = attrs;
        this._storedClasses = element.getAttribute('class') || '';
      }
      var elemStyle = element.style;
      var style = {};
      for (var i = 0; i < elemStyle.length; i += 1) {
        style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
      }
      this._elementAttr.style = style;
      this._elementAttr.class = this._storedClasses;
      return this._elementAttr;
    }
  }, {
    key: "_templatesInfo",
    get: function get() {
      return {};
    }
  }]);
  return ComponentWrapper;
}(_dom_component.default);
ComponentWrapper.IS_RENOVATED_WIDGET = false;
var _default = ComponentWrapper;
exports["default"] = _default;
ComponentWrapper.IS_RENOVATED_WIDGET = true;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 48384:
/***/ (function(__unused_webpack_module, exports) {



exports.recordMutations = recordMutations;
function isChildNode(node) {
  return typeof node.remove === 'function';
}
function revertMutation(_ref) {
  var addedNodes = _ref.addedNodes,
    type = _ref.type;
  switch (type) {
    case 'childList':
      addedNodes.forEach(function (n) {
        return isChildNode(n) && n.remove();
      });
      break;
    default:
      break;
  }
}
function recordMutations(target, func) {
  var observer = new MutationObserver(function () {});
  observer.observe(target, {
    childList: true,
    subtree: false
  });
  func();
  var mutations = observer.takeRecords();
  observer.disconnect();
  return function () {
    return mutations.forEach(revertMutation);
  };
}

/***/ }),

/***/ 93407:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.TemplateWrapper = void 0;
exports.buildTemplateArgs = buildTemplateArgs;
var _inferno = __webpack_require__(74219);
var _inferno2 = __webpack_require__(65414);
var _shallow_equals = __webpack_require__(33502);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _element = __webpack_require__(6415);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _mutations_recording = __webpack_require__(48384);
var _excluded = ["isEqual"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function isDxElementWrapper(element) {
  return !!element.toArray;
}
function buildTemplateArgs(model, template) {
  var _model$data;
  var args = {
    template,
    model: _extends({}, model)
  };
  var _ref = (_model$data = model.data) !== null && _model$data !== void 0 ? _model$data : {},
    isEqual = _ref.isEqual,
    data = _objectWithoutProperties(_ref, _excluded);
  if (isEqual) {
    args.model.data = data;
    args.isEqual = isEqual;
  }
  return args;
}
function buildTemplateContent(props, container) {
  var _props$model;
  var _ref2 = (_props$model = props.model) !== null && _props$model !== void 0 ? _props$model : {
      data: {}
    },
    data = _ref2.data,
    index = _ref2.index;
  if (data) {
    Object.keys(data).forEach(function (name) {
      if (data[name] && _dom_adapter.default.isNode(data[name])) {
        data[name] = (0, _element.getPublicElement)((0, _renderer.default)(data[name]));
      }
    });
  }
  var rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data
  } : {}, !props.transclude && Number.isFinite(index) ? {
    index
  } : {}));
  if (rendered === undefined) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [(0, _renderer.default)(rendered).get(0)];
}
var TemplateWrapper = /*#__PURE__*/function (_InfernoComponent) {
  _inheritsLoose(TemplateWrapper, _InfernoComponent);
  function TemplateWrapper(props) {
    var _this;
    _this = _InfernoComponent.call(this, props) || this;
    _this.cleanParent = _common.noop;
    _this.renderTemplate = _this.renderTemplate.bind(_assertThisInitialized(_this));
    return _this;
  }
  var _proto = TemplateWrapper.prototype;
  _proto.renderTemplate = function renderTemplate() {
    var _this2 = this;
    var node = (0, _inferno2.findDOMfromVNode)(this.$LI, true);
    var container = node.parentElement;
    this.cleanParent();
    this.cleanParent = (0, _mutations_recording.recordMutations)(container, function () {
      var content = buildTemplateContent(_this2.props, (0, _element.getPublicElement)((0, _renderer.default)(container)));
      if (content.length !== 0 && !(content.length === 1 && content[0] === container)) {
        node.after.apply(node, _toConsumableArray(content));
      }
    });
  };
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var _this$props = this.props,
      model = _this$props.model,
      template = _this$props.template;
    var isEqual = nextProps.isEqual,
      nextModel = nextProps.model,
      nextTemplate = nextProps.template;
    var equalityComparer = isEqual !== null && isEqual !== void 0 ? isEqual : _shallow_equals.shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!(0, _type.isDefined)(model) || !(0, _type.isDefined)(nextModel)) {
      return model !== nextModel;
    }
    var data = model.data,
      index = model.index;
    var nextData = nextModel.data,
      nextIndex = nextModel.index;
    if (index !== nextIndex) {
      return true;
    }
    return !equalityComparer(data, nextData);
  };
  _proto.createEffects = function createEffects() {
    return [new _inferno.InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  };
  _proto.updateEffects = function updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cleanParent();
  };
  _proto.render = function render() {
    return null;
  };
  return TemplateWrapper;
}(_inferno.InfernoComponent);
exports.TemplateWrapper = TemplateWrapper;

/***/ }),

/***/ 36583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.updatePropsImmutable = updatePropsImmutable;
var _type = __webpack_require__(35922);
var _data = __webpack_require__(47617);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function cloneObjectValue(value) {
  return Array.isArray(value) ? _toConsumableArray(value) : _extends({}, value);
}
function cloneObjectProp(value, prevValue, fullNameParts) {
  var result = fullNameParts.length > 0 && prevValue && value !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value);
  var name = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result[name] = cloneObjectProp(value[name], prevValue === null || prevValue === void 0 ? void 0 : prevValue[name], fullNameParts.slice(1));
  } else if (name) {
    if ((0, _type.isPlainObject)(value[name])) {
      result[name] = cloneObjectValue(value[name]);
    } else {
      result[name] = value[name];
    }
  }
  return result;
}
function updatePropsImmutable(props, option, name, fullName) {
  var currentPropsValue = option[name];
  var prevPropsValue = props[name];
  var result = props;
  if ((0, _type.isPlainObject)(currentPropsValue) || name !== fullName && Array.isArray(currentPropsValue)) {
    result[name] = cloneObjectProp(currentPropsValue, prevPropsValue, (0, _data.getPathParts)(fullName).slice(1));
  } else {
    result[name] = currentPropsValue;
  }
}

/***/ }),

/***/ 25050:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _toMilliseconds = __webpack_require__(78503);
Object.keys(_toMilliseconds).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _toMilliseconds[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _toMilliseconds[key];
    }
  });
});

/***/ }),

/***/ 78503:
/***/ (function(__unused_webpack_module, exports) {



exports.toMilliseconds = toMilliseconds;
var timeIntervals = {
  millisecond: 1,
  second: 1000,
  minute: 1000 * 60,
  hour: 1000 * 60 * 60,
  day: 1000 * 60 * 60 * 24,
  week: 1000 * 60 * 60 * 24 * 7,
  month: 1000 * 60 * 60 * 24 * 30,
  quarter: 1000 * 60 * 60 * 24 * 30 * 3,
  year: 1000 * 60 * 60 * 24 * 365
};
function toMilliseconds(value) {
  return timeIntervals[value];
}

/***/ }),

/***/ 23842:
/***/ (function(__unused_webpack_module, exports) {



exports.VALIDATE_WHEEL_TIMEOUT = exports.TopPocketState = exports.ShowScrollbarMode = exports.SCROLL_LINE_HEIGHT = exports.SCROLLVIEW_TOP_POCKET_CLASS = exports.SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = exports.SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = exports.SCROLLVIEW_REACHBOTTOM_CLASS = exports.SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = exports.SCROLLVIEW_PULLDOWN_TEXT_CLASS = exports.SCROLLVIEW_PULLDOWN_READY_CLASS = exports.SCROLLVIEW_PULLDOWN_LOADING_CLASS = exports.SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = exports.SCROLLVIEW_PULLDOWN_IMAGE_CLASS = exports.SCROLLVIEW_PULLDOWN = exports.SCROLLVIEW_CONTENT_CLASS = exports.SCROLLVIEW_BOTTOM_POCKET_CLASS = exports.SCROLLABLE_WRAPPER_CLASS = exports.SCROLLABLE_SIMULATED_CLASS = exports.SCROLLABLE_SCROLL_CONTENT_CLASS = exports.SCROLLABLE_SCROLL_CLASS = exports.SCROLLABLE_SCROLLBAR_SIMULATED = exports.SCROLLABLE_SCROLLBAR_CLASS = exports.SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = exports.SCROLLABLE_SCROLLBARS_HIDDEN = exports.SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = exports.SCROLLABLE_DISABLED_CLASS = exports.SCROLLABLE_CONTENT_CLASS = exports.SCROLLABLE_CONTAINER_CLASS = exports.PULLDOWN_ICON_CLASS = exports.KEY_CODES = exports.HOVER_ENABLED_STATE = exports.HIDE_SCROLLBAR_TIMEOUT = exports.DIRECTION_VERTICAL = exports.DIRECTION_HORIZONTAL = exports.DIRECTION_BOTH = void 0;
var SCROLL_LINE_HEIGHT = 40;
exports.SCROLL_LINE_HEIGHT = SCROLL_LINE_HEIGHT;
var DIRECTION_VERTICAL = 'vertical';
exports.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
var DIRECTION_HORIZONTAL = 'horizontal';
exports.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
var DIRECTION_BOTH = 'both';
exports.DIRECTION_BOTH = DIRECTION_BOTH;
var SCROLLABLE_SIMULATED_CLASS = 'dx-scrollable-simulated';
exports.SCROLLABLE_SIMULATED_CLASS = SCROLLABLE_SIMULATED_CLASS;
var SCROLLABLE_CONTENT_CLASS = 'dx-scrollable-content';
exports.SCROLLABLE_CONTENT_CLASS = SCROLLABLE_CONTENT_CLASS;
var SCROLLABLE_WRAPPER_CLASS = 'dx-scrollable-wrapper';
exports.SCROLLABLE_WRAPPER_CLASS = SCROLLABLE_WRAPPER_CLASS;
var SCROLLABLE_CONTAINER_CLASS = 'dx-scrollable-container';
exports.SCROLLABLE_CONTAINER_CLASS = SCROLLABLE_CONTAINER_CLASS;
var SCROLLABLE_DISABLED_CLASS = 'dx-scrollable-disabled';
exports.SCROLLABLE_DISABLED_CLASS = SCROLLABLE_DISABLED_CLASS;
var SCROLLABLE_SCROLLBAR_SIMULATED = 'dx-scrollable-scrollbar-simulated';
exports.SCROLLABLE_SCROLLBAR_SIMULATED = SCROLLABLE_SCROLLBAR_SIMULATED;
var SCROLLABLE_SCROLLBARS_HIDDEN = 'dx-scrollable-scrollbars-hidden';
exports.SCROLLABLE_SCROLLBARS_HIDDEN = SCROLLABLE_SCROLLBARS_HIDDEN;
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = 'dx-scrollable-scrollbars-alwaysvisible';
exports.SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE;
var SCROLLABLE_SCROLLBAR_CLASS = 'dx-scrollable-scrollbar';
exports.SCROLLABLE_SCROLLBAR_CLASS = SCROLLABLE_SCROLLBAR_CLASS;
var SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = 'dx-scrollable-scrollbar-active';
exports.SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = SCROLLABLE_SCROLLBAR_ACTIVE_CLASS;
var SCROLLABLE_SCROLL_CLASS = 'dx-scrollable-scroll';
exports.SCROLLABLE_SCROLL_CLASS = SCROLLABLE_SCROLL_CLASS;
var SCROLLABLE_SCROLL_CONTENT_CLASS = 'dx-scrollable-scroll-content';
exports.SCROLLABLE_SCROLL_CONTENT_CLASS = SCROLLABLE_SCROLL_CONTENT_CLASS;
var HOVER_ENABLED_STATE = 'dx-scrollbar-hoverable';
exports.HOVER_ENABLED_STATE = HOVER_ENABLED_STATE;
var SCROLLVIEW_CONTENT_CLASS = 'dx-scrollview-content';
exports.SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CONTENT_CLASS;
var SCROLLVIEW_TOP_POCKET_CLASS = 'dx-scrollview-top-pocket';
exports.SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_TOP_POCKET_CLASS;
var SCROLLVIEW_PULLDOWN = 'dx-scrollview-pull-down';
exports.SCROLLVIEW_PULLDOWN = SCROLLVIEW_PULLDOWN;
var SCROLLVIEW_PULLDOWN_LOADING_CLASS = 'dx-scrollview-pull-down-loading';
exports.SCROLLVIEW_PULLDOWN_LOADING_CLASS = SCROLLVIEW_PULLDOWN_LOADING_CLASS;
var SCROLLVIEW_PULLDOWN_READY_CLASS = 'dx-scrollview-pull-down-ready';
exports.SCROLLVIEW_PULLDOWN_READY_CLASS = SCROLLVIEW_PULLDOWN_READY_CLASS;
var SCROLLVIEW_PULLDOWN_IMAGE_CLASS = 'dx-scrollview-pull-down-image';
exports.SCROLLVIEW_PULLDOWN_IMAGE_CLASS = SCROLLVIEW_PULLDOWN_IMAGE_CLASS;
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
exports.SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = SCROLLVIEW_PULLDOWN_INDICATOR_CLASS;
var SCROLLVIEW_PULLDOWN_TEXT_CLASS = 'dx-scrollview-pull-down-text';
exports.SCROLLVIEW_PULLDOWN_TEXT_CLASS = SCROLLVIEW_PULLDOWN_TEXT_CLASS;
var SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = 'dx-scrollview-pull-down-text-visible';
exports.SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS;
var PULLDOWN_ICON_CLASS = 'dx-icon-pulldown';
exports.PULLDOWN_ICON_CLASS = PULLDOWN_ICON_CLASS;
var SCROLLVIEW_BOTTOM_POCKET_CLASS = 'dx-scrollview-bottom-pocket';
exports.SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_BOTTOM_POCKET_CLASS;
var SCROLLVIEW_REACHBOTTOM_CLASS = 'dx-scrollview-scrollbottom';
exports.SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS;
var SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = 'dx-scrollview-scrollbottom-indicator';
exports.SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS;
var SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = 'dx-scrollview-scrollbottom-text';
exports.SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_TEXT_CLASS;
var TopPocketState = {
  STATE_RELEASED: 0,
  STATE_READY: 1,
  STATE_REFRESHING: 2,
  STATE_LOADING: 3,
  STATE_TOUCHED: 4,
  STATE_PULLED: 5
};
exports.TopPocketState = TopPocketState;
var ShowScrollbarMode = {
  HOVER: 'onHover',
  ALWAYS: 'always',
  NEVER: 'never',
  SCROLL: 'onScroll'
};
exports.ShowScrollbarMode = ShowScrollbarMode;
var KEY_CODES = {
  PAGE_UP: 'pageUp',
  PAGE_DOWN: 'pageDown',
  END: 'end',
  HOME: 'home',
  LEFT: 'leftArrow',
  UP: 'upArrow',
  RIGHT: 'rightArrow',
  DOWN: 'downArrow'
};
exports.KEY_CODES = KEY_CODES;
var VALIDATE_WHEEL_TIMEOUT = 500;
exports.VALIDATE_WHEEL_TIMEOUT = VALIDATE_WHEEL_TIMEOUT;
var HIDE_SCROLLBAR_TIMEOUT = 500;
exports.HIDE_SCROLLBAR_TIMEOUT = HIDE_SCROLLBAR_TIMEOUT;

/***/ }),

/***/ 60650:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.getElementLocationInternal = getElementLocationInternal;
var _inflector = __webpack_require__(78008);
var _get_relative_offset = __webpack_require__(1515);
var _consts = __webpack_require__(23842);
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function getElementLocationInternal(targetElement, direction, containerElement, scrollOffset, offset) {
  var additionalOffset = _extends({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, offset);
  var isVertical = direction === _consts.DIRECTION_VERTICAL;
  var prop = isVertical ? 'top' : 'left';
  var inverseProp = isVertical ? 'bottom' : 'right';
  var dimension = isVertical ? 'height' : 'width';
  var containerOffsetSize = containerElement["offset".concat((0, _inflector.titleize)(dimension))];
  var containerClientSize = containerElement["client".concat((0, _inflector.titleize)(dimension))];
  var containerSize = containerElement.getBoundingClientRect()[dimension];
  var elementSize = targetElement.getBoundingClientRect()[dimension];
  var scale = 1;
  if (Math.abs(containerSize - containerOffsetSize) > 1) {
    scale = containerSize / containerOffsetSize;
  }
  var relativeElementOffset = (0, _get_relative_offset.getRelativeOffset)(_consts.SCROLLABLE_CONTENT_CLASS, targetElement)[prop] / scale;
  var containerScrollOffset = scrollOffset[prop];
  var relativeStartOffset = containerScrollOffset - relativeElementOffset + additionalOffset[prop];
  var relativeEndOffset = containerScrollOffset - relativeElementOffset - elementSize / scale + containerClientSize - additionalOffset[inverseProp];
  if (relativeStartOffset <= 0 && relativeEndOffset >= 0) {
    return containerScrollOffset;
  }
  return containerScrollOffset - (Math.abs(relativeStartOffset) > Math.abs(relativeEndOffset) ? relativeEndOffset : relativeStartOffset);
}

/***/ }),

/***/ 1515:
/***/ (function(__unused_webpack_module, exports) {



exports.getRelativeOffset = getRelativeOffset;
function getRelativeOffset(targetElementClass, sourceElement) {
  var offset = {
    left: 0,
    top: 0
  };
  var element = sourceElement;
  while ((_element = element) !== null && _element !== void 0 && _element.offsetParent && !element.classList.contains(targetElementClass)) {
    var _element;
    var parentElement = element.offsetParent;
    var elementRect = element.getBoundingClientRect();
    var parentElementRect = parentElement.getBoundingClientRect();
    offset.left += elementRect.left - parentElementRect.left;
    offset.top += elementRect.top - parentElementRect.top;
    element = element.offsetParent;
  }
  return offset;
}

/***/ }),

/***/ 33502:
/***/ (function(__unused_webpack_module, exports) {



exports.shallowEquals = void 0;
var shallowEquals = function shallowEquals(firstObject, secondObject) {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.keys(firstObject).every(function (key) {
    return firstObject[key] === secondObject[key];
  });
};
exports.shallowEquals = shallowEquals;

/***/ }),

/***/ 88673:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Z = void 0;
var _utils = _interopRequireDefault(__webpack_require__(32511));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var getTimeZones = _utils.default.getTimeZones;
exports.Z = getTimeZones;

/***/ }),

/***/ 97326:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var DataControllerMock = {
  load: function load() {
    return (0, _deferred.Deferred)().reject();
  },
  loadSingle: function loadSingle() {
    return (0, _deferred.Deferred)().reject();
  },
  loadFromStore: function loadFromStore() {
    return (0, _deferred.Deferred)().reject();
  },
  loadNextPage: function loadNextPage() {
    return (0, _deferred.Deferred)().reject();
  },
  loadOptions: _common.noop,
  userData: _common.noop,
  cancel: _common.noop,
  cancelAll: _common.noop,
  filter: _common.noop,
  addSearchFilter: _common.noop,
  group: _common.noop,
  paginate: _common.noop,
  pageSize: _common.noop,
  pageIndex: _common.noop,
  resetDataSourcePageIndex: _common.noop,
  totalCount: _common.noop,
  isLastPage: _common.noop,
  isLoading: _common.noop,
  isLoaded: _common.noop,
  searchValue: _common.noop,
  searchOperation: _common.noop,
  searchExpr: _common.noop,
  select: _common.noop,
  key: _common.noop,
  keyOf: _common.noop,
  store: _common.noop,
  items: _common.noop,
  applyMapFunction: _common.noop,
  getDataSource: _common.noop,
  reload: _common.noop,
  on: _common.noop,
  off: _common.noop
};
var DataController = /*#__PURE__*/function () {
  function DataController(dataSource) {
    if (!dataSource) {
      return DataControllerMock;
    }
    this._dataSource = dataSource;
  }
  var _proto = DataController.prototype;
  _proto.load = function load() {
    return this._dataSource.load();
  };
  _proto.loadSingle = function loadSingle(propName, propValue) {
    if (arguments.length < 2) {
      propValue = propName;
      propName = this.key();
    }
    return this._dataSource.loadSingle(propName, propValue);
  };
  _proto.loadFromStore = function loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  };
  _proto.loadNextPage = function loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  };
  _proto.loadOptions = function loadOptions() {
    return this._dataSource.loadOptions();
  };
  _proto.userData = function userData() {
    return this._dataSource._userData;
  };
  _proto.cancel = function cancel(operationId) {
    this._dataSource.cancel(operationId);
  };
  _proto.cancelAll = function cancelAll() {
    this._dataSource.cancelAll();
  };
  _proto.filter = function filter(_filter) {
    return this._dataSource.filter(_filter);
  };
  _proto.addSearchFilter = function addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  };
  _proto.group = function group(_group) {
    return this._dataSource.group(_group);
  };
  _proto.paginate = function paginate() {
    return this._dataSource.paginate();
  };
  _proto.pageSize = function pageSize() {
    return this._dataSource._pageSize;
  };
  _proto.pageIndex = function pageIndex(_pageIndex) {
    return this._dataSource.pageIndex(_pageIndex);
  };
  _proto.resetDataSourcePageIndex = function resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  };
  _proto.totalCount = function totalCount() {
    return this._dataSource.totalCount();
  };
  _proto.isLastPage = function isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  };
  _proto.isLoading = function isLoading() {
    return this._dataSource.isLoading();
  };
  _proto.isLoaded = function isLoaded() {
    return this._dataSource.isLoaded();
  };
  _proto.searchValue = function searchValue(value) {
    if (!arguments.length) {
      return this._dataSource.searchValue();
    }
    return this._dataSource.searchValue(value);
  };
  _proto.searchOperation = function searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  };
  _proto.searchExpr = function searchExpr(expr) {
    if (!arguments.length) {
      return this._dataSource.searchExpr();
    }
    return this._dataSource.searchExpr(expr);
  };
  _proto.select = function select() {
    var _this$_dataSource;
    return (_this$_dataSource = this._dataSource).select.apply(_this$_dataSource, arguments);
  };
  _proto.key = function key() {
    return this._dataSource.key();
  };
  _proto.keyOf = function keyOf(item) {
    return this.store().keyOf(item);
  };
  _proto.store = function store() {
    return this._dataSource.store();
  };
  _proto.items = function items() {
    return this._dataSource.items();
  };
  _proto.applyMapFunction = function applyMapFunction(data) {
    return this._dataSource._applyMapFunction(data);
  };
  _proto.getDataSource = function getDataSource() {
    return this._dataSource || null;
  };
  _proto.reload = function reload() {
    return this._dataSource.reload();
  };
  _proto.on = function on(event, handler) {
    this._dataSource.on(event, handler);
  };
  _proto.off = function off(event, handler) {
    this._dataSource.off(event, handler);
  };
  return DataController;
}();
var _default = DataController;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 54778:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _iterator = __webpack_require__(95479);
var _public_component = __webpack_require__(9321);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INVISIBLE_STATE_CLASS = 'dx-state-invisible';
var DISABLED_STATE_CLASS = 'dx-state-disabled';
var ITEM_CONTENT_PLACEHOLDER_CLASS = 'dx-item-content-placeholder';
var forcibleWatcher = function forcibleWatcher(watchMethod, fn, callback) {
  var filteredCallback = function () {
    var oldValue;
    return function (value) {
      if (oldValue !== value) {
        callback(value, oldValue);
        oldValue = value;
      }
    };
  }();
  return {
    dispose: watchMethod(fn, filteredCallback),
    force: function force() {
      filteredCallback(fn());
    }
  };
};
var CollectionItem = _class.default.inherit({
  ctor: function ctor($element, options, rawData) {
    this._$element = $element;
    this._options = options;
    this._rawData = rawData;
    (0, _public_component.attachInstanceToElement)($element, this, this._dispose);
    this._render();
  },
  _render: function _render() {
    var $placeholder = (0, _renderer.default)('<div>').addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
    this._$element.append($placeholder);
    this._watchers = [];
    this._renderWatchers();
  },
  _renderWatchers: function _renderWatchers() {
    this._startWatcher('disabled', this._renderDisabled.bind(this));
    this._startWatcher('visible', this._renderVisible.bind(this));
  },
  _startWatcher: function _startWatcher(field, render) {
    var rawData = this._rawData;
    var exprGetter = this._options.fieldGetter(field);
    var watcher = forcibleWatcher(this._options.watchMethod(), function () {
      return exprGetter(rawData);
    }, function (value, oldValue) {
      this._dirty = true;
      render(value, oldValue);
    }.bind(this));
    this._watchers.push(watcher);
  },
  setDataField: function setDataField() {
    this._dirty = false;
    (0, _iterator.each)(this._watchers, function (_, watcher) {
      watcher.force();
    });
    if (this._dirty) {
      return true;
    }
  },
  _renderDisabled: function _renderDisabled(value, oldValue) {
    this._$element.toggleClass(DISABLED_STATE_CLASS, !!value);
    this._$element.attr('aria-disabled', !!value);
    this._updateOwnerFocus(value);
  },
  _updateOwnerFocus: function _updateOwnerFocus(isDisabled) {
    var ownerComponent = this._options.owner;
    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  },
  _renderVisible: function _renderVisible(value, oldValue) {
    this._$element.toggleClass(INVISIBLE_STATE_CLASS, value !== undefined && !value);
  },
  _dispose: function _dispose() {
    (0, _iterator.each)(this._watchers, function (_, watcher) {
      watcher.dispose();
    });
  }
});
CollectionItem.getInstance = function ($element) {
  return (0, _public_component.getInstanceByElement)($element, this);
};
var _default = CollectionItem;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 19982:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _common = __webpack_require__(20576);
var _template_manager = __webpack_require__(69697);
var _element = __webpack_require__(6415);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _action = _interopRequireDefault(__webpack_require__(62414));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _ui = _interopRequireDefault(__webpack_require__(14390));
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _data_helper = _interopRequireDefault(__webpack_require__(53305));
var _item = _interopRequireDefault(__webpack_require__(54778));
var _selectors = __webpack_require__(31421);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _hold = _interopRequireDefault(__webpack_require__(11699));
var _data = __webpack_require__(47617);
var _click = __webpack_require__(95429);
var _contextmenu = __webpack_require__(49166);
var _bindable_template = __webpack_require__(93280);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var COLLECTION_CLASS = 'dx-collection';
var ITEM_CLASS = 'dx-item';
var CONTENT_CLASS_POSTFIX = '-content';
var ITEM_CONTENT_PLACEHOLDER_CLASS = 'dx-item-content-placeholder';
var ITEM_DATA_KEY = 'dxItemData';
var ITEM_INDEX_KEY = 'dxItemIndex';
var ITEM_TEMPLATE_ID_PREFIX = 'tmpl-';
var ITEMS_OPTIONS_NAME = 'dxItem';
var SELECTED_ITEM_CLASS = 'dx-item-selected';
var ITEM_RESPONSE_WAIT_CLASS = 'dx-item-response-wait';
var EMPTY_COLLECTION = 'dx-empty-collection';
var TEMPLATE_WRAPPER_CLASS = 'dx-template-wrapper';
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var ANONYMOUS_TEMPLATE_NAME = 'item';
var FOCUS_UP = 'up';
var FOCUS_DOWN = 'down';
var FOCUS_LEFT = 'left';
var FOCUS_RIGHT = 'right';
var FOCUS_PAGE_UP = 'pageup';
var FOCUS_PAGE_DOWN = 'pagedown';
var FOCUS_LAST = 'last';
var FOCUS_FIRST = 'first';
var CollectionWidget = _ui.default.inherit({
  _activeStateUnit: '.' + ITEM_CLASS,
  _supportedKeys: function _supportedKeys() {
    var space = function space(e) {
      e.preventDefault();
      this._enterKeyHandler(e);
    };
    var move = function move(location, e) {
      if (!(0, _index.isCommandKeyPressed)(e)) {
        e.preventDefault();
        e.stopPropagation();
        this._moveFocus(location, e);
      }
    };
    return (0, _extend.extend)(this.callBase(), {
      space: space,
      enter: this._enterKeyHandler,
      leftArrow: move.bind(this, FOCUS_LEFT),
      rightArrow: move.bind(this, FOCUS_RIGHT),
      upArrow: move.bind(this, FOCUS_UP),
      downArrow: move.bind(this, FOCUS_DOWN),
      pageUp: move.bind(this, FOCUS_UP),
      pageDown: move.bind(this, FOCUS_DOWN),
      home: move.bind(this, FOCUS_FIRST),
      end: move.bind(this, FOCUS_LAST)
    });
  },
  _enterKeyHandler: function _enterKeyHandler(e) {
    var $itemElement = (0, _renderer.default)(this.option('focusedElement'));
    if (!$itemElement.length) {
      return;
    }
    var itemData = this._getItemData($itemElement);
    if (itemData !== null && itemData !== void 0 && itemData.onClick) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }
    this._itemClickHandler((0, _extend.extend)({}, e, {
      target: $itemElement.get(0),
      currentTarget: $itemElement.get(0)
    }));
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      /**
      * @name CollectionWidgetOptions.selectOnFocus
      * @type boolean
      * @hidden
      */
      selectOnFocus: false,
      /**
      * @name CollectionWidgetOptions.loopItemFocus
      * @type boolean
      * @hidden
      */
      loopItemFocus: true,
      items: [],
      itemTemplate: 'item',
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: _message.default.format('dxCollectionWidget-noDataText'),
      encodeNoDataText: false,
      dataSource: null,
      _dataController: null,
      _itemAttributes: {},
      itemTemplateProperty: 'template',
      focusOnSelectedItem: true,
      /**
      * @name CollectionWidgetOptions.focusedElement
      * @type DxElement
      * @default null
      * @hidden
      */
      focusedElement: null,
      displayExpr: undefined,
      disabledExpr: function disabledExpr(data) {
        return data ? data.disabled : undefined;
      },
      visibleExpr: function visibleExpr(data) {
        return data ? data.visible : undefined;
      }
    });
  },
  _init: function _init() {
    this._compileDisplayGetter();
    this._initDataController();
    this.callBase();
    this._cleanRenderedItems();
    this._refreshDataSource();
  },
  _compileDisplayGetter: function _compileDisplayGetter() {
    var displayExpr = this.option('displayExpr');
    this._displayGetter = displayExpr ? (0, _data.compileGetter)(this.option('displayExpr')) : undefined;
  },
  _initTemplates: function _initTemplates() {
    this._initItemsFromMarkup();
    this._initDefaultItemTemplate();
    this.callBase();
  },
  _getAnonymousTemplateName: function _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initDefaultItemTemplate: function _initDefaultItemTemplate() {
    var fieldsMap = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new _bindable_template.BindableTemplate(function ($container, data) {
        if ((0, _type.isPlainObject)(data)) {
          this._prepareDefaultItemTemplate(data, $container);
        } else {
          if (fieldsMap && (0, _type.isFunction)(fieldsMap.text)) {
            data = fieldsMap.text(data);
          }
          $container.text(String((0, _common.ensureDefined)(data, '')));
        }
      }.bind(this), this._getBindableFields(), this.option('integrationOptions.watchMethod'), fieldsMap)
    });
  },
  _getBindableFields: function _getBindableFields() {
    return ['text', 'html'];
  },
  _getFieldsMap: function _getFieldsMap() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
  },
  _prepareDefaultItemTemplate: function _prepareDefaultItemTemplate(data, $container) {
    if ((0, _type.isDefined)(data.text)) {
      $container.text(data.text);
    }
    if ((0, _type.isDefined)(data.html)) {
      $container.html(data.html);
    }
  },
  _initItemsFromMarkup: function _initItemsFromMarkup() {
    var _this = this;
    var rawItems = (0, _template_manager.findTemplates)(this.$element(), ITEMS_OPTIONS_NAME);
    if (!rawItems.length || this.option('items').length) {
      return;
    }
    var items = rawItems.map(function (_ref) {
      var element = _ref.element,
        options = _ref.options;
      var isTemplateRequired = /\S/.test(element.innerHTML) && !options.template;
      if (isTemplateRequired) {
        options.template = _this._prepareItemTemplate(element);
      } else {
        (0, _renderer.default)(element).remove();
      }
      return options;
    });
    this.option('items', items);
  },
  _prepareItemTemplate: function _prepareItemTemplate(item) {
    var templateId = ITEM_TEMPLATE_ID_PREFIX + new _guid.default();
    var $template = (0, _renderer.default)(item).detach().clone().removeAttr('data-options').addClass(TEMPLATE_WRAPPER_CLASS);
    this._saveTemplate(templateId, $template);
    return templateId;
  },
  _dataSourceOptions: function _dataSourceOptions() {
    return {
      paginate: false
    };
  },
  _cleanRenderedItems: function _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  },
  _focusTarget: function _focusTarget() {
    return this.$element();
  },
  _focusInHandler: function _focusInHandler(e) {
    this.callBase.apply(this, arguments);
    if (!this._isFocusTarget(e.target)) {
      return;
    }
    var $focusedElement = (0, _renderer.default)(this.option('focusedElement'));
    if ($focusedElement.length) {
      this._setFocusedItem($focusedElement);
    } else {
      var $activeItem = this._getActiveItem();
      if ($activeItem.length) {
        this.option('focusedElement', (0, _element.getPublicElement)($activeItem));
      }
    }
  },
  _focusOutHandler: function _focusOutHandler() {
    this.callBase.apply(this, arguments);
    var $target = (0, _renderer.default)(this.option('focusedElement'));
    this._updateFocusedItemState($target, false);
  },
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit);
  },
  _getActiveItem: function _getActiveItem(last) {
    var $focusedElement = (0, _renderer.default)(this.option('focusedElement'));
    if ($focusedElement.length) {
      return $focusedElement;
    }
    var index = this.option('focusOnSelectedItem') ? this.option('selectedIndex') : 0;
    var activeElements = this._getActiveElement();
    var lastIndex = activeElements.length - 1;
    if (index < 0) {
      index = last ? lastIndex : 0;
    }
    return activeElements.eq(index);
  },
  _moveFocus: function _moveFocus(location) {
    var $items = this._getAvailableItems();
    var $newTarget;
    switch (location) {
      case FOCUS_PAGE_UP:
      case FOCUS_UP:
        $newTarget = this._prevItem($items);
        break;
      case FOCUS_PAGE_DOWN:
      case FOCUS_DOWN:
        $newTarget = this._nextItem($items);
        break;
      case FOCUS_RIGHT:
        $newTarget = this.option('rtlEnabled') ? this._prevItem($items) : this._nextItem($items);
        break;
      case FOCUS_LEFT:
        $newTarget = this.option('rtlEnabled') ? this._nextItem($items) : this._prevItem($items);
        break;
      case FOCUS_FIRST:
        $newTarget = $items.first();
        break;
      case FOCUS_LAST:
        $newTarget = $items.last();
        break;
      default:
        return false;
    }
    if ($newTarget.length !== 0) {
      this.option('focusedElement', (0, _element.getPublicElement)($newTarget));
    }
  },
  _getVisibleItems: function _getVisibleItems($itemElements) {
    $itemElements = $itemElements || this._itemElements();
    return $itemElements.filter(':visible');
  },
  _getAvailableItems: function _getAvailableItems($itemElements) {
    return this._getVisibleItems($itemElements);
  },
  _prevItem: function _prevItem($items) {
    var $target = this._getActiveItem();
    var targetIndex = $items.index($target);
    var $last = $items.last();
    var $item = (0, _renderer.default)($items[targetIndex - 1]);
    var loop = this.option('loopItemFocus');
    if ($item.length === 0 && loop) {
      $item = $last;
    }
    return $item;
  },
  _nextItem: function _nextItem($items) {
    var $target = this._getActiveItem(true);
    var targetIndex = $items.index($target);
    var $first = $items.first();
    var $item = (0, _renderer.default)($items[targetIndex + 1]);
    var loop = this.option('loopItemFocus');
    if ($item.length === 0 && loop) {
      $item = $first;
    }
    return $item;
  },
  _selectFocusedItem: function _selectFocusedItem($target) {
    this.selectItem($target);
  },
  _updateFocusedItemState: function _updateFocusedItemState(target, isFocused, needCleanItemId) {
    var $target = (0, _renderer.default)(target);
    if ($target.length) {
      this._refreshActiveDescendant();
      this._refreshItemId($target, needCleanItemId);
      this._toggleFocusClass(isFocused, $target);
    }
    this._updateParentActiveDescendant();
  },
  _refreshActiveDescendant: function _refreshActiveDescendant($target) {
    this.setAria('activedescendant', (0, _type.isDefined)(this.option('focusedElement')) ? this.getFocusedItemId() : null, $target);
  },
  _refreshItemId: function _refreshItemId($target, needCleanItemId) {
    if (!needCleanItemId && this.option('focusedElement')) {
      this.setAria('id', this.getFocusedItemId(), $target);
    } else {
      this.setAria('id', null, $target);
    }
  },
  _isDisabled($element) {
    return $element && (0, _renderer.default)($element).attr('aria-disabled') === 'true';
  },
  _setFocusedItem: function _setFocusedItem($target) {
    if (!$target || !$target.length) {
      return;
    }
    this._updateFocusedItemState($target, true);
    this.onFocusedItemChanged(this.getFocusedItemId());
    var _this$option = this.option(),
      selectOnFocus = _this$option.selectOnFocus;
    var isTargetDisabled = this._isDisabled($target);
    if (selectOnFocus && !isTargetDisabled) {
      this._selectFocusedItem($target);
    }
  },
  _findItemElementByItem: function _findItemElementByItem(item) {
    var result = (0, _renderer.default)();
    var that = this;
    this.itemElements().each(function () {
      var $item = (0, _renderer.default)(this);
      if ($item.data(that._itemDataKey()) === item) {
        result = $item;
        return false;
      }
    });
    return result;
  },
  _getIndexByItem: function _getIndexByItem(item) {
    return this.option('items').indexOf(item);
  },
  _itemOptionChanged: function _itemOptionChanged(item, property, value, oldValue) {
    var $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value)) {
      this._refreshItem($item, item);
    }
    var isDisabling = property === 'disabled' && value;
    if (isDisabling) {
      this._resetItemFocus($item);
    }
  },
  _resetItemFocus($item) {
    if ($item.is(this.option('focusedElement'))) {
      this.option('focusedElement', null);
    }
  },
  _refreshItem: function _refreshItem($item) {
    var itemData = this._getItemData($item);
    var index = $item.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + index, itemData, null, $item);
  },
  _updateParentActiveDescendant: _common.noop,
  _optionChanged: function _optionChanged(args) {
    if (args.name === 'items') {
      var matches = args.fullName.match(ITEM_PATH_REGEX);
      if (matches && matches.length) {
        var property = matches[matches.length - 1];
        var itemPath = args.fullName.replace('.' + property, '');
        var item = this.option(itemPath);
        this._itemOptionChanged(item, property, args.value, args.previousValue);
        return;
      }
    }
    switch (args.name) {
      case 'items':
      case '_itemAttributes':
      case 'itemTemplateProperty':
      case 'useItemTextAsTitle':
        this._cleanRenderedItems();
        this._invalidate();
        break;
      case 'dataSource':
        this._refreshDataSource();
        this._renderEmptyMessage();
        break;
      case 'noDataText':
      case 'encodeNoDataText':
        this._renderEmptyMessage();
        break;
      case 'itemTemplate':
        this._invalidate();
        break;
      case 'onItemRendered':
        this._createItemRenderAction();
        break;
      case 'onItemClick':
        break;
      case 'onItemHold':
      case 'itemHoldTimeout':
        this._attachHoldEvent();
        break;
      case 'onItemContextMenu':
        this._attachContextMenuEvent();
        break;
      case 'onFocusedItemChanged':
        this.onFocusedItemChanged = this._createActionByOption('onFocusedItemChanged');
        break;
      case 'selectOnFocus':
      case 'loopItemFocus':
      case 'focusOnSelectedItem':
        break;
      case 'focusedElement':
        this._updateFocusedItemState(args.previousValue, false, true);
        this._setFocusedItem((0, _renderer.default)(args.value));
        break;
      case 'displayExpr':
        this._compileDisplayGetter();
        this._initDefaultItemTemplate();
        this._invalidate();
        break;
      case 'visibleExpr':
      case 'disabledExpr':
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  },
  _invalidate: function _invalidate() {
    this.option('focusedElement', null);
    return this.callBase.apply(this, arguments);
  },
  _loadNextPage: function _loadNextPage() {
    this._expectNextPageLoading();
    return this._dataController.loadNextPage();
  },
  _expectNextPageLoading: function _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  },
  _expectLastItemLoading: function _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  },
  _forgetNextPageLoading: function _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler(newItems) {
    var items = this.option('items');
    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;
      if (!this._isLastPage() || this._startIndexForAppendedItems !== -1) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }
      this._forgetNextPageLoading();
      this._refreshContent();
    } else {
      this.option('items', newItems.slice());
    }
  },
  _refreshContent: function _refreshContent() {
    this._prepareContent();
    this._renderContent();
  },
  _dataSourceLoadErrorHandler: function _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    this.option('items', this.option('items'));
  },
  _shouldAppendItems: function _shouldAppendItems() {
    return this._startIndexForAppendedItems != null && this._allowDynamicItemsAppend();
  },
  _allowDynamicItemsAppend: function _allowDynamicItemsAppend() {
    return false;
  },
  _clean: function _clean() {
    this._cleanFocusState();
    this._cleanItemContainer();
    this._inkRipple && delete this._inkRipple;
    this._resetActiveState();
  },
  _cleanItemContainer: function _cleanItemContainer() {
    (0, _renderer.default)(this._itemContainer()).empty();
  },
  _dispose: function _dispose() {
    this.callBase();
    clearTimeout(this._itemFocusTimeout);
  },
  _refresh: function _refresh() {
    this._cleanRenderedItems();
    this.callBase.apply(this, arguments);
  },
  _itemContainer: function _itemContainer() {
    return this.$element();
  },
  _itemClass: function _itemClass() {
    return ITEM_CLASS;
  },
  _itemContentClass: function _itemContentClass() {
    return this._itemClass() + CONTENT_CLASS_POSTFIX;
  },
  _selectedItemClass: function _selectedItemClass() {
    return SELECTED_ITEM_CLASS;
  },
  _itemResponseWaitClass: function _itemResponseWaitClass() {
    return ITEM_RESPONSE_WAIT_CLASS;
  },
  _itemSelector: function _itemSelector() {
    return '.' + this._itemClass();
  },
  _itemDataKey: function _itemDataKey() {
    return ITEM_DATA_KEY;
  },
  _itemIndexKey: function _itemIndexKey() {
    return ITEM_INDEX_KEY;
  },
  _itemElements: function _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  },
  _initMarkup: function _initMarkup() {
    this.callBase();
    this.onFocusedItemChanged = this._createActionByOption('onFocusedItemChanged');
    this.$element().addClass(COLLECTION_CLASS);
    this._prepareContent();
  },
  _prepareContent: (0, _common.deferRenderer)(function () {
    this._renderContentImpl();
  }),
  _renderContent: function _renderContent() {
    this._fireContentReadyAction();
  },
  _render: function _render() {
    this.callBase();
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
  },
  _getPointerEvent() {
    return _pointer.default.down;
  },
  _attachClickEvent() {
    var _this2 = this;
    var itemSelector = this._itemSelector();
    var pointerEvent = this._getPointerEvent();
    var clickEventNamespace = (0, _index.addNamespace)(_click.name, this.NAME);
    var pointerEventNamespace = (0, _index.addNamespace)(pointerEvent, this.NAME);
    var pointerAction = new _action.default(function (args) {
      var event = args.event;
      _this2._itemPointerDownHandler(event);
    });
    var clickEventCallback = function clickEventCallback(e) {
      return _this2._itemClickHandler(e);
    };
    var pointerEventCallback = function pointerEventCallback(e) {
      pointerAction.execute({
        element: (0, _renderer.default)(e.target),
        event: e
      });
    };
    _events_engine.default.off(this._itemContainer(), clickEventNamespace, itemSelector);
    _events_engine.default.off(this._itemContainer(), pointerEventNamespace, itemSelector);
    _events_engine.default.on(this._itemContainer(), clickEventNamespace, itemSelector, clickEventCallback);
    _events_engine.default.on(this._itemContainer(), pointerEventNamespace, itemSelector, pointerEventCallback);
  },
  _itemClickHandler: function _itemClickHandler(e, args, config) {
    this._itemDXEventHandler(e, 'onItemClick', args, config);
  },
  _itemPointerDownHandler: function _itemPointerDownHandler(e) {
    if (!this.option('focusStateEnabled')) {
      return;
    }
    this._itemFocusHandler = function () {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = null;
      if (e.isDefaultPrevented()) {
        return;
      }
      var $target = (0, _renderer.default)(e.target);
      var $closestItem = $target.closest(this._itemElements());
      var $closestFocusable = this._closestFocusable($target);
      if ($closestItem.length && this._isFocusTarget($closestFocusable === null || $closestFocusable === void 0 ? void 0 : $closestFocusable.get(0))) {
        this.option('focusedElement', (0, _element.getPublicElement)($closestItem));
      }
    }.bind(this);
    this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
  },
  _closestFocusable: function _closestFocusable($target) {
    if ($target.is(_selectors.focusable)) {
      return $target;
    } else {
      $target = $target.parent();
      while ($target.length && !_dom_adapter.default.isDocument($target.get(0)) && !_dom_adapter.default.isDocumentFragment($target.get(0))) {
        if ($target.is(_selectors.focusable)) {
          return $target;
        }
        $target = $target.parent();
      }
    }
  },
  _forcePointerDownFocus: function _forcePointerDownFocus() {
    this._itemFocusHandler && this._itemFocusHandler();
  },
  _updateFocusState: function _updateFocusState() {
    this.callBase.apply(this, arguments);
    this._forcePointerDownFocus();
  },
  _attachHoldEvent: function _attachHoldEvent() {
    var $itemContainer = this._itemContainer();
    var itemSelector = this._itemSelector();
    var eventName = (0, _index.addNamespace)(_hold.default.name, this.NAME);
    _events_engine.default.off($itemContainer, eventName, itemSelector);
    _events_engine.default.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  },
  _getHoldTimeout: function _getHoldTimeout() {
    return this.option('itemHoldTimeout');
  },
  _shouldFireHoldEvent: function _shouldFireHoldEvent() {
    return this.hasActionSubscription('onItemHold');
  },
  _itemHoldHandler: function _itemHoldHandler(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, 'onItemHold');
    } else {
      e.cancel = true;
    }
  },
  _attachContextMenuEvent: function _attachContextMenuEvent() {
    var $itemContainer = this._itemContainer();
    var itemSelector = this._itemSelector();
    var eventName = (0, _index.addNamespace)(_contextmenu.name, this.NAME);
    _events_engine.default.off($itemContainer, eventName, itemSelector);
    _events_engine.default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  },
  _shouldFireContextMenuEvent: function _shouldFireContextMenuEvent() {
    return this.hasActionSubscription('onItemContextMenu');
  },
  _itemContextMenuHandler: function _itemContextMenuHandler(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, 'onItemContextMenu');
    } else {
      e.cancel = true;
    }
  },
  _renderContentImpl: function _renderContentImpl() {
    var items = this.option('items') || [];
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
  },
  _renderItems: function _renderItems(items) {
    if (items.length) {
      (0, _iterator.each)(items, function (index, itemData) {
        this._renderItem(this._renderedItemsCount + index, itemData);
      }.bind(this));
    }
    this._renderEmptyMessage();
  },
  _getItemsContainer: function _getItemsContainer() {
    return this._itemContainer();
  },
  _setAttributes($element) {
    var attributes = _extends({}, this.option('_itemAttributes'));
    var customClassValue = attributes.class;
    if (customClassValue) {
      var currentClassValue = $element.get(0).className;
      attributes.class = [currentClassValue, customClassValue].join(' ');
    }
    $element.attr(attributes);
  },
  _renderItem: function _renderItem(index, itemData, $container, $itemToReplace) {
    var _index$item;
    var itemIndex = (_index$item = index === null || index === void 0 ? void 0 : index.item) !== null && _index$item !== void 0 ? _index$item : index;
    $container = $container || this._getItemsContainer();
    var $itemFrame = this._renderItemFrame(itemIndex, itemData, $container, $itemToReplace);
    this._setElementData($itemFrame, itemData, itemIndex);
    this._setAttributes($itemFrame);
    this._attachItemClickEvent(itemData, $itemFrame);
    var $itemContent = this._getItemContent($itemFrame);
    var renderContentPromise = this._renderItemContent({
      index: itemIndex,
      itemData: itemData,
      container: (0, _element.getPublicElement)($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: this.option('itemTemplate')
    });
    var that = this;
    (0, _deferred.when)(renderContentPromise).done(function ($itemContent) {
      that._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $itemContent,
        itemData: itemData,
        itemIndex: itemIndex
      });
      that._executeItemRenderAction(index, itemData, (0, _element.getPublicElement)($itemFrame));
    });
    return $itemFrame;
  },
  _getItemContent: function _getItemContent($itemFrame) {
    var $itemContent = $itemFrame.find('.' + ITEM_CONTENT_PLACEHOLDER_CLASS);
    $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
    return $itemContent;
  },
  _attachItemClickEvent: function _attachItemClickEvent(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }
    _events_engine.default.on($itemElement, _click.name, function (e) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }.bind(this));
  },
  _renderItemContent: function _renderItemContent(args) {
    var itemTemplateName = this._getItemTemplateName(args);
    var itemTemplate = this._getTemplate(itemTemplateName);
    this._addItemContentClasses(args);
    var $templateResult = (0, _renderer.default)(this._createItemByTemplate(itemTemplate, args));
    if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS)) {
      return args.container;
    }
    return this._renderItemContentByNode(args, $templateResult);
  },
  _renderItemContentByNode: function _renderItemContentByNode(args, $node) {
    (0, _renderer.default)(args.container).replaceWith($node);
    args.container = (0, _element.getPublicElement)($node);
    this._addItemContentClasses(args);
    return $node;
  },
  _addItemContentClasses: function _addItemContentClasses(args) {
    var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
    (0, _renderer.default)(args.container).addClass(classes.join(' '));
  },
  _appendItemToContainer: function _appendItemToContainer($container, $itemFrame, index) {
    $itemFrame.appendTo($container);
  },
  _renderItemFrame: function _renderItemFrame(index, itemData, $container, $itemToReplace) {
    var $itemFrame = (0, _renderer.default)('<div>');
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
    if ($itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index);
    }
    if (this.option('useItemTextAsTitle')) {
      var displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr('title', displayValue);
    }
    return $itemFrame;
  },
  _itemOptions: function _itemOptions() {
    var that = this;
    return {
      watchMethod: function watchMethod() {
        return that.option('integrationOptions.watchMethod');
      },
      owner: that,
      fieldGetter: function fieldGetter(field) {
        var expr = that.option(field + 'Expr');
        var getter = (0, _data.compileGetter)(expr);
        return getter;
      }
    };
  },
  _postprocessRenderItem: _common.noop,
  _executeItemRenderAction: function _executeItemRenderAction(index, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement: itemElement,
      itemIndex: index,
      itemData: itemData
    });
  },
  _setElementData: function _setElementData(element, data, index) {
    element.addClass([ITEM_CLASS, this._itemClass()].join(' ')).data(this._itemDataKey(), data).data(this._itemIndexKey(), index);
  },
  _createItemRenderAction: function _createItemRenderAction() {
    return this._itemRenderAction = this._createActionByOption('onItemRendered', {
      element: this.element(),
      excludeValidators: ['disabled', 'readOnly'],
      category: 'rendering'
    });
  },
  _getItemRenderAction: function _getItemRenderAction() {
    return this._itemRenderAction || this._createItemRenderAction();
  },
  _getItemTemplateName: function _getItemTemplateName(args) {
    var data = args.itemData;
    var templateProperty = args.templateProperty || this.option('itemTemplateProperty');
    var template = data && data[templateProperty];
    return template || args.defaultTemplateName;
  },
  _createItemByTemplate: function _createItemByTemplate(itemTemplate, renderArgs) {
    return itemTemplate.render({
      model: renderArgs.itemData,
      container: renderArgs.container,
      index: renderArgs.index,
      onRendered: this._onItemTemplateRendered(itemTemplate, renderArgs)
    });
  },
  _onItemTemplateRendered: function _onItemTemplateRendered() {
    return _common.noop;
  },
  _emptyMessageContainer: function _emptyMessageContainer() {
    return this._itemContainer();
  },
  _renderEmptyMessage: function _renderEmptyMessage(items) {
    items = items || this.option('items');
    var noDataText = this.option('noDataText');
    var hideNoData = !noDataText || items && items.length || this._dataController.isLoading();
    if (hideNoData && this._$noData) {
      this._$noData.remove();
      this._$noData = null;
      this.setAria('label', undefined);
    }
    if (!hideNoData) {
      this._$noData = this._$noData || (0, _renderer.default)('<div>').addClass('dx-empty-message');
      this._$noData.appendTo(this._emptyMessageContainer());
      if (this.option('encodeNoDataText')) {
        this._$noData.text(noDataText);
      } else {
        this._$noData.html(noDataText);
      }
    }
    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  },
  _itemDXEventHandler: function _itemDXEventHandler(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, (0, _extend.extend)(actionArgs, {
      event: dxEvent
    }), actionConfig);
  },
  _itemEventHandler: function _itemEventHandler(initiator, handlerOptionName, actionArgs, actionConfig) {
    var action = this._createActionByOption(handlerOptionName, (0, _extend.extend)({
      validatingTargetName: 'itemElement'
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerByHandler: function _itemEventHandlerByHandler(initiator, handler, actionArgs, actionConfig) {
    var action = this._createAction(handler, (0, _extend.extend)({
      validatingTargetName: 'itemElement'
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  },
  _itemEventHandlerImpl: function _itemEventHandlerImpl(initiator, action, actionArgs) {
    var $itemElement = this._closestItemElement((0, _renderer.default)(initiator));
    var args = (0, _extend.extend)({}, actionArgs);
    return action((0, _extend.extend)(actionArgs, this._extendActionArgs($itemElement), args));
  },
  _extendActionArgs: function _extendActionArgs($itemElement) {
    return {
      itemElement: (0, _element.getPublicElement)($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  },
  _closestItemElement: function _closestItemElement($element) {
    return (0, _renderer.default)($element).closest(this._itemSelector());
  },
  _getItemData: function _getItemData(itemElement) {
    return (0, _renderer.default)(itemElement).data(this._itemDataKey());
  },
  _getSummaryItemsSize(dimension, items, includeMargin) {
    var result = 0;
    if (items) {
      (0, _iterator.each)(items, function (_, item) {
        if (dimension === 'width') {
          result += (0, _size.getOuterWidth)(item, includeMargin || false);
        } else if (dimension === 'height') {
          result += (0, _size.getOuterHeight)(item, includeMargin || false);
        }
      });
    }
    return result;
  },
  /**
  * @name CollectionWidget.getFocusedItemId
  * @publicName getFocusedItemId()
  * @return string
  * @hidden
  */
  getFocusedItemId: function getFocusedItemId() {
    if (!this._focusedItemId) {
      this._focusedItemId = 'dx-' + new _guid.default();
    }
    return this._focusedItemId;
  },
  /**
  * @name CollectionWidget.itemElements
  * @publicName itemElements()
  * @return Array<Element>
  * @hidden
  */
  itemElements: function itemElements() {
    return this._itemElements();
  },
  /**
  * @name CollectionWidget.itemsContainer
  * @publicName itemsContainer()
  * @return Element
  * @hidden
  */
  itemsContainer: function itemsContainer() {
    return this._itemContainer();
  }
}).include(_data_helper.default);
CollectionWidget.ItemClass = _item.default;
var _default = CollectionWidget;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 11050:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(19982));
var _ui = _interopRequireDefault(__webpack_require__(96688));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _uiCollection_widgetEditStrategy = _interopRequireDefault(__webpack_require__(14174));
var _data = __webpack_require__(47617);
var _data_source = __webpack_require__(85273);
var _utils = __webpack_require__(9234);
var _selection = _interopRequireDefault(__webpack_require__(68198));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var ITEM_DELETING_DATA_KEY = 'dxItemDeleting';
var NOT_EXISTING_INDEX = -1;
var indexExists = function indexExists(index) {
  return index !== NOT_EXISTING_INDEX;
};
var CollectionWidget = _uiCollection_widget.default.inherit({
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      selectedItem: true
    });
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      /**
      * @name CollectionWidgetOptions.selectionMode
      * @type string
      * @default 'none'
      * @acceptValues 'multiple'|'single'|'all'|'none'
      * @hidden
      */
      selectionMode: 'none',
      /**
      * @name CollectionWidgetOptions.selectionRequired
      * @type boolean
      * @default false
      * @hidden
      */
      selectionRequired: false,
      selectByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: NOT_EXISTING_INDEX,
      selectedItem: null,
      onSelectionChanged: null,
      /**
      * @section Utils
      * @default null
      * @name CollectionWidgetOptions.onItemReordered
      * @type function(e)
      * @type_function_param1 e:object
      * @type_function_param1_field1 component:this
      * @type_function_param1_field2 element:DxElement
      * @type_function_param1_field3 model:object
      * @type_function_param1_field4 itemData:object
      * @type_function_param1_field5 itemElement:DxElement
      * @type_function_param1_field6 itemIndex:number | object
      * @type_function_param1_field7 fromIndex:number
      * @type_function_param1_field8 toIndex:number
      * @action
      * @hidden
      */
      onItemReordered: null,
      /**
      * @section Utils
      * @default null
      * @name CollectionWidgetOptions.onItemDeleting
      * @type function(e)
      * @type_function_param1 e:object
      * @type_function_param1_field1 component:this
      * @type_function_param1_field2 element:DxElement
      * @type_function_param1_field3 model:object
      * @type_function_param1_field4 itemData:object
      * @type_function_param1_field5 itemElement:DxElement
      * @type_function_param1_field6 itemIndex:number | object
      * @type_function_param1_field7 cancel:boolean | Promise<void>
      * @action
      * @hidden
      */
      onItemDeleting: null,
      /**
      * @section Utils
      * @default null
      * @name CollectionWidgetOptions.onItemDeleted
      * @type function(e)
      * @type_function_param1 e:object
      * @type_function_param1_field1 component:this
      * @type_function_param1_field2 element:DxElement
      * @type_function_param1_field3 model:object
      * @type_function_param1_field4 itemData:object
      * @type_function_param1_field5 itemElement:DxElement
      * @type_function_param1_field6 itemIndex:number | object
      * @action
      * @hidden
      */
      onItemDeleted: null
    });
  },
  ctor: function ctor(element, options) {
    this._userOptions = options || {};
    this.callBase(element, options);
  },
  _init: function _init() {
    this._initEditStrategy();
    this.callBase();
    this._initKeyGetter();
    this._initSelectionModule();
  },
  _initKeyGetter: function _initKeyGetter() {
    this._keyGetter = (0, _data.compileGetter)(this.option('keyExpr'));
  },
  _getKeysByItems: function _getKeysByItems(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  },
  _getItemsByKeys: function _getItemsByKeys(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  },
  _getKeyByIndex: function _getKeyByIndex(index) {
    return this._editStrategy.getKeyByIndex(index);
  },
  _getIndexByKey: function _getIndexByKey(key) {
    return this._editStrategy.getIndexByKey(key);
  },
  _getIndexByItemData: function _getIndexByItemData(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  },
  _isKeySpecified: function _isKeySpecified() {
    return !!this._dataController.key();
  },
  _getCombinedFilter: function _getCombinedFilter() {
    return this._dataController.filter();
  },
  key: function key() {
    if (this.option('keyExpr')) return this.option('keyExpr');
    return this._dataController.key();
  },
  keyOf: function keyOf(item) {
    var key = item;
    if (this.option('keyExpr')) {
      key = this._keyGetter(item);
    } else if (this._dataController.store()) {
      key = this._dataController.keyOf(item);
    }
    return key;
  },
  _nullValueSelectionSupported: function _nullValueSelectionSupported() {
    return false;
  },
  _initSelectionModule: function _initSelectionModule() {
    var that = this;
    var itemsGetter = that._editStrategy.itemsGetter;
    this._selection = new _selection.default({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option('selectionMode'),
      maxFilterLengthInRequest: this.option('maxFilterLengthInRequest'),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanged: function onSelectionChanged(args) {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          that.option('selectedItems', that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
          that._updateSelectedItems(args);
        }
      },
      filter: that._getCombinedFilter.bind(that),
      totalCount: function totalCount() {
        var items = that.option('items');
        var totalCount = that._dataController.totalCount();
        return totalCount >= 0 ? totalCount : that._getItemsCount(items);
      },
      key: that.key.bind(that),
      keyOf: that.keyOf.bind(that),
      load: function load(options) {
        var _dataController$loadO;
        var dataController = that._dataController;
        options.customQueryParams = (_dataController$loadO = dataController.loadOptions()) === null || _dataController$loadO === void 0 ? void 0 : _dataController$loadO.customQueryParams;
        options.userData = dataController.userData();
        if (dataController.store()) {
          return dataController.loadFromStore(options).done(function (loadResult) {
            if (that._disposed) {
              return;
            }
            var items = (0, _utils.normalizeLoadResult)(loadResult).data;
            dataController.applyMapFunction(items);
          });
        } else {
          return new _deferred.Deferred().resolve(this.plainItems());
        }
      },
      dataFields: function dataFields() {
        return that._dataController.select();
      },
      plainItems: itemsGetter.bind(that._editStrategy)
    });
  },
  _getItemsCount: function _getItemsCount(items) {
    var _this = this;
    return items.reduce(function (itemsCount, item) {
      return itemsCount += item.items ? _this._getItemsCount(item.items) : 1;
    }, 0);
  },
  _initEditStrategy: function _initEditStrategy() {
    var Strategy = _uiCollection_widgetEditStrategy.default;
    this._editStrategy = new Strategy(this);
  },
  _getSelectedItemIndices: function _getSelectedItemIndices(keys) {
    var that = this;
    var indices = [];
    keys = keys || this._selection.getSelectedItemKeys();
    that._editStrategy.beginCache();
    (0, _iterator.each)(keys, function (_, key) {
      var selectedIndex = that._getIndexByKey(key);
      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    });
    that._editStrategy.endCache();
    return indices;
  },
  _initMarkup: function _initMarkup() {
    var _this2 = this;
    this._rendering = true;
    if (!this._dataController.isLoading()) {
      this._syncSelectionOptions().done(function () {
        return _this2._normalizeSelectedItems();
      });
    }
    this.callBase();
  },
  _render: function _render() {
    this.callBase();
    this._rendering = false;
  },
  _fireContentReadyAction: function _fireContentReadyAction() {
    this._rendering = false;
    this._rendered = true;
    this.callBase.apply(this, arguments);
  },
  _syncSelectionOptions: function _syncSelectionOptions(byOption) {
    byOption = byOption || this._chooseSelectOption();
    var selectedItem;
    var selectedIndex;
    var selectedItemKeys;
    var selectedItems;
    switch (byOption) {
      case 'selectedIndex':
        selectedItem = this._editStrategy.getItemDataByIndex(this.option('selectedIndex'));
        if ((0, _type.isDefined)(selectedItem)) {
          this._setOptionWithoutOptionChange('selectedItems', [selectedItem]);
          this._setOptionWithoutOptionChange('selectedItem', selectedItem);
          this._setOptionWithoutOptionChange('selectedItemKeys', this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange('selectedItems', []);
          this._setOptionWithoutOptionChange('selectedItemKeys', []);
          this._setOptionWithoutOptionChange('selectedItem', null);
        }
        break;
      case 'selectedItems':
        selectedItems = this.option('selectedItems') || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;
        if (this.option('selectionRequired') && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions('selectedIndex');
        }
        this._setOptionWithoutOptionChange('selectedItem', selectedItems[0]);
        this._setOptionWithoutOptionChange('selectedIndex', selectedIndex);
        this._setOptionWithoutOptionChange('selectedItemKeys', this._editStrategy.getKeysByItems(selectedItems));
        break;
      case 'selectedItem':
        selectedItem = this.option('selectedItem');
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
        if (this.option('selectionRequired') && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions('selectedIndex');
        }
        if ((0, _type.isDefined)(selectedItem)) {
          this._setOptionWithoutOptionChange('selectedItems', [selectedItem]);
          this._setOptionWithoutOptionChange('selectedIndex', selectedIndex);
          this._setOptionWithoutOptionChange('selectedItemKeys', this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange('selectedItems', []);
          this._setOptionWithoutOptionChange('selectedItemKeys', []);
          this._setOptionWithoutOptionChange('selectedIndex', NOT_EXISTING_INDEX);
        }
        break;
      case 'selectedItemKeys':
        selectedItemKeys = this.option('selectedItemKeys');
        if (this.option('selectionRequired')) {
          var selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions('selectedIndex');
          }
        }
        return this._selection.setSelection(selectedItemKeys);
    }
    return new _deferred.Deferred().resolve().promise();
  },
  _chooseSelectOption: function _chooseSelectOption() {
    var optionName = 'selectedIndex';
    var isOptionDefined = function (optionName) {
      var optionValue = this.option(optionName);
      var length = (0, _type.isDefined)(optionValue) && optionValue.length;
      return length || optionName in this._userOptions;
    }.bind(this);
    if (isOptionDefined('selectedItems')) {
      optionName = 'selectedItems';
    } else if (isOptionDefined('selectedItem')) {
      optionName = 'selectedItem';
    } else if (isOptionDefined('selectedItemKeys')) {
      optionName = 'selectedItemKeys';
    }
    return optionName;
  },
  _compareKeys: function _compareKeys(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }
    for (var i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }
    return true;
  },
  _normalizeSelectedItems: function _normalizeSelectedItems() {
    if (this.option('selectionMode') === 'none') {
      this._setOptionWithoutOptionChange('selectedItems', []);
      this._syncSelectionOptions('selectedItems');
    } else if (this.option('selectionMode') === 'single') {
      var newSelection = this.option('selectedItems');
      if (newSelection.length > 1 || !newSelection.length && this.option('selectionRequired') && this.option('items') && this.option('items').length) {
        var currentSelection = this._selection.getSelectedItems();
        var normalizedSelection = newSelection[0] === undefined ? currentSelection[0] : newSelection[0];
        if (normalizedSelection === undefined) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }
        if (this.option('grouped') && normalizedSelection && normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }
        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
        this._setOptionWithoutOptionChange('selectedItems', [normalizedSelection]);
        return this._syncSelectionOptions('selectedItems');
      } else {
        this._selection.setSelection(this._getKeysByItems(newSelection));
      }
    } else {
      var newKeys = this._getKeysByItems(this.option('selectedItems'));
      var oldKeys = this._selection.getSelectedItemKeys();
      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }
    return new _deferred.Deferred().resolve().promise();
  },
  _itemClickHandler: function _itemClickHandler(e) {
    var _arguments = arguments,
      _this3 = this;
    var itemSelectPromise = new _deferred.Deferred().resolve();
    var callBase = this.callBase;
    this._createAction(function (e) {
      var _this$_itemSelectHand;
      itemSelectPromise = (_this$_itemSelectHand = this._itemSelectHandler(e.event)) !== null && _this$_itemSelectHand !== void 0 ? _this$_itemSelectHand : itemSelectPromise;
    }.bind(this), {
      validatingTargetName: 'itemElement'
    })({
      itemElement: (0, _renderer.default)(e.currentTarget),
      event: e
    });
    itemSelectPromise.always(function () {
      callBase.apply(_this3, _arguments);
    });
  },
  _itemSelectHandler: function _itemSelectHandler(e) {
    var _itemSelectPromise;
    var itemSelectPromise;
    if (!this.option('selectByClick')) {
      return;
    }
    var $itemElement = e.currentTarget;
    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      itemSelectPromise = this.selectItem(e.currentTarget);
    }
    return (_itemSelectPromise = itemSelectPromise) === null || _itemSelectPromise === void 0 ? void 0 : _itemSelectPromise.promise();
  },
  _selectedItemElement: function _selectedItemElement(index) {
    return this._itemElements().eq(index);
  },
  _postprocessRenderItem: function _postprocessRenderItem(args) {
    if (this.option('selectionMode') !== 'none') {
      var $itemElement = (0, _renderer.default)(args.itemElement);
      var normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
      var isItemSelected = this._isItemSelected(normalizedItemIndex);
      this._processSelectableItem($itemElement, isItemSelected);
    }
  },
  _processSelectableItem: function _processSelectableItem($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);
    this._setAriaSelectionAttribute($itemElement, String(isSelected));
  },
  _updateSelectedItems: function _updateSelectedItems(args) {
    var that = this;
    var addedItemKeys = args.addedItemKeys;
    var removedItemKeys = args.removedItemKeys;
    if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      var selectionChangePromise = that._selectionChangePromise;
      if (!that._rendering) {
        var addedSelection = [];
        var normalizedIndex;
        var removedSelection = [];
        that._editStrategy.beginCache();
        for (var i = 0; i < addedItemKeys.length; i++) {
          normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);
          that._addSelection(normalizedIndex);
        }
        for (var _i = 0; _i < removedItemKeys.length; _i++) {
          normalizedIndex = that._getIndexByKey(removedItemKeys[_i]);
          removedSelection.push(normalizedIndex);
          that._removeSelection(normalizedIndex);
        }
        that._editStrategy.endCache();
        that._updateSelection(addedSelection, removedSelection);
      }
      (0, _deferred.when)(selectionChangePromise).done(function () {
        that._fireSelectionChangeEvent(args.addedItems, args.removedItems);
      });
    }
  },
  _fireSelectionChangeEvent: function _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption('onSelectionChanged', {
      excludeValidators: ['disabled', 'readOnly']
    })({
      addedItems: addedItems,
      removedItems: removedItems
    });
  },
  _updateSelection: _common.noop,
  _setAriaSelectionAttribute: function _setAriaSelectionAttribute($target, value) {
    this.setAria('selected', value, $target);
  },
  _removeSelection: function _removeSelection(normalizedIndex) {
    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);
      _events_engine.default.triggerHandler($itemElement, 'stateChanged', false);
    }
  },
  _addSelection: function _addSelection(normalizedIndex) {
    var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);
      _events_engine.default.triggerHandler($itemElement, 'stateChanged', true);
    }
  },
  _isItemSelected: function _isItemSelected(index) {
    var key = this._getKeyByIndex(index);
    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  },
  _optionChanged: function _optionChanged(args) {
    var _this4 = this;
    switch (args.name) {
      case 'selectionMode':
        this._invalidate();
        break;
      case 'dataSource':
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option('selectedItemKeys', []);
        }
        this.callBase(args);
        break;
      case 'selectedIndex':
      case 'selectedItem':
      case 'selectedItems':
      case 'selectedItemKeys':
        this._syncSelectionOptions(args.name).done(function () {
          return _this4._normalizeSelectedItems();
        });
        break;
      case 'keyExpr':
        this._initKeyGetter();
        break;
      case 'selectionRequired':
        this._normalizeSelectedItems();
        break;
      case 'selectByClick':
      case 'onSelectionChanged':
      case 'onItemDeleting':
      case 'onItemDeleted':
      case 'onItemReordered':
      case 'maxFilterLengthInRequest':
        break;
      default:
        this.callBase(args);
    }
  },
  _clearSelectedItems: function _clearSelectedItems() {
    this._setOptionWithoutOptionChange('selectedItems', []);
    this._syncSelectionOptions('selectedItems');
  },
  _waitDeletingPrepare: function _waitDeletingPrepare($itemElement) {
    if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
      return new _deferred.Deferred().resolve().promise();
    }
    $itemElement.data(ITEM_DELETING_DATA_KEY, true);
    var deferred = new _deferred.Deferred();
    var deletingActionArgs = {
      cancel: false
    };
    var deletePromise = this._itemEventHandler($itemElement, 'onItemDeleting', deletingActionArgs, {
      excludeValidators: ['disabled', 'readOnly']
    });
    (0, _deferred.when)(deletePromise).always(function (value) {
      var deletePromiseExists = !deletePromise;
      var deletePromiseResolved = !deletePromiseExists && deletePromise.state() === 'resolved';
      var argumentsSpecified = !!arguments.length;
      var shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
      (0, _deferred.when)((0, _deferred.fromPromise)(deletingActionArgs.cancel)).always(function () {
        $itemElement.data(ITEM_DELETING_DATA_KEY, false);
      }).done(function (cancel) {
        shouldDelete && !cancel ? deferred.resolve() : deferred.reject();
      }).fail(deferred.reject);
    }.bind(this));
    return deferred.promise();
  },
  _deleteItemFromDS: function _deleteItemFromDS($item) {
    var dataController = this._dataController;
    var deferred = new _deferred.Deferred();
    var disabledState = this.option('disabled');
    var dataStore = dataController.store();
    if (!dataStore) {
      return new _deferred.Deferred().resolve().promise();
    }
    if (!dataStore.remove) {
      throw _ui.default.Error('E1011');
    }
    this.option('disabled', true);
    dataStore.remove(dataController.keyOf(this._getItemData($item))).done(function (key) {
      if (key !== undefined) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    }).fail(function () {
      deferred.reject();
    });
    deferred.always(function () {
      this.option('disabled', disabledState);
    }.bind(this));
    return deferred;
  },
  _tryRefreshLastPage: function _tryRefreshLastPage() {
    var deferred = new _deferred.Deferred();
    if (this._isLastPage() || this.option('grouped')) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done(function () {
        deferred.resolve();
      });
    }
    return deferred.promise();
  },
  _refreshLastPage: function _refreshLastPage() {
    this._expectLastItemLoading();
    return this._dataController.load();
  },
  _updateSelectionAfterDelete: function _updateSelectionAfterDelete(index) {
    var key = this._getKeyByIndex(index);
    this._selection.deselect([key]);
  },
  _updateIndicesAfterIndex: function _updateIndicesAfterIndex(index) {
    var itemElements = this._itemElements();
    for (var i = index + 1; i < itemElements.length; i++) {
      (0, _renderer.default)(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  },
  _simulateOptionChange: function _simulateOptionChange(optionName) {
    var optionValue = this.option(optionName);
    if (optionValue instanceof _data_source.DataSource) {
      return;
    }
    this._optionChangedAction({
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  },
  /**
  * @name CollectionWidget.isItemSelected
  * @publicName isItemSelected(itemElement)
  * @param1 itemElement:Element
  * @return boolean
  * @hidden
  */
  isItemSelected: function isItemSelected(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  },
  /**
  * @name CollectionWidget.selectItem
  * @publicName selectItem(itemElement)
  * @param1 itemElement:Element
  * @hidden
  */
  selectItem: function selectItem(itemElement) {
    if (this.option('selectionMode') === 'none') return;
    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    var key = this._getKeyByIndex(itemIndex);
    if (this._selection.isItemSelected(key)) {
      return;
    }
    if (this.option('selectionMode') === 'single') {
      return this._selection.setSelection([key]);
    } else {
      var selectedItemKeys = this.option('selectedItemKeys') || [];
      return this._selection.setSelection([].concat(_toConsumableArray(selectedItemKeys), [key]), [key]);
    }
  },
  /**
  * @name CollectionWidget.unselectItem
  * @publicName unselectItem(itemElement)
  * @param1 itemElement:Element
  * @hidden
  */
  unselectItem: function unselectItem(itemElement) {
    var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    var selectedItemKeys = this._selection.getSelectedItemKeys();
    if (this.option('selectionRequired') && selectedItemKeys.length <= 1) {
      return;
    }
    var key = this._getKeyByIndex(itemIndex);
    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }
    this._selection.deselect([key]);
  },
  _deleteItemElementByIndex: function _deleteItemElementByIndex(index) {
    this._updateSelectionAfterDelete(index);
    this._updateIndicesAfterIndex(index);
    this._editStrategy.deleteItemAtIndex(index);
  },
  _afterItemElementDeleted: function _afterItemElementDeleted($item, deletedActionArgs) {
    var changingOption = this._dataController.getDataSource() ? 'dataSource' : 'items';
    this._simulateOptionChange(changingOption);
    this._itemEventHandler($item, 'onItemDeleted', deletedActionArgs, {
      beforeExecute: function beforeExecute() {
        $item.remove();
      },
      excludeValidators: ['disabled', 'readOnly']
    });
    this._renderEmptyMessage();
  },
  /**
  * @name CollectionWidget.deleteItem
  * @publicName deleteItem(itemElement)
  * @param1 itemElement:Element
  * @return Promise<void>
  * @hidden
  */
  deleteItem: function deleteItem(itemElement) {
    var that = this;
    var deferred = new _deferred.Deferred();
    var $item = this._editStrategy.getItemElement(itemElement);
    var index = this._editStrategy.getNormalizedIndex(itemElement);
    var itemResponseWaitClass = this._itemResponseWaitClass();
    if (indexExists(index)) {
      this._waitDeletingPrepare($item).done(function () {
        $item.addClass(itemResponseWaitClass);
        var deletedActionArgs = that._extendActionArgs($item);
        that._deleteItemFromDS($item).done(function () {
          that._deleteItemElementByIndex(index);
          that._afterItemElementDeleted($item, deletedActionArgs);
          that._tryRefreshLastPage().done(function () {
            deferred.resolveWith(that);
          });
        }).fail(function () {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(that);
        });
      }).fail(function () {
        deferred.rejectWith(that);
      });
    } else {
      deferred.rejectWith(that);
    }
    return deferred.promise();
  },
  /**
  * @name CollectionWidget.reorderItem
  * @publicName reorderItem(itemElement, toItemElement)
  * @param1 itemElement:Element
  * @param2 toItemElement:Element
  * @return Promise<void>
  * @hidden
  */
  reorderItem: function reorderItem(itemElement, toItemElement) {
    var deferred = new _deferred.Deferred();
    var that = this;
    var strategy = this._editStrategy;
    var $movingItem = strategy.getItemElement(itemElement);
    var $destinationItem = strategy.getItemElement(toItemElement);
    var movingIndex = strategy.getNormalizedIndex(itemElement);
    var destinationIndex = strategy.getNormalizedIndex(toItemElement);
    var changingOption = this._dataController.getDataSource() ? 'dataSource' : 'items';
    var canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise().done(function () {
      $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
      this._updateIndicesAfterIndex(movingIndex);
      that.option('selectedItems', that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
      if (changingOption === 'items') {
        that._simulateOptionChange(changingOption);
      }
      that._itemEventHandler($movingItem, 'onItemReordered', {
        fromIndex: strategy.getIndex(movingIndex),
        toIndex: strategy.getIndex(destinationIndex)
      }, {
        excludeValidators: ['disabled', 'readOnly']
      });
    });
  }
});
var _default = CollectionWidget;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 41042:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _common = __webpack_require__(20576);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var abstract = _class.default.abstract;
var EditStrategy = _class.default.inherit({
  ctor: function ctor(collectionWidget) {
    this._collectionWidget = collectionWidget;
  },
  getIndexByItemData: abstract,
  getItemDataByIndex: abstract,
  getKeysByItems: abstract,
  getItemsByKeys: abstract,
  itemsGetter: abstract,
  getKeyByIndex: function getKeyByIndex(index) {
    var resultIndex = this._denormalizeItemIndex(index);
    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  },
  _equalKeys: function _equalKeys(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return (0, _common.equalByValue)(key1, key2);
    } else {
      return key1 === key2;
    }
  },
  beginCache: function beginCache() {
    this._cache = {};
  },
  endCache: function endCache() {
    this._cache = null;
  },
  getIndexByKey: abstract,
  getNormalizedIndex: function getNormalizedIndex(value) {
    if (this._isNormalizedItemIndex(value)) {
      return value;
    }
    if (this._isItemIndex(value)) {
      return this._normalizeItemIndex(value);
    }
    if (this._isNode(value)) {
      return this._getNormalizedItemIndex(value);
    }
    return this._normalizeItemIndex(this.getIndexByItemData(value));
  },
  getIndex: function getIndex(value) {
    if (this._isNormalizedItemIndex(value)) {
      return this._denormalizeItemIndex(value);
    }
    if (this._isItemIndex(value)) {
      return value;
    }
    if (this._isNode(value)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value));
    }
    return this.getIndexByItemData(value);
  },
  getItemElement: function getItemElement(value) {
    if (this._isNormalizedItemIndex(value)) {
      return this._getItemByNormalizedIndex(value);
    }
    if (this._isItemIndex(value)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value));
    }
    if (this._isNode(value)) {
      return (0, _renderer.default)(value);
    }
    var normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value));
    return this._getItemByNormalizedIndex(normalizedItemIndex);
  },
  _isNode: function _isNode(el) {
    return _dom_adapter.default.isNode(el && (0, _type.isRenderer)(el) ? el.get(0) : el);
  },
  deleteItemAtIndex: abstract,
  itemPlacementFunc: function itemPlacementFunc(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? 'after' : 'before';
  },
  moveItemAtIndexToIndex: abstract,
  _isNormalizedItemIndex: function _isNormalizedItemIndex(index) {
    return typeof index === 'number' && Math.round(index) === index;
  },
  _isItemIndex: abstract,
  _getNormalizedItemIndex: abstract,
  _normalizeItemIndex: abstract,
  _denormalizeItemIndex: abstract,
  _getItemByNormalizedIndex: abstract,
  _itemsFromSameParent: abstract
});
var _default = EditStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 14174:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _uiCollection_widgetEdit = _interopRequireDefault(__webpack_require__(41042));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var PlainEditStrategy = _uiCollection_widgetEdit.default.inherit({
  _getPlainItems: function _getPlainItems() {
    return this._collectionWidget.option('items') || [];
  },
  getIndexByItemData: function getIndexByItemData(itemData) {
    var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    } else {
      return this._getPlainItems().indexOf(itemData);
    }
  },
  getItemDataByIndex: function getItemDataByIndex(index) {
    return this._getPlainItems()[index];
  },
  deleteItemAtIndex: function deleteItemAtIndex(index) {
    this._getPlainItems().splice(index, 1);
  },
  itemsGetter: function itemsGetter() {
    return this._getPlainItems();
  },
  getKeysByItems: function getKeysByItems(items) {
    var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    var result = items;
    if (keyOf) {
      result = [];
      for (var i = 0; i < items.length; i++) {
        result.push(keyOf(items[i]));
      }
    }
    return result;
  },
  getIndexByKey: function getIndexByKey(key) {
    var cache = this._cache;
    var keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
    if (cache && !cache.keys) {
      cache.keys = keys;
    }
    if (typeof key === 'object') {
      for (var i = 0, length = keys.length; i < length; i++) {
        if (this._equalKeys(key, keys[i])) return i;
      }
    } else {
      return keys.indexOf(key);
    }
    return -1;
  },
  getItemsByKeys: function getItemsByKeys(keys, items) {
    return (items || keys).slice();
  },
  moveItemAtIndexToIndex: function moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    var items = this._getPlainItems();
    var movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  },
  _isItemIndex: function _isItemIndex(index) {
    return typeof index === 'number' && Math.round(index) === index;
  },
  _getNormalizedItemIndex: function _getNormalizedItemIndex(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  },
  _normalizeItemIndex: function _normalizeItemIndex(index) {
    return index;
  },
  _denormalizeItemIndex: function _denormalizeItemIndex(index) {
    return index;
  },
  _getItemByNormalizedIndex: function _getItemByNormalizedIndex(index) {
    return index > -1 ? this._collectionWidget._itemElements().eq(index) : null;
  },
  _itemsFromSameParent: function _itemsFromSameParent() {
    return true;
  }
});
var _default = PlainEditStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 42160:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_draggable = _interopRequireDefault(__webpack_require__(86988));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _m_draggable.default;
/**
 * @section Utils
 * @default null
 * @name dxDraggableOptions.onDrop
 * @type function(e)
 * @type_function_param1 e:object
 * @type_function_param1_field1 component:this
 * @type_function_param1_field2 element:DxElement
 * @type_function_param1_field3 model:object
 * @type_function_param1_field4 event:event
 * @type_function_param1_field5 itemData:any
 * @type_function_param1_field6 itemElement:DxElement
 * @type_function_param1_field7 fromComponent:dxSortable|dxDraggable
 * @type_function_param1_field8 toComponent:dxSortable|dxDraggable
 * @type_function_param1_field9 fromData:any
 * @type_function_param1_field10 toData:any
 * @action
 * @hidden
 */
/**
 * @name DraggableBaseOptions.contentTemplate
 * @type template|function
 * @type_function_return string|Element|jQuery
 * @hidden
 * @default "content"
 */
/**
 * @name dxDraggableOptions.filter
 * @type string
 * @default ""
 * @hidden
 */
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 96452:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _element_data = __webpack_require__(97906);
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _window = __webpack_require__(58201);
var _index = __webpack_require__(39611);
var _extend = __webpack_require__(13306);
var _ui = _interopRequireDefault(__webpack_require__(14390));
var _validation_engine = _interopRequireDefault(__webpack_require__(90964));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _validation_message = _interopRequireDefault(__webpack_require__(8336));
var _guid = _interopRequireDefault(__webpack_require__(73176));
var _common = __webpack_require__(20576);
var _dom = __webpack_require__(3532);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var INVALID_MESSAGE_AUTO = 'dx-invalid-message-auto';
var READONLY_STATE_CLASS = 'dx-state-readonly';
var INVALID_CLASS = 'dx-invalid';
var DX_INVALID_BADGE_CLASS = 'dx-show-invalid-badge';
var VALIDATION_TARGET = 'dx-validation-target';
var VALIDATION_STATUS_VALID = 'valid';
var VALIDATION_STATUS_INVALID = 'invalid';
var READONLY_NAMESPACE = 'editorReadOnly';
var ALLOWED_STYLING_MODES = ['outlined', 'filled', 'underlined'];
var VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: 'mode',
  validationMessagePosition: 'positionSide',
  validationMessageOffset: 'offset',
  validationBoundary: 'boundary'
};
var Editor = _ui.default.inherit({
  ctor: function ctor() {
    this.showValidationMessageTimeout = null;
    this.validationRequest = (0, _callbacks.default)();
    this.callBase.apply(this, arguments);
  },
  _createElement: function _createElement(element) {
    this.callBase(element);
    var $element = this.$element();
    if ($element) {
      (0, _element_data.data)($element[0], VALIDATION_TARGET, this);
    }
  },
  _initOptions: function _initOptions(options) {
    this.callBase.apply(this, arguments);
    this.option(_validation_engine.default.initValidationOptions(options));
  },
  _init: function _init() {
    this._initialValue = this.option('value');
    this.callBase();
    this._options.cache('validationTooltipOptions', this.option('validationTooltipOptions'));
    var $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      value: null,
      /**
      * @name EditorOptions.name
      * @type string
      * @default ""
      * @hidden
      */
      name: '',
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: VALIDATION_STATUS_VALID,
      validationMessageMode: 'auto',
      validationMessagePosition: 'bottom',
      validationBoundary: undefined,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {},
      _showValidationMessage: true,
      isDirty: false
    });
  },
  _attachKeyboardEvents: function _attachKeyboardEvents() {
    if (!this.option('readOnly')) {
      this.callBase();
    }
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      validationError: true
    });
  },
  _createValueChangeAction: function _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption('onValueChanged', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _suppressValueChangeAction: function _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = true;
  },
  _resumeValueChangeAction: function _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = false;
  },
  _initMarkup: function _initMarkup() {
    var _this$option;
    this._toggleReadOnlyState();
    this._setSubmitElementName(this.option('name'));
    this.callBase();
    this._renderValidationState();
    (_this$option = this.option('_onMarkupRendered')) === null || _this$option === void 0 ? void 0 : _this$option();
  },
  _raiseValueChangeAction: function _raiseValueChangeAction(value, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }
    this._valueChangeAction(this._valueChangeArgs(value, previousValue));
  },
  _valueChangeArgs: function _valueChangeArgs(value, previousValue) {
    return {
      value: value,
      previousValue: previousValue,
      event: this._valueChangeEventInstance
    };
  },
  _saveValueChangeEvent: function _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  },
  _focusInHandler: function _focusInHandler(e) {
    var isValidationMessageShownOnFocus = this.option('validationMessageMode') === 'auto';

    // NOTE: The click should be processed before the validation message is shown because
    // it can change the editor's value
    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;
      // NOTE: Prevent the validation message from showing
      var $validationMessageWrapper = (_this$_validationMess = this._validationMessage) === null || _this$_validationMess === void 0 ? void 0 : _this$_validationMess.$wrapper();
      $validationMessageWrapper === null || $validationMessageWrapper === void 0 ? void 0 : $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO);
      clearTimeout(this.showValidationMessageTimeout);

      // NOTE: Show the validation message after a click changes the value
      this.showValidationMessageTimeout = setTimeout(function () {
        return $validationMessageWrapper === null || $validationMessageWrapper === void 0 ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO);
      }, 150);
    }
    return this.callBase(e);
  },
  _canValueBeChangedByClick: function _canValueBeChangedByClick() {
    return false;
  },
  _getStylingModePrefix: function _getStylingModePrefix() {
    return 'dx-editor-';
  },
  _renderStylingMode: function _renderStylingMode() {
    var _this = this;
    var optionName = 'stylingMode';
    var optionValue = this.option(optionName);
    var prefix = this._getStylingModePrefix();
    var allowedStylingClasses = ALLOWED_STYLING_MODES.map(function (mode) {
      return prefix + mode;
    });
    allowedStylingClasses.forEach(function (className) {
      return _this.$element().removeClass(className);
    });
    var stylingModeClass = prefix + optionValue;
    if (allowedStylingClasses.indexOf(stylingModeClass) === -1) {
      var defaultOptionValue = this._getDefaultOptions()[optionName];
      var platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules())[optionName];
      stylingModeClass = prefix + (platformOptionValue || defaultOptionValue);
    }
    this.$element().addClass(stylingModeClass);
  },
  _getValidationErrors: function _getValidationErrors() {
    var validationErrors = this.option('validationErrors');
    if (!validationErrors && this.option('validationError')) {
      validationErrors = [this.option('validationError')];
    }
    return validationErrors;
  },
  _disposeValidationMessage: function _disposeValidationMessage() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();
      this.setAria('describedby', null);
      this._$validationMessage = undefined;
      this._validationMessage = undefined;
    }
  },
  _toggleValidationClasses: function _toggleValidationClasses(isInvalid) {
    this.$element().toggleClass(INVALID_CLASS, isInvalid);
    this.setAria(VALIDATION_STATUS_INVALID, isInvalid || undefined);
  },
  _renderValidationState: function _renderValidationState() {
    var isValid = this.option('isValid') && this.option('validationStatus') !== VALIDATION_STATUS_INVALID;
    var validationErrors = this._getValidationErrors();
    var $element = this.$element();
    this._toggleValidationClasses(!isValid);
    if (!(0, _window.hasWindow)() || this.option('_showValidationMessage') === false) {
      return;
    }
    this._disposeValidationMessage();
    if (!isValid && validationErrors) {
      var _this$option2 = this.option(),
        validationMessageMode = _this$option2.validationMessageMode,
        validationMessageOffset = _this$option2.validationMessageOffset,
        validationBoundary = _this$option2.validationBoundary,
        rtlEnabled = _this$option2.rtlEnabled;
      this._$validationMessage = (0, _renderer.default)('<div>').appendTo($element);
      var validationMessageContentId = "dx-".concat(new _guid.default());
      this.setAria('describedby', validationMessageContentId);
      this._validationMessage = new _validation_message.default(this._$validationMessage, (0, _extend.extend)({
        validationErrors,
        rtlEnabled,
        target: this._getValidationMessageTarget(),
        visualContainer: $element,
        mode: validationMessageMode,
        positionSide: this._getValidationMessagePosition(),
        offset: validationMessageOffset,
        boundary: validationBoundary,
        contentId: validationMessageContentId
      }, this._options.cache('validationTooltipOptions')));
      this._bindInnerWidgetOptions(this._validationMessage, 'validationTooltipOptions');
    }
  },
  _getValidationMessagePosition: function _getValidationMessagePosition() {
    return this.option('validationMessagePosition');
  },
  _getValidationMessageTarget: function _getValidationMessageTarget() {
    return this.$element();
  },
  _toggleReadOnlyState: function _toggleReadOnlyState() {
    var readOnly = this.option('readOnly');
    this._toggleBackspaceHandler(readOnly);
    this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
    this.setAria('readonly', readOnly || undefined);
  },
  _toggleBackspaceHandler: function _toggleBackspaceHandler(isReadOnly) {
    var $eventTarget = this._keyboardEventBindingTarget();
    var eventName = (0, _index.addNamespace)('keydown', READONLY_NAMESPACE);
    _events_engine.default.off($eventTarget, eventName);
    if (isReadOnly) {
      _events_engine.default.on($eventTarget, eventName, function (e) {
        if ((0, _index.normalizeKeyName)(e) === 'backspace') {
          e.preventDefault();
        }
      });
    }
  },
  _dispose: function _dispose() {
    var element = this.$element()[0];
    (0, _element_data.data)(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);
    this._disposeValidationMessage();
    this.callBase();
  },
  _setSubmitElementName: function _setSubmitElementName(name) {
    var $submitElement = this._getSubmitElement();
    if (!$submitElement) {
      return;
    }
    if (name.length > 0) {
      $submitElement.attr('name', name);
    } else {
      $submitElement.removeAttr('name');
    }
  },
  _getSubmitElement: function _getSubmitElement() {
    return null;
  },
  _setValidationMessageOption: function _setValidationMessageOption(_ref) {
    var _this$_validationMess2;
    var name = _ref.name,
      value = _ref.value;
    var optionKey = VALIDATION_MESSAGE_KEYS_MAP[name] ? VALIDATION_MESSAGE_KEYS_MAP[name] : name;
    (_this$_validationMess2 = this._validationMessage) === null || _this$_validationMess2 === void 0 ? void 0 : _this$_validationMess2.option(optionKey, value);
  },
  _hasActiveElement: _common.noop,
  _optionChanged: function _optionChanged(args) {
    var _this$_validationMess3;
    switch (args.name) {
      case 'onValueChanged':
        this._createValueChangeAction();
        break;
      case 'readOnly':
        this._toggleReadOnlyState();
        this._refreshFocusState();
        break;
      case 'value':
        if (args.value != args.previousValue) {
          // eslint-disable-line eqeqeq
          this.option('isDirty', this._initialValue !== args.value);
          this.validationRequest.fire({
            value: args.value,
            editor: this
          });
        }
        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(args.value, args.previousValue);
          this._saveValueChangeEvent(undefined);
        }
        break;
      case 'width':
        this.callBase(args);
        (_this$_validationMess3 = this._validationMessage) === null || _this$_validationMess3 === void 0 ? void 0 : _this$_validationMess3.updateMaxWidth();
        break;
      case 'name':
        this._setSubmitElementName(args.value);
        break;
      case 'isValid':
      case 'validationError':
      case 'validationErrors':
      case 'validationStatus':
        this.option(_validation_engine.default.synchronizeValidationOptions(args, this.option()));
        this._renderValidationState();
        break;
      case 'validationBoundary':
      case 'validationMessageMode':
      case 'validationMessagePosition':
      case 'validationMessageOffset':
        this._setValidationMessageOption(args);
        break;
      case 'rtlEnabled':
        this._setValidationMessageOption(args);
        this.callBase(args);
        break;
      case 'validationTooltipOptions':
        this._innerWidgetOptionChanged(this._validationMessage, args);
        break;
      case '_showValidationMessage':
      case 'isDirty':
        break;
      default:
        this.callBase(args);
    }
  },
  blur: function blur() {
    if (this._hasActiveElement()) {
      (0, _dom.resetActiveElement)();
    }
  },
  clear: function clear() {
    var defaultOptions = this._getDefaultOptions();
    this.option('value', defaultOptions.value);
  }
});
Editor.isEditor = function (instance) {
  return instance instanceof Editor;
};
var _default = Editor;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 13615:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_utils = _interopRequireDefault(__webpack_require__(60082));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// deprecated
var _default = _m_utils.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 2492:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _window = __webpack_require__(58201);
var _support = __webpack_require__(60137);
var _themes = __webpack_require__(75811);
var _extend = __webpack_require__(13306);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _ui = _interopRequireDefault(__webpack_require__(14390));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var navigator = (0, _window.getNavigator)();
// STYLE loadIndicator

var LOADINDICATOR_CLASS = 'dx-loadindicator';
var LOADINDICATOR_WRAPPER_CLASS = 'dx-loadindicator-wrapper';
var LOADINDICATOR_CONTENT_CLASS = 'dx-loadindicator-content';
var LOADINDICATOR_ICON_CLASS = 'dx-loadindicator-icon';
var LOADINDICATOR_SEGMENT_CLASS = 'dx-loadindicator-segment';
var LOADINDICATOR_SEGMENT_INNER_CLASS = 'dx-loadindicator-segment-inner';
var LOADINDICATOR_IMAGE_CLASS = 'dx-loadindicator-image';
var LoadIndicator = _ui.default.inherit({
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      indicatorSrc: '',
      /**
      * @name dxLoadIndicatorOptions.disabled
      * @hidden
      */

      /**
      * @name dxLoadIndicatorOptions.activeStateEnabled
      * @hidden
      */
      activeStateEnabled: false,
      /**
       * @name dxLoadIndicatorOptions.hoverStateEnabled
       * @default false
       * @hidden
      */
      hoverStateEnabled: false,
      /**
      * @name dxLoadIndicatorOptions.focusStateEnabled
      * @hidden
      */

      /**
      * @name dxLoadIndicatorOptions.accessKey
      * @hidden
      */

      /**
      * @name dxLoadIndicatorOptions.tabIndex
      * @hidden
      */

      _animatingSegmentCount: 1,
      _animatingSegmentInner: false
    });
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    var themeName = (0, _themes.current)();
    return this.callBase().concat([{
      device: function device() {
        var realDevice = _devices.default.real();
        var obsoleteAndroid = realDevice.platform === 'android' && !/chrome/i.test(navigator.userAgent);
        return obsoleteAndroid;
      },
      options: {
        viaImage: true
      }
    }, {
      device: function device() {
        return (0, _themes.isMaterial)(themeName);
      },
      options: {
        _animatingSegmentCount: 2,
        _animatingSegmentInner: true
      }
    }, {
      device: function device() {
        return (0, _themes.isGeneric)(themeName);
      },
      options: {
        _animatingSegmentCount: 7
      }
    }]);
  },
  _useTemplates: function _useTemplates() {
    return false;
  },
  _init: function _init() {
    this.callBase();
    this.$element().addClass(LOADINDICATOR_CLASS);
  },
  _initMarkup: function _initMarkup() {
    this.callBase();
    this._renderWrapper();
    this._renderIndicatorContent();
    this._renderMarkup();
  },
  _renderWrapper: function _renderWrapper() {
    this._$wrapper = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_WRAPPER_CLASS);
    this.$element().append(this._$wrapper);
  },
  _renderIndicatorContent: function _renderIndicatorContent() {
    this._$content = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_CONTENT_CLASS);
    this._$wrapper.append(this._$content);
  },
  _renderMarkup: function _renderMarkup() {
    if ((0, _support.animation)() && !this.option('viaImage') && !this.option('indicatorSrc')) {
      // B236922
      this._renderMarkupForAnimation();
    } else {
      this._renderMarkupForImage();
    }
  },
  _renderMarkupForAnimation: function _renderMarkupForAnimation() {
    var animatingSegmentInner = this.option('_animatingSegmentInner');
    this._$indicator = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_ICON_CLASS);
    this._$content.append(this._$indicator);

    // Indicator markup
    for (var i = this.option('_animatingSegmentCount'); i >= 0; --i) {
      var $segment = (0, _renderer.default)('<div>').addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
      if (animatingSegmentInner) {
        $segment.append((0, _renderer.default)('<div>').addClass(LOADINDICATOR_SEGMENT_INNER_CLASS));
      }
      this._$indicator.append($segment);
    }
  },
  _renderMarkupForImage: function _renderMarkupForImage() {
    var indicatorSrc = this.option('indicatorSrc');
    this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
    if (indicatorSrc) {
      this._$wrapper.css('backgroundImage', 'url(' + indicatorSrc + ')');
    }
  },
  _renderDimensions: function _renderDimensions() {
    this.callBase();
    this._updateContentSizeForAnimation();
  },
  _updateContentSizeForAnimation: function _updateContentSizeForAnimation() {
    if (!this._$indicator) {
      return;
    }
    var width = this.option('width');
    var height = this.option('height');
    if (width || height) {
      width = (0, _size.getWidth)(this.$element());
      height = (0, _size.getHeight)(this.$element());
      var minDimension = Math.min(height, width);
      this._$wrapper.css({
        height: minDimension,
        width: minDimension,
        fontSize: minDimension
      });
    }
  },
  _clean: function _clean() {
    this.callBase();
    this._removeMarkupForAnimation();
    this._removeMarkupForImage();
  },
  _removeMarkupForAnimation: function _removeMarkupForAnimation() {
    if (!this._$indicator) {
      return;
    }
    this._$indicator.remove();
    delete this._$indicator;
  },
  _removeMarkupForImage: function _removeMarkupForImage() {
    this._$wrapper.css('backgroundImage', 'none');
  },
  _optionChanged: function _optionChanged(args) {
    switch (args.name) {
      case '_animatingSegmentCount':
      case '_animatingSegmentInner':
      case 'indicatorSrc':
        this._invalidate();
        break;
      default:
        this.callBase(args);
    }
  }

  /**
  * @name dxLoadIndicator.registerKeyHandler
  * @publicName registerKeyHandler(key, handler)
  * @hidden
  */

  /**
  * @name dxLoadIndicator.focus
  * @publicName focus()
  * @hidden
  */
});

(0, _component_registrator.default)('dxLoadIndicator', LoadIndicator);
var _default = LoadIndicator;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97218:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _common = __webpack_require__(20576);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _extend = __webpack_require__(13306);
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _ui = _interopRequireDefault(__webpack_require__(89799));
var _deferred = __webpack_require__(62754);
var _themes = __webpack_require__(75811);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// STYLE loadPanel

var LOADPANEL_CLASS = 'dx-loadpanel';
var LOADPANEL_WRAPPER_CLASS = 'dx-loadpanel-wrapper';
var LOADPANEL_INDICATOR_CLASS = 'dx-loadpanel-indicator';
var LOADPANEL_MESSAGE_CLASS = 'dx-loadpanel-message';
var LOADPANEL_CONTENT_CLASS = 'dx-loadpanel-content';
var LOADPANEL_CONTENT_WRAPPER_CLASS = 'dx-loadpanel-content-wrapper';
var LOADPANEL_PANE_HIDDEN_CLASS = 'dx-loadpanel-pane-hidden';
var LoadPanel = _ui.default.inherit({
  _supportedKeys: function _supportedKeys() {
    return (0, _extend.extend)(this.callBase(), {
      escape: _common.noop
    });
  },
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      message: _message.default.format('Loading'),
      width: 222,
      height: 90,
      animation: null,
      /**
      * @name dxLoadPanelOptions.disabled
      * @hidden
      */

      showIndicator: true,
      indicatorSrc: '',
      showPane: true,
      delay: 0,
      templatesRenderAsynchronously: false,
      hideTopOverlayHandler: null,
      focusStateEnabled: false,
      propagateOutsideClick: true,
      preventScrollEvents: false

      /**
      * @name dxLoadPanelOptions.contentTemplate
      * @type template
      * @hidden
      */

      /**
      * @name dxLoadPanelOptions.accessKey
      * @hidden
      */

      /**
      * @name dxLoadPanelOptions.tabIndex
      * @hidden
      */
    });
  },

  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat([{
      device: {
        platform: 'generic'
      },
      options: {
        shadingColor: 'transparent'
      }
    }, {
      device: function device() {
        return (0, _themes.isMaterial)();
      },
      options: {
        message: '',
        width: 60,
        height: 60,
        maxHeight: 60,
        maxWidth: 60
      }
    }]);
  },
  _init: function _init() {
    this.callBase.apply(this, arguments);
  },
  _render: function _render() {
    this.callBase();
    this.$element().addClass(LOADPANEL_CLASS);
    this.$wrapper().addClass(LOADPANEL_WRAPPER_CLASS);
  },
  _renderContentImpl: function _renderContentImpl() {
    this.callBase();
    this.$content().addClass(LOADPANEL_CONTENT_CLASS);
    this._$loadPanelContentWrapper = (0, _renderer.default)('<div>').addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
    this._$loadPanelContentWrapper.appendTo(this.$content());
    this._togglePaneVisible();
    this._cleanPreviousContent();
    this._renderLoadIndicator();
    this._renderMessage();
  },
  _show: function _show() {
    var delay = this.option('delay');
    if (!delay) {
      return this.callBase();
    }
    var deferred = new _deferred.Deferred();
    var callBase = this.callBase.bind(this);
    this._clearShowTimeout();
    this._showTimeout = setTimeout(function () {
      callBase().done(function () {
        deferred.resolve();
      });
    }, delay);
    return deferred.promise();
  },
  _hide: function _hide() {
    this._clearShowTimeout();
    return this.callBase();
  },
  _clearShowTimeout: function _clearShowTimeout() {
    clearTimeout(this._showTimeout);
  },
  _renderMessage: function _renderMessage() {
    if (!this._$loadPanelContentWrapper) {
      return;
    }
    var message = this.option('message');
    if (!message) return;
    var $message = (0, _renderer.default)('<div>').addClass(LOADPANEL_MESSAGE_CLASS).text(message);
    this._$loadPanelContentWrapper.append($message);
  },
  _renderLoadIndicator: function _renderLoadIndicator() {
    if (!this._$loadPanelContentWrapper || !this.option('showIndicator')) {
      return;
    }
    if (!this._$indicator) {
      this._$indicator = (0, _renderer.default)('<div>').addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$loadPanelContentWrapper);
    }
    this._createComponent(this._$indicator, _load_indicator.default, {
      indicatorSrc: this.option('indicatorSrc')
    });
  },
  _cleanPreviousContent: function _cleanPreviousContent() {
    this.$content().find('.' + LOADPANEL_MESSAGE_CLASS).remove();
    this.$content().find('.' + LOADPANEL_INDICATOR_CLASS).remove();
    delete this._$indicator;
  },
  _togglePaneVisible: function _togglePaneVisible() {
    this.$content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option('showPane'));
  },
  _optionChanged: function _optionChanged(args) {
    switch (args.name) {
      case 'delay':
        break;
      case 'message':
      case 'showIndicator':
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage();
        break;
      case 'showPane':
        this._togglePaneVisible();
        break;
      case 'indicatorSrc':
        this._renderLoadIndicator();
        break;
      default:
        this.callBase(args);
    }
  },
  _dispose: function _dispose() {
    this._clearShowTimeout();
    this.callBase();
  }

  /**
  * @name dxLoadPanel.registerKeyHandler
  * @publicName registerKeyHandler(key, handler)
  * @hidden
  */

  /**
  * @name dxLoadPanel.focus
  * @publicName focus()
  * @hidden
  */
});

(0, _component_registrator.default)('dxLoadPanel', LoadPanel);
var _default = LoadPanel;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 49314:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.OverlayPositionController = exports.OVERLAY_POSITION_ALIASES = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _position = _interopRequireDefault(__webpack_require__(49387));
var _translator = __webpack_require__(31648);
var _window = __webpack_require__(58201);
var _swatch_container = _interopRequireDefault(__webpack_require__(92591));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var window = (0, _window.getWindow)();
var OVERLAY_POSITION_ALIASES = {
  'top': {
    my: 'top center',
    at: 'top center'
  },
  'bottom': {
    my: 'bottom center',
    at: 'bottom center'
  },
  'right': {
    my: 'right center',
    at: 'right center'
  },
  'left': {
    my: 'left center',
    at: 'left center'
  },
  'center': {
    my: 'center',
    at: 'center'
  },
  'right bottom': {
    my: 'right bottom',
    at: 'right bottom'
  },
  'right top': {
    my: 'right top',
    at: 'right top'
  },
  'left bottom': {
    my: 'left bottom',
    at: 'left bottom'
  },
  'left top': {
    my: 'left top',
    at: 'left top'
  }
};
exports.OVERLAY_POSITION_ALIASES = OVERLAY_POSITION_ALIASES;
var OVERLAY_DEFAULT_BOUNDARY_OFFSET = {
  h: 0,
  v: 0
};
var OverlayPositionController = /*#__PURE__*/function () {
  function OverlayPositionController(_ref) {
    var position = _ref.position,
      container = _ref.container,
      visualContainer = _ref.visualContainer,
      $root = _ref.$root,
      $content = _ref.$content,
      $wrapper = _ref.$wrapper,
      onPositioned = _ref.onPositioned,
      onVisualPositionChanged = _ref.onVisualPositionChanged,
      restorePosition = _ref.restorePosition,
      _fixWrapperPosition = _ref._fixWrapperPosition;
    this._props = {
      position,
      container,
      visualContainer,
      restorePosition,
      onPositioned,
      onVisualPositionChanged,
      _fixWrapperPosition
    };
    this._$root = $root;
    this._$content = $content;
    this._$wrapper = $wrapper;
    this._$markupContainer = undefined;
    this._$visualContainer = undefined;
    this._shouldRenderContentInitialPosition = true;
    this._visualPosition = undefined;
    this._initialPosition = undefined;
    this._previousVisualPosition = undefined;
    this.updateContainer(container);
    this.updatePosition(position);
    this.updateVisualContainer(visualContainer);
  }
  var _proto = OverlayPositionController.prototype;
  _proto.restorePositionOnNextRender = function restorePositionOnNextRender(value) {
    // NOTE: no visual position means it's a first render
    this._shouldRenderContentInitialPosition = value || !this._visualPosition;
  };
  _proto.openingHandled = function openingHandled() {
    var shouldRestorePosition = this._props.restorePosition;
    this.restorePositionOnNextRender(shouldRestorePosition);
  };
  _proto.updatePosition = function updatePosition(positionProp) {
    this._props.position = positionProp;
    this._position = this._normalizePosition(positionProp);
    this.updateVisualContainer();
  };
  _proto.updateContainer = function updateContainer() {
    var containerProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._props.container;
    this._props.container = containerProp;
    this._$markupContainer = containerProp ? (0, _renderer.default)(containerProp) : _swatch_container.default.getSwatchContainer(this._$root);
    this.updateVisualContainer(this._props.visualContainer);
  };
  _proto.updateVisualContainer = function updateVisualContainer() {
    var visualContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._props.visualContainer;
    this._props.visualContainer = visualContainer;
    this._$visualContainer = this._getVisualContainer();
  };
  _proto.detectVisualPositionChange = function detectVisualPositionChange(event) {
    this._updateVisualPositionValue();
    this._raisePositionedEvents(event);
  };
  _proto.positionContent = function positionContent() {
    if (this._shouldRenderContentInitialPosition) {
      this._renderContentInitialPosition();
    } else {
      (0, _translator.move)(this._$content, this._visualPosition);
      this.detectVisualPositionChange();
    }
  };
  _proto.positionWrapper = function positionWrapper() {
    if (this._$visualContainer) {
      _position.default.setup(this._$wrapper, {
        my: 'top left',
        at: 'top left',
        of: this._$visualContainer
      });
    }
  };
  _proto.styleWrapperPosition = function styleWrapperPosition() {
    var useFixed = (0, _type.isWindow)(this.$visualContainer.get(0)) || this._props._fixWrapperPosition;
    var positionStyle = useFixed ? 'fixed' : 'absolute';
    this._$wrapper.css('position', positionStyle);
  };
  _proto._updateVisualPositionValue = function _updateVisualPositionValue() {
    this._previousVisualPosition = this._visualPosition;
    this._visualPosition = (0, _translator.locate)(this._$content);
  };
  _proto._renderContentInitialPosition = function _renderContentInitialPosition() {
    this._renderBoundaryOffset();
    (0, _translator.resetPosition)(this._$content);
    var wrapperOverflow = this._$wrapper.css('overflow');
    this._$wrapper.css('overflow', 'hidden');
    var resultPosition = _position.default.setup(this._$content, this._position);
    this._$wrapper.css('overflow', wrapperOverflow);
    this._initialPosition = resultPosition;
    this.detectVisualPositionChange();
  };
  _proto._raisePositionedEvents = function _raisePositionedEvents(event) {
    var previousPosition = this._previousVisualPosition;
    var newPosition = this._visualPosition;
    var isVisualPositionChanged = (previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition.top) !== newPosition.top || (previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition.left) !== newPosition.left;
    if (isVisualPositionChanged) {
      this._props.onVisualPositionChanged({
        previousPosition: previousPosition,
        position: newPosition,
        event
      });
    }
    this._props.onPositioned({
      position: this._initialPosition
    });
  };
  _proto._renderBoundaryOffset = function _renderBoundaryOffset() {
    var _this$_position;
    var boundaryOffset = (_this$_position = this._position) !== null && _this$_position !== void 0 ? _this$_position : {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    this._$content.css('margin', "".concat(boundaryOffset.v, "px ").concat(boundaryOffset.h, "px"));
  };
  _proto._getVisualContainer = function _getVisualContainer() {
    var _this$_props$position, _this$_props$position2;
    var containerProp = this._props.container;
    var visualContainerProp = this._props.visualContainer;
    var positionOf = (0, _type.isEvent)((_this$_props$position = this._props.position) === null || _this$_props$position === void 0 ? void 0 : _this$_props$position.of) ? this._props.position.of.target : (_this$_props$position2 = this._props.position) === null || _this$_props$position2 === void 0 ? void 0 : _this$_props$position2.of;
    if (visualContainerProp) {
      return (0, _renderer.default)(visualContainerProp);
    }
    if (containerProp) {
      return (0, _renderer.default)(containerProp);
    }
    if (positionOf) {
      return (0, _renderer.default)(positionOf);
    }
    return (0, _renderer.default)(window);
  };
  _proto._normalizePosition = function _normalizePosition(positionProp) {
    var defaultPositionConfig = {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    if ((0, _type.isDefined)(positionProp)) {
      return (0, _extend.extend)(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    } else {
      return defaultPositionConfig;
    }
  };
  _proto._positionToObject = function _positionToObject(position) {
    if ((0, _type.isString)(position)) {
      return (0, _extend.extend)({}, OVERLAY_POSITION_ALIASES[position]);
    }
    return position;
  };
  _createClass(OverlayPositionController, [{
    key: "$container",
    get: function get() {
      this.updateContainer(); // NOTE: swatch classes can be updated runtime

      return this._$markupContainer;
    }
  }, {
    key: "$visualContainer",
    get: function get() {
      return this._$visualContainer;
    }
  }, {
    key: "position",
    get: function get() {
      return this._position;
    }
  }, {
    key: "fixWrapperPosition",
    set: function set(fixWrapperPosition) {
      this._props._fixWrapperPosition = fixWrapperPosition;
      this.styleWrapperPosition();
    }
  }, {
    key: "restorePosition",
    set: function set(restorePosition) {
      this._props.restorePosition = restorePosition;
    }
  }]);
  return OverlayPositionController;
}();
exports.OverlayPositionController = OverlayPositionController;

/***/ }),

/***/ 89799:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _fx = _interopRequireDefault(__webpack_require__(87209));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _element = __webpack_require__(6415);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _empty_template = __webpack_require__(10688);
var _common = __webpack_require__(20576);
var _deferred = __webpack_require__(62754);
var _dom = __webpack_require__(3532);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _type = __webpack_require__(35922);
var _view_port = __webpack_require__(77695);
var _window = __webpack_require__(58201);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _ui = _interopRequireDefault(__webpack_require__(96688));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _drag = __webpack_require__(23174);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _short = __webpack_require__(72918);
var _index = __webpack_require__(39611);
var _visibility_change = __webpack_require__(80506);
var _hide_callback = __webpack_require__(4928);
var _selectors = __webpack_require__(31421);
var _ui2 = _interopRequireDefault(__webpack_require__(14390));
var _browser = _interopRequireDefault(__webpack_require__(47810));
var zIndexPool = _interopRequireWildcard(__webpack_require__(85421));
var _overlay_position_controller = __webpack_require__(49314);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ready = _ready_callbacks.default.add;
var window = (0, _window.getWindow)();
var viewPortChanged = _view_port.changeCallback;
var OVERLAY_CLASS = 'dx-overlay';
var OVERLAY_WRAPPER_CLASS = 'dx-overlay-wrapper';
var OVERLAY_CONTENT_CLASS = 'dx-overlay-content';
var OVERLAY_SHADER_CLASS = 'dx-overlay-shader';
var INNER_OVERLAY_CLASS = 'dx-inner-overlay';
var INVISIBLE_STATE_CLASS = 'dx-state-invisible';
var ANONYMOUS_TEMPLATE_NAME = 'content';
var RTL_DIRECTION_CLASS = 'dx-rtl';
var OVERLAY_STACK = [];
var PREVENT_SAFARI_SCROLLING_CLASS = 'dx-prevent-safari-scrolling';
var TAB_KEY = 'tab';
ready(function () {
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), _pointer.default.down, function (e) {
    for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});
var Overlay = _ui2.default.inherit({
  _supportedKeys: function _supportedKeys() {
    return (0, _extend.extend)(this.callBase(), {
      escape: function escape() {
        this.hide();
      }
    });
  },
  _getDefaultOptions: function _getDefaultOptions() {
    var _this = this;
    return (0, _extend.extend)(this.callBase(), {
      /**
      * @name dxOverlayOptions.activeStateEnabled
      * @hidden
      */
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: '',
      wrapperAttr: {},
      position: (0, _extend.extend)({}, _overlay_position_controller.OVERLAY_POSITION_ALIASES.center),
      width: '80vw',
      minWidth: null,
      maxWidth: null,
      height: '80vh',
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: 'pop',
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: 'pop',
          duration: 300,
          from: {
            opacity: 1,
            scale: 1
          },
          to: {
            opacity: 0,
            scale: 0.55
          }
        }
      },
      closeOnOutsideClick: false,
      hideOnOutsideClick: false,
      copyRootClassesToWrapper: false,
      _ignoreCopyRootClassesToWrapperDeprecation: false,
      _ignoreElementAttrDeprecation: false,
      _ignorePreventScrollEventsDeprecation: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: 'content',
      innerOverlay: false,
      restorePosition: true,
      container: undefined,
      visualContainer: undefined,
      // NOTE: private options
      hideTopOverlayHandler: function hideTopOverlayHandler() {
        _this.hide();
      },
      hideOnParentScroll: false,
      preventScrollEvents: true,
      onPositioned: null,
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _fixWrapperPosition: false
    });
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat([{
      device: function device() {
        return !(0, _window.hasWindow)();
      },
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  },
  _setOptionsByReference: function _setOptionsByReference() {
    this.callBase();
    (0, _extend.extend)(this._optionsByReference, {
      animation: true
    });
  },
  $wrapper: function $wrapper() {
    return this._$wrapper;
  },
  _eventBindingTarget: function _eventBindingTarget() {
    return this._$content;
  },
  _setDeprecatedOptions() {
    this.callBase();
    (0, _extend.extend)(this._deprecatedOptions, {
      'closeOnOutsideClick': {
        since: '22.1',
        alias: 'hideOnOutsideClick'
      }
    });
  },
  ctor: function ctor(element, options) {
    this.callBase(element, options);
    function createWrapperAttrDeprecationInfo() {
      return {
        since: '21.2',
        message: 'Use the "wrapperAttr" option instead'
      };
    }
    if (options) {
      if (options.copyRootClassesToWrapper && !options._ignoreCopyRootClassesToWrapperDeprecation) {
        this._logDeprecatedOptionWarning('copyRootClassesToWrapper', createWrapperAttrDeprecationInfo());
      }
      if (options.elementAttr && !options._ignoreElementAttrDeprecation) {
        this._logDeprecatedOptionWarning('elementAttr', createWrapperAttrDeprecationInfo());
      }
      if ('preventScrollEvents' in options && !options._ignorePreventScrollEventsDeprecation) {
        this._logDeprecatedPreventScrollEventsInfo();
      }
    }
  },
  _logDeprecatedPreventScrollEventsInfo() {
    this._logDeprecatedOptionWarning('preventScrollEvents', {
      since: '23.1',
      message: 'If you enable this option, end-users may experience scrolling issues.'
    });
  },
  _init: function _init() {
    var _this2 = this;
    this.callBase();
    this._initActions();
    this._initHideOnOutsideClickHandler();
    this._initTabTerminatorHandler();
    this._customWrapperClass = null;
    this._$wrapper = (0, _renderer.default)('<div>').addClass(OVERLAY_WRAPPER_CLASS);
    this._$content = (0, _renderer.default)('<div>').addClass(OVERLAY_CONTENT_CLASS);
    this._initInnerOverlayClass();
    var $element = this.$element();
    if (this.option('copyRootClassesToWrapper')) {
      this._$wrapper.addClass($element.attr('class'));
    }
    $element.addClass(OVERLAY_CLASS);
    this._$wrapper.attr('data-bind', 'dxControlsDescendantBindings: true');
    this._toggleViewPortSubscription(true);
    this._initHideTopOverlayHandler(this.option('hideTopOverlayHandler'));
    this._parentsScrollSubscriptionInfo = {
      handler: function handler(e) {
        _this2._hideOnParentsScrollHandler(e);
      }
    };
    this.warnPositionAsFunction();
  },
  warnPositionAsFunction() {
    if ((0, _type.isFunction)(this.option('position'))) {
      // position as function deprecated in 21.2
      _errors.default.log('W0018');
    }
  },
  _initInnerOverlayClass: function _initInnerOverlayClass() {
    this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option('innerOverlay'));
  },
  _initHideTopOverlayHandler: function _initHideTopOverlayHandler(handler) {
    this._hideTopOverlayHandler = handler;
  },
  _getActionsList: function _getActionsList() {
    return ['onShowing', 'onShown', 'onHiding', 'onHidden', 'onPositioned', 'onVisualPositionChanged'];
  },
  _initActions: function _initActions() {
    var _this3 = this;
    this._actions = {};
    var actions = this._getActionsList();
    (0, _iterator.each)(actions, function (_, action) {
      _this3._actions[action] = _this3._createActionByOption(action, {
        excludeValidators: ['disabled', 'readOnly']
      }) || _common.noop;
    });
  },
  _initHideOnOutsideClickHandler: function _initHideOnOutsideClickHandler() {
    var _this4 = this;
    this._proxiedDocumentDownHandler = function () {
      return _this4._documentDownHandler.apply(_this4, arguments);
    };
  },
  _initMarkup() {
    this.callBase();
    this._renderWrapperAttributes();
    this._initPositionController();
  },
  _documentDownHandler: function _documentDownHandler(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }
    var isAttachedTarget = (0, _renderer.default)(window.document).is(e.target) || (0, _dom.contains)(window.document, e.target);
    var isInnerOverlay = (0, _renderer.default)(e.target).closest(".".concat(INNER_OVERLAY_CLASS)).length;
    var outsideClick = isAttachedTarget && !isInnerOverlay && !(this._$content.is(e.target) || (0, _dom.contains)(this._$content.get(0), e.target));
    if (outsideClick && this._shouldHideOnOutsideClick(e)) {
      this._outsideClickHandler(e);
    }
    return this.option('propagateOutsideClick');
  },
  _shouldHideOnOutsideClick: function _shouldHideOnOutsideClick(e) {
    var _this$option = this.option(),
      hideOnOutsideClick = _this$option.hideOnOutsideClick;
    if ((0, _type.isFunction)(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    return hideOnOutsideClick;
  },
  _outsideClickHandler(e) {
    if (this.option('shading')) {
      e.preventDefault();
    }
    this.hide();
  },
  _getAnonymousTemplateName: function _getAnonymousTemplateName() {
    return ANONYMOUS_TEMPLATE_NAME;
  },
  _initTemplates: function _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new _empty_template.EmptyTemplate()
    });
    this.callBase();
  },
  _isTopOverlay: function _isTopOverlay() {
    var overlayStack = this._overlayStack();
    for (var i = overlayStack.length - 1; i >= 0; i--) {
      var tabbableElements = overlayStack[i]._findTabbableBounds();
      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }
    return false;
  },
  _overlayStack: function _overlayStack() {
    return OVERLAY_STACK;
  },
  _zIndexInitValue: function _zIndexInitValue() {
    return Overlay.baseZIndex();
  },
  _toggleViewPortSubscription: function _toggleViewPortSubscription(toggle) {
    var _this5 = this;
    viewPortChanged.remove(this._viewPortChangeHandle);
    if (toggle) {
      this._viewPortChangeHandle = function () {
        _this5._viewPortChangeHandler.apply(_this5, arguments);
      };
      viewPortChanged.add(this._viewPortChangeHandle);
    }
  },
  _viewPortChangeHandler: function _viewPortChangeHandler() {
    this._positionController.updateContainer(this.option('container'));
    this._refresh();
  },
  _renderWrapperAttributes() {
    var _this$option2 = this.option(),
      wrapperAttr = _this$option2.wrapperAttr;
    var attributes = (0, _extend.extend)({}, wrapperAttr);
    var classNames = attributes.class;
    delete attributes.class;
    this.$wrapper().attr(attributes).removeClass(this._customWrapperClass).addClass(classNames);
    this._customWrapperClass = classNames;
  },
  _renderVisibilityAnimate: function _renderVisibilityAnimate(visible) {
    this._stopAnimation();
    return visible ? this._show() : this._hide();
  },
  _getAnimationConfig: function _getAnimationConfig() {
    return this._getOptionValue('animation', this);
  },
  _toggleBodyScroll: _common.noop,
  _animateShowing: function _animateShowing() {
    var _this$_getAnimationCo,
      _showAnimation$start,
      _showAnimation$comple,
      _this6 = this;
    var animation = (_this$_getAnimationCo = this._getAnimationConfig()) !== null && _this$_getAnimationCo !== void 0 ? _this$_getAnimationCo : {};
    var showAnimation = this._normalizeAnimation(animation.show, 'to');
    var startShowAnimation = (_showAnimation$start = showAnimation === null || showAnimation === void 0 ? void 0 : showAnimation.start) !== null && _showAnimation$start !== void 0 ? _showAnimation$start : _common.noop;
    var completeShowAnimation = (_showAnimation$comple = showAnimation === null || showAnimation === void 0 ? void 0 : showAnimation.complete) !== null && _showAnimation$comple !== void 0 ? _showAnimation$comple : _common.noop;
    this._animate(showAnimation, function () {
      if (_this6._isAnimationPaused) {
        return;
      }
      if (_this6.option('focusStateEnabled')) {
        _events_engine.default.trigger(_this6._focusTarget(), 'focus');
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      completeShowAnimation.call.apply(completeShowAnimation, [_this6].concat(args));
      _this6._showAnimationProcessing = false;
      _this6._isHidden = false;
      _this6._actions.onShown();
      _this6._toggleSafariScrolling();
      _this6._showingDeferred.resolve();
    }, function () {
      if (_this6._isAnimationPaused) {
        return;
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      startShowAnimation.call.apply(startShowAnimation, [_this6].concat(args));
      _this6._showAnimationProcessing = true;
    });
  },
  _processShowingHidingCancel: function _processShowingHidingCancel(cancelArg, applyFunction, cancelFunction) {
    if ((0, _type.isPromise)(cancelArg)) {
      cancelArg.then(function (shouldCancel) {
        if (shouldCancel) {
          cancelFunction();
        } else {
          applyFunction();
        }
      }).catch(function () {
        return applyFunction();
      });
    } else {
      cancelArg ? cancelFunction() : applyFunction();
    }
  },
  _show: function _show() {
    var _this7 = this;
    this._showingDeferred = new _deferred.Deferred();
    this._parentHidden = this._isParentHidden();
    this._showingDeferred.done(function () {
      delete _this7._parentHidden;
    });
    if (this._parentHidden) {
      this._isHidden = true;
      return this._showingDeferred.resolve();
    }
    if (this._currentVisible) {
      return new _deferred.Deferred().resolve().promise();
    }
    this._currentVisible = true;
    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      this._showingDeferred.reject();
    } else {
      var show = function show() {
        _this7._toggleBodyScroll(_this7.option('enableBodyScroll'));
        _this7._stopAnimation();
        _this7._toggleVisibility(true);
        _this7._$content.css('visibility', 'hidden');
        _this7._$content.toggleClass(INVISIBLE_STATE_CLASS, false);
        _this7._updateZIndexStackPosition(true);
        _this7._positionController.openingHandled();
        _this7._renderContent();
        var showingArgs = {
          cancel: false
        };
        _this7._actions.onShowing(showingArgs);
        var cancelShow = function cancelShow() {
          _this7._toggleVisibility(false);
          _this7._$content.css('visibility', '');
          _this7._$content.toggleClass(INVISIBLE_STATE_CLASS, true);
          _this7._isShowingActionCanceled = true;
          _this7._moveFromContainer();
          _this7.option('visible', false);
          _this7._showingDeferred.resolve();
        };
        var applyShow = function applyShow() {
          _this7._$content.css('visibility', '');
          _this7._renderVisibility(true);
          _this7._animateShowing();
        };
        _this7._processShowingHidingCancel(showingArgs.cancel, applyShow, cancelShow);
      };
      if (this.option('templatesRenderAsynchronously')) {
        this._stopShowTimer();
        // NOTE: T390360, T386038
        this._asyncShowTimeout = setTimeout(show);
      } else {
        show();
      }
    }
    return this._showingDeferred.promise();
  },
  _normalizeAnimation: function _normalizeAnimation(showHideConfig, direction) {
    if (showHideConfig) {
      showHideConfig = (0, _extend.extend)({
        type: 'slide',
        skipElementInitialStyles: true // NOTE: for fadeIn animation
      }, showHideConfig);
      if ((0, _type.isObject)(showHideConfig[direction])) {
        (0, _extend.extend)(showHideConfig[direction], {
          position: this._positionController.position
        });
      }
    }
    return showHideConfig;
  },
  _animateHiding: function _animateHiding() {
    var _this$_getAnimationCo2,
      _hideAnimation$start,
      _hideAnimation$comple,
      _this8 = this;
    var animation = (_this$_getAnimationCo2 = this._getAnimationConfig()) !== null && _this$_getAnimationCo2 !== void 0 ? _this$_getAnimationCo2 : {};
    var hideAnimation = this._normalizeAnimation(animation.hide, 'from');
    var startHideAnimation = (_hideAnimation$start = hideAnimation === null || hideAnimation === void 0 ? void 0 : hideAnimation.start) !== null && _hideAnimation$start !== void 0 ? _hideAnimation$start : _common.noop;
    var completeHideAnimation = (_hideAnimation$comple = hideAnimation === null || hideAnimation === void 0 ? void 0 : hideAnimation.complete) !== null && _hideAnimation$comple !== void 0 ? _hideAnimation$comple : _common.noop;
    this._animate(hideAnimation, function () {
      var _this8$_actions;
      _this8._$content.css('pointerEvents', '');
      _this8._renderVisibility(false);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      completeHideAnimation.call.apply(completeHideAnimation, [_this8].concat(args));
      _this8._hideAnimationProcessing = false;
      (_this8$_actions = _this8._actions) === null || _this8$_actions === void 0 ? void 0 : _this8$_actions.onHidden();
      _this8._hidingDeferred.resolve();
    }, function () {
      _this8._$content.css('pointerEvents', 'none');
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      startHideAnimation.call.apply(startHideAnimation, [_this8].concat(args));
      _this8._hideAnimationProcessing = true;
    });
  },
  _hide: function _hide() {
    var _this9 = this;
    if (!this._currentVisible) {
      return new _deferred.Deferred().resolve().promise();
    }
    this._currentVisible = false;
    this._hidingDeferred = new _deferred.Deferred();
    var hidingArgs = {
      cancel: false
    };
    if (this._isShowingActionCanceled) {
      delete this._isShowingActionCanceled;
      this._hidingDeferred.reject();
    } else {
      this._actions.onHiding(hidingArgs);
      this._toggleSafariScrolling();
      this._toggleBodyScroll(true);
      var cancelHide = function cancelHide() {
        _this9._isHidingActionCanceled = true;
        _this9.option('visible', true);
        _this9._hidingDeferred.resolve();
      };
      var applyHide = function applyHide() {
        _this9._forceFocusLost();
        _this9._toggleShading(false);
        _this9._toggleSubscriptions(false);
        _this9._stopShowTimer();
        _this9._animateHiding();
      };
      this._processShowingHidingCancel(hidingArgs.cancel, applyHide, cancelHide);
    }
    return this._hidingDeferred.promise();
  },
  _forceFocusLost: function _forceFocusLost() {
    var activeElement = _dom_adapter.default.getActiveElement();
    var shouldResetActiveElement = !!this._$content.find(activeElement).length;
    if (shouldResetActiveElement) {
      (0, _dom.resetActiveElement)();
    }
  },
  _animate: function _animate(animation, completeCallback, startCallback) {
    if (animation) {
      startCallback = startCallback || animation.start || _common.noop;
      _fx.default.animate(this._$content, (0, _extend.extend)({}, animation, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  },
  _stopAnimation: function _stopAnimation() {
    _fx.default.stop(this._$content, true);
  },
  _renderVisibility: function _renderVisibility(visible) {
    if (visible && this._isParentHidden()) {
      return;
    }
    this._currentVisible = visible;
    this._stopAnimation();
    if (!visible) {
      (0, _visibility_change.triggerHidingEvent)(this._$content);
    }
    if (visible) {
      this._checkContainerExists();
      this._moveToContainer();
      this._renderGeometry();
      (0, _visibility_change.triggerShownEvent)(this._$content);
      (0, _visibility_change.triggerResizeEvent)(this._$content);
    } else {
      this._toggleVisibility(visible);
      this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
      this._updateZIndexStackPosition(visible);
      this._moveFromContainer();
    }
    this._toggleShading(visible);
    this._toggleSubscriptions(visible);
  },
  _updateZIndexStackPosition: function _updateZIndexStackPosition(pushToStack) {
    var overlayStack = this._overlayStack();
    var index = overlayStack.indexOf(this);
    if (pushToStack) {
      if (index === -1) {
        this._zIndex = zIndexPool.create(this._zIndexInitValue());
        overlayStack.push(this);
      }
      this._$wrapper.css('zIndex', this._zIndex);
      this._$content.css('zIndex', this._zIndex);
    } else if (index !== -1) {
      overlayStack.splice(index, 1);
      zIndexPool.remove(this._zIndex);
    }
  },
  _toggleShading: function _toggleShading(visible) {
    this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option('shading'));
    this._$wrapper.css('backgroundColor', this.option('shading') ? this.option('shadingColor') : '');
    this._toggleTabTerminator(visible && this.option('shading'));
  },
  _initTabTerminatorHandler: function _initTabTerminatorHandler() {
    var _this10 = this;
    this._proxiedTabTerminatorHandler = function () {
      _this10._tabKeyHandler.apply(_this10, arguments);
    };
  },
  _toggleTabTerminator: function _toggleTabTerminator(enabled) {
    var eventName = (0, _index.addNamespace)('keydown', this.NAME);
    if (enabled) {
      _events_engine.default.on(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      _events_engine.default.off(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    }
  },
  _findTabbableBounds: function _findTabbableBounds() {
    var $elements = this._$wrapper.find('*');
    var elementsCount = $elements.length - 1;
    var result = {
      first: null,
      last: null
    };
    for (var i = 0; i <= elementsCount; i++) {
      if (!result.first && $elements.eq(i).is(_selectors.tabbable)) {
        result.first = $elements.eq(i);
      }
      if (!result.last && $elements.eq(elementsCount - i).is(_selectors.tabbable)) {
        result.last = $elements.eq(elementsCount - i);
      }
      if (result.first && result.last) {
        break;
      }
    }
    return result;
  },
  _tabKeyHandler: function _tabKeyHandler(e) {
    if ((0, _index.normalizeKeyName)(e) !== TAB_KEY || !this._isTopOverlay()) {
      return;
    }
    var tabbableElements = this._findTabbableBounds();
    var $firstTabbable = tabbableElements.first;
    var $lastTabbable = tabbableElements.last;
    var isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
    var isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
    var isEmptyTabList = tabbableElements.length === 0;
    var isOutsideTarget = !(0, _dom.contains)(this._$wrapper.get(0), e.target);
    if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
      e.preventDefault();
      var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
      _events_engine.default.trigger($focusElement, 'focusin');
      _events_engine.default.trigger($focusElement, 'focus');
    }
  },
  _toggleSubscriptions: function _toggleSubscriptions(enabled) {
    if ((0, _window.hasWindow)()) {
      this._toggleHideTopOverlayCallback(enabled);
      this._toggleHideOnParentsScrollSubscription(enabled);
    }
  },
  _toggleHideTopOverlayCallback: function _toggleHideTopOverlayCallback(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }
    if (subscribe) {
      _hide_callback.hideCallback.add(this._hideTopOverlayHandler);
    } else {
      _hide_callback.hideCallback.remove(this._hideTopOverlayHandler);
    }
  },
  _toggleHideOnParentsScrollSubscription: function _toggleHideOnParentsScrollSubscription(needSubscribe) {
    var _this$_parentsScrollS;
    var scrollEvent = (0, _index.addNamespace)('scroll', this.NAME);
    var _ref = (_this$_parentsScrollS = this._parentsScrollSubscriptionInfo) !== null && _this$_parentsScrollS !== void 0 ? _this$_parentsScrollS : {},
      prevTargets = _ref.prevTargets,
      handler = _ref.handler;
    _events_engine.default.off(prevTargets, scrollEvent, handler);
    var closeOnScroll = this.option('hideOnParentScroll');
    if (needSubscribe && closeOnScroll) {
      var $parents = this._hideOnParentScrollTarget().parents();
      if (_devices.default.real().deviceType === 'desktop') {
        $parents = $parents.add(window);
      }
      _events_engine.default.on($parents, scrollEvent, handler);
      this._parentsScrollSubscriptionInfo.prevTargets = $parents;
    }
  },
  _hideOnParentsScrollHandler: function _hideOnParentsScrollHandler(e) {
    var closeHandled = false;
    var closeOnScroll = this.option('hideOnParentScroll');
    if ((0, _type.isFunction)(closeOnScroll)) {
      closeHandled = closeOnScroll(e);
    }
    if (!closeHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  },
  _hideOnParentScrollTarget: function _hideOnParentScrollTarget() {
    return this._$wrapper;
  },
  _render: function _render() {
    this.callBase();
    this._appendContentToElement();
    this._renderVisibilityAnimate(this.option('visible'));
  },
  _appendContentToElement: function _appendContentToElement() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  },
  _renderContent: function _renderContent() {
    var shouldDeferRendering = !this._currentVisible && this.option('deferRendering');
    var isParentHidden = this.option('visible') && this._isParentHidden();
    if (isParentHidden) {
      this._isHidden = true;
      return;
    }
    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }
    this._contentAlreadyRendered = true;
    this._appendContentToElement();
    this.callBase();
  },
  _isParentHidden: function _isParentHidden() {
    if (!this.option('_checkParentVisibility')) {
      return false;
    }
    if (this._parentHidden !== undefined) {
      return this._parentHidden;
    }
    var $parent = this.$element().parent();
    if ($parent.is(':visible')) {
      return false;
    }
    var isHidden = false;
    $parent.add($parent.parents()).each(function () {
      var $element = (0, _renderer.default)(this);
      if ($element.css('display') === 'none') {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !_dom_adapter.default.getBody().contains($parent.get(0));
  },
  _renderContentImpl: function _renderContentImpl() {
    var _this11 = this;
    var whenContentRendered = new _deferred.Deferred();
    var contentTemplateOption = this.option('contentTemplate');
    var contentTemplate = this._getTemplate(contentTemplateOption);
    var transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    contentTemplate && contentTemplate.render({
      container: (0, _element.getPublicElement)(this.$content()),
      noModel: true,
      transclude,
      onRendered: function onRendered() {
        whenContentRendered.resolve();

        // NOTE: T1114344
        if (_this11.option('templatesRenderAsynchronously')) {
          _this11._dimensionChanged();
        }
      }
    });
    this._toggleWrapperScrollEventsSubscription(this.option('preventScrollEvents'));
    whenContentRendered.done(function () {
      if (_this11.option('visible')) {
        _this11._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  },
  _getPositionControllerConfig() {
    var _this$option3 = this.option(),
      container = _this$option3.container,
      visualContainer = _this$option3.visualContainer,
      _fixWrapperPosition = _this$option3._fixWrapperPosition,
      restorePosition = _this$option3.restorePosition;
    // NOTE: position is passed to controller in renderGeometry to prevent window field using in server side mode

    return {
      container,
      visualContainer,
      $root: this.$element(),
      $content: this._$content,
      $wrapper: this._$wrapper,
      onPositioned: this._actions.onPositioned,
      onVisualPositionChanged: this._actions.onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition
    };
  },
  _initPositionController() {
    this._positionController = new _overlay_position_controller.OverlayPositionController(this._getPositionControllerConfig());
  },
  _toggleWrapperScrollEventsSubscription: function _toggleWrapperScrollEventsSubscription(enabled) {
    var eventName = (0, _index.addNamespace)(_drag.move, this.NAME);
    _events_engine.default.off(this._$wrapper, eventName);
    if (enabled) {
      _events_engine.default.on(this._$wrapper, eventName, {
        validate: function validate() {
          return true;
        },
        getDirection: function getDirection() {
          return 'both';
        },
        _toggleGestureCover: function _toggleGestureCover(toggle) {
          if (!toggle) {
            this._toggleGestureCoverImpl(toggle);
          }
        },
        _clearSelection: _common.noop,
        isNative: true
      }, function (e) {
        var originalEvent = e.originalEvent.originalEvent;
        var _ref2 = originalEvent || {},
          type = _ref2.type;
        var isWheel = type === 'wheel';
        var isMouseMove = type === 'mousemove';
        var isScrollByWheel = isWheel && !(0, _index.isCommandKeyPressed)(e);
        e._cancelPreventDefault = true;
        if (originalEvent && e.cancelable !== false && (!isMouseMove && !isWheel || isScrollByWheel)) {
          e.preventDefault();
        }
      });
    }
  },
  _moveFromContainer: function _moveFromContainer() {
    this._$content.appendTo(this.$element());
    this._$wrapper.detach();
  },
  _checkContainerExists() {
    var $wrapperContainer = this._positionController.$container;

    // NOTE: The container is undefined when DOM is not ready yet. See T1143527
    if ($wrapperContainer === undefined) {
      return;
    }
    var containerExists = $wrapperContainer.length > 0;
    if (!containerExists) {
      _ui.default.log('W1021', this.NAME);
    }
  },
  _moveToContainer: function _moveToContainer() {
    var $wrapperContainer = this._positionController.$container;
    this._$wrapper.appendTo($wrapperContainer);
    this._$content.appendTo(this._$wrapper);
  },
  _renderGeometry: function _renderGeometry(options) {
    var _this$option4 = this.option(),
      visible = _this$option4.visible;
    if (visible && (0, _window.hasWindow)()) {
      this._stopAnimation();
      this._renderGeometryImpl();
    }
  },
  _renderGeometryImpl: function _renderGeometryImpl() {
    // NOTE: position can be specified as a function which needs to be called strict on render start
    this._positionController.updatePosition(this._getOptionValue('position'));
    this._renderWrapper();
    this._renderDimensions();
    this._renderPosition();
  },
  _renderPosition() {
    this._positionController.positionContent();
  },
  _isAllWindowCovered: function _isAllWindowCovered() {
    return (0, _type.isWindow)(this._positionController.$visualContainer.get(0)) && this.option('shading');
  },
  _toggleSafariScrolling: function _toggleSafariScrolling() {
    var visible = this.option('visible');
    var $body = (0, _renderer.default)(_dom_adapter.default.getBody());
    var isIosSafari = _devices.default.real().platform === 'ios' && _browser.default.safari;
    var isAllWindowCovered = this._isAllWindowCovered();
    var isScrollingPrevented = $body.hasClass(PREVENT_SAFARI_SCROLLING_CLASS);
    var shouldPreventScrolling = !isScrollingPrevented && visible && isAllWindowCovered;
    var shouldEnableScrolling = isScrollingPrevented && (!visible || !isAllWindowCovered || this._disposed);
    if (isIosSafari) {
      if (shouldEnableScrolling) {
        $body.removeClass(PREVENT_SAFARI_SCROLLING_CLASS);
        window.scrollTo(0, this._cachedBodyScrollTop);
        this._cachedBodyScrollTop = undefined;
      } else if (shouldPreventScrolling) {
        this._cachedBodyScrollTop = window.pageYOffset;
        $body.addClass(PREVENT_SAFARI_SCROLLING_CLASS);
      }
    }
  },
  _renderWrapper: function _renderWrapper() {
    this._positionController.styleWrapperPosition();
    this._renderWrapperDimensions();
    this._positionController.positionWrapper();
  },
  _renderWrapperDimensions: function _renderWrapperDimensions() {
    var $visualContainer = this._positionController.$visualContainer;
    var documentElement = _dom_adapter.default.getDocumentElement();
    var isVisualContainerWindow = (0, _type.isWindow)($visualContainer.get(0));
    var wrapperWidth = isVisualContainerWindow ? documentElement.clientWidth : (0, _size.getOuterWidth)($visualContainer);
    var wrapperHeight = isVisualContainerWindow ? window.innerHeight : (0, _size.getOuterHeight)($visualContainer);
    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  },
  _renderDimensions: function _renderDimensions() {
    var content = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue('minWidth', content),
      maxWidth: this._getOptionValue('maxWidth', content),
      minHeight: this._getOptionValue('minHeight', content),
      maxHeight: this._getOptionValue('maxHeight', content),
      width: this._getOptionValue('width', content),
      height: this._getOptionValue('height', content)
    });
  },
  _focusTarget: function _focusTarget() {
    return this._$content;
  },
  _attachKeyboardEvents: function _attachKeyboardEvents() {
    var _this12 = this;
    this._keyboardListenerId = _short.keyboard.on(this._$content, null, function (opts) {
      return _this12._keyboardHandler(opts);
    });
  },
  _keyboardHandler: function _keyboardHandler(options) {
    var e = options.originalEvent;
    var $target = (0, _renderer.default)(e.target);
    if ($target.is(this._$content) || !this.option('ignoreChildEvents')) {
      this.callBase.apply(this, arguments);
    }
  },
  _isVisible: function _isVisible() {
    return this.option('visible');
  },
  _visibilityChanged: function _visibilityChanged(visible) {
    if (visible) {
      if (this.option('visible')) {
        this._renderVisibilityAnimate(visible);
      }
    } else {
      this._renderVisibilityAnimate(visible);
    }
  },
  _dimensionChanged: function _dimensionChanged() {
    this._renderGeometry();
  },
  _clean: function _clean() {
    var options = this.option();
    if (!this._contentAlreadyRendered && !options.isRenovated) {
      this.$content().empty();
    }
    this._renderVisibility(false);
    this._stopShowTimer();
    this._cleanFocusState();
  },
  _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }
    this._asyncShowTimeout = null;
  },
  _dispose: function _dispose() {
    _fx.default.stop(this._$content, false);
    clearTimeout(this._deferShowTimer);
    this._toggleViewPortSubscription(false);
    this._toggleSubscriptions(false);
    this._updateZIndexStackPosition(false);
    this._toggleTabTerminator(false);
    this._actions = null;
    this._parentsScrollSubscriptionInfo = null;
    this.callBase();
    this._toggleSafariScrolling();
    this.option('visible') && zIndexPool.remove(this._zIndex);
    this._$wrapper.remove();
    this._$content.remove();
  },
  _toggleRTLDirection: function _toggleRTLDirection(rtl) {
    this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl);
  },
  _optionChanged: function _optionChanged(args) {
    var _this13 = this;
    var value = args.value,
      name = args.name;
    if (this._getActionsList().includes(name)) {
      this._initActions();
      return;
    }
    switch (name) {
      case 'animation':
        break;
      case 'shading':
        this._toggleShading(this.option('visible'));
        this._toggleSafariScrolling();
        break;
      case 'shadingColor':
        this._toggleShading(this.option('visible'));
        break;
      case 'width':
      case 'height':
        this._renderGeometry();
        break;
      case 'minWidth':
      case 'maxWidth':
      case 'minHeight':
      case 'maxHeight':
        this._renderGeometry();
        break;
      case 'position':
        this._positionController.updatePosition(this.option('position'));
        this._positionController.restorePositionOnNextRender(true);
        this._renderGeometry();
        this._toggleSafariScrolling();
        break;
      case 'visible':
        this._renderVisibilityAnimate(value).done(function () {
          var _this13$_animateDefer;
          return (_this13$_animateDefer = _this13._animateDeferred) === null || _this13$_animateDefer === void 0 ? void 0 : _this13$_animateDefer.resolveWith(_this13);
        }).fail(function () {
          var _this13$_animateDefer2;
          return (_this13$_animateDefer2 = _this13._animateDeferred) === null || _this13$_animateDefer2 === void 0 ? void 0 : _this13$_animateDefer2.reject();
        });
        break;
      case 'container':
        this._positionController.updateContainer(value);
        this._invalidate();
        this._toggleSafariScrolling();
        break;
      case 'visualContainer':
        this._positionController.updateVisualContainer(value);
        this._renderWrapper();
        this._toggleSafariScrolling();
        break;
      case 'innerOverlay':
        this._initInnerOverlayClass();
        break;
      case 'deferRendering':
      case 'contentTemplate':
        this._contentAlreadyRendered = false;
        this._clean();
        this._invalidate();
        break;
      case 'hideTopOverlayHandler':
        this._toggleHideTopOverlayCallback(false);
        this._initHideTopOverlayHandler(value);
        this._toggleHideTopOverlayCallback(this.option('visible'));
        break;
      case 'hideOnParentScroll':
        this._toggleHideOnParentsScrollSubscription(this.option('visible'));
        break;
      case 'closeOnOutsideClick':
      case 'hideOnOutsideClick':
      case 'propagateOutsideClick':
        break;
      case 'rtlEnabled':
        this._contentAlreadyRendered = false;
        this.callBase(args);
        break;
      case '_fixWrapperPosition':
        this._positionController.fixWrapperPosition = value;
        break;
      case 'wrapperAttr':
        this._renderWrapperAttributes();
        break;
      case 'restorePosition':
        this._positionController.restorePosition = value;
        break;
      case 'preventScrollEvents':
        this._logDeprecatedPreventScrollEventsInfo();
        this._toggleWrapperScrollEventsSubscription(value);
        break;
      default:
        this.callBase(args);
    }
  },
  toggle: function toggle(showing) {
    var _this14 = this;
    showing = showing === undefined ? !this.option('visible') : showing;
    var result = new _deferred.Deferred();
    if (showing === this.option('visible')) {
      return result.resolveWith(this, [showing]).promise();
    }
    var animateDeferred = new _deferred.Deferred();
    this._animateDeferred = animateDeferred;
    this.option('visible', showing);
    animateDeferred.promise().done(function () {
      delete _this14._animateDeferred;
      result.resolveWith(_this14, [_this14.option('visible')]);
    }).fail(function () {
      delete _this14._animateDeferred;
      result.reject();
    });
    return result.promise();
  },
  $content: function $content() {
    return this._$content;
  },
  show: function show() {
    return this.toggle(true);
  },
  hide: function hide() {
    return this.toggle(false);
  },
  content: function content() {
    return (0, _element.getPublicElement)(this._$content);
  },
  repaint: function repaint() {
    if (this._contentAlreadyRendered) {
      this._positionController.restorePositionOnNextRender(true);
      this._renderGeometry({
        forceStopAnimation: true
      });
      (0, _visibility_change.triggerResizeEvent)(this._$content);
    } else {
      this.callBase();
    }
  }
});

/**
* @name ui.dxOverlay
* @section utils
*/
Overlay.baseZIndex = function (zIndex) {
  return zIndexPool.base(zIndex);
};
(0, _component_registrator.default)('dxOverlay', Overlay);
var _default = Overlay;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 85421:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.remove = exports.isLastZIndexInStack = exports.create = exports.clearStack = exports.base = void 0;
var _common = __webpack_require__(20576);
var baseZIndex = 1500;
var zIndexStack = [];
var base = function base(ZIndex) {
  baseZIndex = (0, _common.ensureDefined)(ZIndex, baseZIndex);
  return baseZIndex;
};
exports.base = base;
var create = function create() {
  var baseIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : baseZIndex;
  var length = zIndexStack.length;
  var index = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index);
  return index;
};
exports.create = create;
var remove = function remove(zIndex) {
  var position = zIndexStack.indexOf(zIndex);
  if (position >= 0) {
    zIndexStack.splice(position, 1);
  }
};
exports.remove = remove;
var isLastZIndexInStack = function isLastZIndexInStack(zIndex) {
  return zIndexStack.length && zIndexStack[zIndexStack.length - 1] === zIndex;
};
exports.isLastZIndexInStack = isLastZIndexInStack;
var clearStack = function clearStack() {
  zIndexStack = [];
};
exports.clearStack = clearStack;

/***/ }),

/***/ 26983:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var toMs = _date.default.dateToMilliseconds;
var DateAdapterCore = /*#__PURE__*/function () {
  function DateAdapterCore(source) {
    this._source = new Date(source.getTime ? source.getTime() : source);
  }
  var _proto = DateAdapterCore.prototype;
  _proto.result = function result() {
    return this._source;
  };
  _proto.getTimezoneOffset = function getTimezoneOffset() {
    var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
    var value = this._source.getTimezoneOffset();
    if (format === 'minute') {
      return value * toMs('minute');
    }
    return value;
  };
  _proto.getTime = function getTime() {
    return this._source.getTime();
  };
  _proto.setTime = function setTime(value) {
    this._source.setTime(value);
    return this;
  };
  _proto.addTime = function addTime(value) {
    this._source.setTime(this._source.getTime() + value);
    return this;
  };
  _proto.setMinutes = function setMinutes(value) {
    this._source.setMinutes(value);
    return this;
  };
  _proto.addMinutes = function addMinutes(value) {
    this._source.setMinutes(this._source.getMinutes() + value);
    return this;
  };
  _proto.subtractMinutes = function subtractMinutes(value) {
    this._source.setMinutes(this._source.getMinutes() - value);
    return this;
  };
  _createClass(DateAdapterCore, [{
    key: "source",
    get: function get() {
      // TODO
      return this._source;
    }
  }]);
  return DateAdapterCore;
}();
var DateAdapter = function DateAdapter(date) {
  return new DateAdapterCore(date);
};
var _default = DateAdapter;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 61189:
/***/ (function(module, exports) {



exports["default"] = void 0;
var _default = {
  'zones': [{
    'id': 'Africa/Abidjan',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Accra',
    'untils': '-r507yk|1e3pak|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|cjvlc|681qo|clq9c|681qo|cjvlc|681qo|cjvlc|681qo|Infinity',
    'offsets': '0.8667|0|-20',
    'offsetIndices': '012121212121212121212121212121212121212121212121'
  }, {
    'id': 'Africa/Addis_Ababa',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Algiers',
    'untils': '-uozn3l|2qx1nl|5luo0|8y800|a4tc0|7vc00|auqo0|7idc0|b7pc0|6sg00|cyo00|7ayo0|53c00|9idxc0|3i040|51mw0|253uk0|9o2k0|92040|8l3s0|jutc0|4uy840|3rdzw0|46xc00|7x6o0|2xco40|8n180|7x9g0|9d440|kiqg0|9d440|9q2s0|9cyk0|Infinity',
    'offsets': '-9.35|0|-60|-120',
    'offsetIndices': '0121212121212121232321212122321212'
  }, {
    'id': 'Africa/Asmara',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Asmera',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Bamako',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Bangui',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Banjul',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Bissau',
    'untils': '-u9rek0|wvoyo0|Infinity',
    'offsets': '62.3333|60|0',
    'offsetIndices': '012'
  }, {
    'id': 'Africa/Blantyre',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Brazzaville',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Bujumbura',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Cairo',
    'untils': '-fdls80|40d80|a31g0|7x3w0|a4w40|aqyk0|80ys0|b07w0|7tk40|b07w0|8jhg0|a8fw0|60go40|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|f9x80|3i040|eluk0|462s0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|b5rw0|7m5g0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|aqvs0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7k580|b5xg0|6u7w0|bvus0|6h980|c8tg0|64ak0|cyqs0|5anw0|1jms0|12t80|1w22s0|25p80|1sw40|2vmk0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Africa/Casablanca',
    'untils': '-tblt9g|di7nxg|3huk0|51k40|2znuk0|2dp9g0|776k0|8nt2s0|657w0|3ifxg0|3jp80|va040|4qak0|e1ms0|7pp80|cnms0|3afw0|2xi840|xqqk0|bp56s0|4qak0|e1ms0|45x80|d2g40|51ek0|c8tg0|64ak0|e1sc0|47uo0|1leo0|23xc0|asw00|3lmo0|1qyo0|40g00|7x6o0|4mo00|1stc0|4deo0|7x6o0|3ylc0|1stc0|51hc0|7x6o0|3lmo0|1stc0|5reo0|7k800|2vpc0|25s00|64dc0|7k800|2iqo0|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|25s00|g7c00|1stc0|g7c00|25s00|Infinity',
    'offsets': '30.3333|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Africa/Ceuta',
    'untils': '-qyiys0|7x3w0|2vt440|8sqs0|ssyk0|8n6s0|9px80|905g0|a2yo0|902o0|k69dc0|657w0|3ifxg0|3jp80|va040|4qak0|e1ms0|7pp80|cnms0|3afw0|2xi840|129us0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Africa/Conakry',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Dakar',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Dar_es_Salaam',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Djibouti',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Douala',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/El_Aaiun',
    'untils': '-isdxk0|m2g0c0|vek0|4qak0|e1ms0|7pp80|cnms0|3afw0|fke5g0|4qak0|e1ms0|45x80|d2g40|51ek0|c8tg0|64ak0|e1sc0|47uo0|1leo0|23xc0|asw00|3lmo0|1qyo0|40g00|7x6o0|4mo00|1stc0|4deo0|7x6o0|3ylc0|1stc0|51hc0|7x6o0|3lmo0|1stc0|5reo0|7k800|2vpc0|25s00|64dc0|7k800|2iqo0|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|1stc0|gkao0|1stc0|g7c00|25s00|g7c00|1stc0|g7c00|25s00|g7c00|25s00|g7c00|1stc0|g7c00|25s00|Infinity',
    'offsets': '52.8|60|0|-60',
    'offsetIndices': '012323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Africa/Freetown',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Gaborone',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Harare',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Johannesburg',
    'untils': '-yvtdi0|kn7o60|9cyk0|9d440|9cyk0|Infinity',
    'offsets': '-90|-120|-180',
    'offsetIndices': '012121'
  }, {
    'id': 'Africa/Juba',
    'untils': '-kcrsis|kixuys|8l6k0|a4w40|8n180|a6qs0|8n180|a31g0|8ovw0|a16s0|8qqk0|9zc40|8sl80|9xhg0|8wak0|9ts40|8y580|a4w40|8n180|a31g0|8ovw0|a16s0|8sl80|9xhg0|8ufw0|9vms0|8wak0|9ts40|8y580|a4w40|8ovw0|a16s0|8qqk0|7frw40|Infinity',
    'offsets': '-126.4667|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212'
  }, {
    'id': 'Africa/Kampala',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Khartoum',
    'untils': '-kcrsow|kixv4w|8l6k0|a4w40|8n180|a6qs0|8n180|a31g0|8ovw0|a16s0|8qqk0|9zc40|8sl80|9xhg0|8wak0|9ts40|8y580|a4w40|8n180|a31g0|8ovw0|a16s0|8sl80|9xhg0|8ufw0|9vms0|8wak0|9ts40|8y580|a4w40|8ovw0|a16s0|8qqk0|7frw40|9ac180|Infinity',
    'offsets': '-130.1333|-120|-180',
    'offsetIndices': '012121212121212121212121212121212121'
  }, {
    'id': 'Africa/Kigali',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Kinshasa',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lagos',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Libreville',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lome',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Luanda',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lubumbashi',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Lusaka',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Malabo',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Maputo',
    'untils': '-yvtfd8|Infinity',
    'offsets': '-130.3333|-120',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Maseru',
    'untils': '-yvtdi0|kn7o60|9cyk0|9d440|9cyk0|Infinity',
    'offsets': '-90|-120|-180',
    'offsetIndices': '012121'
  }, {
    'id': 'Africa/Mbabane',
    'untils': '-yvtdi0|kn7o60|9cyk0|9d440|9cyk0|Infinity',
    'offsets': '-90|-120|-180',
    'offsetIndices': '012121'
  }, {
    'id': 'Africa/Mogadishu',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Monrovia',
    'untils': '-qj6zc4|rl202a|Infinity',
    'offsets': '43.1333|44.5|0',
    'offsetIndices': '012'
  }, {
    'id': 'Africa/Nairobi',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Africa/Ndjamena',
    'untils': '-u9rk4c|zdk5cc|7iak0|Infinity',
    'offsets': '-60.2|-60|-120',
    'offsetIndices': '0121'
  }, {
    'id': 'Africa/Niamey',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Nouakchott',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Ouagadougou',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Porto-Novo',
    'untils': '-q9qbao|Infinity',
    'offsets': '-13.6|-60',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Sao_Tome',
    'untils': '-u9rhc0|1jbm840|irxc0|Infinity',
    'offsets': '36.75|0|-60',
    'offsetIndices': '0121'
  }, {
    'id': 'Africa/Timbuktu',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Africa/Tripoli',
    'untils': '-q3gfrw|gl6ajw|422c0|xado0|4bbo0|wrpg0|4s580|1kdpg0|c05bw0|4mqs0|9et80|9d440|9et80|9eys0|9et80|9mdg0|95jw0|9io40|9cyk0|99es0|9et80|9eys0|9et80|9d440|9et80|b2840|3cf3w0|9kis0|9et80|7vqyw0|75eo0|asw00|Infinity',
    'offsets': '-52.7333|-60|-120',
    'offsetIndices': '012121212121212121212121212122122'
  }, {
    'id': 'Africa/Tunis',
    'untils': '-uozn3l|enxevl|b5uo0|53c00|u8w00|7x9g0|c8w80|7k800|z3w0|ew40|8bx80|9d440|9nx00|925o0|8l100|gi3440|7k800|b9k00|7vc00|51mw00|5ytc0|9d1c0|9d1c0|b9k00|7thc0|7m0tc0|7tk40|93us0|b5uo0|7k800|b5uo0|7x6o0|asw00|Infinity',
    'offsets': '-9.35|-60|-120',
    'offsetIndices': '0121212121212121212121212121212121'
  }, {
    'id': 'Africa/Windhoek',
    'untils': '-yvtdi0|kn7o60|9cyk0|oj2nw0|235k00|8lho0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '-90|-120|-180|-60',
    'offsetIndices': '01211313131313131313131313131313131313131313131313131'
  }, {
    'id': 'America/Adak',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Anchorage',
    'untils': '-ek1qo0|1tyx80|2e400|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '600|540|480',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Anguilla',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Antigua',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Araguaina',
    'untils': '-t85j2o|99k8mo|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|2yl440|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|51udg0|64ak0|Infinity',
    'offsets': '192.8|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Argentina/Buenos_Aires',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232323232'
  }, {
    'id': 'America/Argentina/Catamarca',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132321232'
  }, {
    'id': 'America/Argentina/ComodRivadavia',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132321232'
  }, {
    'id': 'America/Argentina/Cordoba',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132323232'
  }, {
    'id': 'America/Argentina/Jujuy',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|c8w80|776k0|ag040|7k2g0|bvus0|776k0|7qcg40|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323121323232'
  }, {
    'id': 'America/Argentina/La_Rioja',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6qik0|3g880|8jbw0|6u7w0|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323231232321232'
  }, {
    'id': 'America/Argentina/Mendoza',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bktk0|71mk0|bqas0|73h80|bvus0|773s0|5unes0|6hes0|1p7mk0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232312121321232'
  }, {
    'id': 'America/Argentina/Rio_Gallegos',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232321232'
  }, {
    'id': 'America/Argentina/Salta',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323231323232'
  }, {
    'id': 'America/Argentina/San_Juan',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6qik0|3g880|8jbw0|6u7w0|bvus0|776k0|5v2840|2txg0|1sgak0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323231232321232'
  }, {
    'id': 'America/Argentina/San_Luis',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|7pp80|b2aw0|71mk0|4qg40|6s8ik0|2txg0|1sgak0|14nw0|2gys0|b5xg0|7k580|b5xg0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323121212321212'
  }, {
    'id': 'America/Argentina/Tucuman',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|mas0|1um2k0|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212323232313232123232'
  }, {
    'id': 'America/Argentina/Ushuaia',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|5v0dg0|12ys0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232321232'
  }, {
    'id': 'America/Aruba',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Asuncion',
    'untils': '-jy93zk|ldwofk|s4vw0|s6w40|7tek0|b0dg0|7rjw0|b0dg0|7rjw0|b0dg0|9cyk0|9eys0|9et80|9eys0|9cyk0|9eys0|9cyk0|9eys0|9cyk0|9eys0|9et80|9eys0|9cyk0|9eys0|9cyk0|9eys0|9cyk0|9eys0|9et80|9eys0|9cyk0|ahus0|8a2k0|9eys0|9cyk0|9o840|7k580|b7s40|93p80|9gtg0|7nuk0|b42s0|7lzw0|b5xg0|7tek0|b9ms0|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|7kas0|b5rw0|7x9g0|ast80|a31g0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|776k0|biw40|8zzw0|905g0|9px80|905g0|9px80|9d440|8n180|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|a31g0|8n180|a31g0|8n180|a31g0|Infinity',
    'offsets': '230.6667|240|180',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Atikokan',
    'untils': '-qzov40|a2vw0|bfxjw0|pmdk0|1tz8c0|2dsw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101111'
  }, {
    'id': 'America/Atka',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Bahia_Banderas',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|asqg0|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '421|420|360|480|300',
    'offsetIndices': '0121212131212121212121212121212121212142424242424242424242424242424242424242424242424242424242'
  }, {
    'id': 'America/Bahia',
    'untils': '-t85kv8|99kaf8|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|4irc40|6u7w0|Infinity',
    'offsets': '154.0667|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Barbados',
    'untils': '-o0aiaj|46b400|npv1mj|5rbw0|a31g0|8n180|a31g0|8n180|ag040|84ik0|Infinity',
    'offsets': '238.4833|240|180',
    'offsetIndices': '00121212121'
  }, {
    'id': 'America/Belem',
    'untils': '-t85j0s|99k8ks|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|Infinity',
    'offsets': '193.9333|180|120',
    'offsetIndices': '012121212121212121212121212121'
  }, {
    'id': 'America/Belize',
    'untils': '-u52ic0|3edkc0|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|bvte0|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|bvte0|6u9a0|g2t2q0|3e580|4mcys0|2vmk0|Infinity',
    'offsets': '352.8|360|330|300',
    'offsetIndices': '01212121212121212121212121212121212121212121212121213131'
  }, {
    'id': 'America/Blanc-Sablon',
    'untils': '-qzp0o0|a2vw0|c5jxg0|1tzdw0|2dnc0|Infinity',
    'offsets': '240|180',
    'offsetIndices': '010110'
  }, {
    'id': 'America/Boa_Vista',
    'untils': '-t85grk|99k93k|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|62xk40|7k580|biw40|cvw0|Infinity',
    'offsets': '242.6667|240|180',
    'offsetIndices': '0121212121212121212121212121212121'
  }, {
    'id': 'America/Bogota',
    'untils': '-srdoy8|14f1hi8|ha580|Infinity',
    'offsets': '296.2667|300|240',
    'offsetIndices': '0121'
  }, {
    'id': 'America/Boise',
    'untils': '-r0emw0|ast80|7x9g0|ast80|1um840|9s7jw0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|51k40|doik0|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|360',
    'offsetIndices': '0101012212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Buenos_Aires',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvus0|6u7w0|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323232323232'
  }, {
    'id': 'America/Cambridge_Bay',
    'untils': '-q3gdc0|bjeec0|1tz5k0|2dvo0|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x6o0|ast80|ct40|7kj40|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|420|360|300',
    'offsetIndices': '0122131212121212121212121212121212121212121212233221212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Campo_Grande',
    'untils': '-t85hvw|99ka7w|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|cls40|64ak0|dfes0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '218.4667|240|180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Cancun',
    'untils': '-p1u7c0|vauo00|7ggw40|afuk0|8a840|afuk0|8a840|64ak0|4bms0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|51k40|Infinity',
    'offsets': '347.0667|360|300|240',
    'offsetIndices': '0123232321212121212121212121212121212121212'
  }, {
    'id': 'America/Caracas',
    'untils': '-u7lcxw|rlo83w|meoxm0|4dps00|Infinity',
    'offsets': '267.6667|270|240',
    'offsetIndices': '01212'
  }, {
    'id': 'America/Catamarca',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|5v42s0|z9g0|1u93w0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132321232'
  }, {
    'id': 'America/Cayenne',
    'untils': '-uj7yb4|tcw6r4|Infinity',
    'offsets': '209.3333|240|180',
    'offsetIndices': '012'
  }, {
    'id': 'America/Cayman',
    'untils': '-w757vc|Infinity',
    'offsets': '319.6|300',
    'offsetIndices': '01'
  }, {
    'id': 'America/Chicago',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bvus0|776k0|7kas0|b5rw0|9d440|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|7x9g0|dbjw0|8a840|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Chihuahua',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|xes2s0|afuk0|8a840|afuk0|8aaw0|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '424.3333|420|360|300',
    'offsetIndices': '0121212323221212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Coral_Harbour',
    'untils': '-qzov40|a2vw0|bfxjw0|pmdk0|1tz8c0|2dsw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101111'
  }, {
    'id': 'America/Cordoba',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132323232'
  }, {
    'id': 'America/Costa_Rica',
    'untils': '-pjw8fn|ubtl3n|51ek0|doo40|51ek0|5jso40|8drw0|acas0|2xh80|Infinity',
    'offsets': '336.2167|360|300',
    'offsetIndices': '0121212121'
  }, {
    'id': 'America/Creston',
    'untils': '-rshz80|vbus0|Infinity',
    'offsets': '420|480',
    'offsetIndices': '010'
  }, {
    'id': 'America/Cuiaba',
    'untils': '-t85hm4|99k9y4|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|w5hg0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '224.3333|240|180',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Curacao',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Danmarkshavn',
    'untils': '-rvusjk|x8nx3k|8zrk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|53hk0|Infinity',
    'offsets': '74.6667|180|120|0',
    'offsetIndices': '01212121212121212121212121212121213'
  }, {
    'id': 'America/Dawson_Creek',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|69uk0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '0101101010101010101010101010101010101010101010101010101011'
  }, {
    'id': 'America/Dawson',
    'untils': '-qzoms0|a2vw0|asys0|882c0|bmiwc0|1tz000|2e180|a7n3w0|9q000|465k00|3e2is0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '540|480|420',
    'offsetIndices': '01010110201212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Denver',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Detroit',
    'untils': '-xx8dyd|5eraud|dyeyk0|1tzb40|2dq40|1c9440|7x3w0|9rlbxo|71s2c|9d440|9cyk0|2cmdg0|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '332.1833|360|300|240',
    'offsetIndices': '0123323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Dominica',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Edmonton',
    'untils': '-x1yazk|629ink|a2vw0|8n6s0|29ek0|h6lg0|9px80|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|9l0g40|1tz5k0|2dvo0|tj1g0|7x3w0|ctzk40|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '453.8667|420|360',
    'offsetIndices': '0121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Eirunepe',
    'untils': '-t85f28|99ka68|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|2yy2s0|6h980|7hg2s0|2t2t80|Infinity',
    'offsets': '279.4667|300|240',
    'offsetIndices': '0121212121212121212121212121212121'
  }, {
    'id': 'America/El_Salvador',
    'untils': '-pkm4tc|ymao5c|7k580|b5xg0|7k580|Infinity',
    'offsets': '356.8|360|300',
    'offsetIndices': '012121'
  }, {
    'id': 'America/Ensenada',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Fort_Nelson',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '01011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'America/Fort_Wayne',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Fortaleza',
    'untils': '-t85kvc|99kafc|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|puk0|id6s0|6h980|Infinity',
    'offsets': '154|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'America/Glace_Bay',
    'untils': '-z94kwc|89fk8c|a2vw0|c5jxg0|1tzdw0|2dnc0|3y8g40|7x3w0|9pa5g0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '239.8|240|180',
    'offsetIndices': '012122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Godthab',
    'untils': '-rvumf4|x8nqz4|8zrk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '206.9333|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Goose_Bay',
    'untils': '-qzp20k|a2vw0|8kjbw0|kzjyk|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|7k580|b5xg0|7k580|b5xg0|1pb260|2dly0|biw40|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|7k580|ag040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|6y2s0|22420|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a2lo|afuk0|8a840|asqg0|7xc80|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8tec|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '210.8667|150.8667|210|150|240|180|120',
    'offsetIndices': '010232323232323233232323232323232323232323232323232323232324545454545454545454545454545454545454545454546454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454'
  }, {
    'id': 'America/Grand_Turk',
    'untils': '-u85og2|z3brw2|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|18ais0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '307.1667|300|240',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121222121212121212121212121212121212121212121'
  }, {
    'id': 'America/Grenada',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Guadeloupe',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Guatemala',
    'untils': '-qqqskk|ss0akk|4ofw0|4tidg0|6djw0|3wwas0|8n180|7n5ms0|7x3w0|Infinity',
    'offsets': '362.0667|360|300',
    'offsetIndices': '0121212121'
  }, {
    'id': 'America/Guayaquil',
    'untils': '-kcr84o|wb620o|3jp80|Infinity',
    'offsets': '314|300|240',
    'offsetIndices': '0121'
  }, {
    'id': 'America/Guyana',
    'untils': '-smcak8|vj4sz8|81rf90|Infinity',
    'offsets': '232.6667|225|180|240',
    'offsetIndices': '0123'
  }, {
    'id': 'America/Halifax',
    'untils': '-z94k80|777go0|9et80|st9o0|a2vw0|ssyk0|5rbw0|cv1g0|69uk0|c6ys0|6kyk0|ci2s0|67zw0|ci2s0|6w2k0|bu040|7lzw0|bu040|66580|bu040|7lzw0|bu040|64ak0|cls40|5v180|cv1g0|6j3w0|c6ys0|79180|b42s0|7lzw0|b42s0|7yyk0|bu040|64ak0|dbpg0|66580|cls40|5ed80|bu040|7lzw0|b42s0|7lzw0|cjxg0|66580|bh1g0|7lzw0|b42s0|7lzw0|6uj00|1tzdw0|2dnc0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|1cm2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '254.4|240|180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Havana',
    'untils': '-n7762o|1icfyo|69uk0|62s040|4ofw0|e1ms0|51ek0|e1ms0|4ofw0|1fhs40|4ofw0|e1ms0|4ofw0|9s9k40|67zw0|cedg0|6h980|9o840|7yyk0|b5xg0|7k580|bvus0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|8a2k0|ag040|8bx80|ae5g0|8drw0|acas0|9cyk0|9d440|9px80|905g0|9px80|9q2s0|7x3w0|8a840|ast80|7x9g0|ast80|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|8a2k0|ag040|8a2k0|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|905g0|a2vw0|905g0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|8n400|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|7x6o0|1cm000|6uao0|bvs00|779c0|bitc0|6uao0|bvs00|779c0|bvs00|779c0|c8qo0|779c0|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|Infinity',
    'offsets': '329.6|300|240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Hermosillo',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '443.8667|420|360|480',
    'offsetIndices': '0121212131212121'
  }, {
    'id': 'America/Indiana/Indianapolis',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Knox',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|9px80|9d440|9cyk0|9d440|s3180|1twas0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|7j5400|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101010101010101010111010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Indiana/Marengo',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|2wsas0|7x3w0|1c9440|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|465h80|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4g00|64dc0|clmk0|fvt9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101011010101010101010101212121212111212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Petersburg',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|501ek0|7kas0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|sfzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|eu02o0|asw00|6udg0|c8nw0|6hc00|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101010101010101010101010111011212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Tell_City',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|501ek0|7kas0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|1tw580|9d440|9cyk0|9d440|9cvs0|9d440|9cyk0|ihslg0|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101021211010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Indiana/Vevay',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|4gyis0|7txx80|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|hfzhg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101101212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Vincennes',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|asys0|7x3w0|3fidg0|7x3w0|asys0|7x3w0|b5rw0|7kas0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|2lz980|9cyk0|9d440|9cyk0|ihslg0|asw00|6udg0|c8nw0|6hc00|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101010121211011212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indiana/Winamac',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|465h80|9cyk0|9d440|9cyk0|ihslg0|asw00|6udg0|c8l40|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '01010110101010101010101010101010101010121211021212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Indianapolis',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Inuvik',
    'untils': '-8ve5c0|6fce80|9q000|71i2w0|ipzw0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|480|360|420',
    'offsetIndices': '0121323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'America/Iqaluit',
    'untils': '-eb6ao0|1l3h80|2dq40|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7xc80|ast80|7x6o0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|240|300|180|360',
    'offsetIndices': '01123212121212121212121212121212121212121212142212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Jamaica',
    'untils': '-u85og2|wbl182|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|Infinity',
    'offsets': '307.1667|300|240',
    'offsetIndices': '0121212121212121212121'
  }, {
    'id': 'America/Jujuy',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|c8w80|776k0|ag040|7k2g0|bvus0|776k0|7qcg40|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121232323121323232'
  }, {
    'id': 'America/Juneau',
    'untils': '-ek1w80|1tz2s0|2dyg0|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9d1c0|9d1c0|9cyk0|9d440|9px80|905g0|9px80|1leo0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|540',
    'offsetIndices': '01101010101010101010101010001010122020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202'
  }, {
    'id': 'America/Kentucky/Louisville',
    'untils': '-r0esg0|ast80|7x9g0|ast80|sg5g0|6bp80|a98o40|7x3w0|6w840|1tz8c0|2dsw0|ast9o|1sw2c|21gis0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|4bh80|3j3xc0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4g00|64dc0|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101010101101010101010101010101010101121212121212111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Kentucky/Monticello',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|bs6g40|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x6o0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Knox_IN',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|9px80|9d440|9cyk0|9d440|s3180|1twas0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|7j5400|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101010101010101010111010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Kralendijk',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/La_Paz',
    'untils': '-jxzspo|84ik0|Infinity',
    'offsets': '272.6|212.6|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Lima',
    'untils': '-w25lpo|fcxjlo|4ml80|93us0|9cyk0|9d440|9cyk0|nw16s0|4ml80|e5c40|4ml80|1fr1g0|4ml80|1yiys0|4ml80|Infinity',
    'offsets': '308.6|300|240',
    'offsetIndices': '0121212121212121'
  }, {
    'id': 'America/Los_Angeles',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|1a3c5o|f2iic|owao0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Louisville',
    'untils': '-r0esg0|ast80|7x9g0|ast80|sg5g0|6bp80|a98o40|7x3w0|6w840|1tz8c0|2dsw0|ast9o|1sw2c|21gis0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|4bh80|3j3xc0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4g00|64dc0|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0101010101101010101010101010101010101121212121212111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Lower_Princes',
    'untils': '-u7lckd|rlo7qd|Infinity',
    'offsets': '275.7833|270|240',
    'offsetIndices': '012'
  }, {
    'id': 'America/Maceio',
    'untils': '-t85ldw|99kaxw|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|2yl440|64ak0|1wf1g0|7k580|biw40|puk0|id6s0|6h980|Infinity',
    'offsets': '142.8667|180|120',
    'offsetIndices': '012121212121212121212121212121212121212121'
  }, {
    'id': 'America/Managua',
    'untils': '-ijh6oo|ka1i0o|xqqk0|24p6s0|53980|dmtg0|53980|60itw0|dq240|53es0|235h80|4beis0|8zzw0|at4c0|7x140|Infinity',
    'offsets': '345.2|360|300',
    'offsetIndices': '0121212121212121'
  }, {
    'id': 'America/Manaus',
    'untils': '-t85gvw|99k97w|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|2yy2s0|6h980|Infinity',
    'offsets': '240.0667|240|180',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'America/Marigot',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Martinique',
    'untils': '-umcvcs|zz5x4s|8zzw0|Infinity',
    'offsets': '244.3333|240|180',
    'offsetIndices': '0121'
  }, {
    'id': 'America/Matamoros',
    'untils': '-p1u7c0|ykt480|ast80|3vppg0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '400|360|300',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Mazatlan',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '425.6667|420|360|480',
    'offsetIndices': '0121212131212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Mendoza',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bktk0|71mk0|bqas0|73h80|bvus0|773s0|5unes0|6hes0|1p7mk0|3yik0|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232312121321232'
  }, {
    'id': 'America/Menominee',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|asys0|7x3w0|a7n9g0|9px80|1at9g0|2396k0|9d1c0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '01010110101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Merida',
    'untils': '-p1u7c0|vauo00|hoyk0|6ys0c0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '358.4667|360|300',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Metlakatla',
    'untils': '-ek1w80|1tz2s0|2dyg0|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|gpc840|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|3ylc0|2itg0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|540',
    'offsetIndices': '01101010101010101010101010101010102020200202020202020202020202020202020202020202'
  }, {
    'id': 'America/Mexico_City',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|3knek0|776k0|rf440|5t6k0|1evk40|71mk0|30p1g0|8n180|nufxo0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '396.6|420|360|300',
    'offsetIndices': '012121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Miquelon',
    'untils': '-ulmyxk|zzqbdk|3m59g0|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '224.6667|240|180|120',
    'offsetIndices': '012323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Moncton',
    'untils': '-z94i40|89fhg0|a2vw0|7mqqo0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|e1ms0|4ofw0|dmtg0|64ak0|cao40|6fek0|bkqs0|7iak0|6y5k0|1tzdw0|2dnc0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|s36s0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a2lo|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6uiyc|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240|180',
    'offsetIndices': '012121212121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Monterrey',
    'untils': '-p1u7c0|ykt480|ast80|3vppg0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '401.2667|360|300',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Montevideo',
    'untils': '-w4mll9|67elc0|1s74p9|9et80|9exe0|9czy0|9exe0|9czy0|3ydyq0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|b5w20|7k6m0|9q1e0|9czy0|asxe0|7x5a0|6do20|ppvy0|4mmm0|8g9qq0|901a0|38pe0|2inw0|2nf9g0|8zzw0|1e3s40|9o3y0|q8he0|2kik0|yxhg0|4bh80|s36s0|2vl60|905g0|5rg20|51ek0|weqs0|3yik0|e1ms0|4ofw0|erk40|3yik0|2vs40|gk7w0|41iys0|3wnw0|erk40|4bh80|c8tg0|64ak0|c8tg0|6u7w0|c8tg0|6h980|bvus0|6u7w0|614qs0|9q2s0|a31g0|7x3w0|ag040|8a2k0|asys0|7x3w0|asys0|7x3w0|asys0|8a2k0|ag040|8a2k0|ag040|8a2k0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '224.85|240|180|210|150|120|90',
    'offsetIndices': '001232323232323232323232324242525242525264252525252525252525252525252525252525252525252'
  }, {
    'id': 'America/Montreal',
    'untils': '-qzoxw0|a2vw0|7yx60|aqzy0|9q8c0|7jzo0|bw0c0|6bp80|cedg0|6h980|c8tg0|6h980|bvus0|776k0|biw40|776k0|biw40|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|xjeo0|1tzb40|2dq40|asys0|7x3w0|ast80|7x3w0|asys0|7x3w0|asys0|b5rw0|7xf00|ast80|7x9g0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Montserrat',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Nassau',
    'untils': '-u6m4c6|r7u7s6|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '309.5|300|240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/New_York',
    'untils': '-r0ev80|ast80|7x9g0|ast80|7x9g0|b5rw0|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tzb40|2dq40|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Nipigon',
    'untils': '-qzoxw0|a2vw0|bfxjw0|pmdk0|1tzb40|2dq40|ewvus0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '010111010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Nome',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l6c0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540|480',
    'offsetIndices': '011001010101010101010101010101010122323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Noronha',
    'untils': '-t85lzw|99k8rw|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|cvw0|iq5g0|6h980|Infinity',
    'offsets': '129.6667|120|60',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'America/North_Dakota/Beulah',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hc00|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101011212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/North_Dakota/Center',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a5c0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101011212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/North_Dakota/New_Salem',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a5c0|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Nuuk',
    'untils': '-rvumf4|x8nqz4|8zrk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '206.9333|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Ojinaga',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|xes2s0|afuk0|8a840|afuk0|8aaw0|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '417.6667|420|360|300',
    'offsetIndices': '0121212323221212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Panama',
    'untils': '-w757vc|Infinity',
    'offsets': '319.6|300',
    'offsetIndices': '01'
  }, {
    'id': 'America/Pangnirtung',
    'untils': '-pkmlc0|b0ke00|1tzdw0|2dnc0|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|asw00|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7xc80|ast80|7x6o0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|240|180|120|300|360',
    'offsetIndices': '012213121212121212121212121212121212114141414154414141414141414141414141414141414141414141414141414141414141414141414141414'
  }, {
    'id': 'America/Paramaribo',
    'untils': '-usj4g8|cixc0c|5lydbk|kcrm6c|Infinity',
    'offsets': '220.6667|220.8667|220.6|210|180',
    'offsetIndices': '01234'
  }, {
    'id': 'America/Phoenix',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|zjedo|4olg0|9et80|bs6lmc|9cyk0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101010'
  }, {
    'id': 'America/Port_of_Spain',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Port-au-Prince',
    'untils': '-rmk9ac|ylcf6c|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8aaw0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|3vpjw0|ast80|7x9g0|ast80|2stv00|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|pkg40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '289|300|240',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Porto_Acre',
    'untils': '-t85fg0|99kak0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|2t2t80|Infinity',
    'offsets': '271.2|300|240',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'America/Porto_Velho',
    'untils': '-t85g60|99k8i0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|Infinity',
    'offsets': '255.6|240|180',
    'offsetIndices': '012121212121212121212121212121'
  }, {
    'id': 'America/Puerto_Rico',
    'untils': '-efsnk0|1ppu40|2dnc0|Infinity',
    'offsets': '240|180',
    'offsetIndices': '0110'
  }, {
    'id': 'America/Punta_Arenas',
    'untils': '-vauawq|3dlssq|157b7a|f4e0q|49hzba|aye0q|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|534ik0|351g0|2fnh80|2mg00|b73400|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|Infinity',
    'offsets': '282.7667|300|240|180',
    'offsetIndices': '0102021212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'America/Rainy_River',
    'untils': '-qzov40|a2vw0|bfxjw0|pmdk0|1tz8c0|2dsw0|ewvus0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010111010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Rankin_Inlet',
    'untils': '-6s8lc0|4c6oo0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|360|240|300',
    'offsetIndices': '012131313131313131313131313131313131313131313331313131313131313131313131313131313131313131313131313131313131313131313131'
  }, {
    'id': 'America/Recife',
    'untils': '-t85ljc|99kb3c|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|cvw0|iq5g0|6h980|Infinity',
    'offsets': '139.6|180|120',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'America/Regina',
    'untils': '-xkq9yc|6l1hmc|a2vw0|60enw0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|1b6840|9cyk0|9d440|8zzw0|9q2s0|9cyk0|9q2s0|9cyk0|9d440|9cyk0|66gc0|1tz5k0|2dvo0|a31g0|9cyk0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|tj1g0|9cyk0|9d440|Infinity',
    'offsets': '418.6|420|360',
    'offsetIndices': '012121212121212121212121221212121212121212121212121212'
  }, {
    'id': 'America/Resolute',
    'untils': '-bnp9c0|97nco0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|360|240|300',
    'offsetIndices': '012131313131313131313131313131313131313131313331313131313331313131313131313131313131313131313131313131313131313131313131'
  }, {
    'id': 'America/Rio_Branco',
    'untils': '-t85fg0|99kak0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|2t2t80|Infinity',
    'offsets': '271.2|300|240',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'America/Rosario',
    'untils': '-px7ys0|5iv8k0|67zw0|a4w40|73h80|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|cls40|66580|cls40|66580|cls40|66580|cls40|67zw0|6a040|hy7w0|6a040|xovw0|3uys0|18nbw0|b0dg0|8ve2k0|3uys0|3yik0|bqas0|71mk0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|7m2qs0|4tzw0|biw40|776k0|bvus0|6u7w0|bvxk0|6u540|bvus0|776k0|7qcg40|3yik0|b5xg0|7k580|Infinity',
    'offsets': '256.8|240|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212123232323132323232'
  }, {
    'id': 'America/Santa_Isabel',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Santarem',
    'untils': '-t85hvc|99ka7c|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|Infinity',
    'offsets': '218.8|240|180',
    'offsetIndices': '0121212121212121212121212121212'
  }, {
    'id': 'America/Santiago',
    'untils': '-vauawq|3dlssq|157b7a|f4e0q|49hzba|aye0q|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|534ik0|351g0|229zw0|2gt80|awo40|2mg00|b73400|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '282.7667|300|240|180',
    'offsetIndices': '010202121212121212321232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'America/Santo_Domingo',
    'untils': '-j6hz1c|hiw29c|67zw0|1dy840|62ha0|cnle0|4h2m0|elyq0|47ta0|ei9e0|4bim0|eek20|4dda0|ecpe0|dkmtg0|1stc0|Infinity',
    'offsets': '280|300|240|270',
    'offsetIndices': '01213131313131212'
  }, {
    'id': 'America/Sao_Paulo',
    'untils': '-t85jd8|99k8x8|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5k02s0|6onw0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|cls40|64ak0|dfes0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '186.4667|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Scoresbysund',
    'untils': '-rvurxk|x8ntpk|902o0|9cvs0|9cyk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '87.8667|120|60|0',
    'offsetIndices': '0121323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/Shiprock',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Sitka',
    'untils': '-ek1w80|1tz2s0|2dyg0|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1leo0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420|540',
    'offsetIndices': '01101010101010101010101010101010122020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202'
  }, {
    'id': 'America/St_Barthelemy',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Johns',
    'untils': '-ris3ck|8bx80|ar440|a2vw0|9tjs0|53980|dkys0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|7tmw0|1wfuk|8zzw0|a3480|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|7k580|b5xg0|7k580|b5xg0|1pb260|2dly0|biw40|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|7k580|ag040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a2lo|afuk0|8a840|asqg0|7xc80|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8tec|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '210.8667|150.8667|210|150|90',
    'offsetIndices': '01010101010101010101010101010101010102323232323232323323232323232323232323232323232323232323232323232323232323232323232323232323232323232324232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'America/St_Kitts',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Lucia',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Thomas',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/St_Vincent',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Swift_Current',
    'untils': '-xkq9d4|6l1h14|a2vw0|c5jxg0|1tz5k0|2dvo0|asys0|8n180|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|3yles0|9cyk0|s36s0|9cyk0|9d440|7x3w0|b5xg0|7k580|5j4lg0|Infinity',
    'offsets': '431.3333|420|360',
    'offsetIndices': '012122121212121212121212'
  }, {
    'id': 'America/Tegucigalpa',
    'untils': '-pfzh6k|yho0ik|7k580|b5xg0|7k580|96x1g0|4qak0|Infinity',
    'offsets': '348.8667|360|300',
    'offsetIndices': '01212121'
  }, {
    'id': 'America/Thule',
    'untils': '-rvuj9g|12yzilg|9cyk0|9d440|9cyk0|9q2s0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '275.1333|240|180',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Thunder_Bay',
    'untils': '-vbavc0|gr8qs0|1tzb40|2dq40|ctmlg0|9cyk0|9d440|9px80|9d440|9cyk0|s36s0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '0122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'America/Tijuana',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Toronto',
    'untils': '-qzoxw0|a2vw0|7yx60|aqzy0|9q8c0|7jzo0|bw0c0|6bp80|cedg0|6h980|c8tg0|6h980|bvus0|776k0|biw40|776k0|biw40|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|xjeo0|1tzb40|2dq40|asys0|7x3w0|ast80|7x3w0|asys0|7x3w0|asys0|b5rw0|7xf00|ast80|7x9g0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Tortola',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Vancouver',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '0101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Virgin',
    'untils': '-u6m79w|Infinity',
    'offsets': '246.0667|240',
    'offsetIndices': '01'
  }, {
    'id': 'America/Whitehorse',
    'untils': '-qzoms0|a2vw0|asys0|882c0|bmiwc0|1tz000|2e180|a7n3w0|9q000|tiyo0|6qp440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '540|480|420',
    'offsetIndices': '01010110201212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'America/Winnipeg',
    'untils': '-s0s7c0|7k580|tj700|a2vw0|9ok840|6u7w0|2a5hg0|1tz8c0|2dsw0|biw40|7x3w0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b7s40|7tek0|autg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|7x3w0|1cm2s0|7k580|1cm2s0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Yakutat',
    'untils': '-ek1tg0|1tz000|2e180|cawis0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1lbw0|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '540|480',
    'offsetIndices': '01101010101010101010101010101010100101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'America/Yellowknife',
    'untils': '-i9m2o0|3pk3o0|1tz5k0|2dvo0|a7n3w0|9q000|7k85k0|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '0|420|360|300',
    'offsetIndices': '012213121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Antarctica/Casey',
    'untils': '-irxc0|lag4o0|73bo0|uz1o0|60l80|2fnh80|pz9g0|Infinity',
    'offsets': '0|-480|-660',
    'offsetIndices': '01212121'
  }, {
    'id': 'Antarctica/Davis',
    'untils': '-6rmdc0|42jdw0|27wgs0|l8uss0|7eqs0|unmk0|60qs0|Infinity',
    'offsets': '0|-420|-300',
    'offsetIndices': '01012121'
  }, {
    'id': 'Antarctica/DumontDUrville',
    'untils': '-c05eo0|2mks80|2i72g0|Infinity',
    'offsets': '0|-600',
    'offsetIndices': '0101'
  }, {
    'id': 'Antarctica/Macquarie',
    'untils': '-rsj4w0|8zzw0|11wqk0|f4kh40|a6p8g0|9d1c0|asw00|6uao0|bvs00|6uao0|bvs00|779c0|bvs00|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660|0',
    'offsetIndices': '0102010101010101010101010101010101010101010101010101010101010101010101010101010101010101011'
  }, {
    'id': 'Antarctica/Mawson',
    'untils': '-8aelc0|t22y80|Infinity',
    'offsets': '0|-360|-300',
    'offsetIndices': '012'
  }, {
    'id': 'Antarctica/McMurdo',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Antarctica/Palmer',
    'untils': '-2lxhc0|31ho0|bqas0|71mk0|bqas0|8ovw0|9d440|9px80|9d440|9cyk0|9d440|28t6k0|51ek0|46b6s0|8c2s0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|Infinity',
    'offsets': '0|180|240|120',
    'offsetIndices': '0121212121213121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Antarctica/Rothera',
    'untils': '3lxs00|Infinity',
    'offsets': '0|180',
    'offsetIndices': '01'
  }, {
    'id': 'Antarctica/South_Pole',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Antarctica/Syowa',
    'untils': '-6qsqo0|Infinity',
    'offsets': '0|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Antarctica/Troll',
    'untils': 'ibruo0|27pg0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-120',
    'offsetIndices': '00101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Antarctica/Vostok',
    'untils': '-6aaao0|Infinity',
    'offsets': '0|-360',
    'offsetIndices': '01'
  }, {
    'id': 'Arctic/Longyearbyen',
    'untils': '-rzayo0|6qfs0|cgcqo0|15tsc0|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|70q5c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|b5uo0|7k800|7law00|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Aden',
    'untils': '-bwgbbg|Infinity',
    'offsets': '-186.8667|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Almaty',
    'untils': '-nu1a90|37a0d0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|Infinity',
    'offsets': '-307.8|-300|-360|-420',
    'offsetIndices': '012323232323232323232321232323232323232323232323232'
  }, {
    'id': 'Asia/Amman',
    'untils': '-kcrtbk|m566fk|60l80|awo40|7v980|awo40|7v980|ayis0|9gnw0|9b9g0|7v980|autg0|7v980|3e6840|9et80|9io40|9cyk0|9d440|9cyk0|9d440|9px80|ayis0|7rjw0|ag040|8a2k0|9zc40|8drw0|a31g0|8zzw0|9d440|9cyk0|9d440|8n180|ag040|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|epmo0|4deo0|9o5c0|9ew00|9b6o0|9ew00|9d1c0|9d1c0|9d1c0|asw00|7x6o0|afxc0|8n400|9d1c0|9d1c0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|wel80|51k40|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|Infinity',
    'offsets': '-143.7333|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Anadyr',
    'untils': '-nu1sv8|379zj8|qi27w0|9et80|is040|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-709.9333|-720|-780|-840|-660',
    'offsetIndices': '01232121212121212121214121212121212121212121212121212121212141'
  }, {
    'id': 'Asia/Aqtau',
    'untils': '-nu15b4|379y74|qrh3w0|iruk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-201.0667|-240|-300|-360',
    'offsetIndices': '012323232323232323232123232312121212121212121212'
  }, {
    'id': 'Asia/Aqtobe',
    'untils': '-nu16l4|379zh4|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|Infinity',
    'offsets': '-228.6667|-240|-300|-360',
    'offsetIndices': '0123232323232323232321232323232323232323232323232'
  }, {
    'id': 'Asia/Ashgabat',
    'untils': '-nu16t8|379zp8|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|Infinity',
    'offsets': '-233.5333|-240|-300|-360',
    'offsetIndices': '0123232323232323232323212'
  }, {
    'id': 'Asia/Ashkhabad',
    'untils': '-nu16t8|379zp8|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|Infinity',
    'offsets': '-233.5333|-240|-300|-360',
    'offsetIndices': '0123232323232323232323212'
  }, {
    'id': 'Asia/Atyrau',
    'untils': '-nu15m8|37a1a8|qrh140|iruk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|j3440|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-207.7333|-180|-300|-360|-240',
    'offsetIndices': '01232323232323232323242323232323232324242424242'
  }, {
    'id': 'Asia/Baghdad',
    'untils': '-r50g80|xkn3w0|7v980|9b9g0|9gnw0|9eys0|9et80|9d440|9b9g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9f1k0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|9ew00|9ew00|9d1c0|9ew00|9d1c0|9ew00|9d1c0|9ew00|Infinity',
    'offsets': '-177.6|-180|-240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Bahrain',
    'untils': '-q3gmvk|rctnrk|Infinity',
    'offsets': '-206.1333|-240|-180',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Baku',
    'untils': '-nu158c|h4tkwc|ckinw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|9d1c0|239ew0|asw00|7x3w0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-199.4|-180|-240|-300',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Bangkok',
    'untils': '-pysda4|Infinity',
    'offsets': '-402.0667|-420',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Barnaul',
    'untils': '-q4ljic|5hu6uc|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|38fo0|64og0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-335|-360|-420|-480',
    'offsetIndices': '0123232323232323232323212323232321212121212121212121212121212121212'
  }, {
    'id': 'Asia/Beirut',
    'untils': '-pyzew0|aunw0|88dg0|9et80|8yas0|a2vw0|a31g0|7k580|hjqo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|7v980|5lhs40|56yk0|awo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|7v980|autg0|7v980|2wxus0|8n180|a4w40|8n180|a4w40|8n180|a4w40|8n180|bs5g0|71mk0|alk40|86d80|a4w40|8n180|a4w40|8n180|a6qs0|80t80|905g0|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Bishkek',
    'untils': '-nu19tc|379zxc|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|h8dc0|bkl80|8n180|a31g0|8n180|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|9db20|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|Infinity',
    'offsets': '-298.4|-300|-360|-420',
    'offsetIndices': '012323232323232323232321212121212121212121212121212'
  }, {
    'id': 'Asia/Brunei',
    'untils': '-mvofy4|3khxs4|Infinity',
    'offsets': '-459.6667|-450|-480',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Calcutta',
    'untils': '-xehava|innm9a|bmfw0|5lxg0|1mn180|Infinity',
    'offsets': '-321.1667|-330|-390',
    'offsetIndices': '012121'
  }, {
    'id': 'Asia/Chita',
    'untils': '-q4cfog|5hkxgg|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnew0|Infinity',
    'offsets': '-453.8667|-480|-540|-600',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323232312'
  }, {
    'id': 'Asia/Choibalsan',
    'untils': '-xmct7c|11sndrc|2qk2k0|9eqg0|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|s6qk0|3nc0c0|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-458|-420|-480|-600|-540',
    'offsetIndices': '0123434343434343434343434343434343434343434343424242'
  }, {
    'id': 'Asia/Chongqing',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Chungking',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Colombo',
    'untils': '-xehask|isle6k|cajy0|1mp2u0|qetjw0|7x5a0|4xvqq0|Infinity',
    'offsets': '-319.5333|-330|-360|-390',
    'offsetIndices': '01231321'
  }, {
    'id': 'Asia/Dacca',
    'untils': '-eqtpow|bmgyw|5lxg0|4qknw0|u4ijy0|a1400|Infinity',
    'offsets': '-353.3333|-390|-330|-360|-420',
    'offsetIndices': '0121343'
  }, {
    'id': 'Asia/Damascus',
    'untils': '-q3gk20|5k6q0|8n180|a31g0|8n180|a31g0|8n180|a31g0|8zzw0|k4hk40|7yyk0|awo40|7tek0|b0dg0|7v980|awo40|7tek0|alk40|887w0|awo40|7v980|ayis0|7v980|awo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|7v980|awo40|7v980|awo40|7v980|ayis0|7v980|awo40|6bp80|cg840|6bp80|2eh1g0|8zzw0|9ts40|8zzw0|pvk40|c33w0|7cw40|cjrw0|6zxg0|btuk0|7rpg0|9gnw0|9d440|9cyk0|9et80|9et80|9rxg0|91uk0|92040|9et80|9o840|9et80|9d440|9et80|9eys0|9et80|9b9g0|9gnw0|99es0|9iik0|9d440|9et80|9eys0|9et80|9d440|9et80|9d440|9et80|9d440|9et80|9eys0|9et80|9d440|9et80|9d440|8y580|9q2s0|b5rw0|7x9g0|aunw0|7ig40|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|Infinity',
    'offsets': '-145.2|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Dhaka',
    'untils': '-eqtpow|bmgyw|5lxg0|4qknw0|u4ijy0|a1400|Infinity',
    'offsets': '-353.3333|-390|-330|-360|-420',
    'offsetIndices': '0121343'
  }, {
    'id': 'Asia/Dili',
    'untils': '-u9s4l8|fqcu98|hufs00|cpz440|Infinity',
    'offsets': '-502.3333|-480|-540',
    'offsetIndices': '01212'
  }, {
    'id': 'Asia/Dubai',
    'untils': '-q3gnko|Infinity',
    'offsets': '-221.2|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Dushanbe',
    'untils': '-nu18qo|379yuo|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|hp440|Infinity',
    'offsets': '-275.2|-300|-360|-420',
    'offsetIndices': '012323232323232323232321'
  }, {
    'id': 'Asia/Famagusta',
    'untils': '-p4bqac|rvhy2c|9cyk0|b42s0|7nuk0|8yas0|8zzw0|9q2s0|9et80|9b9g0|9cyk0|9q2s0|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|at4c0|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|8h8w0|leog0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-135.8|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Gaza',
    'untils': '-ffv9k0|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|5hoqs0|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|1sns0|3p6is0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|66as0|4vxc0|8n400|a2yo0|8n400|a2yo0|8n400|asw00|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|8n400|a2yo0|8ulg0|97ek0|8y580|9ts40|8hms0|a4qk0|7x3w0|asys0|8a5c0|ahs1o|71mic|bzk5o|69uic|cg840|902o0|9q000|9cyk0|9d440|ast80|7z440|aqyk0|7z6w0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010100101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Harbin',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Hebron',
    'untils': '-ffv9k0|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|5hoqs0|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|1sns0|3p6is0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|66as0|4vxc0|8n400|a2yo0|8n400|a2yo0|8n400|asw00|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|8n400|a2yo0|8ulg0|97ek0|8y580|9ts40|8hms0|a4qk0|82nw0|anes0|8a5c0|afxc0|73h80|bzk5o|69uic|1hs40|1lbw0|9d440|902o0|9q000|9cyk0|9d440|ast80|7z440|aqyk0|7z6w0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|7idc0|b7pc0|7vc00|auqo0|7vc00|auqo0|7vc00|auqo0|7vc00|b7pc0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Ho_Chi_Minh',
    'untils': '-x56934|2isioa|gj25iu|15ct80|8so00|tmtk0|4azjw0|2cmao0|8285c0|Infinity',
    'offsets': '-426.6667|-426.5|-420|-480|-540',
    'offsetIndices': '0123423232'
  }, {
    'id': 'Asia/Hong_Kong',
    'untils': '-y0i0s0|j44dk0|5k000|4d4y0|2195i0|7x3w0|bj320|6uao0|bvs00|7x6o0|9d1c0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|ast80|77c40|biqk0|77c40|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-456.7|-480|-540|-510',
    'offsetIndices': '0123212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Hovd',
    'untils': '-xmcoz0|11sncb0|2qk2k0|9et80|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|4fio40|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-366.6|-360|-420|-480',
    'offsetIndices': '012323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Irkutsk',
    'untils': '-q28gn5|5fh175|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-417.0833|-420|-480|-540',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Istanbul',
    'untils': '-ux9xew|2wvx6w|7v980|1tjc40|aunw0|88dg0|9et80|8yas0|a2vw0|tzpg0|79180|awo40|7v980|7p4040|4zjw0|2vs40|f4d80|9vms0|1u5ek0|c5440|69uk0|acas0|8n180|a31g0|8n180|9q2s0|8zzw0|a31g0|8zzw0|a31g0|8n180|5md9g0|o9zw0|a6qs0|75bw0|4iwyw0|7x6o0|7kas0|b5rw0|75hg0|bkl80|77c40|biqk0|7x9g0|a2vw0|8n6s0|4iqc0|2nkw80|38l80|kdes0|8qtc0|8a5c0|9ew00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|902o0|9q000|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7kdk0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7m2o0|b4000|7k800|b5uo0|7x6o0|asw00|7z1c0|ar1c0|7x6o0|bitc0|779c0|8fe80|Infinity',
    'offsets': '-116.9333|-120|-180|-240',
    'offsetIndices': '0121212121212121212121212121212121212121212121223212121212121212121212121212121212121212121212121212121212121212122'
  }, {
    'id': 'Asia/Jakarta',
    'untils': '-o0bdpc|4lzxc0|4wdzjc|1tu960|1cx860|11jta0|74uc20|Infinity',
    'offsets': '-427.2|-440|-450|-540|-480|-420',
    'offsetIndices': '01232425'
  }, {
    'id': 'Asia/Jayapura',
    'untils': '-jebm20|66bqe0|a37vy0|Infinity',
    'offsets': '-562.8|-540|-570',
    'offsetIndices': '0121'
  }, {
    'id': 'Asia/Jerusalem',
    'untils': '-r50eig|bp54yg|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|t9s40|56vs0|35700|9b3w0|9gtg0|8jbw0|7tmw0|a6ig0|biyw0|8a5c0|9d1c0|902o0|7x6o0|e1eg0|4ofw0|dzxo0|4q500|doo40|64iw0|auqo0|7i500|8rfms0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|9zc40|9iik0|9kis0|93p80|9mdg0|8qqk0|apf00|7x3w0|biw40|8zx40|9io40|8n180|9kis0|9vh80|8ulg0|9px80|9mdg0|8n180|9tuw0|9tmk0|8wg40|9gnw0|99es0|8qqk0|9zc40|9tmk0|8wg40|9gnw0|99es0|8qqk0|acas0|9gnw0|99es0|93p80|9mdg0|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|Infinity',
    'offsets': '-140.6667|-120|-180|-240',
    'offsetIndices': '012121212121321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Kabul',
    'untils': '-d1pkg0|Infinity',
    'offsets': '-240|-270',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Kamchatka',
    'untils': '-olrupo|3z045o|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-634.6|-660|-720|-780',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323212'
  }, {
    'id': 'Asia/Karachi',
    'untils': '-wvpb30|im3zt0|1mn180|33xpg0|a63o20|g72qo0|9cyk0|2y85g0|7v980|8hms0|aaak0|Infinity',
    'offsets': '-268.2|-330|-390|-300|-360',
    'offsetIndices': '012133434343'
  }, {
    'id': 'Asia/Kashgar',
    'untils': '-lx5pjw|Infinity',
    'offsets': '-350.3333|-360',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Kathmandu',
    'untils': '-q3gt4s|yg2lus|Infinity',
    'offsets': '-341.2667|-330|-345',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Katmandu',
    'untils': '-q3gt4s|yg2lus|Infinity',
    'offsets': '-341.2667|-330|-345',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Khandyga',
    'untils': '-q4cjrp|5hl1jp|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|3fx40|4h6s0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|8ql00|1mlho0|Infinity',
    'offsets': '-542.2167|-480|-540|-600|-660',
    'offsetIndices': '0123232323232323232323212323232323232323232323232343434343434343432'
  }, {
    'id': 'Asia/Kolkata',
    'untils': '-xehava|innm9a|bmfw0|5lxg0|1mn180|Infinity',
    'offsets': '-321.1667|-330|-390',
    'offsetIndices': '012121'
  }, {
    'id': 'Asia/Krasnoyarsk',
    'untils': '-q37l72|5gg8j2|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-371.4333|-360|-420|-480',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Kuala_Lumpur',
    'untils': '-xphpwd|eeb94d|4it32o|8n3jc|1v2p60|iy3o60|Infinity',
    'offsets': '-415.4167|-420|-440|-450|-540|-480',
    'offsetIndices': '0123435'
  }, {
    'id': 'Asia/Kuching',
    'untils': '-mvof3k|3khwxk|1epvy0|4ohqo|e5a9c|4ohqo|e3flc|4ohqo|e3flc|4ohqo|e3flc|4ohqo|e5a9c|4ohqo|e3flc|4ohqo|3ajlc|1v2qk0|Infinity',
    'offsets': '-441.3333|-450|-480|-500|-540',
    'offsetIndices': '0123232323232323242'
  }, {
    'id': 'Asia/Kuwait',
    'untils': '-bwgbbg|Infinity',
    'offsets': '-186.8667|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Macao',
    'untils': '-y0i2cy|jdvyoy|6onw0|ac580|8fs40|7v980|11luw0|awlc0|7vc00|ac800|bko00|7x6o0|9d1c0|7vc00|asw00|7x6o0|asw00|7x6o0|auqo0|88ao0|asw00|7x6o0|asw00|779c0|bitc0|779c0|bvs00|6uao0|bw1q0|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cvs0|9d6w0|9cvs0|9d6w0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-454.1667|-480|-540|-600',
    'offsetIndices': '012323212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Macau',
    'untils': '-y0i2cy|jdvyoy|6onw0|ac580|8fs40|7v980|11luw0|awlc0|7vc00|ac800|bko00|7x6o0|9d1c0|7vc00|asw00|7x6o0|asw00|7x6o0|auqo0|88ao0|asw00|7x6o0|asw00|779c0|bitc0|779c0|bvs00|6uao0|bw1q0|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cvs0|9d6w0|9cvs0|9d6w0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-454.1667|-480|-540|-600',
    'offsetIndices': '012323212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Magadan',
    'untils': '-nu1nxc|37a05c|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|s39k0|Infinity',
    'offsets': '-603.2|-600|-660|-720',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323232312'
  }, {
    'id': 'Asia/Makassar',
    'untils': '-q3gzg0|6p5hc0|4u87w0|1w02k0|Infinity',
    'offsets': '-477.6|-480|-540',
    'offsetIndices': '00121'
  }, {
    'id': 'Asia/Manila',
    'untils': '-hb5y80|4qak0|2qidg0|1b2d80|4xf440|442k0|cdqdg0|9et80|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '010101010'
  }, {
    'id': 'Asia/Muscat',
    'untils': '-q3gnko|Infinity',
    'offsets': '-221.2|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Nicosia',
    'untils': '-p4bq6g|rvhxyg|9cyk0|b42s0|7nuk0|8yas0|8zzw0|9q2s0|9et80|9b9g0|9cyk0|9q2s0|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|at4c0|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-133.4667|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Novokuznetsk',
    'untils': '-nu36tc|37bu5c|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-348.8|-360|-420|-480',
    'offsetIndices': '012323232323232323232321232323232323232323232323232323232323212'
  }, {
    'id': 'Asia/Novosibirsk',
    'untils': '-q4do0s|5hmbcs|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|2vh00|6hn40|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|wrpg0|Infinity',
    'offsets': '-331.6667|-360|-420|-480',
    'offsetIndices': '0123232323232323232323212323212121212121212121212121212121212121212'
  }, {
    'id': 'Asia/Omsk',
    'untils': '-q5xmx6|5j6d16|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-293.5|-300|-360|-420',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Oral',
    'untils': '-nu15ic|37a16c|qi2540|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|9d1c0|9d1c0|5reo0|cyo00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-205.4|-180|-300|-360|-240',
    'offsetIndices': '01232323232323232424242424242424242424242424242'
  }, {
    'id': 'Asia/Phnom_Penh',
    'untils': '-pysda4|Infinity',
    'offsets': '-402.0667|-420',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Pontianak',
    'untils': '-w6piww|cse2o0|4tnu2w|1wkei0|1cx860|11jta0|74uc20|cixam0|Infinity',
    'offsets': '-437.3333|-450|-540|-480|-420',
    'offsetIndices': '001213134'
  }, {
    'id': 'Asia/Pyongyang',
    'untils': '-w895yc|1yh10c|hk5da0|10ipmo0|1f4qo0|Infinity',
    'offsets': '-503|-510|-540',
    'offsetIndices': '012212'
  }, {
    'id': 'Asia/Qatar',
    'untils': '-q3gmvk|rctnrk|Infinity',
    'offsets': '-206.1333|-240|-180',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Qostanay',
    'untils': '-nu17s4|37a0o4|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-254.4667|-240|-300|-360',
    'offsetIndices': '012323232323232323232123232323232323232323232323'
  }, {
    'id': 'Asia/Qyzylorda',
    'untils': '-nu184g|37a10g|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|ohhc0|cyo00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|7osl00|Infinity',
    'offsets': '-261.8667|-240|-300|-360',
    'offsetIndices': '01232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Rangoon',
    'untils': '-q3gv5b|bnjp3b|1kh520|Infinity',
    'offsets': '-384.7833|-390|-540',
    'offsetIndices': '0121'
  }, {
    'id': 'Asia/Riyadh',
    'untils': '-bwgbbg|Infinity',
    'offsets': '-186.8667|-180',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Saigon',
    'untils': '-x56934|2isioa|gj25iu|15ct80|8so00|tmtk0|4azjw0|2cmao0|8285c0|Infinity',
    'offsets': '-426.6667|-426.5|-420|-480|-540',
    'offsetIndices': '0123423232'
  }, {
    'id': 'Asia/Sakhalin',
    'untils': '-xl87rc|kvnarc|ikvh40|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|iq5g0|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-570.8|-540|-660|-720|-600',
    'offsetIndices': '01232323232323232323232423232323232424242424242424242424242424242'
  }, {
    'id': 'Asia/Samarkand',
    'untils': '-nu18eh|37a1ah|qi27w0|s6qk0|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|Infinity',
    'offsets': '-267.8833|-240|-300|-360',
    'offsetIndices': '01232323232323232323232'
  }, {
    'id': 'Asia/Seoul',
    'untils': '-w8966g|1yh18g|hkx5a0|1faao0|5cik0|ae5g0|8a2k0|ae5g0|8bx80|c8tg0|6h980|1bj6s0|l3aq0|6j3w0|d2g40|6u7w0|b5xg0|776k0|biw40|776k0|biw40|776k0|biw40|776k0|grs40|dfqxi0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-507.8667|-510|-540|-600|-570',
    'offsetIndices': '012232323232141414141414123232'
  }, {
    'id': 'Asia/Shanghai',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'Asia/Singapore',
    'untils': '-xphpwd|eeb94d|4it32o|8n3jc|1v2p60|iy3o60|Infinity',
    'offsets': '-415.4167|-420|-440|-450|-540|-480',
    'offsetIndices': '0123435'
  }, {
    'id': 'Asia/Srednekolymsk',
    'untils': '-nu1ogs|37a0os|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-614.8667|-600|-660|-720',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Taipei',
    'untils': '-gtzfk0|45slc0|c51c0|75bw0|a31g0|aaak0|9d440|7v980|awo40|7v980|awo40|7v980|awo40|7v980|7tk40|clmk0|7rpg0|b07w0|7rpg0|b07w0|7rpg0|9et80|9eys0|9et80|9d440|9et80|9d440|9et80|9d440|9et80|cjxg0|69uk0|ci2s0|69uk0|6its40|9et80|9d440|9et80|1yf9g0|4qak0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010101010101010'
  }, {
    'id': 'Asia/Tashkent',
    'untils': '-nu18tz|379yxz|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|Infinity',
    'offsets': '-277.1833|-300|-360|-420',
    'offsetIndices': '012323232323232323232321'
  }, {
    'id': 'Asia/Tbilisi',
    'untils': '-nu14an|h4tjyn|ckinw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|9cvs0|9cyk0|9d440|9cyk0|9d440|ipzw0|9cyk0|9q2s0|tivw0|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|4ofw0|6hn40|7k800|Infinity',
    'offsets': '-179.1833|-180|-240|-300',
    'offsetIndices': '0123232323232323232323212121232323232323232323212'
  }, {
    'id': 'Asia/Tehran',
    'untils': '-s6m6uw|fnolc0|gm3h4w|777y0|b07w0|3pes0|42c20|9cyk0|9gtg0|9kd80|5ja5g0|7avw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|1av440|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|Infinity',
    'offsets': '-205.7333|-210|-240|-300|-270',
    'offsetIndices': '00123214141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141'
  }, {
    'id': 'Asia/Tel_Aviv',
    'untils': '-r50eig|bp54yg|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|t9s40|56vs0|35700|9b3w0|9gtg0|8jbw0|7tmw0|a6ig0|biyw0|8a5c0|9d1c0|902o0|7x6o0|e1eg0|4ofw0|dzxo0|4q500|doo40|64iw0|auqo0|7i500|8rfms0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|9zc40|9iik0|9kis0|93p80|9mdg0|8qqk0|apf00|7x3w0|biw40|8zx40|9io40|8n180|9kis0|9vh80|8ulg0|9px80|9mdg0|8n180|9tuw0|9tmk0|8wg40|9gnw0|99es0|8qqk0|9zc40|9tmk0|8wg40|9gnw0|99es0|8qqk0|acas0|9gnw0|99es0|93p80|9mdg0|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|Infinity',
    'offsets': '-140.6667|-120|-180|-240',
    'offsetIndices': '012121212121321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Asia/Thimbu',
    'untils': '-bojclo|kxymno|Infinity',
    'offsets': '-358.6|-330|-360',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Thimphu',
    'untils': '-bojclo|kxymno|Infinity',
    'offsets': '-358.6|-330|-360',
    'offsetIndices': '012'
  }, {
    'id': 'Asia/Tokyo',
    'untils': '-bb4900|6uao0|afxc0|8a5c0|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-540|-600',
    'offsetIndices': '010101010'
  }, {
    'id': 'Asia/Tomsk',
    'untils': '-q3zbqf|5h7z2f|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|1leo0|97k40|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|tw040|Infinity',
    'offsets': '-339.85|-360|-420|-480',
    'offsetIndices': '0123232323232323232323212323232323232323232323212121212121212121212'
  }, {
    'id': 'Asia/Ujung_Pandang',
    'untils': '-q3gzg0|6p5hc0|4u87w0|1w02k0|Infinity',
    'offsets': '-477.6|-480|-540',
    'offsetIndices': '00121'
  }, {
    'id': 'Asia/Ulaanbaatar',
    'untils': '-xmcrsk|11sncck|2qk2k0|9et80|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|4fio40|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-427.5333|-420|-480|-540',
    'offsetIndices': '012323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Ulan_Bator',
    'untils': '-xmcrsk|11sncck|2qk2k0|9et80|9eys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|1ckdo0|7x3w0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|4fio40|9ct00|9d9o0|9ct00|Infinity',
    'offsets': '-427.5333|-420|-480|-540',
    'offsetIndices': '012323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Urumqi',
    'untils': '-lx5pjw|Infinity',
    'offsets': '-350.3333|-360',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Ust-Nera',
    'untils': '-q4cl6u|5hl2yu|qi27w0|9eno0|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|8ql00|1mlho0|Infinity',
    'offsets': '-572.9|-480|-540|-720|-660|-600',
    'offsetIndices': '012343434343434343434345434343434343434343434343434343434343434345'
  }, {
    'id': 'Asia/Vientiane',
    'untils': '-pysda4|Infinity',
    'offsets': '-402.0667|-420',
    'offsetIndices': '01'
  }, {
    'id': 'Asia/Vladivostok',
    'untils': '-oligf7|3yqvf7|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-527.5167|-540|-600|-660',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Yakutsk',
    'untils': '-q4cioy|5hl0gy|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-518.9667|-480|-540|-600',
    'offsetIndices': '01232323232323232323232123232323232323232323232323232323232323232'
  }, {
    'id': 'Asia/Yangon',
    'untils': '-q3gv5b|bnjp3b|1kh520|Infinity',
    'offsets': '-384.7833|-390|-540',
    'offsetIndices': '0121'
  }, {
    'id': 'Asia/Yekaterinburg',
    'untils': '-rx5hw9|1kybx4|5pfyv5|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-242.55|-225.0833|-240|-300|-360',
    'offsetIndices': '012343434343434343434343234343434343434343434343434343434343434343'
  }, {
    'id': 'Asia/Yerevan',
    'untils': '-nu148o|h4tjwo|ckinw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|iq5g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|11t180|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|Infinity',
    'offsets': '-178|-180|-240|-300',
    'offsetIndices': '0123232323232323232323212121212323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Azores',
    'untils': '-u9rbs0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5qbjo0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9cyk0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '114.5333|120|60|0',
    'offsetIndices': '01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121232323232323232323232323232323233323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Bermuda',
    'untils': '-kvj2fu|n4pr3u|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '259.3|240|180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Atlantic/Canary',
    'untils': '-oytbtc|ctvupc|hhq7s0|905g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '61.6|60|0|-60',
    'offsetIndices': '01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Cape_Verde',
    'untils': '-u9rbs0|g06lc0|1mn180|fpqwc0|Infinity',
    'offsets': '94.0667|120|60',
    'offsetIndices': '01212'
  }, {
    'id': 'Atlantic/Faeroe',
    'untils': '-wcehew|127keuw|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '27.0667|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Atlantic/Faroe',
    'untils': '-wcehew|127keuw|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '27.0667|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Atlantic/Jan_Mayen',
    'untils': '-rzayo0|6qfs0|cgcqo0|15tsc0|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|70q5c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|b5uo0|7k800|7law00|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Atlantic/Madeira',
    'untils': '-u9rek0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5qbjo0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '67.6|60|0|-60',
    'offsetIndices': '01212121212121212121212121212121212121212121232123212321232121212121212121212121212121212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Atlantic/Reykjavik',
    'untils': '-wcwx9c|4rpd9c|ci2s0|69uk0|du840|4xp80|du840|p7bw0|4w040|9bdzw0|9d6w0|64g40|cyl80|64dc0|clpc0|6hc00|bvs00|6uao0|bvs00|6uao0|bvs00|6uao0|c8qo0|6hc00|c8qo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|Infinity',
    'offsets': '88|60|0',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Atlantic/South_Georgia',
    'untils': 'Infinity',
    'offsets': '120',
    'offsetIndices': '0'
  }, {
    'id': 'Atlantic/St_Helena',
    'untils': '-u9rgl4|Infinity',
    'offsets': '16.1333|0',
    'offsetIndices': '01'
  }, {
    'id': 'Atlantic/Stanley',
    'untils': '-u63pac|dbvxqc|8zzw0|9q2s0|8zzw0|a31g0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|4xp80|l1pus0|7k580|b5rw0|77c40|biqk0|id6s0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|biqk0|77c40|biqk0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|biqk0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5rw0|7kas0|b5xg0|77c40|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|77c40|biqk0|77c40|biqk0|77c40|Infinity',
    'offsets': '231.4|240|180|120',
    'offsetIndices': '012121212121212323212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Australia/ACT',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Adelaide',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|7k800|b5uo0|6uao0|c8qo0|779c0|bitc0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Brisbane',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|97zuo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '01010101010101010'
  }, {
    'id': 'Australia/Broken_Hill',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Canberra',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Currie',
    'untils': '-rsj4w0|8zzw0|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Darwin',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '010101010'
  }, {
    'id': 'Australia/Eucla',
    'untils': '-rnstlc|49s2c|cxfms0|4h180|9d440|9cyk0|ghf1g0|6hc00|4ir9c0|6hc00|40r400|5eg00|7p9hc0|5reo0|b5uo0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-525|-585',
    'offsetIndices': '0101010101010101010'
  }, {
    'id': 'Australia/Hobart',
    'untils': '-rsj4w0|8zzw0|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|c9tms0|9d1c0|asw00|6uao0|bvs00|6uao0|bvs00|779c0|bvs00|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/LHI',
    'untils': '5tp880|c8uu0|6u7w0|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|777y0|b5w20|7k6m0|biuq0|7k6m0|biuq0|777y0|biuq0|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|7x820|asum0|b5w20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|b5w20|7x5a0|asxe0|7k6m0|b5w20|8a3y0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9pym0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|Infinity',
    'offsets': '-600|-630|-690|-660',
    'offsetIndices': '0121212121313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313'
  }, {
    'id': 'Australia/Lindeman',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|97zuo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '010101010101010101010'
  }, {
    'id': 'Australia/Lord_Howe',
    'untils': '5tp880|c8uu0|6u7w0|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|777y0|b5w20|7k6m0|biuq0|7k6m0|biuq0|777y0|biuq0|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|7x820|asum0|b5w20|7x5a0|asxe0|7x5a0|asxe0|7x5a0|b5w20|7k6m0|b5w20|7x5a0|asxe0|7k6m0|b5w20|8a3y0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9pym0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9d2q0|9czy0|9q1e0|9czy0|9d2q0|9czy0|9d2q0|Infinity',
    'offsets': '-600|-630|-690|-660',
    'offsetIndices': '0121212121313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313131313'
  }, {
    'id': 'Australia/Melbourne',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|b5uo0|7x6o0|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/North',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '010101010'
  }, {
    'id': 'Australia/NSW',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Perth',
    'untils': '-rnsric|49s2c|cxfms0|4h180|9d440|9cyk0|ghf1g0|6hc00|4ir9c0|6hc00|40r400|5eg00|7p9hc0|5reo0|b5uo0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '0101010101010101010'
  }, {
    'id': 'Australia/Queensland',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|97zuo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '01010101010101010'
  }, {
    'id': 'Australia/South',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|7k800|b5uo0|6uao0|c8qo0|779c0|bitc0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Sydney',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Tasmania',
    'untils': '-rsj4w0|8zzw0|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|c9tms0|9d1c0|asw00|6uao0|bvs00|6uao0|bvs00|779c0|bvs00|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|b5uo0|7k800|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|bvs00|7k800|bitc0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x6o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|7x6o0|asw00|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/Victoria',
    'untils': '-rnsx2c|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|b5uo0|7x6o0|bitc0|779c0|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|7x6o0|asw00|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-600|-660',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Australia/West',
    'untils': '-rnsric|49s2c|cxfms0|4h180|9d440|9cyk0|ghf1g0|6hc00|4ir9c0|6hc00|40r400|5eg00|7p9hc0|5reo0|b5uo0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '0101010101010101010'
  }, {
    'id': 'Australia/Yancowinna',
    'untils': '-rnsvoc|49s2c|cxfms0|4h180|9d440|9cyk0|9q2s0|8zzw0|eeiqs0|64dc0|clpc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|8a5c0|asw00|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|779c0|b5uo0|7k800|bitc0|7k800|bitc0|779c0|bitc0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|8a5c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-570|-630',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101'
  }, {
    'id': 'Brazil/Acre',
    'untils': '-t85fg0|99kak0|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|amves0|2t2t80|Infinity',
    'offsets': '271.2|300|240',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'Brazil/DeNoronha',
    'untils': '-t85lzw|99k8rw|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|514g40|7k580|biw40|cvw0|iq5g0|6h980|Infinity',
    'offsets': '129.6667|120|60',
    'offsetIndices': '0121212121212121212121212121212121212121'
  }, {
    'id': 'Brazil/East',
    'untils': '-t85jd8|99k8x8|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5k02s0|6onw0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|cyqs0|5ed80|dbpg0|64ak0|cyqs0|64ak0|cls40|5rbw0|dbpg0|51ek0|dbpg0|6h980|c8tg0|6h980|c8tg0|64ak0|c8tg0|6u7w0|bxpg0|7iak0|biw40|6u7w0|biw40|7k580|biw40|6u7w0|c8tg0|6h980|dbpg0|5ed80|cls40|64ak0|dfes0|5nmk0|c8tg0|6h980|dbpg0|5rbw0|bvus0|6h980|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6u7w0|c8tg0|64ak0|cls40|64ak0|cls40|6h980|c8tg0|6h980|c8tg0|6h980|c8tg0|6h980|dbpg0|5ed80|Infinity',
    'offsets': '186.4667|180|120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Brazil/West',
    'untils': '-t85gvw|99k97w|9a9c0|9io40|99980|8p65g0|6zuo0|bs2o0|67zw0|cjxg0|69uk0|cjxg0|4ml80|5mf440|49mk0|haas0|316k0|cls40|4ml80|cls40|66580|cls40|67zw0|981s40|6u7w0|biw40|5rbw0|d0lg0|5ed80|2yy2s0|6h980|Infinity',
    'offsets': '240.0667|240|180',
    'offsetIndices': '01212121212121212121212121212121'
  }, {
    'id': 'Canada/Atlantic',
    'untils': '-z94k80|777go0|9et80|st9o0|a2vw0|ssyk0|5rbw0|cv1g0|69uk0|c6ys0|6kyk0|ci2s0|67zw0|ci2s0|6w2k0|bu040|7lzw0|bu040|66580|bu040|7lzw0|bu040|64ak0|cls40|5v180|cv1g0|6j3w0|c6ys0|79180|b42s0|7lzw0|b42s0|7yyk0|bu040|64ak0|dbpg0|66580|cls40|5ed80|bu040|7lzw0|b42s0|7lzw0|cjxg0|66580|bh1g0|7lzw0|b42s0|7lzw0|6uj00|1tzdw0|2dnc0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|tw040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|1cm2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '254.4|240|180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Canada/Central',
    'untils': '-s0s7c0|7k580|tj700|a2vw0|9ok840|6u7w0|2a5hg0|1tz8c0|2dsw0|biw40|7x3w0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b7s40|7tek0|autg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|7x3w0|1cm2s0|7k580|1cm2s0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|asw00|7x6o0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Canada/Eastern',
    'untils': '-qzoxw0|a2vw0|7yx60|aqzy0|9q8c0|7jzo0|bw0c0|6bp80|cedg0|6h980|c8tg0|6h980|bvus0|776k0|biw40|776k0|biw40|776k0|biw40|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|xjeo0|1tzb40|2dq40|asys0|7x3w0|ast80|7x3w0|asys0|7x3w0|asys0|b5rw0|7xf00|ast80|7x9g0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101011101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Canada/Mountain',
    'untils': '-x1yazk|629ink|a2vw0|8n6s0|29ek0|h6lg0|9px80|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|9l0g40|1tz5k0|2dvo0|tj1g0|7x3w0|ctzk40|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '453.8667|420|360',
    'offsetIndices': '0121212121212122121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Canada/Newfoundland',
    'untils': '-ris3ck|8bx80|ar440|a2vw0|9tjs0|53980|dkys0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9d440|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|8zzw0|9q2s0|9cyk0|9q2s0|8zzw0|9q2s0|8zzw0|7tmw0|1wfuk|8zzw0|a3480|7k580|b5xg0|7k580|b5xg0|7k580|biw40|776k0|biw40|7k580|b5xg0|7k580|b5xg0|1pb260|2dly0|biw40|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|biw40|7k580|ag040|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a2lo|afuk0|8a840|asqg0|7xc80|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8tec|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '210.8667|150.8667|210|150|90',
    'offsetIndices': '01010101010101010101010101010101010102323232323232323323232323232323232323232323232323232323232323232323232323232323232323232323232323232324232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Canada/Pacific',
    'untils': '-qzopk0|a2vw0|c5jxg0|1tz2s0|2dyg0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '0101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Canada/Saskatchewan',
    'untils': '-xkq9yc|6l1hmc|a2vw0|60enw0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|1b6840|9cyk0|9d440|8zzw0|9q2s0|9cyk0|9q2s0|9cyk0|9d440|9cyk0|66gc0|1tz5k0|2dvo0|a31g0|9cyk0|a31g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|tj1g0|9cyk0|9d440|Infinity',
    'offsets': '418.6|420|360',
    'offsetIndices': '012121212121212121212121221212121212121212121212121212'
  }, {
    'id': 'Canada/Yukon',
    'untils': '-qzoms0|a2vw0|asys0|882c0|bmiwc0|1tz000|2e180|a7n3w0|9q000|tiyo0|6qp440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|Infinity',
    'offsets': '540|480|420',
    'offsetIndices': '01010110201212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'CET',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|8l9c0|ggp1c0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Chile/Continental',
    'untils': '-vauawq|3dlssq|157b7a|f4e0q|49hzba|aye0q|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|534ik0|351g0|229zw0|2gt80|awo40|2mg00|b73400|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '282.7667|300|240|180',
    'offsetIndices': '010202121212121212321232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Chile/EasterIsland',
    'untils': '-jhfaew|ivmeuw|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|iq2o0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '437.4667|420|360|300',
    'offsetIndices': '012121212121212121212121212123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'CST6CDT',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Cuba',
    'untils': '-n7762o|1icfyo|69uk0|62s040|4ofw0|e1ms0|51ek0|e1ms0|4ofw0|1fhs40|4ofw0|e1ms0|4ofw0|9s9k40|67zw0|cedg0|6h980|9o840|7yyk0|b5xg0|7k580|bvus0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|8a2k0|ag040|8bx80|ae5g0|8drw0|acas0|9cyk0|9d440|9px80|905g0|9px80|9q2s0|7x3w0|8a840|ast80|7x9g0|ast80|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|8a2k0|ag040|8a2k0|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|905g0|a2vw0|905g0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|8n400|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|8a5c0|afxc0|8a5c0|afxc0|7x6o0|1cm000|6uao0|bvs00|779c0|bitc0|6uao0|bvs00|779c0|bvs00|779c0|c8qo0|779c0|b5uo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|Infinity',
    'offsets': '329.6|300|240',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'EET',
    'untils': '3s9ms0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Egypt',
    'untils': '-fdls80|40d80|a31g0|7x3w0|a4w40|aqyk0|80ys0|b07w0|7tk40|b07w0|8jhg0|a8fw0|60go40|7el80|awo40|7v980|awqw0|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7tk40|ayd80|7tk40|b07w0|7tk40|ayd80|7tk40|ayd80|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|f9x80|3i040|eluk0|462s0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|b5rw0|7m5g0|awik0|7ves0|awik0|7ves0|ayd80|7ves0|awik0|7ves0|awik0|7ves0|aqvs0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7k580|b5xg0|6u7w0|bvus0|6h980|c8tg0|64ak0|cyqs0|5anw0|1jms0|12t80|1w22s0|25p80|1sw40|2vmk0|Infinity',
    'offsets': '-120|-180',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Eire',
    'untils': '-rzcmlr|6uao0|9pytr|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|3g8800|8a5c0|bvs00|8n400|a2yo0|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '25.35|-34.65|0|-60',
    'offsetIndices': '01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'EST',
    'untils': 'Infinity',
    'offsets': '300',
    'offsetIndices': '0'
  }, {
    'id': 'EST5EDT',
    'untils': '-r0ev80|ast80|7x9g0|ast80|bmtus0|1tzb40|2dq40|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Etc/GMT-0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-1',
    'untils': 'Infinity',
    'offsets': '-60',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-10',
    'untils': 'Infinity',
    'offsets': '-600',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-11',
    'untils': 'Infinity',
    'offsets': '-660',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-12',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-13',
    'untils': 'Infinity',
    'offsets': '-780',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-14',
    'untils': 'Infinity',
    'offsets': '-840',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-2',
    'untils': 'Infinity',
    'offsets': '-120',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-3',
    'untils': 'Infinity',
    'offsets': '-180',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-4',
    'untils': 'Infinity',
    'offsets': '-240',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-5',
    'untils': 'Infinity',
    'offsets': '-300',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-6',
    'untils': 'Infinity',
    'offsets': '-360',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-7',
    'untils': 'Infinity',
    'offsets': '-420',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-8',
    'untils': 'Infinity',
    'offsets': '-480',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT-9',
    'untils': 'Infinity',
    'offsets': '-540',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+1',
    'untils': 'Infinity',
    'offsets': '60',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+10',
    'untils': 'Infinity',
    'offsets': '600',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+11',
    'untils': 'Infinity',
    'offsets': '660',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+12',
    'untils': 'Infinity',
    'offsets': '720',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+2',
    'untils': 'Infinity',
    'offsets': '120',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+3',
    'untils': 'Infinity',
    'offsets': '180',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+4',
    'untils': 'Infinity',
    'offsets': '240',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+5',
    'untils': 'Infinity',
    'offsets': '300',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+6',
    'untils': 'Infinity',
    'offsets': '360',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+7',
    'untils': 'Infinity',
    'offsets': '420',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+8',
    'untils': 'Infinity',
    'offsets': '480',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT+9',
    'untils': 'Infinity',
    'offsets': '540',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/GMT0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/Greenwich',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/UCT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/Universal',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/UTC',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Etc/Zulu',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Europe/Amsterdam',
    'untils': '-s0dvkk|7v980|a51o0|7x6o0|a2yo0|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9b6o0|a2yo0|c51c0|6l1c0|902o0|9q000|ci000|682o0|bgyo0|79400|bitc0|779c0|bmio0|7gio0|bbeo0|7eo00|bd9c0|7ctc0|bf400|7ayo0|bvs00|6uao0|bko00|7idc0|b9k00|7gio0|bbeo0|7eo00|bf400|7ayo0|btxc0|21uc0|4uaz8|bitc0|779c0|bko00|7idc0|bd3s0|1aarpc|7k800|9q000|9d1c0|9d1c0|9d1c0|8l9c0|ggp1c0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-19.5333|-79.5333|-80|-20|-120|-60',
    'offsetIndices': '010101010101010101010101010101010101010101012323234545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545454545'
  }, {
    'id': 'Europe/Andorra',
    'untils': '-c4xmo0|k3ctg0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Astrakhan',
    'untils': '-nu2zkc|37bv8c|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-192.2|-180|-240|-300',
    'offsetIndices': '012323232323232323212121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Athens',
    'untils': '-rvv0cg|8bjasg|2vmk0|4hiw40|16ik0|scog0|7lx40|9o2k0|9eys0|4atzw0|6djw0|bplus0|bq800|71uw0|9d1c0|902o0|91xc0|9o5c0|905g0|9qgo0|9akg0|9iik0|99980|9dcg0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-94.8667|-120|-180|-60',
    'offsetIndices': '012121313121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Belfast',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Belgrade',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Berlin',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|2o7w0|6bs00|2txg0|7k800|91xc0|9b9g0|1sqk0|2inw0|51k40|a2yo0|8n400|9q000|902o0|fx91c0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|-180',
    'offsetIndices': '01010101010101210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Bratislava',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|b5uo0|7vc00|2vs40|4bk00|2vmk0|8n400|a2yo0|8n400|9o5c0|91xc0|fe6000|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|0',
    'offsetIndices': '01010101010101010201010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Brussels',
    'untils': '-ss5uo0|rrx80|7vc00|a4yw0|7x6o0|asw00|7x6o0|2wh40|5omo0|b5uo0|6uao0|cyo00|7ayo0|bko00|7rmo0|a2yo0|a2yo0|8n400|902o0|9q000|9d1c0|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|90b00|a2yo0|8n400|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|4deo0|1a36k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8l9c0|clpc0|79400|fwu800|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0121212101010101010101010101010101010101010101010101212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Bucharest',
    'untils': '-k29zi0|fj8m0|6w5c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|kp0dc0|6h980|9q000|905g0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9cvs0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9cyk0|9d440|9cyk0|9q2s0|ast80|7xhs0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-104.4|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Budapest',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|a31g0|8n180|autg0|bgvw0|b5jeg0|th9k0|7k800|9q000|9d1c0|9d1c0|awd00|9ew00|7q0c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|a4tc0|9q000|1va2g0|6u7w0|bxpg0|6u7w0|cjxg0|64ak0|cluw0|64g40|br3ek0|905g0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Busingen',
    'untils': '-eyh6o0|7x6o0|asw00|7x6o0|k2zus0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Chisinau',
    'untils': '-r2p1bo|70f1to|fj8m0|6w5c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|geqo0|ha580|oc8g0|7k800|9q000|9d1c0|7cl00|j3pbw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|25p80|7kdk0|9d1c0|9d1c0|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|ast80|7xf00|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-115|-104.4|-120|-180|-60|-240',
    'offsetIndices': '012323232323232323232424235353535353535353535323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Copenhagen',
    'untils': '-rzo2w0|75bw0|cbs2w0|1aco80|7k800|9q000|9d1c0|9d1c0|9d1c0|6y000|dbmo0|6bs00|clpc0|51hc0|e1k00|4oio0|giutc0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Dublin',
    'untils': '-rzcmlr|6uao0|9pytr|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|3g8800|8a5c0|bvs00|8n400|a2yo0|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '25.35|-34.65|0|-60',
    'offsetIndices': '01232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Gibraltar',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|d0tp80|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101012121212121010121010101010101010101012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Guernsey',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Helsinki',
    'untils': '-peghyd|ax3tqd|9gqo0|k31s80|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-99.8167|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Isle_of_Man',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Istanbul',
    'untils': '-ux9xew|2wvx6w|7v980|1tjc40|aunw0|88dg0|9et80|8yas0|a2vw0|tzpg0|79180|awo40|7v980|7p4040|4zjw0|2vs40|f4d80|9vms0|1u5ek0|c5440|69uk0|acas0|8n180|a31g0|8n180|9q2s0|8zzw0|a31g0|8zzw0|a31g0|8n180|5md9g0|o9zw0|a6qs0|75bw0|4iwyw0|7x6o0|7kas0|b5rw0|75hg0|bkl80|77c40|biqk0|7x9g0|a2vw0|8n6s0|4iqc0|2nkw80|38l80|kdes0|8qtc0|8a5c0|9ew00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|902o0|9q000|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7kdk0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7m2o0|b4000|7k800|b5uo0|7x6o0|asw00|7z1c0|ar1c0|7x6o0|bitc0|779c0|8fe80|Infinity',
    'offsets': '-116.9333|-120|-180|-240',
    'offsetIndices': '0121212121212121212121212121212121212121212121223212121212121212121212121212121212121212121212121212121212121212122'
  }, {
    'id': 'Europe/Jersey',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Kaliningrad',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|el00|z6o0|9kd80|82tg0|i9avw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-60|-120|-180|-240',
    'offsetIndices': '01010101010101121232323232323232322121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Kiev',
    'untils': '-nu11ng|37a03g|5vd6k0|kzv40|7k800|9q000|1oyg0|jipzs0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|51ek0|neqw0|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9dcg0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-122.0667|-120|-180|-60|-240',
    'offsetIndices': '0121313242424242424242424242121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Kirov',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-198.8|-180|-240|-300',
    'offsetIndices': '01232323232323232321212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Lisbon',
    'untils': '-u9rhc0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5gyl40|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '36.75|0|-60|-120',
    'offsetIndices': '012121212121212121212121212121212121212121212321232123212321212121212121212121212121212121212121212121212121212121212121212121212122323232212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Ljubljana',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/London',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Luxembourg',
    'untils': '-y89550|68l290|75hg0|ast80|796s0|at1k0|7x6o0|3lh40|4zmo0|b6300|6u2c0|cytk0|7at40|bktk0|7rh40|a31g0|a2vw0|8n9k0|8zx40|9q2s0|9et80|9b9g0|a2vw0|8n6s0|9px80|905g0|a2vw0|905g0|a2vw0|8ncc0|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|42ao0|1aeak0|7k800|9q000|9d1c0|8n400|a2yo0|8l9c0|clpc0|79400|fwu800|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-24.6|-60|-120|0',
    'offsetIndices': '0121212131313131313131313131313131313131313131313131212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Madrid',
    'untils': '-qzlus0|8yas0|9cyk0|9eys0|2d2vw0|8sqs0|ssyk0|8n6s0|9px80|905g0|a2yo0|902o0|a2vw0|8n6s0|40lh80|5k2s0|9cyk0|1frw0|7z1c0|j1c80|8a2k0|13yt80|685g0|brzw0|8n6s0|a2vw0|8n6s0|a2vw0|8n6s0|a2vw0|8n6s0|1clx80|7x9g0|cswik0|905g0|9px80|905g0|8zzw0|9d440|9px80|905g0|9q5k0|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '010101010101010101210121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Malta',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9b6o0|8n400|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|9b6o0|9d1c0|ahs00|7m2o0|b45k0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|a4w40|8y580|9q2s0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Mariehamn',
    'untils': '-peghyd|ax3tqd|9gqo0|k31s80|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-99.8167|-120|-180',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Minsk',
    'untils': '-nu113c|379zjc|5r1mk0|pbf40|7k800|9q000|9d1c0|4oac0|j6dmk0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|sg2o0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|Infinity',
    'offsets': '-110|-120|-180|-60|-240',
    'offsetIndices': '01213131242424242424242424221212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Monaco',
    'untils': '-uozn3l|2qx1nl|5luo0|8y800|a4tc0|7vc00|auqo0|7idc0|b7pc0|6sg00|cyo00|7ayo0|bko00|7rmo0|a2yo0|bvs00|6uao0|902o0|9q000|9d1c0|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51po0|mdbo0|7x3w0|7x9g0|c8w80|7k800|9q000|9d1c0|9nzs0|922w0|8l9c0|fxlx80|9cyk0|9q5k0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-9.35|0|-60|-120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Moscow',
    'untils': '-rx5dmh|ipzua|97hc0|7yyk0|5i840|d9p80|1jwk7|2cvk0|s8o00|1qvw0|8fpc0|1jms0|is040|412as0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d440|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-150.2833|-151.3167|-211.3167|-271.3167|-240|-180|-300|-120',
    'offsetIndices': '012132345464575454545454545454545455754545454545454545454545454545454545454545'
  }, {
    'id': 'Europe/Nicosia',
    'untils': '-p4bq6g|rvhxyg|9cyk0|b42s0|7nuk0|8yas0|8zzw0|9q2s0|9et80|9b9g0|9cyk0|9q2s0|8zzw0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|9cyk0|9d440|9cyk0|9d440|at4c0|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-133.4667|-120|-180',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Oslo',
    'untils': '-rzayo0|6qfs0|cgcqo0|15tsc0|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|70q5c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|b5uo0|7k800|7law00|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Paris',
    'untils': '-uozn1x|2qx1lx|5luo0|8y800|a4tc0|7vc00|auqo0|7idc0|b7pc0|6sg00|cyo00|7ayo0|bko00|7rmo0|a2yo0|bvs00|6uao0|902o0|9q000|9d1c0|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|9d1c0|9d1c0|902o0|a2yo0|9d1c0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51po0|5p8w0|18rcc0|7k800|9q000|9d1c0|7efo0|29k40|922w0|8l9c0|fxlx80|9cyk0|9q5k0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-9.35|0|-60|-120',
    'offsetIndices': '0121212121212121212121212121212121212121212121212123232332323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Podgorica',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Prague',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|9d1c0|b5uo0|7vc00|2vs40|4bk00|2vmk0|8n400|a2yo0|8n400|9o5c0|91xc0|fe6000|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|0',
    'offsetIndices': '01010101010101010201010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Riga',
    'untils': '-qznlky|7x6o0|a4tc0|2mg00|3myns0|7fhlky|gz180|p5v40|7k800|9q000|9d1c0|9d1c0|k7s0|j14ns0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d440|asw00|7x6o0|asw00|7x6o0|b5uo0|qaao0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-96.5667|-156.5667|-120|-180|-60|-240',
    'offsetIndices': '010102324242435353535353535353323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Rome',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|clpc0|64dc0|c8qo0|6hc00|clpc0|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|c8qo0|6hc00|9q5k0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Samara',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|jt1g0|89zs0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|j3440|7k800|Infinity',
    'offsets': '-200.3333|-180|-240|-300',
    'offsetIndices': '0123232323232323232121232323232323232323232323232323232323212'
  }, {
    'id': 'Europe/San_Marino',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|clpc0|64dc0|c8qo0|6hc00|clpc0|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|c8qo0|6hc00|9q5k0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Sarajevo',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Saratov',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|13m040|Infinity',
    'offsets': '-184.3|-180|-240|-300',
    'offsetIndices': '012323232323232321212121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Simferopol',
    'untils': '-nu12ao|37a0qo|5xiyk0|iu340|7k800|9q000|9d1c0|iac0|jajmk0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|eeio0|wrjw0|9cyk0|9d440|9cyk0|9d440|1sqk0|7k580|9d440|9cyk0|9q2s0|at4c0|7x9g0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x3w0|asqg0|Infinity',
    'offsets': '-136|-120|-180|-60|-240',
    'offsetIndices': '012131312424242424242424242121212424242212121212121212121212121212121212142'
  }, {
    'id': 'Europe/Skopje',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Sofia',
    'untils': '-e6dzw0|7k800|9q000|9d1c0|9d1c0|9d440|hqq240|9eys0|9o2k0|92040|9o2k0|90880|9pug0|90b00|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|ast80|7xhs0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-120|-60|-180',
    'offsetIndices': '01010102020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020'
  }, {
    'id': 'Europe/Stockholm',
    'untils': '-rzo2w0|75hg0|x5bew0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Tallinn',
    'untils': '-r3exx0|3re10|7x6o0|et6g0|ygov0|a1zgd0|ktx80|l94g0|7k800|9q000|9d1c0|8uac0|j27mk0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asys0|7x6o0|b5uo0|19dc00|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-99|-60|-120|-180|-240',
    'offsetIndices': '012102321212343434343434343433232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Tirane',
    'untils': '-t85vo8|dt2gw8|18pew0|7k800|m800|g7ot40|7rjw0|autg0|7x3w0|ayis0|7x3w0|b5xg0|7k580|b42s0|7lzw0|b42s0|7lzw0|b42s0|7x3w0|ahus0|7x3w0|b5xg0|7x3w0|a4w40|8jbw0|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-79.3333|-60|-120',
    'offsetIndices': '01212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Tiraspol',
    'untils': '-r2p1bo|70f1to|fj8m0|6w5c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|geqo0|ha580|oc8g0|7k800|9q000|9d1c0|7cl00|j3pbw0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|25p80|7kdk0|9d1c0|9d1c0|9cvs0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|ast80|7xf00|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-115|-104.4|-120|-180|-60|-240',
    'offsetIndices': '012323232323232323232424235353535353535353535323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'Europe/Ulyanovsk',
    'untils': '-qcx400|5q5zo0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9q000|iq5g0|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|qnc40|Infinity',
    'offsets': '-193.6|-180|-240|-300|-120',
    'offsetIndices': '01232323232323232321214121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Uzhgorod',
    'untils': '-fizzw0|1cm000|7k800|9q000|9d1c0|al900|cnms0|int140|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|eeio0|e1sc0|iprk0|9cyk0|9d440|9cyk0|9d440|9cyk0|9dcg0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120|-180|-240',
    'offsetIndices': '010101023232323232323232320121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Vaduz',
    'untils': '-eyh6o0|7x6o0|asw00|7x6o0|k2zus0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Vatican',
    'untils': '-rymys0|64ak0|9d440|9et80|88dg0|aunw0|7ig40|b5rw0|8n6s0|9cyk0|aau2s0|18r9k0|7k800|9q000|9d1c0|8l9c0|a4tc0|8j940|9f1k0|afxc0|89zs0|afxc0|7kdk0|b5uo0|979rs0|6h980|cls40|64dc0|clpc0|64dc0|cyo00|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|clpc0|64dc0|c8qo0|6hc00|clpc0|64dc0|clpc0|64dc0|c8qo0|6hc00|clpc0|6hc00|c8qo0|6hc00|9q5k0|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Vienna',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|t6000|8a5c0|a7a800|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|iio0|ivmo0|91xc0|9b6o0|9d1c0|a2yo0|8n400|gfyyg0|8zzw0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Vilnius',
    'untils': '-rns980|1g224o|e75nc|4kqk0|acbs40|gpp40|pits0|7k800|9q000|9d1c0|65zo0|j4vx80|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x9g0|asw00|7x6o0|b5uo0|1s3eo0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-84|-95.6|-60|-120|-180|-240',
    'offsetIndices': '012324323234545454545454545443434343434343434332334343434343434343434343434343434343434343434343434343434343434343434343'
  }, {
    'id': 'Europe/Volgograd',
    'untils': '-q3cw84|5glrw4|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|iq5g0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|s3400|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|239c40|Infinity',
    'offsets': '-177.6667|-180|-240|-300',
    'offsetIndices': '012323232323232321212121212121212121212121212121212121212121212'
  }, {
    'id': 'Europe/Warsaw',
    'untils': '-se9yk0|dvyc0|7ves0|a4yw0|7x6o0|asw00|7x6o0|aunw0|7x6o0|1evbs0|9fcwc0|18cao0|7k800|9q000|9d1c0|9gnw0|an980|9kd80|8fs40|922w0|ar1c0|7x6o0|a2yo0|8n400|9q000|902o0|4013w0|64dc0|9d1c0|9d1c0|clpc0|6hc00|9d1c0|9d1c0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|clpc0|64dc0|6j4tc0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-84|-60|-120|-180',
    'offsetIndices': '012121223212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Zagreb',
    'untils': '-ezayw0|swz00|7k800|9q000|9d1c0|9d1c0|b7pc0|6qlc0|jl1hc0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Europe/Zaporozhye',
    'untils': '-nu12hc|37a0xc|5u1180|mc0g0|7k800|9q000|12qg0|jjc7s0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9cvs0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9dcg0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-140|-120|-180|-60|-240',
    'offsetIndices': '01213132424242424242424242422121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Europe/Zurich',
    'untils': '-eyh6o0|7x6o0|asw00|7x6o0|k2zus0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'GB-Eire',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'GB',
    'untils': '-rzcns0|6uao0|9q000|8c000|9o5c0|9ruo0|9b6o0|9ew00|9b6o0|auqo0|88ao0|9ew00|8y800|a2yo0|a2yo0|7k800|asw00|8a5c0|asw00|8n400|a2yo0|8n400|9q000|902o0|afxc0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|9d1c0|a2yo0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|a2yo0|b5uo0|51hc0|mbmk0|51hc0|c8qo0|6hc00|c8qo0|6uao0|bvs00|8n400|a4tc0|5clc0|4bms0|9q000|902o0|8a5c0|1frw0|64dc0|4bms0|6uao0|bvs00|7x6o0|asw00|8n400|9q000|902o0|9q000|9d1c0|9q000|902o0|8n400|9q000|902o0|a2yo0|8n400|afxc0|8n400|9q000|902o0|a2yo0|8n400|a2yo0|8n400|9q000|902o0|902o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|5reo0|1xhuo0|779c0|bitc0|779c0|bitc0|779c0|bitc0|779c0|bitc0|7k800|b5uo0|7k800|b5uo0|7k800|bitc0|779c0|bitc0|779c0|bitc0|7x3w0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60|-120',
    'offsetIndices': '0101010101010101010101010101010101010101010101010121212121210101210101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'GMT-0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'GMT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'GMT+0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'GMT0',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Greenwich',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Hongkong',
    'untils': '-y0i0s0|j44dk0|5k000|4d4y0|2195i0|7x3w0|bj320|6uao0|bvs00|7x6o0|9d1c0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|8a5c0|asw00|7x6o0|ast80|77c40|biqk0|77c40|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|77c40|biqk0|77c40|bvp80|6udg0|bvp80|6udg0|bvp80|77c40|biqk0|77c40|biqk0|8n6s0|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9cyk0|1c9440|8a2k0|Infinity',
    'offsets': '-456.7|-480|-540|-510',
    'offsetIndices': '0123212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'HST',
    'untils': 'Infinity',
    'offsets': '600',
    'offsetIndices': '0'
  }, {
    'id': 'Iceland',
    'untils': '-wcwx9c|4rpd9c|ci2s0|69uk0|du840|4xp80|du840|p7bw0|4w040|9bdzw0|9d6w0|64g40|cyl80|64dc0|clpc0|6hc00|bvs00|6uao0|bvs00|6uao0|bvs00|6uao0|c8qo0|6hc00|c8qo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|7x6o0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|asw00|8a5c0|Infinity',
    'offsets': '88|60|0',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Indian/Antananarivo',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Indian/Chagos',
    'untils': '-wvpc2s|1ag64us|Infinity',
    'offsets': '-289.6667|-300|-360',
    'offsetIndices': '012'
  }, {
    'id': 'Indian/Christmas',
    'untils': 'Infinity',
    'offsets': '-420',
    'offsetIndices': '0'
  }, {
    'id': 'Indian/Cocos',
    'untils': 'Infinity',
    'offsets': '-390',
    'offsetIndices': '0'
  }, {
    'id': 'Indian/Comoro',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Indian/Kerguelen',
    'untils': '-afrs00|Infinity',
    'offsets': '0|-300',
    'offsetIndices': '01'
  }, {
    'id': 'Indian/Mahe',
    'untils': '-x6pjlo|Infinity',
    'offsets': '-221.8|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Indian/Maldives',
    'untils': '-57x6y0|Infinity',
    'offsets': '-294|-300',
    'offsetIndices': '01'
  }, {
    'id': 'Indian/Mauritius',
    'untils': '-wvp9bc|13jnu7c|8bx80|dd0wc0|7x3w0|Infinity',
    'offsets': '-230|-240|-300',
    'offsetIndices': '012121'
  }, {
    'id': 'Indian/Mayotte',
    'untils': '-lnsetg|s8mhg|57v020|afrrb0|Infinity',
    'offsets': '-147.2667|-180|-150|-165',
    'offsetIndices': '01231'
  }, {
    'id': 'Indian/Reunion',
    'untils': '-uks29s|Infinity',
    'offsets': '-221.8667|-240',
    'offsetIndices': '01'
  }, {
    'id': 'Iran',
    'untils': '-s6m6uw|fnolc0|gm3h4w|777y0|b07w0|3pes0|42c20|9cyk0|9gtg0|9kd80|5ja5g0|7avw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|1av440|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9d440|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|9b9g0|9gnw0|Infinity',
    'offsets': '-205.7333|-210|-240|-300|-270',
    'offsetIndices': '00123214141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141'
  }, {
    'id': 'Israel',
    'untils': '-r50eig|bp54yg|19f3w0|7rv00|b02c0|7tk40|b07w0|8jhg0|a8lg0|8jhg0|a8ac0|t9s40|56vs0|35700|9b3w0|9gtg0|8jbw0|7tmw0|a6ig0|biyw0|8a5c0|9d1c0|902o0|7x6o0|e1eg0|4ofw0|dzxo0|4q500|doo40|64iw0|auqo0|7i500|8rfms0|51ek0|9q2s0|6u7w0|2khpg0|25s00|1weyo0|5reo0|bxmo0|7x3w0|cls40|5rbw0|bbhg0|7rjw0|asys0|7k580|c8tg0|6h980|ag040|7x3w0|asys0|8a2k0|asys0|8a2k0|ap9g0|80t80|ap9g0|7nuk0|b2840|80t80|9zc40|9iik0|9kis0|93p80|9mdg0|8qqk0|apf00|7x3w0|biw40|8zx40|9io40|8n180|9kis0|9vh80|8ulg0|9px80|9mdg0|8n180|9tuw0|9tmk0|8wg40|9gnw0|99es0|8qqk0|9zc40|9tmk0|8wg40|9gnw0|99es0|8qqk0|acas0|9gnw0|99es0|93p80|9mdg0|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|7tk40|b9h80|7glg0|b9h80|7glg0|b9h80|7glg0|b9h80|7tk40|awik0|7tk40|awik0|Infinity',
    'offsets': '-140.6667|-120|-180|-240',
    'offsetIndices': '012121212121321212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Jamaica',
    'untils': '-u85og2|wbl182|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|Infinity',
    'offsets': '307.1667|300|240',
    'offsetIndices': '0121212121212121212121'
  }, {
    'id': 'Japan',
    'untils': '-bb4900|6uao0|afxc0|8a5c0|c8qo0|6hc00|c8qo0|6hc00|Infinity',
    'offsets': '-540|-600',
    'offsetIndices': '010101010'
  }, {
    'id': 'Kwajalein',
    'untils': '-h817w0|27sas0|1hjus0|ddxug0|cgv6k0|Infinity',
    'offsets': '-660|-600|-540|720|-720',
    'offsetIndices': '012034'
  }, {
    'id': 'Libya',
    'untils': '-q3gfrw|gl6ajw|422c0|xado0|4bbo0|wrpg0|4s580|1kdpg0|c05bw0|4mqs0|9et80|9d440|9et80|9eys0|9et80|9mdg0|95jw0|9io40|9cyk0|99es0|9et80|9eys0|9et80|9d440|9et80|b2840|3cf3w0|9kis0|9et80|7vqyw0|75eo0|asw00|Infinity',
    'offsets': '-52.7333|-60|-120',
    'offsetIndices': '012121212121212121212121212122122'
  }, {
    'id': 'MET',
    'untils': '-s0e080|7ves0|a4yw0|7x6o0|asw00|7x6o0|b8qdc0|1cm000|7k800|9q000|9d1c0|9d1c0|9d1c0|8l9c0|ggp1c0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-60|-120',
    'offsetIndices': '01010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Mexico/BajaNorte',
    'untils': '-p1u1s0|11jrw0|1sns00|1sgdc0|71s40|9cyk0|5iidg0|1q6700|4lfk0|190g40|eluk0|2r4o80|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|84qys0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|77c40|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '468.0667|420|480',
    'offsetIndices': '012121211212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Mexico/BajaSur',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|591h80|3ie2s0|axvpg0|dpgw40|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '425.6667|420|360|480',
    'offsetIndices': '0121212131212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Mexico/General',
    'untils': '-p1u4k0|2u7jw0|1sgdc0|8n400|7thc0|9eys0|3knek0|776k0|rf440|5t6k0|1evk40|71mk0|30p1g0|8n180|nufxo0|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|9q2s0|7k580|9q2s0|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|Infinity',
    'offsets': '396.6|420|360|300',
    'offsetIndices': '012121232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'MST',
    'untils': 'Infinity',
    'offsets': '420',
    'offsetIndices': '0'
  }, {
    'id': 'MST7MDT',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|1tz5k0|2dvo0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Navajo',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'NZ-CHAT',
    'untils': '-ciya10|f1tq90|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-735|-765|-825',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'NZ',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Pacific/Apia',
    'untils': '-usiiv4|kcrmt4|vp3la0|9odo0|902o0|4zbk0|4qog0|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '686.9333|690|660|600|-840|-780',
    'offsetIndices': '01232345454545454545454545454545454545454545454545454545454'
  }, {
    'id': 'Pacific/Auckland',
    'untils': '-m01p20|64ak0|biw40|7x5a0|asxe0|7x5a0|asxe0|7x5a0|asxe0|8a3y0|afyq0|8a3y0|afyq0|afvy0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|asum0|7x820|b5ta0|7k9e0|b5ta0|7x820|hsl2m0|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-690|-750|-720|-780',
    'offsetIndices': '01020202020202020202020202023232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Pacific/Bougainville',
    'untils': '-ecsh40|1n05g0|1071c40|Infinity',
    'offsets': '-600|-540|-660',
    'offsetIndices': '0102'
  }, {
    'id': 'Pacific/Chatham',
    'untils': '-ciya10|f1tq90|5reo0|clpc0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6uao0|c8qo0|6hc00|b5uo0|8a5c0|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|afxc0|8a5c0|afxc0|8a5c0|afxc0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|8n400|a2yo0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|a2yo0|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|902o0|9q000|9d1c0|9q000|902o0|9q000|902o0|Infinity',
    'offsets': '-735|-765|-825',
    'offsetIndices': '012121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212'
  }, {
    'id': 'Pacific/Chuuk',
    'untils': '-su4zs0|29hes0|bkenw0|29fk40|Infinity',
    'offsets': '-600|-540',
    'offsetIndices': '01010'
  }, {
    'id': 'Pacific/Easter',
    'untils': '-jhfaew|ivmeuw|7k580|c8tg0|6h980|a31g0|7x3w0|asys0|7x3w0|b5xg0|7k580|ag040|8a2k0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|iq2o0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|9cyk0|9d440|7x3w0|asys0|7x3w0|b5xg0|7k580|9q2s0|8zzw0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|a31g0|9px80|9q2s0|7x3w0|b5xg0|7k580|b5xg0|7k580|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|8n180|a31g0|7x3w0|asys0|8zzw0|9q2s0|ast80|5eis0|cyl80|6hes0|c8nw0|6udg0|bvp80|6udg0|vonw0|4olg0|e1h80|4olg0|e1h80|4olg0|c8nw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|b5rw0|7x9g0|ast80|7x9g0|Infinity',
    'offsets': '437.4667|420|360|300',
    'offsetIndices': '012121212121212121212121212123232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323'
  }, {
    'id': 'Pacific/Efate',
    'untils': '-u964i4|11f4ba4|9cyk0|awo40|7tek0|9q2s0|8zzw0|9q2s0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9q2s0|64ak0|e1ms0|4ofw0|Infinity',
    'offsets': '-673.2667|-660|-720',
    'offsetIndices': '0121212121212121212121'
  }, {
    'id': 'Pacific/Enderbury',
    'untils': '535io0|7yiqk0|Infinity',
    'offsets': '720|660|-780',
    'offsetIndices': '012'
  }, {
    'id': 'Pacific/Fakaofo',
    'untils': 'lx0jw0|Infinity',
    'offsets': '660|-780',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Fiji',
    'untils': '-sa2x4w|17bs00w|64dc0|cyo00|5reo0|53a5c0|64dc0|asw00|6uao0|bvs00|4oio0|e1k00|4oio0|eeio0|4bh80|erk40|3ylc0|erhc0|3ylc0|f4g00|3lmo0|f4g00|3lmo0|f4g00|3lmo0|fheo0|38o00|fheo0|3lmo0|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|3lmo0|f4g00|3lmo0|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|3lmo0|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|38o00|fheo0|3lmo0|f4g00|3lmo0|Infinity',
    'offsets': '-715.7333|-720|-780',
    'offsetIndices': '0121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Pacific/Funafuti',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Galapagos',
    'untils': '-kcr62o|spdryo|3lsas0|3jp80|Infinity',
    'offsets': '358.4|300|360',
    'offsetIndices': '01212'
  }, {
    'id': 'Pacific/Gambier',
    'untils': '-tvndoc|Infinity',
    'offsets': '539.8|540',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Guadalcanal',
    'untils': '-tvowac|Infinity',
    'offsets': '-639.8|-660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Guam',
    'untils': '-en8eg0|1dl9g0|7s1k40|txp80|3frms0|qdrpo|7kgac|3ljw0|c8tg0|6u7w0|bvus0|6u7w0|16uo40|3ljw0|16aas0|4ivxo|cls2c|6h980|c65zw0|Infinity',
    'offsets': '-600|-540|-660',
    'offsetIndices': '01020202020202020200'
  }, {
    'id': 'Pacific/Honolulu',
    'untils': '-j50la0|13l00|4jvb00|1tyvu0|2e5e0|votg0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '0101102'
  }, {
    'id': 'Pacific/Johnston',
    'untils': '-j50la0|13l00|4jvb00|1tyvu0|2e5e0|votg0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '0101102'
  }, {
    'id': 'Pacific/Kiritimati',
    'untils': '535eyo|7yirhc|Infinity',
    'offsets': '640|600|-840',
    'offsetIndices': '012'
  }, {
    'id': 'Pacific/Kosrae',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|29fk40|cm2540|f9l3w0|Infinity',
    'offsets': '-660|-540|-600|-720',
    'offsetIndices': '01021030'
  }, {
    'id': 'Pacific/Kwajalein',
    'untils': '-h817w0|27sas0|1hjus0|ddxug0|cgv6k0|Infinity',
    'offsets': '-660|-600|-540|720|-720',
    'offsetIndices': '012034'
  }, {
    'id': 'Pacific/Majuro',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|1h6w40|deat40|Infinity',
    'offsets': '-660|-540|-600|-720',
    'offsetIndices': '0102103'
  }, {
    'id': 'Pacific/Marquesas',
    'untils': '-tvncu0|Infinity',
    'offsets': '558|570',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Midway',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Nauru',
    'untils': '-pjxiws|ba66ys|1kwca0|hfzda0|Infinity',
    'offsets': '-667.6667|-690|-540|-720',
    'offsetIndices': '01213'
  }, {
    'id': 'Pacific/Niue',
    'untils': '-9wyz6o|ehcj4o|Infinity',
    'offsets': '680|690|660',
    'offsetIndices': '012'
  }, {
    'id': 'Pacific/Norfolk',
    'untils': '-9x0ps0|cfj8q0|6hc00|l6nk00|239aq0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|Infinity',
    'offsets': '-672|-690|-750|-660|-720',
    'offsetIndices': '012134343434343434343434343434343434343434'
  }, {
    'id': 'Pacific/Noumea',
    'untils': '-u9645o|ye0ixo|4dbw0|ecqs0|4f6k0|99p700|4oio0|Infinity',
    'offsets': '-665.8|-660|-720',
    'offsetIndices': '01212121'
  }, {
    'id': 'Pacific/Pago_Pago',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Palau',
    'untils': 'Infinity',
    'offsets': '-540',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Pitcairn',
    'untils': 'es2cy0|Infinity',
    'offsets': '510|480',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Pohnpei',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|29fk40|Infinity',
    'offsets': '-660|-540|-600',
    'offsetIndices': '010210'
  }, {
    'id': 'Pacific/Ponape',
    'untils': '-su52k0|29hhk0|9cmd40|27sas0|29fk40|Infinity',
    'offsets': '-660|-540|-600',
    'offsetIndices': '010210'
  }, {
    'id': 'Pacific/Port_Moresby',
    'untils': 'Infinity',
    'offsets': '-600',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Rarotonga',
    'untils': '4mj960|5rbw0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|c8s20|6u9a0|c8s20|6ham0|c8s20|6ham0|c8s20|6ham0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '012121212121212121212121212'
  }, {
    'id': 'Pacific/Saipan',
    'untils': '-en8eg0|1dl9g0|7s1k40|txp80|3frms0|qdrpo|7kgac|3ljw0|c8tg0|6u7w0|bvus0|6u7w0|16uo40|3ljw0|16aas0|4ivxo|cls2c|6h980|c65zw0|Infinity',
    'offsets': '-600|-540|-660',
    'offsetIndices': '01020202020202020200'
  }, {
    'id': 'Pacific/Samoa',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Tahiti',
    'untils': '-tvnayw|Infinity',
    'offsets': '598.2667|600',
    'offsetIndices': '01'
  }, {
    'id': 'Pacific/Tarawa',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Tongatapu',
    'untils': '-f4vrlc|uo2edc|8fpc0|bvs00|4bh80|eelg0|4bh80|7pmis0|3lmo0|Infinity',
    'offsets': '-740|-780|-840',
    'offsetIndices': '0121212121'
  }, {
    'id': 'Pacific/Truk',
    'untils': '-su4zs0|29hes0|bkenw0|29fk40|Infinity',
    'offsets': '-600|-540',
    'offsetIndices': '01010'
  }, {
    'id': 'Pacific/Wake',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Wallis',
    'untils': 'Infinity',
    'offsets': '-720',
    'offsetIndices': '0'
  }, {
    'id': 'Pacific/Yap',
    'untils': '-su4zs0|29hes0|bkenw0|29fk40|Infinity',
    'offsets': '-600|-540',
    'offsetIndices': '01010'
  }, {
    'id': 'Poland',
    'untils': '-se9yk0|dvyc0|7ves0|a4yw0|7x6o0|asw00|7x6o0|aunw0|7x6o0|1evbs0|9fcwc0|18cao0|7k800|9q000|9d1c0|9gnw0|an980|9kd80|8fs40|922w0|ar1c0|7x6o0|a2yo0|8n400|9q000|902o0|4013w0|64dc0|9d1c0|9d1c0|clpc0|6hc00|9d1c0|9d1c0|c8qo0|6hc00|c8qo0|6hc00|c8qo0|6hc00|clpc0|64dc0|6j4tc0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '-84|-60|-120|-180',
    'offsetIndices': '012121223212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'Portugal',
    'untils': '-u9rhc0|2bufw0|6zxg0|66580|bq800|73k00|bodc0|71pc0|bq800|73k00|bq800|71pc0|bq800|1b2g00|9b6o0|saio0|8n400|9q000|902o0|a2yo0|902o0|a2yo0|8n400|st1c0|8n400|9d1c0|9d1c0|sg2o0|9d1c0|902o0|9q000|a2yo0|8n400|9d1c0|9d1c0|902o0|9q000|a2yo0|b5uo0|51hc0|bitc0|9d1c0|9ew00|88ao0|25p80|5reo0|3lpg0|779c0|1sqk0|6uao0|38qs0|6uao0|25p80|6hc00|38qs0|6uao0|25p80|6hc00|38qs0|8a5c0|9d1c0|9d9o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|s3400|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|5gyl40|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d440|9cyk0|9d440|9d1c0|9d1c0|9d1c0|9d1c0|9d440|9cyk0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '36.75|0|-60|-120',
    'offsetIndices': '012121212121212121212121212121212121212121212321232123212321212121212121212121212121212121212121212121212121212121212121212121212122323232212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'PRC',
    'untils': '-qh00w0|8sl80|asbpg0|6w2k0|7ves0|bxjw0|4mqs0|1vduk0|d4as0|75bw0|a31g0|aaak0|9d440|7v980|awo40|1dx80|j9xpo0|6u7w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010'
  }, {
    'id': 'PST8PDT',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|b9gdg0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'ROC',
    'untils': '-gtzfk0|45slc0|c51c0|75bw0|a31g0|aaak0|9d440|7v980|awo40|7v980|awo40|7v980|awo40|7v980|7tk40|clmk0|7rpg0|b07w0|7rpg0|b07w0|7rpg0|9et80|9eys0|9et80|9d440|9et80|9d440|9et80|9d440|9et80|cjxg0|69uk0|ci2s0|69uk0|6its40|9et80|9d440|9et80|1yf9g0|4qak0|Infinity',
    'offsets': '-480|-540',
    'offsetIndices': '01010101010101010101010101010101010101010'
  }, {
    'id': 'ROK',
    'untils': '-w8966g|1yh18g|hkx5a0|1faao0|5cik0|ae5g0|8a2k0|ae5g0|8bx80|c8tg0|6h980|1bj6s0|l3aq0|6j3w0|d2g40|6u7w0|b5xg0|776k0|biw40|776k0|biw40|776k0|biw40|776k0|grs40|dfqxi0|7x6o0|asw00|7x6o0|Infinity',
    'offsets': '-507.8667|-510|-540|-600|-570',
    'offsetIndices': '012232323232141414141414123232'
  }, {
    'id': 'Singapore',
    'untils': '-xphpwd|eeb94d|4it32o|8n3jc|1v2p60|iy3o60|Infinity',
    'offsets': '-415.4167|-420|-440|-450|-540|-480',
    'offsetIndices': '0123435'
  }, {
    'id': 'Turkey',
    'untils': '-ux9xew|2wvx6w|7v980|1tjc40|aunw0|88dg0|9et80|8yas0|a2vw0|tzpg0|79180|awo40|7v980|7p4040|4zjw0|2vs40|f4d80|9vms0|1u5ek0|c5440|69uk0|acas0|8n180|a31g0|8n180|9q2s0|8zzw0|a31g0|8zzw0|a31g0|8n180|5md9g0|o9zw0|a6qs0|75bw0|4iwyw0|7x6o0|7kas0|b5rw0|75hg0|bkl80|77c40|biqk0|7x9g0|a2vw0|8n6s0|4iqc0|2nkw80|38l80|kdes0|8qtc0|8a5c0|9ew00|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|902o0|9q000|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7kdk0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7m2o0|b4000|7k800|b5uo0|7x6o0|asw00|7z1c0|ar1c0|7x6o0|bitc0|779c0|8fe80|Infinity',
    'offsets': '-116.9333|-120|-180|-240',
    'offsetIndices': '0121212121212121212121212121212121212121212121223212121212121212121212121212121212121212121212121212121212121212122'
  }, {
    'id': 'UCT',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'Universal',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'US/Alaska',
    'untils': '-ek1qo0|1tyx80|2e400|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '600|540|480',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'US/Aleutian',
    'untils': '-ek1nw0|1tyug0|2e6s0|b7yik0|12y080|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|1l940|7rs80|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '660|600|540',
    'offsetIndices': '011001010101010101010101010101010111212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'US/Arizona',
    'untils': '-r0epo0|ast80|7x9g0|ast80|bmtus0|zjedo|4olg0|9et80|bs6lmc|9cyk0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101010'
  }, {
    'id': 'US/Central',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bvus0|776k0|7kas0|b5rw0|9d440|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|7x9g0|dbjw0|8a840|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/East-Indiana',
    'untils': '-r0esg0|ast80|7x9g0|ast80|baw840|51ek0|6w840|1tz8c0|2dsw0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|19q7w0|asys0|5qonw0|9cyk0|9d440|9cyk0|ihslg0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300|240',
    'offsetIndices': '010101011010101010101010101010121212121212121212121212121212121212121212121212121212121212121212121'
  }, {
    'id': 'US/Eastern',
    'untils': '-r0ev80|ast80|7x9g0|ast80|7x9g0|b5rw0|905g0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|6w840|1tzb40|2dq40|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '300|240',
    'offsetIndices': '01010101010101010101010101010101010101010101010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Hawaii',
    'untils': '-j50la0|13l00|4jvb00|1tyvu0|2e5e0|votg0|Infinity',
    'offsets': '630|570|600',
    'offsetIndices': '0101102'
  }, {
    'id': 'US/Indiana-Starke',
    'untils': '-r0esg0|ast80|7x9g0|ast80|bmtus0|1tz8c0|2dsw0|tj1g0|7x3w0|asys0|7x3w0|asys0|7x3w0|b5xg0|7k580|b5xg0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|7x3w0|asys0|9px80|9d440|9cyk0|9d440|7x3w0|asys0|7x3w0|asys0|9cyk0|9d440|9px80|9d440|9cyk0|9d440|s3180|1twas0|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|7j5400|asw00|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '360|300',
    'offsetIndices': '0101011010101010101010101010101010101010101010101010101010101010101010101010101010101010111010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Michigan',
    'untils': '-xx8dyd|5eraud|dyeyk0|1tzb40|2dq40|1c9440|7x3w0|9rlbxo|71s2c|9d440|9cyk0|2cmdg0|9cyk0|3lpg0|f4d80|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '332.1833|360|300|240',
    'offsetIndices': '0123323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232323232'
  }, {
    'id': 'US/Mountain',
    'untils': '-r0epo0|ast80|7x9g0|ast80|7x9g0|b5rw0|7kas0|2vmk0|ataw40|1tz5k0|2dvo0|a7n9g0|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '420|360',
    'offsetIndices': '01010101011010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Pacific-New',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|1a3c5o|f2iic|owao0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Pacific',
    'untils': '-r0emw0|ast80|7x9g0|ast80|bmtus0|1tz2s0|2dyg0|1a3c5o|f2iic|owao0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|902o0|9q000|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|9d440|9cyk0|9d440|9cyk0|3lpg0|f4d80|64g40|clmk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|9d440|9px80|905g0|9px80|9d440|9cyk0|9d440|9cyk0|9d440|9cyk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|8a840|afuk0|8a840|afuk0|8a840|ast80|7x9g0|ast80|7x9g0|ast80|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6udg0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|6hes0|c8nw0|Infinity',
    'offsets': '480|420',
    'offsetIndices': '010101101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'US/Samoa',
    'untils': '-usij20|Infinity',
    'offsets': '682.8|660',
    'offsetIndices': '01'
  }, {
    'id': 'UTC',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }, {
    'id': 'W-SU',
    'untils': '-rx5dmh|ipzua|97hc0|7yyk0|5i840|d9p80|1jwk7|2cvk0|s8o00|1qvw0|8fpc0|1jms0|is040|412as0|qi27w0|9et80|9d440|9et80|9d440|9et80|9eys0|9d6w0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d440|5reo0|3ljw0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|1vbzw0|Infinity',
    'offsets': '-150.2833|-151.3167|-211.3167|-271.3167|-240|-180|-300|-120',
    'offsetIndices': '012132345464575454545454545454545455754545454545454545454545454545454545454545'
  }, {
    'id': 'WET',
    'untils': '3s9ms0|902o0|9q000|9d1c0|9d1c0|9d1c0|9q000|902o0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9d1c0|9q000|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|7x6o0|b5uo0|7k800|b5uo0|7k800|b5uo0|7k800|b5uo0|7x6o0|asw00|7x6o0|asw00|Infinity',
    'offsets': '0|-60',
    'offsetIndices': '010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010'
  }, {
    'id': 'Zulu',
    'untils': 'Infinity',
    'offsets': '0',
    'offsetIndices': '0'
  }]
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 51690:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _query = _interopRequireDefault(__webpack_require__(96687));
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _timezones_data = _interopRequireDefault(__webpack_require__(61189));
var _math = __webpack_require__(60810);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var getConvertedUntils = function getConvertedUntils(value) {
  return value.split('|').map(function (until) {
    if (until === 'Infinity') {
      return null;
    }
    return parseInt(until, 36) * 1000;
  });
};
var parseTimezone = function parseTimezone(timeZoneConfig) {
  var offsets = timeZoneConfig.offsets;
  var offsetIndices = timeZoneConfig.offsetIndices;
  var untils = timeZoneConfig.untils;
  var offsetList = offsets.split('|').map(function (value) {
    return parseInt(value);
  });
  var offsetIndexList = offsetIndices.split('').map(function (value) {
    return parseInt(value);
  });
  var dateList = getConvertedUntils(untils).map(function (accumulator) {
    return function (value) {
      return accumulator += value;
    };
  }(0));
  return {
    offsetList,
    offsetIndexList,
    dateList
  };
};
var TimeZoneCache = /*#__PURE__*/function () {
  function TimeZoneCache() {
    this.map = new Map();
  }
  var _proto = TimeZoneCache.prototype;
  _proto.tryGet = function tryGet(id) {
    if (!this.map.get(id)) {
      var config = timeZoneDataUtils.getTimezoneById(id);
      if (!config) {
        return false;
      }
      var timeZoneInfo = parseTimezone(config);
      this.map.set(id, timeZoneInfo);
    }
    return this.map.get(id);
  };
  return TimeZoneCache;
}();
var tzCache = new TimeZoneCache();
var timeZoneDataUtils = {
  _tzCache: tzCache,
  _timeZones: _timezones_data.default.zones,
  getDisplayedTimeZones: function getDisplayedTimeZones(timestamp) {
    var _this = this;
    var timeZones = this._timeZones.map(function (timezone) {
      var timeZoneInfo = parseTimezone(timezone);
      var offset = _this.getUtcOffset(timeZoneInfo, timestamp);
      var title = "(GMT ".concat(_this.formatOffset(offset), ") ").concat(_this.formatId(timezone.id));
      return {
        offset,
        title,
        id: timezone.id
      };
    });
    return (0, _query.default)(timeZones).sortBy('offset').toArray();
  },
  formatOffset: function formatOffset(offset) {
    var hours = Math.floor(offset);
    var minutesInDecimal = offset - hours;
    var signString = (0, _math.sign)(offset) >= 0 ? '+' : '-';
    var hoursString = "0".concat(Math.abs(hours)).slice(-2);
    var minutesString = minutesInDecimal > 0 ? ":".concat(minutesInDecimal * 60) : ':00';
    return signString + hoursString + minutesString;
  },
  formatId: function formatId(id) {
    return id.split('/').join(' - ').split('_').join(' ');
  },
  getTimezoneById: function getTimezoneById(id) {
    if (!id) {
      return;
    }
    var tzList = this._timeZones;
    for (var i = 0; i < tzList.length; i++) {
      var currentId = tzList[i]['id'];
      if (currentId === id) {
        return tzList[i];
      }
    }
    _errors.default.log('W0009', id);
    return;
  },
  getTimeZoneOffsetById: function getTimeZoneOffsetById(id, timestamp) {
    var timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : undefined;
  },
  getTimeZoneDeclarationTuple: function getTimeZoneDeclarationTuple(id, year) {
    var timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];
  },
  getTimeZoneDeclarationTupleCore: function getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {
    var offsetList = timeZoneInfo.offsetList;
    var offsetIndexList = timeZoneInfo.offsetIndexList;
    var dateList = timeZoneInfo.dateList;
    var tupleResult = [];
    for (var i = 0; i < dateList.length; i++) {
      var currentDate = dateList[i];
      var currentYear = new Date(currentDate).getFullYear();
      if (currentYear === year) {
        var offset = offsetList[offsetIndexList[i + 1]];
        tupleResult.push({
          date: currentDate,
          offset: -offset / 60
        });
      }
      if (currentYear > year) {
        break;
      }
    }
    return tupleResult;
  },
  getUtcOffset: function getUtcOffset(timeZoneInfo, dateTimeStamp) {
    var offsetList = timeZoneInfo.offsetList;
    var offsetIndexList = timeZoneInfo.offsetIndexList;
    var dateList = timeZoneInfo.dateList;
    var infinityUntilCorrection = 1;
    var lastIntervalStartIndex = dateList.length - 1 - infinityUntilCorrection;
    var index = lastIntervalStartIndex;
    while (index >= 0 && dateTimeStamp < dateList[index]) {
      index--;
    }
    var offset = offsetList[offsetIndexList[index + 1]];
    return -offset / 60 || offset;
  }
};
var _default = timeZoneDataUtils;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 32511:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _date = _interopRequireDefault(__webpack_require__(91198));
var _utils = _interopRequireDefault(__webpack_require__(51690));
var _dateAdapter = _interopRequireDefault(__webpack_require__(26983));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } /* globals Intl */
var toMs = _date.default.dateToMilliseconds;
var MINUTES_IN_HOUR = 60;
var MS_IN_MINUTE = 60000;
var createUTCDateWithLocalOffset = function createUTCDateWithLocalOffset(date) {
  if (!date) {
    return null;
  }
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
};
var createDateFromUTCWithLocalOffset = function createDateFromUTCWithLocalOffset(date) {
  var result = (0, _dateAdapter.default)(date);
  var timezoneOffsetBeforeInMin = result.getTimezoneOffset();
  result.addTime(result.getTimezoneOffset('minute'));
  result.subtractMinutes(timezoneOffsetBeforeInMin - result.getTimezoneOffset());
  return result.source;
};
var getTimeZones = function getTimeZones() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  var dateInUTC = createUTCDate(date);
  return _utils.default.getDisplayedTimeZones(dateInUTC.getTime());
};
var createUTCDate = function createUTCDate(date) {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));
};
var getTimezoneOffsetChangeInMinutes = function getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) {
  return getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);
};
var getTimezoneOffsetChangeInMs = function getTimezoneOffsetChangeInMs(startDate, endDate, updatedStartDate, updatedEndDate) {
  return getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs('minute');
};
var getDaylightOffset = function getDaylightOffset(startDate, endDate) {
  return new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();
};
var getDaylightOffsetInMs = function getDaylightOffsetInMs(startDate, endDate) {
  return getDaylightOffset(startDate, endDate) * toMs('minute');
};
var calculateTimezoneByValue = function calculateTimezoneByValue(timezone) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  // NOTE: This check could be removed. We don't support numerical timezones
  if (typeof timezone === 'string') {
    var dateUtc = createUTCDate(date);
    return _utils.default.getTimeZoneOffsetById(timezone, dateUtc.getTime());
  }
  return timezone;
};
var _getDaylightOffsetByTimezone = function _getDaylightOffsetByTimezone(startDate, endDate, timeZone) {
  return calculateTimezoneByValue(timeZone, startDate) - calculateTimezoneByValue(timeZone, endDate);
};
var getCorrectedDateByDaylightOffsets = function getCorrectedDateByDaylightOffsets(convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) {
  var daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);
  var daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);
  var diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;
  return new Date(date.getTime() - diff * toMs('hour'));
};
var correctRecurrenceExceptionByTimezone = function correctRecurrenceExceptionByTimezone(exception, exceptionByStartDate, timeZone, startDateTimeZone) {
  var isBackConversion = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / MINUTES_IN_HOUR;
  if (startDateTimeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);
  } else if (timeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);
  }
  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs('hour'));
};
var isTimezoneChangeInDate = function isTimezoneChangeInDate(date) {
  var startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));
  var endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));
  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;
};
var getDateWithoutTimezoneChange = function getDateWithoutTimezoneChange(date) {
  var clonedDate = new Date(date);
  if (isTimezoneChangeInDate(clonedDate)) {
    var result = new Date(clonedDate);
    return new Date(result.setDate(result.getDate() + 1));
  }
  return clonedDate;
};
var isSameAppointmentDates = function isSameAppointmentDates(startDate, endDate) {
  // NOTE: subtract 1 millisecond to avoid 00.00 time. Method should return 'true' for "2020:10:10 22:00:00" and "2020:10:11 00:00:00", for example.
  endDate = new Date(endDate.getTime() - 1);
  return _date.default.sameDate(startDate, endDate);
};
var getClientTimezoneOffset = function getClientTimezoneOffset() {
  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  return date.getTimezoneOffset() * MS_IN_MINUTE;
};
var getDiffBetweenClientTimezoneOffsets = function getDiffBetweenClientTimezoneOffsets() {
  var firstDate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
  var secondDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate);
};
var isEqualLocalTimeZone = function isEqualLocalTimeZone(timeZoneName) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
  if (Intl) {
    var localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
    if (localTimeZoneName === timeZoneName) {
      return true;
    }
  }
  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);
};

// TODO: Not used anywhere, if it isn't use in the future, then it must be removed
var hasDSTInLocalTimeZone = function hasDSTInLocalTimeZone() {
  var _getExtremeDates = getExtremeDates(),
    _getExtremeDates2 = _slicedToArray(_getExtremeDates, 2),
    startDate = _getExtremeDates2[0],
    endDate = _getExtremeDates2[1];
  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();
};
var isEqualLocalTimeZoneByDeclaration = function isEqualLocalTimeZoneByDeclaration(timeZoneName, date) {
  var year = date.getFullYear();
  var getOffset = function getOffset(date) {
    return -date.getTimezoneOffset() / 60;
  };
  var getDateAndMoveHourBack = function getDateAndMoveHourBack(dateStamp) {
    return new Date(dateStamp - 3600000);
  };
  var configTuple = _utils.default.getTimeZoneDeclarationTuple(timeZoneName, year);
  var _configTuple = _slicedToArray(configTuple, 2),
    summerTime = _configTuple[0],
    winterTime = _configTuple[1];
  var noDSTInTargetTimeZone = configTuple.length < 2;
  if (noDSTInTargetTimeZone) {
    var targetTimeZoneOffset = _utils.default.getTimeZoneOffsetById(timeZoneName, date);
    var localTimeZoneOffset = getOffset(date);
    if (targetTimeZoneOffset !== localTimeZoneOffset) {
      return false;
    }
    return hasDSTInLocalTimeZone() ? false : true;
  }
  var localSummerOffset = getOffset(new Date(summerTime.date));
  var localWinterOffset = getOffset(new Date(winterTime.date));
  if (localSummerOffset !== summerTime.offset) {
    return false;
  }
  if (localSummerOffset === getOffset(getDateAndMoveHourBack(summerTime.date))) {
    return false;
  }
  if (localWinterOffset !== winterTime.offset) {
    return false;
  }
  if (localWinterOffset === getOffset(getDateAndMoveHourBack(winterTime.date))) {
    return false;
  }
  return true;
};

// TODO: Getting two dates in january or june is the standard mechanism for determining that an offset has occurred.
var getExtremeDates = function getExtremeDates() {
  var nowDate = new Date(Date.now());
  var startDate = new Date();
  var endDate = new Date();
  startDate.setFullYear(nowDate.getFullYear(), 0, 1);
  endDate.setFullYear(nowDate.getFullYear(), 6, 1);
  return [startDate, endDate];
};
var setOffsetsToDate = function setOffsetsToDate(targetDate, offsetsArray) {
  var newDateMs = offsetsArray.reduce(function (result, offset) {
    return result + offset;
  }, targetDate.getTime());
  return new Date(newDateMs);
};
var utils = {
  getDaylightOffset,
  getDaylightOffsetInMs,
  getTimezoneOffsetChangeInMinutes,
  getTimezoneOffsetChangeInMs,
  calculateTimezoneByValue,
  getCorrectedDateByDaylightOffsets,
  isSameAppointmentDates,
  correctRecurrenceExceptionByTimezone,
  getClientTimezoneOffset,
  getDiffBetweenClientTimezoneOffsets,
  createUTCDateWithLocalOffset,
  createDateFromUTCWithLocalOffset,
  createUTCDate,
  isTimezoneChangeInDate,
  getDateWithoutTimezoneChange,
  hasDSTInLocalTimeZone,
  isEqualLocalTimeZone,
  isEqualLocalTimeZoneByDeclaration,
  getTimeZones,
  setOffsetsToDate
};
var _default = utils;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 4741:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(3164));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 6866:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _frame = __webpack_require__(90057);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var abstract = _class.default.abstract;
var Animator = _class.default.inherit({
  ctor: function ctor() {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  },
  start: function start() {
    this._stopped = false;
    this._finished = false;
    this._stepCore();
  },
  stop: function stop() {
    this._stopped = true;
    (0, _frame.cancelAnimationFrame)(this._stepAnimationFrame);
  },
  _stepCore: function _stepCore() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = true;
      this._complete();
      return;
    }
    this._step();
    this._stepAnimationFrame = (0, _frame.requestAnimationFrame)(this._proxiedStepCore);
  },
  _step: abstract,
  _isFinished: _common.noop,
  _stop: _common.noop,
  _complete: _common.noop,
  _isStopped: function _isStopped() {
    return this._stopped;
  },
  inProgress: function inProgress() {
    return !(this._stopped || this._finished);
  }
});
var _default = Animator;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 3164:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _window = __webpack_require__(58201);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _element = __webpack_require__(6415);
var _extend = __webpack_require__(13306);
var _common = __webpack_require__(20576);
var _uiScroll_viewNative = _interopRequireDefault(__webpack_require__(27765));
var _uiScroll_viewNative2 = _interopRequireDefault(__webpack_require__(90778));
var _uiScroll_view = _interopRequireDefault(__webpack_require__(91616));
var _ui = _interopRequireDefault(__webpack_require__(41183));
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _themes = __webpack_require__(75811);
var _load_panel = _interopRequireDefault(__webpack_require__(97218));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// STYLE scrollView

var SCROLLVIEW_CLASS = 'dx-scrollview';
var SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + '-content';
var SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + '-top-pocket';
var SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + '-bottom-pocket';
var SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + '-pull-down';
var SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + '-scrollbottom';
var SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + '-indicator';
var SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + '-text';
var SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + '-loadpanel';
var refreshStrategies = {
  pullDown: _uiScroll_viewNative.default,
  swipeDown: _uiScroll_viewNative2.default,
  simulated: _uiScroll_view.default
};
var isServerSide = !(0, _window.hasWindow)();
var scrollViewServerConfig = {
  finishLoading: _common.noop,
  release: _common.noop,
  refresh: _common.noop,
  scrollOffset: function scrollOffset() {
    return {
      top: 0,
      left: 0
    };
  },
  _optionChanged: function _optionChanged(args) {
    if (args.name !== 'onUpdated') {
      return this.callBase.apply(this, arguments);
    }
  }
};
var ScrollView = _ui.default.inherit(isServerSide ? scrollViewServerConfig : {
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      pullingDownText: _message.default.format('dxScrollView-pullingDownText'),
      pulledDownText: _message.default.format('dxScrollView-pulledDownText'),
      refreshingText: _message.default.format('dxScrollView-refreshingText'),
      reachBottomText: _message.default.format('dxScrollView-reachBottomText'),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: 'pullDown'
    });
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat([{
      device: function device() {
        var realDevice = _devices.default.real();
        return realDevice.platform === 'android';
      },
      options: {
        refreshStrategy: 'swipeDown'
      }
    }, {
      device: function device() {
        return (0, _themes.isMaterial)();
      },
      options: {
        pullingDownText: '',
        pulledDownText: '',
        refreshingText: '',
        reachBottomText: ''
      }
    }]);
  },
  _init: function _init() {
    this.callBase();
    this._loadingIndicatorEnabled = true;
  },
  _initScrollableMarkup: function _initScrollableMarkup() {
    this.callBase();
    this.$element().addClass(SCROLLVIEW_CLASS);
    this._initContent();
    this._initTopPocket();
    this._initBottomPocket();
    this._initLoadPanel();
  },
  _initContent: function _initContent() {
    var $content = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_CONTENT_CLASS);
    this._$content.wrapInner($content);
  },
  _initTopPocket: function _initTopPocket() {
    var $topPocket = this._$topPocket = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_TOP_POCKET_CLASS);
    var $pullDown = this._$pullDown = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_CLASS);
    $topPocket.append($pullDown);
    this._$content.prepend($topPocket);
  },
  _initBottomPocket: function _initBottomPocket() {
    var $bottomPocket = this._$bottomPocket = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS);
    var $reachBottom = this._$reachBottom = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_REACHBOTTOM_CLASS);
    var $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS);
    var $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    var $text = this._$reachBottomText = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
    this._updateReachBottomText();
    $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
    $bottomPocket.append($reachBottom);
    this._$content.append($bottomPocket);
  },
  _initLoadPanel: function _initLoadPanel() {
    var $loadPanelElement = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
    var loadPanelOptions = {
      shading: false,
      delay: 400,
      message: this.option('refreshingText'),
      position: {
        of: this.$element()
      }
    };
    this._loadPanel = this._createComponent($loadPanelElement, _load_panel.default, loadPanelOptions);
  },
  _updateReachBottomText: function _updateReachBottomText() {
    this._$reachBottomText.text(this.option('reachBottomText'));
  },
  _createStrategy: function _createStrategy() {
    var strategyName = this.option('useNative') ? this.option('refreshStrategy') : 'simulated';
    var strategyClass = refreshStrategies[strategyName];
    this._strategy = new strategyClass(this);
    this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
    this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
    this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  },
  _createActions: function _createActions() {
    this.callBase();
    this._pullDownAction = this._createActionByOption('onPullDown');
    this._reachBottomAction = this._createActionByOption('onReachBottom');
    this._tryRefreshPocketState();
  },
  _tryRefreshPocketState: function _tryRefreshPocketState() {
    this._pullDownEnable(this.hasActionSubscription('onPullDown'));
    this._reachBottomEnable(this.hasActionSubscription('onReachBottom'));
  },
  on: function on(eventName) {
    var result = this.callBase.apply(this, arguments);
    if (eventName === 'pullDown' || eventName === 'reachBottom') {
      this._tryRefreshPocketState();
    }
    return result;
  },
  _pullDownEnable: function _pullDownEnable(enabled) {
    if (arguments.length === 0) {
      return this._pullDownEnabled;
    }
    if (this._$pullDown && this._strategy) {
      this._$pullDown.toggle(enabled);
      this._strategy.pullDownEnable(enabled);
      this._pullDownEnabled = enabled;
    }
  },
  _reachBottomEnable: function _reachBottomEnable(enabled) {
    if (arguments.length === 0) {
      return this._reachBottomEnabled;
    }
    if (this._$reachBottom && this._strategy) {
      this._$reachBottom.toggle(enabled);
      this._strategy.reachBottomEnable(enabled);
      this._reachBottomEnabled = enabled;
    }
  },
  _pullDownHandler: function _pullDownHandler() {
    this._loadingIndicator(false);
    this._pullDownLoading();
  },
  _loadingIndicator: function _loadingIndicator(value) {
    if (arguments.length < 1) {
      return this._loadingIndicatorEnabled;
    }
    this._loadingIndicatorEnabled = value;
  },
  _pullDownLoading: function _pullDownLoading() {
    this.startLoading();
    this._pullDownAction();
  },
  _reachBottomHandler: function _reachBottomHandler() {
    this._loadingIndicator(false);
    this._reachBottomLoading();
  },
  _reachBottomLoading: function _reachBottomLoading() {
    this.startLoading();
    this._reachBottomAction();
  },
  _releaseHandler: function _releaseHandler() {
    this.finishLoading();
    this._loadingIndicator(true);
  },
  _optionChanged: function _optionChanged(args) {
    switch (args.name) {
      case 'onPullDown':
      case 'onReachBottom':
        this._createActions();
        break;
      case 'pullingDownText':
      case 'pulledDownText':
      case 'refreshingText':
      case 'refreshStrategy':
        this._invalidate();
        break;
      case 'reachBottomText':
        this._updateReachBottomText();
        break;
      default:
        this.callBase(args);
    }
  },
  content: function content() {
    return (0, _element.getPublicElement)(this._$content.children().eq(1));
  },
  release: function release(preventReachBottom) {
    if (preventReachBottom !== undefined) {
      this.toggleLoading(!preventReachBottom);
    }
    return this._strategy.release();
  },
  /**
  * @name dxScrollView.toggleLoading
  * @publicName toggleLoading(showOrHide)
  * @param1 showOrHide:boolean
  * @hidden
  */
  toggleLoading: function toggleLoading(showOrHide) {
    this._reachBottomEnable(showOrHide);
  },
  refresh: function refresh() {
    if (!this.hasActionSubscription('onPullDown')) {
      return;
    }
    this._strategy.pendingRelease();
    this._pullDownLoading();
  },
  startLoading: function startLoading() {
    if (this._loadingIndicator() && this.$element().is(':visible')) {
      this._loadPanel.show();
    }
    this._lock();
  },
  finishLoading: function finishLoading() {
    this._loadPanel.hide();
    this._unlock();
  },
  _dispose: function _dispose() {
    this._strategy.dispose();
    this.callBase();
    if (this._loadPanel) {
      this._loadPanel.$element().remove();
    }
  }
});
(0, _component_registrator.default)('dxScrollView', ScrollView);
var _default = ScrollView;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 27765:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _translator = __webpack_require__(31648);
var _uiScrollable = _interopRequireDefault(__webpack_require__(78831));
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _iterator = __webpack_require__(95479);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = 'dx-scrollview-pull-down-loading';
var SCROLLVIEW_PULLDOWN_READY_CLASS = 'dx-scrollview-pull-down-ready';
var SCROLLVIEW_PULLDOWN_IMAGE_CLASS = 'dx-scrollview-pull-down-image';
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
var SCROLLVIEW_PULLDOWN_TEXT_CLASS = 'dx-scrollview-pull-down-text';
var SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = 'dx-scrollview-pull-down-text-visible';
var STATE_RELEASED = 0;
var STATE_READY = 1;
var STATE_REFRESHING = 2;
var STATE_LOADING = 3;
var PULLDOWN_RELEASE_TIME = 400;
var PullDownNativeScrollViewStrategy = _uiScrollable.default.inherit({
  _init: function _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$refreshingText = scrollView._$refreshingText;
    this._$scrollViewContent = (0, _renderer.default)(scrollView.content());
    this._$container = (0, _renderer.default)(scrollView.container());
    this._initCallbacks();
  },
  _initCallbacks: function _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  render: function render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown: function _renderPullDown() {
    var $image = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
    var $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
    var $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    var $text = this._$pullDownText = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
    this._$pullingDownText = (0, _renderer.default)('<div>').text(this.option('pullingDownText')).appendTo($text);
    this._$pulledDownText = (0, _renderer.default)('<div>').text(this.option('pulledDownText')).appendTo($text);
    this._$refreshingText = (0, _renderer.default)('<div>').text(this.option('refreshingText')).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  _releaseState: function _releaseState() {
    this._state = STATE_RELEASED;
    this._refreshPullDownText();
  },
  _refreshPullDownText: function _refreshPullDownText() {
    var that = this;
    var pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: STATE_RELEASED
    }, {
      element: this._$pulledDownText,
      visibleState: STATE_READY
    }, {
      element: this._$refreshingText,
      visibleState: STATE_REFRESHING
    }];
    (0, _iterator.each)(pullDownTextItems, function (_, item) {
      var action = that._state === item.visibleState ? 'addClass' : 'removeClass';
      item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS);
    });
  },
  update: function update() {
    this.callBase();
    this._setTopPocketOffset();
  },
  _updateDimensions: function _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    var contentEl = this._$scrollViewContent.get(0);
    var containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections: function _allowedDirections() {
    var allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  _setTopPocketOffset: function _setTopPocketOffset() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  },
  handleEnd: function handleEnd() {
    this.callBase();
    this._complete();
  },
  handleStop: function handleStop() {
    this.callBase();
    this._complete();
  },
  _complete: function _complete() {
    if (this._state === STATE_READY) {
      this._setPullDownOffset(this._topPocketSize);
      clearTimeout(this._pullDownRefreshTimeout);
      this._pullDownRefreshTimeout = setTimeout(function () {
        this._pullDownRefreshing();
      }.bind(this), 400);
    }
  },
  _setPullDownOffset: function _setPullDownOffset(offset) {
    (0, _translator.move)(this._$topPocket, {
      top: offset
    });
    (0, _translator.move)(this._$scrollViewContent, {
      top: offset
    });
  },
  handleScroll: function handleScroll(e) {
    this.callBase(e);

    // TODO: replace with disabled check
    if (this._state === STATE_REFRESHING) {
      return;
    }
    var currentLocation = this.location().top;
    var scrollDelta = (this._location || 0) - currentLocation;
    this._location = currentLocation;
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isPullDown: function _isPullDown() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  },
  _isReachBottom: function _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom: function _reachBottom() {
    if (this._state === STATE_LOADING) {
      return;
    }
    this._state = STATE_LOADING;
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady: function _pullDownReady() {
    if (this._state === STATE_READY) {
      return;
    }
    this._state = STATE_READY;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
  },
  _stateReleased: function _stateReleased() {
    if (this._state === STATE_RELEASED) {
      return;
    }
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._releaseState();
  },
  _pullDownRefreshing: function _pullDownRefreshing() {
    if (this._state === STATE_REFRESHING) {
      return;
    }
    this._state = STATE_REFRESHING;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  pullDownEnable: function pullDownEnable(enabled) {
    if (enabled) {
      this._updateDimensions();
      this._setTopPocketOffset();
    }
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable: function reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease: function pendingRelease() {
    this._state = STATE_READY;
  },
  release: function release() {
    var deferred = new _deferred.Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    if (this._state === STATE_LOADING) {
      this._state = STATE_RELEASED;
    }
    this._releaseTimeout = setTimeout(function () {
      this._setPullDownOffset(0);
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }.bind(this), PULLDOWN_RELEASE_TIME);
    return deferred.promise();
  },
  dispose: function dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var _default = PullDownNativeScrollViewStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 90778:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _translator = __webpack_require__(31648);
var _index = __webpack_require__(39611);
var _uiScrollable = _interopRequireDefault(__webpack_require__(78831));
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = 'dx-scrollview-pull-down-loading';
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = 'dx-scrollview-pull-down-refreshing';
var PULLDOWN_ICON_CLASS = 'dx-icon-pulldown';
var STATE_RELEASED = 0;
var STATE_READY = 1;
var STATE_REFRESHING = 2;
var STATE_TOUCHED = 4;
var STATE_PULLED = 5;
var SwipeDownNativeScrollViewStrategy = _uiScrollable.default.inherit({
  _init: function _init(scrollView) {
    this.callBase(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$scrollViewContent = (0, _renderer.default)(scrollView.content());
    this._$container = (0, _renderer.default)(scrollView.container());
    this._initCallbacks();
    this._location = 0;
  },
  _initCallbacks: function _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  render: function render() {
    this.callBase();
    this._renderPullDown();
    this._releaseState();
  },
  _renderPullDown: function _renderPullDown() {
    var $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
    var $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    this._$icon = (0, _renderer.default)('<div>').addClass(PULLDOWN_ICON_CLASS);
    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
  },
  _releaseState: function _releaseState() {
    this._state = STATE_RELEASED;
    this._releasePullDown();
    this._updateDimensions();
  },
  _releasePullDown: function _releasePullDown() {
    this._$pullDown.css({
      opacity: 0
    });
  },
  _updateDimensions: function _updateDimensions() {
    this.callBase();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    var contentEl = this._$scrollViewContent.get(0);
    var containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  },
  _allowedDirections: function _allowedDirections() {
    var allowedDirections = this.callBase();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  },
  handleInit: function handleInit(e) {
    this.callBase(e);
    if (this._state === STATE_RELEASED && this._location === 0) {
      this._startClientY = (0, _index.eventData)(e.originalEvent).y;
      this._state = STATE_TOUCHED;
    }
  },
  handleMove: function handleMove(e) {
    this.callBase(e);
    this._deltaY = (0, _index.eventData)(e.originalEvent).y - this._startClientY;
    if (this._state === STATE_TOUCHED) {
      if (this._pullDownEnabled && this._deltaY > 0) {
        this._state = STATE_PULLED;
      } else {
        this._complete();
      }
    }
    if (this._state === STATE_PULLED) {
      e.preventDefault();
      this._movePullDown();
    }
  },
  _movePullDown: function _movePullDown() {
    var pullDownHeight = this._getPullDownHeight();
    var top = Math.min(pullDownHeight * 3, this._deltaY + this._getPullDownStartPosition());
    var angle = 180 * top / pullDownHeight / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS, top < pullDownHeight);
    (0, _translator.move)(this._$pullDown, {
      top: top
    });
    this._$icon.css({
      transform: 'rotate(' + angle + 'deg)'
    });
  },
  _isPullDown: function _isPullDown() {
    return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  },
  _getPullDownHeight: function _getPullDownHeight() {
    return Math.round((0, _size.getOuterHeight)(this._$element) * 0.05);
  },
  _getPullDownStartPosition: function _getPullDownStartPosition() {
    return -Math.round((0, _size.getOuterHeight)(this._$pullDown) * 1.5);
  },
  handleEnd: function handleEnd() {
    if (this._isPullDown()) {
      this._pullDownRefreshing();
    }
    this._complete();
  },
  handleStop: function handleStop() {
    this._complete();
  },
  _complete: function _complete() {
    if (this._state === STATE_TOUCHED || this._state === STATE_PULLED) {
      this._releaseState();
    }
  },
  handleScroll: function handleScroll(e) {
    this.callBase(e);

    // TODO: replace with disabled check
    if (this._state === STATE_REFRESHING) {
      return;
    }
    var currentLocation = this.location().top;
    var scrollDelta = this._location - currentLocation;
    this._location = currentLocation;
    if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  },
  _isReachBottom: function _isReachBottom() {
    return this._reachBottomEnabled && Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  },
  _reachBottom: function _reachBottom() {
    this.reachBottomCallbacks.fire();
  },
  _stateReleased: function _stateReleased() {
    if (this._state === STATE_RELEASED) {
      return;
    }
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
    this._releaseState();
  },
  _pullDownRefreshing: function _pullDownRefreshing() {
    this._state = STATE_REFRESHING;
    this._pullDownRefreshHandler();
  },
  _pullDownRefreshHandler: function _pullDownRefreshHandler() {
    this._refreshPullDown();
    this.pullDownCallbacks.fire();
  },
  _refreshPullDown: function _refreshPullDown() {
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
    (0, _translator.move)(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  },
  pullDownEnable: function pullDownEnable(enabled) {
    this._$topPocket.toggle(enabled);
    this._pullDownEnabled = enabled;
  },
  reachBottomEnable: function reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  },
  pendingRelease: function pendingRelease() {
    this._state = STATE_READY;
  },
  release: function release() {
    var deferred = new _deferred.Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    this._releaseTimeout = setTimeout(function () {
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }.bind(this), 800);
    return deferred.promise();
  },
  dispose: function dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    this.callBase();
  }
});
var _default = SwipeDownNativeScrollViewStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 91616:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
var _iterator = __webpack_require__(95479);
var _common = __webpack_require__(20576);
var _extend = __webpack_require__(13306);
var _uiScrollable = __webpack_require__(54142);
var _load_indicator = _interopRequireDefault(__webpack_require__(2492));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var math = Math;
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = 'dx-scrollview-pull-down-loading';
var SCROLLVIEW_PULLDOWN_READY_CLASS = 'dx-scrollview-pull-down-ready';
var SCROLLVIEW_PULLDOWN_IMAGE_CLASS = 'dx-scrollview-pull-down-image';
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = 'dx-scrollview-pull-down-indicator';
var SCROLLVIEW_PULLDOWN_TEXT_CLASS = 'dx-scrollview-pull-down-text';
var SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = 'dx-scrollview-pull-down-text-visible';
var STATE_RELEASED = 0;
var STATE_READY = 1;
var STATE_REFRESHING = 2;
var STATE_LOADING = 3;
var ScrollViewScroller = _uiScrollable.Scroller.inherit({
  ctor: function ctor() {
    this._topPocketSize = 0;
    this._bottomPocketSize = 0;
    this.callBase.apply(this, arguments);
    this._initCallbacks();
    this._releaseState();
  },
  _releaseState: function _releaseState() {
    this._state = STATE_RELEASED;
    this._refreshPullDownText();
  },
  _refreshPullDownText: function _refreshPullDownText() {
    var that = this;
    var pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: STATE_RELEASED
    }, {
      element: this._$pulledDownText,
      visibleState: STATE_READY
    }, {
      element: this._$refreshingText,
      visibleState: STATE_REFRESHING
    }];
    (0, _iterator.each)(pullDownTextItems, function (_, item) {
      var action = that._state === item.visibleState ? 'addClass' : 'removeClass';
      item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS);
    });
  },
  _initCallbacks: function _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  _updateBounds: function _updateBounds() {
    var considerPockets = this._direction !== 'horizontal';
    if (considerPockets) {
      this._topPocketSize = this._$topPocket.get(0).clientHeight;
      this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
      var containerEl = this._$container.get(0);
      var contentEl = this._$content.get(0);
      this._bottomBoundary = Math.max(contentEl.clientHeight - this._bottomPocketSize - containerEl.clientHeight, 0);
    }
    this.callBase();
  },
  _updateScrollbar: function _updateScrollbar() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  },
  _moveContent: function _moveContent() {
    this.callBase();
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (this._isReachBottom()) {
      this._reachBottomReady();
    } else if (this._state !== STATE_RELEASED) {
      this._stateReleased();
    }
  },
  _moveScrollbar: function _moveScrollbar() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  },
  _isPullDown: function _isPullDown() {
    return this._pullDownEnabled && this._location >= 0;
  },
  _isReachBottom: function _isReachBottom() {
    var containerEl = this._$container.get(0);
    return this._reachBottomEnabled && Math.round(this._bottomBoundary - Math.ceil(containerEl.scrollTop)) <= 1;
  },
  _scrollComplete: function _scrollComplete() {
    if (this._inBounds() && this._state === STATE_READY) {
      this._pullDownRefreshing();
    } else if (this._inBounds() && this._state === STATE_LOADING) {
      this._reachBottomLoading();
    } else {
      this.callBase();
    }
  },
  _reachBottomReady: function _reachBottomReady() {
    if (this._state === STATE_LOADING) {
      return;
    }
    this._state = STATE_LOADING;
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset: function _getMaxOffset() {
    return -this._topPocketSize;
  },
  _getMinOffset: function _getMinOffset() {
    return math.min(this.callBase(), -this._topPocketSize);
  },
  _reachBottomLoading: function _reachBottomLoading() {
    this.reachBottomCallbacks.fire();
  },
  _pullDownReady: function _pullDownReady() {
    if (this._state === STATE_READY) {
      return;
    }
    this._state = STATE_READY;
    this._maxOffset = 0;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
  },
  _stateReleased: function _stateReleased() {
    if (this._state === STATE_RELEASED) {
      return;
    }
    this._releaseState();
    this._updateBounds();
    this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this.releaseCallbacks.fire();
  },
  _pullDownRefreshing: function _pullDownRefreshing() {
    if (this._state === STATE_REFRESHING) {
      return;
    }
    this._state = STATE_REFRESHING;
    this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  },
  _releaseHandler: function _releaseHandler() {
    if (this._state === STATE_RELEASED) {
      this._moveToBounds();
    }
    this._update();
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this._releaseTask = (0, _common.executeAsync)(this._release.bind(this));
    return this._releaseTask.promise;
  },
  _release: function _release() {
    this._stateReleased();
    this._scrollComplete();
  },
  _reachBottomEnablingHandler: function _reachBottomEnablingHandler(enabled) {
    if (this._reachBottomEnabled === enabled) {
      return;
    }
    this._reachBottomEnabled = enabled;
    this._updateBounds();
  },
  _pullDownEnablingHandler: function _pullDownEnablingHandler(enabled) {
    if (this._pullDownEnabled === enabled) {
      return;
    }
    this._pullDownEnabled = enabled;
    this._considerTopPocketChange();
    this._updateHandler();
  },
  _considerTopPocketChange: function _considerTopPocketChange() {
    this._location -= (0, _size.getHeight)(this._$topPocket) || -this._topPocketSize;
    this._maxOffset = 0;
    this._move();
  },
  _pendingReleaseHandler: function _pendingReleaseHandler() {
    this._state = STATE_READY;
  },
  dispose: function dispose() {
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this.callBase();
  }
});
var SimulatedScrollViewStrategy = _uiScrollable.SimulatedStrategy.inherit({
  _init: function _init(scrollView) {
    this.callBase(scrollView);
    this._$pullDown = scrollView._$pullDown;
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._initCallbacks();
  },
  _initCallbacks: function _initCallbacks() {
    this.pullDownCallbacks = (0, _callbacks.default)();
    this.releaseCallbacks = (0, _callbacks.default)();
    this.reachBottomCallbacks = (0, _callbacks.default)();
  },
  render: function render() {
    this._renderPullDown();
    this.callBase();
  },
  _renderPullDown: function _renderPullDown() {
    var $image = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
    var $loadContainer = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
    var $loadIndicator = new _load_indicator.default((0, _renderer.default)('<div>')).$element();
    var $text = this._$pullDownText = (0, _renderer.default)('<div>').addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
    this._$pullingDownText = (0, _renderer.default)('<div>').text(this.option('pullingDownText')).appendTo($text);
    this._$pulledDownText = (0, _renderer.default)('<div>').text(this.option('pulledDownText')).appendTo($text);
    this._$refreshingText = (0, _renderer.default)('<div>').text(this.option('refreshingText')).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  },
  pullDownEnable: function pullDownEnable(enabled) {
    this._eventHandler('pullDownEnabling', enabled);
  },
  reachBottomEnable: function reachBottomEnable(enabled) {
    this._eventHandler('reachBottomEnabling', enabled);
  },
  _createScroller: function _createScroller(direction) {
    var that = this;
    var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
    scroller.pullDownCallbacks.add(function () {
      that.pullDownCallbacks.fire();
    });
    scroller.releaseCallbacks.add(function () {
      that.releaseCallbacks.fire();
    });
    scroller.reachBottomCallbacks.add(function () {
      that.reachBottomCallbacks.fire();
    });
  },
  _scrollerOptions: function _scrollerOptions(direction) {
    return (0, _extend.extend)(this.callBase(direction), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  },
  pendingRelease: function pendingRelease() {
    this._eventHandler('pendingRelease');
  },
  release: function release() {
    return this._eventHandler('release').done(this._updateAction);
  },
  location: function location() {
    var location = this.callBase();
    location.top += (0, _size.getHeight)(this._$topPocket);
    return location;
  },
  dispose: function dispose() {
    (0, _iterator.each)(this._scrollers, function () {
      this.dispose();
    });
    this.callBase();
  }
});
var _default = SimulatedScrollViewStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.deviceDependentOptions = void 0;
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _support = __webpack_require__(60137);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var deviceDependentOptions = function deviceDependentOptions() {
  return [{
    device: function device() {
      return !_support.nativeScrolling;
    },
    options: {
      useNative: false
    }
  }, {
    device: function device(_device) {
      return !_devices.default.isSimulator() && _devices.default.real().deviceType === 'desktop' && _device.platform === 'generic';
    },
    options: {
      bounceEnabled: false,
      scrollByThumb: true,
      scrollByContent: _support.touch,
      showScrollbar: 'onHover'
    }
  }];
};
exports.deviceDependentOptions = deviceDependentOptions;

/***/ }),

/***/ 41183:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _uiScrollable = _interopRequireDefault(__webpack_require__(58788));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _uiScrollable.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 78831:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _ui = _interopRequireDefault(__webpack_require__(89043));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SCROLLABLE_NATIVE = 'dxNativeScrollable';
var SCROLLABLE_NATIVE_CLASS = 'dx-scrollable-native';
var SCROLLABLE_SCROLLBAR_SIMULATED = 'dx-scrollable-scrollbar-simulated';
var SCROLLABLE_SCROLLBARS_HIDDEN = 'dx-scrollable-scrollbars-hidden';
var VERTICAL = 'vertical';
var HORIZONTAL = 'horizontal';
var HIDE_SCROLLBAR_TIMEOUT = 500;
var NativeStrategy = _class.default.inherit({
  ctor: function ctor(scrollable) {
    this._init(scrollable);
  },
  _init: function _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = (0, _renderer.default)(scrollable.container());
    this._$content = scrollable.$content();
    this._direction = scrollable.option('direction');
    this._useSimulatedScrollbar = scrollable.option('useSimulatedScrollbar');
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
    this._isRtlNativeStrategy = scrollable._isRtlNativeStrategy.bind(scrollable);
  },
  render: function render() {
    var device = _devices.default.real();
    var deviceType = device.platform;
    this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + '-' + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._isScrollbarVisible());
    if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
      this._renderScrollbars();
    }
  },
  updateRtlPosition: function updateRtlPosition(isFirstRender) {
    if (isFirstRender && this.option('rtlEnabled')) {
      if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
        this._moveScrollbars();
      }
    }
  },
  _renderScrollbars: function _renderScrollbars() {
    this._scrollbars = {};
    this._hideScrollbarTimeout = 0;
    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
    this._renderScrollbar(VERTICAL);
    this._renderScrollbar(HORIZONTAL);
  },
  _renderScrollbar: function _renderScrollbar(direction) {
    if (!this._isDirection(direction)) {
      return;
    }
    this._scrollbars[direction] = new _ui.default((0, _renderer.default)('<div>').appendTo(this._$element), {
      direction: direction,
      expandable: this._component.option('scrollByThumb')
    });
  },
  handleInit: _common.noop,
  handleStart: _common.noop,
  handleMove: function handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      return;
    }
    if (this._allowedDirection()) {
      e.originalEvent.isScrollingEvent = true;
    }
  },
  handleEnd: _common.noop,
  handleCancel: _common.noop,
  handleStop: _common.noop,
  _eachScrollbar: function _eachScrollbar(callback) {
    callback = callback.bind(this);
    (0, _iterator.each)(this._scrollbars || {}, function (direction, scrollbar) {
      callback(scrollbar, direction);
    });
  },
  createActions: function createActions() {
    this._scrollAction = this._createActionByOption('onScroll');
    this._updateAction = this._createActionByOption('onUpdated');
  },
  _createActionArgs: function _createActionArgs() {
    var _this$location = this.location(),
      left = _this$location.left,
      top = _this$location.top;
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-left) : this._isReachedLeft(left),
      reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
      reachedTop: this._isDirection(VERTICAL) ? Math.round(top) >= 0 : undefined,
      reachedBottom: this._isDirection(VERTICAL) ? Math.round(Math.abs(top) - this._getMaxOffset().top) >= 0 : undefined
    };
  },
  _getScrollOffset: function _getScrollOffset() {
    var _this$location2 = this.location(),
      top = _this$location2.top,
      left = _this$location2.left;
    return {
      top: -top,
      left: this._normalizeOffsetLeft(-left)
    };
  },
  _normalizeOffsetLeft(scrollLeft) {
    if (this._isRtlNativeStrategy()) {
      return this._getMaxOffset().left + scrollLeft;
    }
    return scrollLeft;
  },
  _isReachedLeft: function _isReachedLeft(left) {
    return this._isDirection(HORIZONTAL) ? Math.round(left) >= 0 : undefined;
  },
  _isReachedRight: function _isReachedRight(left) {
    return this._isDirection(HORIZONTAL) ? Math.round(Math.abs(left) - this._getMaxOffset().left) >= 0 : undefined;
  },
  _isScrollbarVisible: function _isScrollbarVisible() {
    var _this$option = this.option(),
      showScrollbar = _this$option.showScrollbar;
    return showScrollbar !== 'never' && showScrollbar !== false;
  },
  handleScroll: function handleScroll(e) {
    this._eventForUserAction = e;
    this._moveScrollbars();
    this._scrollAction(this._createActionArgs());
  },
  _moveScrollbars: function _moveScrollbars() {
    var _this$_getScrollOffse = this._getScrollOffset(),
      top = _this$_getScrollOffse.top,
      left = _this$_getScrollOffse.left;
    this._eachScrollbar(function (scrollbar) {
      scrollbar.moveTo({
        top: -top,
        left: -left
      });
      scrollbar.option('visible', true);
    });
    this._hideScrollbars();
  },
  _hideScrollbars: function _hideScrollbars() {
    clearTimeout(this._hideScrollbarTimeout);
    this._hideScrollbarTimeout = setTimeout(function () {
      this._eachScrollbar(function (scrollbar) {
        scrollbar.option('visible', false);
      });
    }.bind(this), HIDE_SCROLLBAR_TIMEOUT);
  },
  location: function location() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  },
  disabledChanged: _common.noop,
  update: function update() {
    this._update();
    this._updateAction(this._createActionArgs());
  },
  _update: function _update() {
    this._updateDimensions();
    this._updateScrollbars();
  },
  _updateDimensions: function _updateDimensions() {
    this._containerSize = {
      height: (0, _size.getHeight)(this._$container),
      width: (0, _size.getWidth)(this._$container)
    };
    this._componentContentSize = {
      height: (0, _size.getHeight)(this._component.$content()),
      width: (0, _size.getWidth)(this._component.$content())
    };
    this._contentSize = {
      height: (0, _size.getHeight)(this._$content),
      width: (0, _size.getWidth)(this._$content)
    };
  },
  _updateScrollbars: function _updateScrollbars() {
    this._eachScrollbar(function (scrollbar, direction) {
      var dimension = direction === VERTICAL ? 'height' : 'width';
      scrollbar.option({
        containerSize: this._containerSize[dimension],
        contentSize: this._componentContentSize[dimension]
      });
      scrollbar.update();
    });
  },
  _allowedDirections: function _allowedDirections() {
    return {
      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width
    };
  },
  dispose: function dispose() {
    var className = this._$element.get(0).className;
    var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + '\\S*', 'g');
    if (scrollableNativeRegexp.test(className)) {
      this._$element.removeClass(className.match(scrollableNativeRegexp).join(' '));
    }
    _events_engine.default.off(this._$element, '.' + SCROLLABLE_NATIVE);
    _events_engine.default.off(this._$container, '.' + SCROLLABLE_NATIVE);
    this._removeScrollbars();
    clearTimeout(this._hideScrollbarTimeout);
  },
  _removeScrollbars: function _removeScrollbars() {
    this._eachScrollbar(function (scrollbar) {
      scrollbar.$element().remove();
    });
  },
  scrollBy: function scrollBy(distance) {
    var location = this.location();
    this._$container.scrollTop(Math.round(-location.top - distance.top));
    this._$container.scrollLeft(Math.round(-location.left - distance.left));
  },
  validate: function validate(e) {
    if (this.option('disabled')) {
      return false;
    }
    if ((0, _index.isDxMouseWheelEvent)(e) && this._isScrolledInMaxDirection(e)) {
      return false;
    }
    return !!this._allowedDirection();
  },
  // TODO: rtl
  // TODO: horizontal scroll when shift is pressed
  _isScrolledInMaxDirection(e) {
    var container = this._$container.get(0);
    var result;
    if (e.delta > 0) {
      result = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
    } else {
      if (e.shiftKey) {
        result = container.scrollLeft >= this._getMaxOffset().left;
      } else {
        result = container.scrollTop >= this._getMaxOffset().top;
      }
    }
    return result;
  },
  getDirection: function getDirection() {
    return this._allowedDirection();
  }
});
var _default = NativeStrategy;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 58788:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _support = __webpack_require__(60137);
var _browser = _interopRequireDefault(__webpack_require__(47810));
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _element = __webpack_require__(6415);
var _window = __webpack_require__(58201);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _index = __webpack_require__(39611);
var _emitterGesture = _interopRequireDefault(__webpack_require__(37334));
var _uiScrollable = __webpack_require__(54142);
var _uiScrollable2 = _interopRequireDefault(__webpack_require__(78831));
var _uiScrollable3 = __webpack_require__(82205);
var _deferred = __webpack_require__(62754);
var _get_element_location_internal = __webpack_require__(60650);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SCROLLABLE = 'dxScrollable';
var SCROLLABLE_STRATEGY = 'dxScrollableStrategy';
var SCROLLABLE_CLASS = 'dx-scrollable';
var SCROLLABLE_DISABLED_CLASS = 'dx-scrollable-disabled';
var SCROLLABLE_CONTAINER_CLASS = 'dx-scrollable-container';
var SCROLLABLE_WRAPPER_CLASS = 'dx-scrollable-wrapper';
var SCROLLABLE_CONTENT_CLASS = 'dx-scrollable-content';
var VERTICAL = 'vertical';
var HORIZONTAL = 'horizontal';
var BOTH = 'both';
var Scrollable = _dom_component.default.inherit({
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      disabled: false,
      onScroll: null,
      direction: VERTICAL,
      showScrollbar: 'onScroll',
      useNative: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: false,
      useKeyboard: true,
      inertiaEnabled: true,
      updateManually: false
    });
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat((0, _uiScrollable3.deviceDependentOptions)(), [{
      device: function device() {
        return _support.nativeScrolling && _devices.default.real().platform === 'android' && !_browser.default.mozilla;
      },
      options: {
        useSimulatedScrollbar: true
      }
    }]);
  },
  _initOptions: function _initOptions(options) {
    this.callBase(options);
    if (!('useSimulatedScrollbar' in options)) {
      this._setUseSimulatedScrollbar();
    }
  },
  _setUseSimulatedScrollbar: function _setUseSimulatedScrollbar() {
    if (!this.initialOption('useSimulatedScrollbar')) {
      this.option('useSimulatedScrollbar', !this.option('useNative'));
    }
  },
  _init: function _init() {
    this.callBase();
    this._initScrollableMarkup();
    this._locked = false;
  },
  _visibilityChanged: function _visibilityChanged(visible) {
    if (visible) {
      this.update();
      this._updateRtlPosition();
      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
      delete this._savedScrollOffset;
    } else {
      this._savedScrollOffset = this.scrollOffset();
    }
  },
  _initScrollableMarkup: function _initScrollableMarkup() {
    var $element = this.$element().addClass(SCROLLABLE_CLASS);
    var $container = this._$container = (0, _renderer.default)('<div>').addClass(SCROLLABLE_CONTAINER_CLASS);
    var $wrapper = this._$wrapper = (0, _renderer.default)('<div>').addClass(SCROLLABLE_WRAPPER_CLASS);
    var $content = this._$content = (0, _renderer.default)('<div>').addClass(SCROLLABLE_CONTENT_CLASS);
    $content.append($element.contents()).appendTo($container);
    $container.appendTo($wrapper);
    $wrapper.appendTo($element);
  },
  _dimensionChanged: function _dimensionChanged() {
    this.update();
    this._updateRtlPosition();
  },
  _initMarkup: function _initMarkup() {
    this.callBase();
    this._renderDirection();
  },
  _render: function _render() {
    this._renderStrategy();
    this._attachEventHandlers();
    this._renderDisabledState();
    this._createActions();
    this.update();
    this.callBase();
    this._updateRtlPosition(true);
  },
  _updateRtlPosition: function _updateRtlPosition(needInitializeRtlConfig) {
    this._strategy.updateRtlPosition(needInitializeRtlConfig);
  },
  _getMaxOffset: function _getMaxOffset() {
    var _$$get = (0, _renderer.default)(this.container()).get(0),
      scrollWidth = _$$get.scrollWidth,
      clientWidth = _$$get.clientWidth,
      scrollHeight = _$$get.scrollHeight,
      clientHeight = _$$get.clientHeight;
    return {
      left: scrollWidth - clientWidth,
      top: scrollHeight - clientHeight
    };
  },
  _attachEventHandlers: function _attachEventHandlers() {
    var strategy = this._strategy;
    var initEventData = {
      getDirection: strategy.getDirection.bind(strategy),
      validate: this._validate.bind(this),
      isNative: this.option('useNative'),
      scrollTarget: this._$container
    };
    _events_engine.default.off(this._$wrapper, '.' + SCROLLABLE);
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.start, SCROLLABLE), strategy.handleStart.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.move, SCROLLABLE), strategy.handleMove.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.end, SCROLLABLE), strategy.handleEnd.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));
    _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_emitterGesture.default.stop, SCROLLABLE), strategy.handleStop.bind(strategy));
    _events_engine.default.off(this._$container, '.' + SCROLLABLE);
    _events_engine.default.on(this._$container, (0, _index.addNamespace)('scroll', SCROLLABLE), strategy.handleScroll.bind(strategy));
  },
  _validate: function _validate(e) {
    if (this._isLocked()) {
      return false;
    }
    this._updateIfNeed();
    return this._moveIsAllowed(e);
  },
  _moveIsAllowed(e) {
    return this._strategy.validate(e);
  },
  handleMove(e) {
    this._strategy.handleMove(e);
  },
  _prepareDirections(value) {
    this._strategy._prepareDirections(value);
  },
  _initHandler: function _initHandler() {
    var strategy = this._strategy;
    strategy.handleInit.apply(strategy, arguments);
  },
  _renderDisabledState: function _renderDisabledState() {
    this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option('disabled'));
    if (this.option('disabled')) {
      this._lock();
    } else {
      this._unlock();
    }
  },
  _renderDirection: function _renderDirection() {
    this.$element().removeClass('dx-scrollable-' + HORIZONTAL).removeClass('dx-scrollable-' + VERTICAL).removeClass('dx-scrollable-' + BOTH).addClass('dx-scrollable-' + this.option('direction'));
  },
  _renderStrategy: function _renderStrategy() {
    this._createStrategy();
    this._strategy.render();
    this.$element().data(SCROLLABLE_STRATEGY, this._strategy);
  },
  _createStrategy: function _createStrategy() {
    this._strategy = this.option('useNative') ? new _uiScrollable2.default(this) : new _uiScrollable.SimulatedStrategy(this);
  },
  _createActions: function _createActions() {
    this._strategy && this._strategy.createActions();
  },
  _clean: function _clean() {
    this._strategy && this._strategy.dispose();
  },
  _optionChanged: function _optionChanged(args) {
    switch (args.name) {
      case 'onStart':
      case 'onEnd':
      case 'onUpdated':
      case 'onScroll':
      case 'onBounce':
        this._createActions();
        break;
      case 'direction':
        this._resetInactiveDirection();
        this._invalidate();
        break;
      case 'useNative':
        this._setUseSimulatedScrollbar();
        this._invalidate();
        break;
      case 'inertiaEnabled':
      case 'scrollByThumb':
      case 'bounceEnabled':
      case 'useKeyboard':
      case 'showScrollbar':
      case 'useSimulatedScrollbar':
        this._invalidate();
        break;
      case 'disabled':
        this._renderDisabledState();
        this._strategy && this._strategy.disabledChanged();
        break;
      case 'updateManually':
      case 'scrollByContent':
        break;
      case 'width':
        this.callBase(args);
        this._updateRtlPosition();
        break;
      default:
        this.callBase(args);
    }
  },
  _resetInactiveDirection: function _resetInactiveDirection() {
    var inactiveProp = this._getInactiveProp();
    if (!inactiveProp || !(0, _window.hasWindow)()) {
      return;
    }
    var scrollOffset = this.scrollOffset();
    scrollOffset[inactiveProp] = 0;
    this.scrollTo(scrollOffset);
  },
  _getInactiveProp: function _getInactiveProp() {
    var direction = this.option('direction');
    if (direction === VERTICAL) {
      return 'left';
    }
    if (direction === HORIZONTAL) {
      return 'top';
    }
  },
  _location: function _location() {
    return this._strategy.location();
  },
  _normalizeLocation: function _normalizeLocation(location) {
    if ((0, _type.isPlainObject)(location)) {
      var left = (0, _common.ensureDefined)(location.left, location.x);
      var top = (0, _common.ensureDefined)(location.top, location.y);
      return {
        left: (0, _type.isDefined)(left) ? -left : undefined,
        top: (0, _type.isDefined)(top) ? -top : undefined
      };
    } else {
      var direction = this.option('direction');
      return {
        left: direction !== VERTICAL ? -location : undefined,
        top: direction !== HORIZONTAL ? -location : undefined
      };
    }
  },
  _isLocked: function _isLocked() {
    return this._locked;
  },
  _lock: function _lock() {
    this._locked = true;
  },
  _unlock: function _unlock() {
    if (!this.option('disabled')) {
      this._locked = false;
    }
  },
  _isDirection: function _isDirection(direction) {
    var current = this.option('direction');
    if (direction === VERTICAL) {
      return current !== HORIZONTAL;
    }
    if (direction === HORIZONTAL) {
      return current !== VERTICAL;
    }
    return current === direction;
  },
  _updateAllowedDirection: function _updateAllowedDirection() {
    var allowedDirections = this._strategy._allowedDirections();
    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
      this._allowedDirectionValue = BOTH;
    } else if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {
      this._allowedDirectionValue = HORIZONTAL;
    } else if (this._isDirection(VERTICAL) && allowedDirections.vertical) {
      this._allowedDirectionValue = VERTICAL;
    } else {
      this._allowedDirectionValue = null;
    }
  },
  _allowedDirection: function _allowedDirection() {
    return this._allowedDirectionValue;
  },
  $content: function $content() {
    return this._$content;
  },
  content: function content() {
    return (0, _element.getPublicElement)(this._$content);
  },
  container: function container() {
    return (0, _element.getPublicElement)(this._$container);
  },
  scrollOffset: function scrollOffset() {
    return this._strategy._getScrollOffset();
  },
  _isRtlNativeStrategy: function _isRtlNativeStrategy() {
    var _this$option = this.option(),
      useNative = _this$option.useNative,
      rtlEnabled = _this$option.rtlEnabled;
    return useNative && rtlEnabled;
  },
  scrollTop: function scrollTop() {
    return this.scrollOffset().top;
  },
  scrollLeft: function scrollLeft() {
    return this.scrollOffset().left;
  },
  clientHeight: function clientHeight() {
    return (0, _size.getHeight)(this._$container);
  },
  scrollHeight: function scrollHeight() {
    return (0, _size.getOuterHeight)(this.$content());
  },
  clientWidth: function clientWidth() {
    return (0, _size.getWidth)(this._$container);
  },
  scrollWidth: function scrollWidth() {
    return (0, _size.getOuterWidth)(this.$content());
  },
  update: function update() {
    if (!this._strategy) {
      return;
    }
    return (0, _deferred.when)(this._strategy.update()).done(function () {
      this._updateAllowedDirection();
    }.bind(this));
  },
  scrollBy: function scrollBy(distance) {
    distance = this._normalizeLocation(distance);
    if (!distance.top && !distance.left) {
      return;
    }
    this._updateIfNeed();
    this._strategy.scrollBy(distance);
  },
  scrollTo: function scrollTo(targetLocation) {
    targetLocation = this._normalizeLocation(targetLocation);
    this._updateIfNeed();
    var location = this._location();
    if (!this.option('useNative')) {
      targetLocation = this._strategy._applyScaleRatio(targetLocation);
      location = this._strategy._applyScaleRatio(location);
    }
    if (this._isRtlNativeStrategy()) {
      location.left = location.left - this._getMaxOffset().left;
    }
    var distance = this._normalizeLocation({
      left: location.left - (0, _common.ensureDefined)(targetLocation.left, location.left),
      top: location.top - (0, _common.ensureDefined)(targetLocation.top, location.top)
    });
    if (!distance.top && !distance.left) {
      return;
    }
    this._strategy.scrollBy(distance);
  },
  scrollToElement: function scrollToElement(element, offset) {
    var $element = (0, _renderer.default)(element);
    var elementInsideContent = this.$content().find(element).length;
    var elementIsInsideContent = $element.parents('.' + SCROLLABLE_CLASS).length - $element.parents('.' + SCROLLABLE_CONTENT_CLASS).length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    var scrollPosition = {
      top: 0,
      left: 0
    };
    var direction = this.option('direction');
    if (direction !== VERTICAL) {
      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL, offset);
    }
    if (direction !== HORIZONTAL) {
      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL, offset);
    }
    this.scrollTo(scrollPosition);
  },
  getScrollElementPosition: function getScrollElementPosition($element, direction, offset) {
    var scrollOffset = this.scrollOffset();
    return (0, _get_element_location_internal.getElementLocationInternal)($element.get(0), direction, (0, _renderer.default)(this.container()).get(0), scrollOffset, offset);
  },
  _updateIfNeed: function _updateIfNeed() {
    if (!this.option('updateManually')) {
      this.update();
    }
  },
  _useTemplates: function _useTemplates() {
    return false;
  },
  isRenovated: function isRenovated() {
    return !!Scrollable.IS_RENOVATED_WIDGET;
  }
});
(0, _component_registrator.default)(SCROLLABLE, Scrollable);
var _default = Scrollable;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 54142:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SimulatedStrategy = exports.Scroller = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _inflector = __webpack_require__(78008);
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _iterator = __webpack_require__(95479);
var _type = __webpack_require__(35922);
var _position = __webpack_require__(37518);
var _translator = __webpack_require__(31648);
var _class = _interopRequireDefault(__webpack_require__(38377));
var _animator = _interopRequireDefault(__webpack_require__(6866));
var _index = __webpack_require__(39611);
var _common = __webpack_require__(20576);
var _ui = _interopRequireDefault(__webpack_require__(89043));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SCROLLABLE_SIMULATED = 'dxSimulatedScrollable';
var SCROLLABLE_STRATEGY = 'dxScrollableStrategy';
var SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + 'Cursor';
var SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + 'Keyboard';
var SCROLLABLE_SIMULATED_CLASS = 'dx-scrollable-simulated';
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = 'dx-scrollable-scrollbars-alwaysvisible';
var SCROLLABLE_SCROLLBAR_CLASS = 'dx-scrollable-scrollbar';
var VERTICAL = 'vertical';
var HORIZONTAL = 'horizontal';
var ACCELERATION = 0.92;
var OUT_BOUNDS_ACCELERATION = 0.5;
var MIN_VELOCITY_LIMIT = 1;
var FRAME_DURATION = Math.round(1000 / 60);
var SCROLL_LINE_HEIGHT = 40;
var VALIDATE_WHEEL_TIMEOUT = 500;
var BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;
var BOUNCE_DURATION = 400;
var BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;
var BOUNCE_ACCELERATION_SUM = (1 - Math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
var KEY_CODES = {
  PAGE_UP: 'pageUp',
  PAGE_DOWN: 'pageDown',
  END: 'end',
  HOME: 'home',
  LEFT: 'leftArrow',
  UP: 'upArrow',
  RIGHT: 'rightArrow',
  DOWN: 'downArrow',
  TAB: 'tab'
};
var InertiaAnimator = _animator.default.inherit({
  ctor: function ctor(scroller) {
    this.callBase();
    this.scroller = scroller;
  },
  VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
  _isFinished: function _isFinished() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  },
  _step: function _step() {
    this.scroller._scrollStep(this.scroller._velocity);
    this.scroller._velocity *= this._acceleration();
  },
  _acceleration: function _acceleration() {
    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;
  },
  _complete: function _complete() {
    this.scroller._scrollComplete();
  }
});
var BounceAnimator = InertiaAnimator.inherit({
  VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
  _isFinished: function _isFinished() {
    return this.scroller._crossBoundOnNextStep() || this.callBase();
  },
  _acceleration: function _acceleration() {
    return ACCELERATION;
  },
  _complete: function _complete() {
    this.scroller._move(this.scroller._bounceLocation);
    this.callBase();
  }
});
var Scroller = _class.default.inherit({
  ctor: function ctor(options) {
    this._initOptions(options);
    this._initAnimators();
    this._initScrollbar();
  },
  _initOptions: function _initOptions(options) {
    var _this = this;
    this._location = 0;
    this._topReached = false;
    this._bottomReached = false;
    this._axis = options.direction === HORIZONTAL ? 'x' : 'y';
    this._prop = options.direction === HORIZONTAL ? 'left' : 'top';
    this._dimension = options.direction === HORIZONTAL ? 'width' : 'height';
    this._scrollProp = options.direction === HORIZONTAL ? 'scrollLeft' : 'scrollTop';
    (0, _iterator.each)(options, function (optionName, optionValue) {
      _this['_' + optionName] = optionValue;
    });
  },
  _initAnimators: function _initAnimators() {
    this._inertiaAnimator = new InertiaAnimator(this);
    this._bounceAnimator = new BounceAnimator(this);
  },
  _initScrollbar: function _initScrollbar() {
    this._scrollbar = new _ui.default((0, _renderer.default)('<div>').appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    });
    this._$scrollbar = this._scrollbar.$element();
  },
  _visibilityModeNormalize: function _visibilityModeNormalize(mode) {
    return mode === true ? 'onScroll' : mode === false ? 'never' : mode;
  },
  _scrollStep: function _scrollStep(delta) {
    var prevLocation = this._location;
    this._location += delta;
    this._suppressBounce();
    this._move();
    if (Math.abs(prevLocation - this._location) < 1) {
      return;
    }
    _events_engine.default.triggerHandler(this._$container, {
      type: 'scroll'
    });
  },
  _suppressBounce: function _suppressBounce() {
    if (this._bounceEnabled || this._inBounds(this._location)) {
      return;
    }
    this._velocity = 0;
    this._location = this._boundLocation();
  },
  _boundLocation: function _boundLocation(location) {
    location = location !== undefined ? location : this._location;
    return Math.max(Math.min(location, this._maxOffset), this._minOffset);
  },
  _move: function _move(location) {
    this._location = location !== undefined ? location * this._getScaleRatio() : this._location;
    this._moveContent();
    this._moveScrollbar();
  },
  _moveContent: function _moveContent() {
    var location = this._location;
    this._$container[this._scrollProp](-location / this._getScaleRatio());
    this._moveContentByTranslator(location);
  },
  _getScaleRatio: function _getScaleRatio() {
    if ((0, _window.hasWindow)() && !this._scaleRatio) {
      var element = this._$element.get(0);
      var realDimension = this._getRealDimension(element, this._dimension);
      var baseDimension = this._getBaseDimension(element, this._dimension);

      // NOTE: Ratio can be a fractional number, which leads to inaccuracy in the calculation of sizes.
      //       We should round it to hundredths in order to reduce the inaccuracy and prevent the unexpected appearance of a scrollbar.
      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
    }
    return this._scaleRatio || 1;
  },
  _getRealDimension: function _getRealDimension(element, dimension) {
    return Math.round((0, _position.getBoundingRect)(element)[dimension]);
  },
  _getBaseDimension: function _getBaseDimension(element, dimension) {
    var dimensionName = 'offset' + (0, _inflector.titleize)(dimension);
    return element[dimensionName];
  },
  _moveContentByTranslator: function _moveContentByTranslator(location) {
    var translateOffset;
    var minOffset = -this._maxScrollPropValue;
    if (location > 0) {
      translateOffset = location;
    } else if (location <= minOffset) {
      translateOffset = location - minOffset;
    } else {
      translateOffset = location % 1;
    }
    if (this._translateOffset === translateOffset) {
      return;
    }
    var targetLocation = {};
    targetLocation[this._prop] = translateOffset;
    this._translateOffset = translateOffset;
    if (translateOffset === 0) {
      (0, _translator.resetPosition)(this._$content);
      return;
    }
    (0, _translator.move)(this._$content, targetLocation);
  },
  _moveScrollbar: function _moveScrollbar() {
    this._scrollbar.moveTo(this._location);
  },
  _scrollComplete: function _scrollComplete() {
    if (this._inBounds()) {
      this._hideScrollbar();
      if (this._completeDeferred) {
        this._completeDeferred.resolve();
      }
    }
    this._scrollToBounds();
  },
  _scrollToBounds: function _scrollToBounds() {
    if (this._inBounds()) {
      return;
    }
    this._bounceAction();
    this._setupBounce();
    this._bounceAnimator.start();
  },
  _setupBounce: function _setupBounce() {
    var boundLocation = this._bounceLocation = this._boundLocation();
    var bounceDistance = boundLocation - this._location;
    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
  },
  _inBounds: function _inBounds(location) {
    location = location !== undefined ? location : this._location;
    return this._boundLocation(location) === location;
  },
  _crossBoundOnNextStep: function _crossBoundOnNextStep() {
    var location = this._location;
    var nextLocation = location + this._velocity;
    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
  },
  _initHandler: function _initHandler(e) {
    this._stopScrolling();
    this._prepareThumbScrolling(e);
  },
  _stopScrolling: (0, _common.deferRenderer)(function () {
    this._hideScrollbar();
    this._inertiaAnimator.stop();
    this._bounceAnimator.stop();
  }),
  _prepareThumbScrolling: function _prepareThumbScrolling(e) {
    if ((0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
      return;
    }
    var $target = (0, _renderer.default)(e.originalEvent.target);
    var scrollbarClicked = this._isScrollbar($target);
    if (scrollbarClicked) {
      this._moveToMouseLocation(e);
    }
    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
    if (this._thumbScrolling) {
      this._scrollbar.feedbackOn();
    }
  },
  _isThumbScrollingHandler: function _isThumbScrollingHandler($target) {
    return this._isThumb($target);
  },
  _moveToMouseLocation: function _moveToMouseLocation(e) {
    var mouseLocation = e['page' + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
    var location = this._location + mouseLocation / this._containerToContentRatio() - (0, _size.getHeight)(this._$container) / 2;
    this._scrollStep(-Math.round(location));
  },
  _startHandler: function _startHandler() {
    this._showScrollbar();
  },
  _moveHandler: function _moveHandler(delta) {
    if (this._crossThumbScrolling) {
      return;
    }
    if (this._thumbScrolling) {
      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
    }
    this._scrollBy(delta);
  },
  _scrollBy: function _scrollBy(delta) {
    delta = delta[this._axis];
    if (!this._inBounds()) {
      delta *= OUT_BOUNDS_ACCELERATION;
    }
    this._scrollStep(delta);
  },
  _scrollByHandler: function _scrollByHandler(delta) {
    this._scrollBy(delta);
    this._scrollComplete();
  },
  _containerToContentRatio: function _containerToContentRatio() {
    return this._scrollbar.containerToContentRatio();
  },
  _endHandler: function _endHandler(velocity) {
    this._completeDeferred = new _deferred.Deferred();
    this._velocity = velocity[this._axis];
    this._inertiaHandler();
    this._resetThumbScrolling();
    return this._completeDeferred.promise();
  },
  _inertiaHandler: function _inertiaHandler() {
    this._suppressInertia();
    this._inertiaAnimator.start();
  },
  _suppressInertia: function _suppressInertia() {
    if (!this._inertiaEnabled || this._thumbScrolling) {
      this._velocity = 0;
    }
  },
  _resetThumbScrolling: function _resetThumbScrolling() {
    this._thumbScrolling = false;
    this._crossThumbScrolling = false;
  },
  _stopHandler: function _stopHandler() {
    if (this._thumbScrolling) {
      this._scrollComplete();
    }
    this._resetThumbScrolling();
    this._scrollToBounds();
  },
  _disposeHandler: function _disposeHandler() {
    this._stopScrolling();
    this._$scrollbar.remove();
  },
  _updateHandler: function _updateHandler() {
    this._update();
    this._moveToBounds();
  },
  _update: function _update() {
    var _this2 = this;
    this._stopScrolling();
    return (0, _common.deferUpdate)(function () {
      _this2._resetScaleRatio();
      _this2._updateLocation();
      _this2._updateBounds();
      _this2._updateScrollbar();
      (0, _common.deferRender)(function () {
        _this2._moveScrollbar();
        _this2._scrollbar.update();
      });
    });
  },
  _resetScaleRatio: function _resetScaleRatio() {
    this._scaleRatio = null;
  },
  _updateLocation: function _updateLocation() {
    this._location = ((0, _translator.locate)(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  },
  _updateBounds: function _updateBounds() {
    this._maxOffset = this._getMaxOffset();
    this._minOffset = this._getMinOffset();
  },
  _getMaxOffset: function _getMaxOffset() {
    return 0;
  },
  _getMinOffset: function _getMinOffset() {
    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
    return -this._maxScrollPropValue;
  },
  _updateScrollbar: (0, _common.deferUpdater)(function () {
    var _this3 = this;
    var containerSize = this._containerSize();
    var contentSize = this._contentSize();

    // NOTE: Real container and content sizes can be a fractional number when scaling.
    //       Let's save sizes when scale = 100% to decide whether it is necessary to show
    //       the scrollbar based on by more precise numbers. We can do it because the container
    //       size to content size ratio should remain approximately the same at any zoom.
    var baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
    var baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
    (0, _common.deferRender)(function () {
      _this3._scrollbar.option({
        containerSize,
        contentSize,
        baseContainerSize,
        baseContentSize,
        scaleRatio: _this3._getScaleRatio()
      });
    });
  }),
  _moveToBounds: (0, _common.deferRenderer)((0, _common.deferUpdater)((0, _common.deferRenderer)(function () {
    var location = this._boundLocation();
    var locationChanged = location !== this._location;
    this._location = location;
    this._move();
    if (locationChanged) {
      this._scrollAction();
    }
  }))),
  _createActionsHandler: function _createActionsHandler(actions) {
    this._scrollAction = actions.scroll;
    this._bounceAction = actions.bounce;
  },
  _showScrollbar: function _showScrollbar() {
    this._scrollbar.option('visible', true);
  },
  _hideScrollbar: function _hideScrollbar() {
    this._scrollbar.option('visible', false);
  },
  _containerSize: function _containerSize() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  },
  _contentSize: function _contentSize() {
    var isOverflowHidden = this._$content.css('overflow' + this._axis.toUpperCase()) === 'hidden';
    var contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!isOverflowHidden) {
      var containerScrollSize = this._$content[0]['scroll' + (0, _inflector.titleize)(this._dimension)] * this._getScaleRatio();
      contentSize = Math.max(containerScrollSize, contentSize);
    }
    return contentSize;
  },
  _validateEvent: function _validateEvent(e) {
    var $target = (0, _renderer.default)(e.originalEvent.target);
    return this._isThumb($target) || this._isScrollbar($target);
  },
  _isThumb: function _isThumb($element) {
    return this._scrollByThumb && this._scrollbar.isThumb($element);
  },
  _isScrollbar: function _isScrollbar($element) {
    return this._scrollByThumb && $element && $element.is(this._$scrollbar);
  },
  _reachedMin: function _reachedMin() {
    return Math.round(this._location - this._minOffset) <= 0;
  },
  _reachedMax: function _reachedMax() {
    return Math.round(this._location - this._maxOffset) >= 0;
  },
  _cursorEnterHandler: function _cursorEnterHandler() {
    this._resetScaleRatio();
    this._updateScrollbar();
    this._scrollbar.cursorEnter();
  },
  _cursorLeaveHandler: function _cursorLeaveHandler() {
    this._scrollbar.cursorLeave();
  },
  dispose: _common.noop
});
exports.Scroller = Scroller;
var hoveredScrollable;
var activeScrollable;
var SimulatedStrategy = _class.default.inherit({
  ctor: function ctor(scrollable) {
    this._init(scrollable);
  },
  _init: function _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = (0, _renderer.default)(scrollable.container());
    this._$wrapper = scrollable._$wrapper;
    this._$content = scrollable.$content();
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
  },
  render: function render() {
    this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
    this._createScrollers();
    if (this.option('useKeyboard')) {
      this._$container.prop('tabIndex', 0);
    }
    this._attachKeyboardHandler();
    this._attachCursorHandlers();
  },
  _createScrollers: function _createScrollers() {
    this._scrollers = {};
    if (this._isDirection(HORIZONTAL)) {
      this._createScroller(HORIZONTAL);
    }
    if (this._isDirection(VERTICAL)) {
      this._createScroller(VERTICAL);
    }
    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, this.option('showScrollbar') === 'always');
  },
  _createScroller: function _createScroller(direction) {
    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
  },
  _scrollerOptions: function _scrollerOptions(direction) {
    return {
      direction: direction,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByThumb: this.option('scrollByThumb'),
      scrollbarVisible: this.option('showScrollbar'),
      bounceEnabled: this.option('bounceEnabled'),
      inertiaEnabled: this.option('inertiaEnabled'),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  },
  _applyScaleRatio: function _applyScaleRatio(targetLocation) {
    for (var direction in this._scrollers) {
      var prop = this._getPropByDirection(direction);
      if ((0, _type.isDefined)(targetLocation[prop])) {
        var scroller = this._scrollers[direction];
        targetLocation[prop] *= scroller._getScaleRatio();
      }
    }
    return targetLocation;
  },
  _isAnyThumbScrolling: function _isAnyThumbScrolling($target) {
    var result = false;
    this._eventHandler('isThumbScrolling', $target).done(function (isThumbScrollingVertical, isThumbScrollingHorizontal) {
      result = isThumbScrollingVertical || isThumbScrollingHorizontal;
    });
    return result;
  },
  handleInit: function handleInit(e) {
    this._suppressDirections(e);
    this._eventForUserAction = e;
    this._eventHandler('init', e);
  },
  _suppressDirections: function _suppressDirections(e) {
    if ((0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
      this._prepareDirections(true);
      return;
    }
    this._prepareDirections();
    this._eachScroller(function (scroller, direction) {
      var $target = (0, _renderer.default)(e.originalEvent.target);
      var isValid = scroller._validateEvent(e) || this.option('scrollByContent') && this._isContent($target);
      this._validDirections[direction] = isValid;
    });
  },
  _isContent: function _isContent($element) {
    return !!$element.closest(this._$element).length;
  },
  _prepareDirections: function _prepareDirections(value) {
    value = value || false;
    this._validDirections = {};
    this._validDirections[HORIZONTAL] = value;
    this._validDirections[VERTICAL] = value;
  },
  _eachScroller: function _eachScroller(callback) {
    callback = callback.bind(this);
    (0, _iterator.each)(this._scrollers, function (direction, scroller) {
      callback(scroller, direction);
    });
  },
  handleStart: function handleStart(e) {
    this._eventForUserAction = e;
    this._eventHandler('start').done(this._startAction);
  },
  _saveActive: function _saveActive() {
    activeScrollable = this;
  },
  _resetActive: function _resetActive() {
    if (activeScrollable === this) {
      activeScrollable = null;
    }
  },
  handleMove: function handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      this._resetActive();
      return;
    }
    this._saveActive();
    e.preventDefault && e.preventDefault();
    this._adjustDistance(e, e.delta);
    this._eventForUserAction = e;
    this._eventHandler('move', e.delta);
  },
  _adjustDistance: function _adjustDistance(e, distance) {
    distance.x *= this._validDirections[HORIZONTAL];
    distance.y *= this._validDirections[VERTICAL];
    var devicePixelRatio = this._tryGetDevicePixelRatio();
    if (devicePixelRatio && (0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
    }
  },
  _tryGetDevicePixelRatio: function _tryGetDevicePixelRatio() {
    if ((0, _window.hasWindow)()) {
      return (0, _window.getWindow)().devicePixelRatio;
    }
  },
  handleEnd: function handleEnd(e) {
    this._resetActive();
    this._refreshCursorState(e.originalEvent && e.originalEvent.target);
    this._adjustDistance(e, e.velocity);
    this._eventForUserAction = e;
    return this._eventHandler('end', e.velocity).done(this._endAction);
  },
  handleCancel: function handleCancel(e) {
    this._resetActive();
    this._eventForUserAction = e;
    return this._eventHandler('end', {
      x: 0,
      y: 0
    });
  },
  handleStop: function handleStop() {
    this._resetActive();
    this._eventHandler('stop');
  },
  handleScroll: function handleScroll() {
    this._updateRtlConfig();
    this._scrollAction();
  },
  _attachKeyboardHandler: function _attachKeyboardHandler() {
    _events_engine.default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD));
    if (!this.option('disabled') && this.option('useKeyboard')) {
      _events_engine.default.on(this._$element, (0, _index.addNamespace)('keydown', SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
    }
  },
  _keyDownHandler: function _keyDownHandler(e) {
    var _this4 = this;
    clearTimeout(this._updateHandlerTimeout);
    this._updateHandlerTimeout = setTimeout(function () {
      if ((0, _index.normalizeKeyName)(e) === KEY_CODES.TAB) {
        _this4._eachScroller(function (scroller) {
          scroller._updateHandler();
        });
      }
    });
    if (!this._$container.is(_dom_adapter.default.getActiveElement(this._$container.get(0)))) {
      return;
    }
    var handled = true;
    switch ((0, _index.normalizeKeyName)(e)) {
      case KEY_CODES.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case KEY_CODES.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case KEY_CODES.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case KEY_CODES.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case KEY_CODES.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case KEY_CODES.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case KEY_CODES.HOME:
        this._scrollToHome();
        break;
      case KEY_CODES.END:
        this._scrollToEnd();
        break;
      default:
        handled = false;
        break;
    }
    if (handled) {
      e.stopPropagation();
      e.preventDefault();
    }
  },
  _scrollByLine: function _scrollByLine(lines) {
    var devicePixelRatio = this._tryGetDevicePixelRatio();
    var scrollOffset = SCROLL_LINE_HEIGHT;
    if (devicePixelRatio) {
      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
    }
    this.scrollBy({
      top: (lines.y || 0) * -scrollOffset,
      left: (lines.x || 0) * -scrollOffset
    });
  },
  _scrollByPage: function _scrollByPage(page) {
    var prop = this._wheelProp();
    var dimension = this._dimensionByProp(prop);
    var distance = {};
    var getter = dimension === 'width' ? _size.getWidth : _size.getHeight;
    distance[prop] = page * -getter(this._$container);
    this.scrollBy(distance);
  },
  _dimensionByProp: function _dimensionByProp(prop) {
    return prop === 'left' ? 'width' : 'height';
  },
  _getPropByDirection: function _getPropByDirection(direction) {
    return direction === HORIZONTAL ? 'left' : 'top';
  },
  _scrollToHome: function _scrollToHome() {
    var prop = this._wheelProp();
    var distance = {};
    distance[prop] = 0;
    this._component.scrollTo(distance);
  },
  _scrollToEnd: function _scrollToEnd() {
    var prop = this._wheelProp();
    var dimension = this._dimensionByProp(prop);
    var distance = {};
    var getter = dimension === 'width' ? _size.getWidth : _size.getHeight;
    distance[prop] = getter(this._$content) - getter(this._$container);
    this._component.scrollTo(distance);
  },
  createActions: function createActions() {
    this._startAction = this._createActionHandler('onStart');
    this._endAction = this._createActionHandler('onEnd');
    this._updateAction = this._createActionHandler('onUpdated');
    this._createScrollerActions();
  },
  _createScrollerActions: function _createScrollerActions() {
    this._scrollAction = this._createActionHandler('onScroll');
    this._bounceAction = this._createActionHandler('onBounce');
    this._eventHandler('createActions', {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  },
  _createActionHandler: function _createActionHandler(optionName) {
    var _arguments = arguments,
      _this5 = this;
    var actionHandler = this._createActionByOption(optionName);
    return function () {
      actionHandler((0, _extend.extend)(_this5._createActionArgs(), _arguments));
    };
  },
  _createActionArgs: function _createActionArgs() {
    var _this$_scrollers = this._scrollers,
      scrollerX = _this$_scrollers.horizontal,
      scrollerY = _this$_scrollers.vertical;
    var offset = this._getScrollOffset();
    this._scrollOffset = {
      top: scrollerY && offset.top,
      left: scrollerX && offset.left
    };
    return {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: scrollerX && scrollerX._reachedMax(),
      reachedRight: scrollerX && scrollerX._reachedMin(),
      reachedTop: scrollerY && scrollerY._reachedMax(),
      reachedBottom: scrollerY && scrollerY._reachedMin()
    };
  },
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  },
  _eventHandler: function _eventHandler(eventName) {
    var args = [].slice.call(arguments).slice(1);
    var deferreds = (0, _iterator.map)(this._scrollers, function (scroller) {
      return scroller['_' + eventName + 'Handler'].apply(scroller, args);
    });
    return _deferred.when.apply(_renderer.default, deferreds).promise();
  },
  location: function location() {
    var location = (0, _translator.locate)(this._$content);
    location.top -= this._$container.scrollTop();
    location.left -= this._$container.scrollLeft();
    return location;
  },
  disabledChanged: function disabledChanged() {
    this._attachCursorHandlers();
  },
  _attachCursorHandlers: function _attachCursorHandlers() {
    _events_engine.default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
    if (!this.option('disabled') && this._isHoverMode()) {
      _events_engine.default.on(this._$element, (0, _index.addNamespace)('mouseenter', SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
      _events_engine.default.on(this._$element, (0, _index.addNamespace)('mouseleave', SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
    }
  },
  _isHoverMode: function _isHoverMode() {
    return this.option('showScrollbar') === 'onHover';
  },
  _cursorEnterHandler: function _cursorEnterHandler(e) {
    e = e || {};
    e.originalEvent = e.originalEvent || {};
    if (activeScrollable || e.originalEvent._hoverHandled) {
      return;
    }
    if (hoveredScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    hoveredScrollable = this;
    this._eventHandler('cursorEnter');
    e.originalEvent._hoverHandled = true;
  },
  _cursorLeaveHandler: function _cursorLeaveHandler(e) {
    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
      return;
    }
    this._eventHandler('cursorLeave');
    hoveredScrollable = null;
    this._refreshCursorState(e && e.relatedTarget);
  },
  _refreshCursorState: function _refreshCursorState(target) {
    if (!this._isHoverMode() && (!target || activeScrollable)) {
      return;
    }
    var $target = (0, _renderer.default)(target);
    var $scrollable = $target.closest(".".concat(SCROLLABLE_SIMULATED_CLASS, ":not(.dx-state-disabled)"));
    var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    if (targetScrollable) {
      targetScrollable._cursorEnterHandler();
    }
  },
  update: function update() {
    var _this6 = this;
    var result = this._eventHandler('update').done(this._updateAction);
    return (0, _deferred.when)(result, (0, _common.deferUpdate)(function () {
      var allowedDirections = _this6._allowedDirections();
      (0, _common.deferRender)(function () {
        var touchDirection = allowedDirections.vertical ? 'pan-x' : '';
        touchDirection = allowedDirections.horizontal ? 'pan-y' : touchDirection;
        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? 'none' : touchDirection;
        _this6._$container.css('touchAction', touchDirection);
      });
      return (0, _deferred.when)().promise();
    }));
  },
  _allowedDirections: function _allowedDirections() {
    var bounceEnabled = this.option('bounceEnabled');
    var verticalScroller = this._scrollers[VERTICAL];
    var horizontalScroller = this._scrollers[HORIZONTAL];
    return {
      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
    };
  },
  _updateBounds: function _updateBounds() {
    this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds();
  },
  _isHorizontalAndRtlEnabled: function _isHorizontalAndRtlEnabled() {
    return this.option('rtlEnabled') && this.option('direction') !== VERTICAL;
  },
  updateRtlPosition: function updateRtlPosition(needInitializeRtlConfig) {
    if (needInitializeRtlConfig) {
      this._rtlConfig = {
        scrollRight: 0,
        clientWidth: this._$container.get(0).clientWidth,
        windowPixelRatio: this._getWindowDevicePixelRatio()
      };
    }
    this._updateBounds();
    if (this._isHorizontalAndRtlEnabled()) {
      var scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
      if (scrollLeft <= 0) {
        scrollLeft = 0;
        this._rtlConfig.scrollRight = this._getMaxOffset().left;
      }
      if (this._getScrollOffset().left !== scrollLeft) {
        this._rtlConfig.skipUpdating = true;
        this._component.scrollTo({
          left: scrollLeft
        });
        this._rtlConfig.skipUpdating = false;
      }
    }
  },
  _updateRtlConfig: function _updateRtlConfig() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      var _this$_$container$get = this._$container.get(0),
        clientWidth = _this$_$container$get.clientWidth,
        scrollLeft = _this$_$container$get.scrollLeft;
      var windowPixelRatio = this._getWindowDevicePixelRatio();
      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
      }
      this._rtlConfig.clientWidth = clientWidth;
      this._rtlConfig.windowPixelRatio = windowPixelRatio;
    }
  },
  _getWindowDevicePixelRatio: function _getWindowDevicePixelRatio() {
    return (0, _window.hasWindow)() ? (0, _window.getWindow)().devicePixelRatio : 1;
  },
  scrollBy: function scrollBy(distance) {
    var verticalScroller = this._scrollers[VERTICAL];
    var horizontalScroller = this._scrollers[HORIZONTAL];
    if (verticalScroller) {
      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
    }
    if (horizontalScroller) {
      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
    }
    this._prepareDirections(true);
    this._startAction();
    this._eventHandler('scrollBy', {
      x: distance.left,
      y: distance.top
    });
    this._endAction();
    this._updateRtlConfig();
  },
  validate: function validate(e) {
    if ((0, _index.isDxMouseWheelEvent)(e) && (0, _index.isCommandKeyPressed)(e)) {
      return false;
    }
    if (this.option('disabled')) {
      return false;
    }
    if (this.option('bounceEnabled')) {
      return true;
    }
    return (0, _index.isDxMouseWheelEvent)(e) ? this._validateWheel(e) : this._validateMove(e);
  },
  _validateWheel: function _validateWheel(e) {
    var _this7 = this;
    var scroller = this._scrollers[this._wheelDirection(e)];
    var reachedMin = scroller._reachedMin();
    var reachedMax = scroller._reachedMax();
    var contentGreaterThanContainer = !reachedMin || !reachedMax;
    var locatedNotAtBound = !reachedMin && !reachedMax;
    var scrollFromMin = reachedMin && e.delta > 0;
    var scrollFromMax = reachedMax && e.delta < 0;
    var validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
    validated = validated || this._validateWheelTimer !== undefined;
    if (validated) {
      clearTimeout(this._validateWheelTimer);
      this._validateWheelTimer = setTimeout(function () {
        _this7._validateWheelTimer = undefined;
      }, VALIDATE_WHEEL_TIMEOUT);
    }
    return validated;
  },
  _validateMove: function _validateMove(e) {
    if (!this.option('scrollByContent') && !(0, _renderer.default)(e.target).closest(".".concat(SCROLLABLE_SCROLLBAR_CLASS)).length) {
      return false;
    }
    return this._allowedDirection();
  },
  getDirection: function getDirection(e) {
    return (0, _index.isDxMouseWheelEvent)(e) ? this._wheelDirection(e) : this._allowedDirection();
  },
  _wheelProp: function _wheelProp() {
    return this._wheelDirection() === HORIZONTAL ? 'left' : 'top';
  },
  _wheelDirection: function _wheelDirection(e) {
    switch (this.option('direction')) {
      case HORIZONTAL:
        return HORIZONTAL;
      case VERTICAL:
        return VERTICAL;
      default:
        return e && e.shiftKey ? HORIZONTAL : VERTICAL;
    }
  },
  dispose: function dispose() {
    this._resetActive();
    if (hoveredScrollable === this) {
      hoveredScrollable = null;
    }
    this._eventHandler('dispose');
    this._detachEventHandlers();
    this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
    this._eventForUserAction = null;
    clearTimeout(this._validateWheelTimer);
    clearTimeout(this._updateHandlerTimeout);
  },
  _detachEventHandlers: function _detachEventHandlers() {
    _events_engine.default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
    _events_engine.default.off(this._$container, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD));
  }
});
exports.SimulatedStrategy = SimulatedStrategy;

/***/ }),

/***/ 89043:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _translator = __webpack_require__(31648);
var _ui = _interopRequireDefault(__webpack_require__(14390));
var _index = __webpack_require__(39611);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SCROLLBAR = 'dxScrollbar';
var SCROLLABLE_SCROLLBAR_CLASS = 'dx-scrollable-scrollbar';
var SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = "".concat(SCROLLABLE_SCROLLBAR_CLASS, "-active");
var SCROLLABLE_SCROLL_CLASS = 'dx-scrollable-scroll';
var SCROLLABLE_SCROLL_CONTENT_CLASS = 'dx-scrollable-scroll-content';
var HOVER_ENABLED_STATE = 'dx-scrollbar-hoverable';
var HORIZONTAL = 'horizontal';
var THUMB_MIN_SIZE = 15;
var SCROLLBAR_VISIBLE = {
  onScroll: 'onScroll',
  onHover: 'onHover',
  always: 'always',
  never: 'never'
};
var activeScrollbar = null;
var Scrollbar = _ui.default.inherit({
  _getDefaultOptions: function _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      direction: null,
      visible: false,
      activeStateEnabled: false,
      visibilityMode: SCROLLBAR_VISIBLE.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: true,
      scaleRatio: 1
    });
  },
  _init: function _init() {
    this.callBase();
    this._isHovered = false;
  },
  _initMarkup: function _initMarkup() {
    this._renderThumb();
    this.callBase();
  },
  _render: function _render() {
    this.callBase();
    this._renderDirection();
    this._update();
    this._attachPointerDownHandler();
    this.option('hoverStateEnabled', this._isHoverMode());
    this.$element().toggleClass(HOVER_ENABLED_STATE, this.option('hoverStateEnabled'));
  },
  _renderThumb: function _renderThumb() {
    this._$thumb = (0, _renderer.default)('<div>').addClass(SCROLLABLE_SCROLL_CLASS);
    (0, _renderer.default)('<div>').addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
    this.$element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb);
  },
  isThumb: function isThumb($element) {
    return !!this.$element().find($element).length;
  },
  _isHoverMode: function _isHoverMode() {
    var visibilityMode = this.option('visibilityMode');
    return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option('expandable');
  },
  _renderDirection: function _renderDirection() {
    var direction = this.option('direction');
    this.$element().addClass('dx-scrollbar-' + direction);
    this._dimension = direction === HORIZONTAL ? 'width' : 'height';
    this._prop = direction === HORIZONTAL ? 'left' : 'top';
  },
  _attachPointerDownHandler: function _attachPointerDownHandler() {
    _events_engine.default.on(this._$thumb, (0, _index.addNamespace)(_pointer.default.down, SCROLLBAR), this.feedbackOn.bind(this));
  },
  feedbackOn: function feedbackOn() {
    this.$element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
    activeScrollbar = this;
  },
  feedbackOff: function feedbackOff() {
    this.$element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
    activeScrollbar = null;
  },
  cursorEnter: function cursorEnter() {
    this._isHovered = true;
    if (this._needScrollbar()) {
      this.option('visible', true);
    }
  },
  cursorLeave: function cursorLeave() {
    this._isHovered = false;
    this.option('visible', false);
  },
  _renderDimensions: function _renderDimensions() {
    this._$thumb.css({
      width: this.option('width'),
      height: this.option('height')
    });
  },
  _toggleVisibility: function _toggleVisibility(visible) {
    if (this.option('visibilityMode') === SCROLLBAR_VISIBLE.onScroll) {
      // NOTE: need to relayout thumb and show it instantly
      this._$thumb.css('opacity');
    }
    visible = this._adjustVisibility(visible);
    this.option().visible = visible;
    this._$thumb.toggleClass('dx-state-invisible', !visible);
  },
  _adjustVisibility: function _adjustVisibility(visible) {
    if (this._baseContainerToContentRatio && !this._needScrollbar()) {
      return false;
    }
    switch (this.option('visibilityMode')) {
      case SCROLLBAR_VISIBLE.onScroll:
        break;
      case SCROLLBAR_VISIBLE.onHover:
        visible = visible || !!this._isHovered;
        break;
      case SCROLLBAR_VISIBLE.never:
        visible = false;
        break;
      case SCROLLBAR_VISIBLE.always:
        visible = true;
        break;
    }
    return visible;
  },
  moveTo: function moveTo(location) {
    if (this._isHidden()) {
      return;
    }
    if ((0, _type.isPlainObject)(location)) {
      location = location[this._prop] || 0;
    }
    var scrollBarLocation = {};
    scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
    (0, _translator.move)(this._$thumb, scrollBarLocation);
  },
  _calculateScrollBarPosition: function _calculateScrollBarPosition(location) {
    return -location * this._thumbRatio;
  },
  _update: function _update() {
    var containerSize = Math.round(this.option('containerSize'));
    var contentSize = Math.round(this.option('contentSize'));
    var baseContainerSize = Math.round(this.option('baseContainerSize'));
    var baseContentSize = Math.round(this.option('baseContentSize'));

    // NOTE: if current scrollbar's using outside of scrollable
    if (isNaN(baseContainerSize)) {
      baseContainerSize = containerSize;
      baseContentSize = contentSize;
    }
    this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
    this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
    var thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), THUMB_MIN_SIZE));
    this._thumbRatio = (containerSize - thumbSize) / (this.option('scaleRatio') * (contentSize - containerSize));
    this.option(this._dimension, thumbSize / this.option('scaleRatio'));
    this.$element().css('display', this._needScrollbar() ? '' : 'none');
  },
  _isHidden: function _isHidden() {
    return this.option('visibilityMode') === SCROLLBAR_VISIBLE.never;
  },
  _needScrollbar: function _needScrollbar() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  },
  containerToContentRatio: function containerToContentRatio() {
    return this._realContainerToContentRatio;
  },
  _normalizeSize: function _normalizeSize(size) {
    return (0, _type.isPlainObject)(size) ? size[this._dimension] || 0 : size;
  },
  _clean: function _clean() {
    this.callBase();
    if (this === activeScrollbar) {
      activeScrollbar = null;
    }
    _events_engine.default.off(this._$thumb, '.' + SCROLLBAR);
  },
  _optionChanged: function _optionChanged(args) {
    if (this._isHidden()) {
      return;
    }
    switch (args.name) {
      case 'containerSize':
      case 'contentSize':
        this.option()[args.name] = this._normalizeSize(args.value);
        this._update();
        break;
      case 'baseContentSize':
      case 'baseContainerSize':
        this._update();
        break;
      case 'visibilityMode':
      case 'direction':
        this._invalidate();
        break;
      case 'scaleRatio':
        this._update();
        break;
      default:
        this.callBase.apply(this, arguments);
    }
  },
  update: (0, _common.deferRenderer)(function () {
    this._adjustVisibility() && this.option('visible', true);
  })
});
_ready_callbacks.default.add(function () {
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.up, SCROLLBAR), function () {
    if (activeScrollbar) {
      activeScrollbar.feedbackOff();
    }
  });
});
var _default = Scrollbar;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 68198:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _selectionStrategy = _interopRequireDefault(__webpack_require__(83014));
var _selectionStrategy2 = _interopRequireDefault(__webpack_require__(78600));
var _extend = __webpack_require__(13306);
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var Selection = /*#__PURE__*/function () {
  function Selection(options) {
    this.options = (0, _extend.extend)(this._getDefaultOptions(), options, {
      selectedItemKeys: options.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new _selectionStrategy.default(this.options) : new _selectionStrategy2.default(this.options);
    this._focusedItemIndex = -1;
    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  }
  var _proto = Selection.prototype;
  _proto._getDefaultOptions = function _getDefaultOptions() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: 'multiple',
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: _common.noop,
      key: _common.noop,
      keyOf: function keyOf(item) {
        return item;
      },
      load: function load() {
        return new _deferred.Deferred().resolve([]);
      },
      totalCount: function totalCount() {
        return -1;
      },
      isSelectableItem: function isSelectableItem() {
        return true;
      },
      isItemSelected: function isItemSelected() {
        return false;
      },
      getItemData: function getItemData(item) {
        return item;
      },
      dataFields: _common.noop,
      filter: _common.noop
    };
  };
  _proto.validate = function validate() {
    this._selectionStrategy.validate();
  };
  _proto.getSelectedItemKeys = function getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  };
  _proto.getSelectedItems = function getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  };
  _proto.selectionFilter = function selectionFilter(value) {
    if (value === undefined) {
      return this.options.selectionFilter;
    }
    var filterIsChanged = this.options.selectionFilter !== value && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value);
    this.options.selectionFilter = value;
    filterIsChanged && this.onSelectionChanged();
  };
  _proto.setSelection = function setSelection(keys, updatedKeys) {
    return this.selectedItemKeys(keys, false, false, false, updatedKeys);
  };
  _proto.select = function select(keys) {
    return this.selectedItemKeys(keys, true);
  };
  _proto.deselect = function deselect(keys) {
    return this.selectedItemKeys(keys, true, true);
  };
  _proto.selectedItemKeys = function selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    var _keys;
    var that = this;
    keys = (_keys = keys) !== null && _keys !== void 0 ? _keys : [];
    keys = Array.isArray(keys) ? keys : [keys];
    that.validate();
    return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys);
  };
  _proto.clearSelection = function clearSelection() {
    return this.selectedItemKeys([]);
  };
  _proto._addSelectedItem = function _addSelectedItem(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  };
  _proto._removeSelectedItem = function _removeSelectedItem(key) {
    this._selectionStrategy.removeSelectedItem(key);
  };
  _proto._setSelectedItems = function _setSelectedItems(keys, items) {
    this._selectionStrategy.setSelectedItems(keys, items);
  };
  _proto.onSelectionChanged = function onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  };
  _proto.changeItemSelection = function changeItemSelection(itemIndex, keys, setFocusOnly) {
    var _this$options$allowLo,
      _this$options,
      _this = this;
    var isSelectedItemsChanged;
    var items = this.options.plainItems();
    var item = items[itemIndex];
    var deferred;
    var allowLoadByRange = (_this$options$allowLo = (_this$options = this.options).allowLoadByRange) === null || _this$options$allowLo === void 0 ? void 0 : _this$options$allowLo.call(_this$options);
    var indexOffset;
    var focusedItemNotInLoadedRange = false;
    var shiftFocusedItemNotInLoadedRange = false;
    var itemIsNotInLoadedRange = function itemIsNotInLoadedRange(index) {
      return index >= 0 && !items.filter(function (it) {
        return it.loadIndex === index;
      }).length;
    };
    if (allowLoadByRange && (0, _type.isDefined)(item)) {
      indexOffset = item.loadIndex - itemIndex;
      itemIndex = item.loadIndex;
      focusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._focusedItemIndex);
      if ((0, _type.isDefined)(this._shiftFocusedItemIndex)) {
        shiftFocusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._shiftFocusedItemIndex);
      }
    }
    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }
    var itemData = this.options.getItemData(item);
    var itemKey = this.options.keyOf(itemData);
    keys = keys || {};
    if (keys.shift && this.options.mode === 'multiple' && this._focusedItemIndex >= 0) {
      if (focusedItemNotInLoadedRange || shiftFocusedItemNotInLoadedRange) {
        isSelectedItemsChanged = itemIndex !== this._shiftFocusedItemIndex || this._focusedItemIndex !== this._shiftFocusedItemIndex;
        if (isSelectedItemsChanged) {
          deferred = this.changeItemSelectionWhenShiftKeyInVirtualPaging(itemIndex);
        }
      } else {
        isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset);
      }
    } else if (keys.control) {
      this._resetItemSelectionWhenShiftKeyPressed();
      if (!setFocusOnly) {
        var isSelected = this._selectionStrategy.isItemDataSelected(itemData);
        if (this.options.mode === 'single') {
          this.clearSelectedItems();
        }
        if (isSelected) {
          this._removeSelectedItem(itemKey);
        } else {
          this._addSelectedItem(itemData, itemKey);
        }
      }
      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      var isKeysEqual = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
      if (this.options.selectedItemKeys.length !== 1 || !isKeysEqual) {
        this._setSelectedItems([itemKey], [itemData]);
        isSelectedItemsChanged = true;
      }
    }
    if (isSelectedItemsChanged) {
      (0, _deferred.when)(deferred).done(function () {
        _this._focusedItemIndex = itemIndex;
        !setFocusOnly && _this.onSelectionChanged();
      });
      return true;
    }
  };
  _proto.isDataItem = function isDataItem(item) {
    return this.options.isSelectableItem(item);
  };
  _proto.isSelectable = function isSelectable() {
    return this.options.mode === 'single' || this.options.mode === 'multiple';
  };
  _proto.isItemDataSelected = function isItemDataSelected(data) {
    return this._selectionStrategy.isItemDataSelected(data, {
      checkPending: true
    });
  };
  _proto.isItemSelected = function isItemSelected(arg, options) {
    return this._selectionStrategy.isItemKeySelected(arg, options);
  };
  _proto._resetItemSelectionWhenShiftKeyPressed = function _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  };
  _proto._resetFocusedItemIndex = function _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  };
  _proto.changeItemSelectionWhenShiftKeyInVirtualPaging = function changeItemSelectionWhenShiftKeyInVirtualPaging(loadIndex) {
    var _this2 = this;
    var loadOptions = this.options.getLoadOptions(loadIndex, this._focusedItemIndex, this._shiftFocusedItemIndex);
    var deferred = new _deferred.Deferred();
    var indexOffset = loadOptions.skip;
    this.options.load(loadOptions).done(function (items) {
      _this2.changeItemSelectionWhenShiftKeyPressed(loadIndex, items, indexOffset);
      deferred.resolve();
    });
    return deferred.promise();
  };
  _proto.changeItemSelectionWhenShiftKeyPressed = function changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset) {
    var isSelectedItemsChanged = false;
    var itemIndexStep;
    var indexOffsetDefined = (0, _type.isDefined)(indexOffset);
    var index = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
    var keyOf = this.options.keyOf;
    var focusedItem = items[index];
    var focusedData = this.options.getItemData(focusedItem);
    var focusedKey = keyOf(focusedData);
    var isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
    if (!(0, _type.isDefined)(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }
    var data;
    var itemKey;
    var startIndex;
    var endIndex;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index = startIndex; index !== endIndex; index += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index])) {
          itemKey = keyOf(this.options.getItemData(items[index]));
          this._removeSelectedItem(itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? itemIndex - indexOffset : itemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index = startIndex; index !== endIndex; index += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index])) {
          data = this.options.getItemData(items[index]);
          itemKey = keyOf(data);
          this._addSelectedItem(data, itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if ((indexOffsetDefined || this.isDataItem(focusedItem)) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);
      isSelectedItemsChanged = true;
    }
    return isSelectedItemsChanged;
  };
  _proto.clearSelectedItems = function clearSelectedItems() {
    this._setSelectedItems([], []);
  };
  _proto.selectAll = function selectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(false);
    } else {
      return this.selectedItemKeys([], true, false, true);
    }
  };
  _proto.deselectAll = function deselectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._onePageSelectAll(true);
    } else {
      return this.selectedItemKeys([], true, true, true);
    }
  };
  _proto._onePageSelectAll = function _onePageSelectAll(isDeselect) {
    var items = this._selectionStrategy.getSelectableItems(this.options.plainItems());
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      if (this.isDataItem(item)) {
        var itemData = this.options.getItemData(item);
        var itemKey = this.options.keyOf(itemData);
        var isSelected = this.isItemSelected(itemKey);
        if (!isSelected && !isDeselect) {
          this._addSelectedItem(itemData, itemKey);
        }
        if (isSelected && isDeselect) {
          this._removeSelectedItem(itemKey);
        }
      }
    }
    this.onSelectionChanged();
    return new _deferred.Deferred().resolve();
  };
  _proto.getSelectAllState = function getSelectAllState(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  };
  _proto.loadSelectedItemsWithFilter = function loadSelectedItemsWithFilter() {
    return this._selectionStrategy.loadSelectedItemsWithFilter();
  };
  return Selection;
}();
exports["default"] = Selection;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 83014:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _selection = _interopRequireDefault(__webpack_require__(34344));
var _ui = _interopRequireDefault(__webpack_require__(96688));
var _query = _interopRequireDefault(__webpack_require__(96687));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var DeferredStrategy = /*#__PURE__*/function (_SelectionStrategy) {
  _inheritsLoose(DeferredStrategy, _SelectionStrategy);
  function DeferredStrategy() {
    return _SelectionStrategy.apply(this, arguments) || this;
  }
  var _proto = DeferredStrategy.prototype;
  _proto.getSelectedItems = function getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  };
  _proto.getSelectedItemKeys = function getSelectedItemKeys() {
    var d = new _deferred.Deferred();
    var that = this;
    var key = this.options.key();
    var select = (0, _type.isString)(key) ? [key] : key;
    this._loadFilteredData(this.options.selectionFilter, null, select).done(function (items) {
      var keys = items.map(function (item) {
        return that.options.keyOf(item);
      });
      d.resolve(keys);
    }).fail(d.reject);
    return d.promise();
  };
  _proto.selectedItemKeys = function selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      var filter = this.options.filter();
      var needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
      if (needResetSelectionFilter) {
        this._setOption('selectionFilter', isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption('selectionFilter', []);
      }
      for (var i = 0; i < keys.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys[i]);
        } else {
          this.addSelectedItem(keys[i], isSelectAll, !preserve);
        }
      }
    }
    this.onSelectionChanged();
    return new _deferred.Deferred().resolve();
  };
  _proto.setSelectedItems = function setSelectedItems(keys) {
    this._setOption('selectionFilter', null);
    for (var i = 0; i < keys.length; i++) {
      this.addSelectedItem(keys[i]);
    }
  };
  _proto.isItemDataSelected = function isItemDataSelected(itemData) {
    return this.isItemKeySelected(itemData);
  };
  _proto.isItemKeySelected = function isItemKeySelected(itemData) {
    var selectionFilter = this.options.selectionFilter;
    if (!selectionFilter) {
      return true;
    }
    return !!(0, _query.default)([itemData]).filter(selectionFilter).toArray().length;
  };
  _proto._getKeyExpr = function _getKeyExpr() {
    var keyField = this.options.key();
    if (Array.isArray(keyField) && keyField.length === 1) {
      return keyField[0];
    }
    return keyField;
  };
  _proto._normalizeKey = function _normalizeKey(key) {
    var keyExpr = this.options.key();
    if (Array.isArray(keyExpr) && keyExpr.length === 1) {
      return key[keyExpr[0]];
    }
    return key;
  };
  _proto._getFilterByKey = function _getFilterByKey(key) {
    var keyField = this._getKeyExpr();
    var filter = [keyField, '=', this._normalizeKey(key)];
    if (Array.isArray(keyField)) {
      filter = [];
      for (var i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], '=', key[keyField[i]]]);
        if (i !== keyField.length - 1) {
          filter.push('and');
        }
      }
    }
    return filter;
  };
  _proto.addSelectedItem = function addSelectedItem(key, isSelectAll, skipFilter) {
    var filter = this._getFilterByKey(key);
    this._addSelectionFilter(false, filter, isSelectAll, skipFilter);
  };
  _proto.removeSelectedItem = function removeSelectedItem(key) {
    var filter = this._getFilterByKey(key);
    this._addSelectionFilter(true, filter);
  };
  _proto.validate = function validate() {
    var key = this.options.key;
    if (key && key() === undefined) {
      throw _ui.default.Error('E1042', 'Deferred selection');
    }
  };
  _proto._findSubFilter = function _findSubFilter(selectionFilter, filter) {
    if (!selectionFilter) return -1;
    var filterString = JSON.stringify(filter);
    for (var index = 0; index < selectionFilter.length; index++) {
      var subFilter = selectionFilter[index];
      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index;
      }
    }
    return -1;
  };
  _proto._isLastSubFilter = function _isLastSubFilter(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || this._findSubFilter([selectionFilter], filter) === 0;
    }
    return false;
  };
  _proto._addFilterOperator = function _addFilterOperator(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && (0, _type.isString)(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }
    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }
    return selectionFilter;
  };
  _proto._denormalizeFilter = function _denormalizeFilter(filter) {
    if (filter && (0, _type.isString)(filter[0])) {
      filter = [filter];
    }
    return filter;
  };
  _proto._isOnlyNegativeFiltersLeft = function _isOnlyNegativeFiltersLeft(filters) {
    return filters.every(function (filterItem, i) {
      if (i % 2 === 0) {
        return Array.isArray(filterItem) && filterItem[0] === '!';
      } else {
        return filterItem === 'and';
      }
    });
  };
  _proto._addSelectionFilter = function _addSelectionFilter(isDeselect, filter, isSelectAll, skipFilter) {
    var _selectionFilter;
    var that = this;
    var currentFilter = isDeselect ? ['!', filter] : filter;
    var currentOperation = isDeselect ? 'and' : 'or';
    var needAddFilter = true;
    var selectionFilter = that.options.selectionFilter || [];
    selectionFilter = that._denormalizeFilter(selectionFilter);
    if ((_selectionFilter = selectionFilter) !== null && _selectionFilter !== void 0 && _selectionFilter.length && !skipFilter) {
      var removedIndex = that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
      var filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
      var shouldCleanFilter = isDeselect && (removedIndex !== -1 || filterIndex !== -1) && this._isOnlyNegativeFiltersLeft(selectionFilter);
      if (shouldCleanFilter) {
        selectionFilter = [];
      }
      var isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
    }
    if (needAddFilter) {
      selectionFilter = that._addFilterOperator(selectionFilter, currentOperation);
      selectionFilter.push(currentFilter);
    }
    selectionFilter = that._normalizeFilter(selectionFilter);
    that._setOption('selectionFilter', !isDeselect && !selectionFilter.length ? null : selectionFilter);
  };
  _proto._normalizeFilter = function _normalizeFilter(filter) {
    if (filter && filter.length === 1) {
      filter = filter[0];
    }
    return filter;
  };
  _proto._removeFilterByIndex = function _removeFilterByIndex(filter, filterIndex, isSelectAll) {
    var operation = filter[1];
    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }
    if (isSelectAll && operation === 'and') {
      filter.splice(0, filter.length);
    }
  };
  _proto._isSimpleKeyFilter = function _isSimpleKeyFilter(filter, key) {
    return filter.length === 3 && filter[0] === key && filter[1] === '=';
  };
  _proto._isKeyFilter = function _isKeyFilter(filter) {
    if (filter.length === 2 && filter[0] === '!') {
      return this._isKeyFilter(filter[1]);
    }
    var keyField = this._getKeyExpr();
    if (Array.isArray(keyField)) {
      if (filter.length !== keyField.length * 2 - 1) {
        return false;
      }
      for (var i = 0; i < keyField.length; i++) {
        if (i > 0 && filter[i * 2 - 1] !== 'and') {
          return false;
        }
        if (!this._isSimpleKeyFilter(filter[i * 2], keyField[i])) {
          return false;
        }
      }
      return true;
    }
    return this._isSimpleKeyFilter(filter, keyField);
  };
  _proto._hasKeyFiltersOnlyStartingFromIndex = function _hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (var i = filterIndex; i < selectionFilter.length; i++) {
        if (typeof selectionFilter[i] !== 'string' && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  _proto._removeSameFilter = function _removeSameFilter(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ['!', filter] : filter;
    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }
    var filterIndex = this._findSubFilter(selectionFilter, filter);
    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
      return filterIndex;
    } else {
      for (var i = 0; i < selectionFilter.length; i++) {
        if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
          var _filterIndex = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
          if (_filterIndex >= 0) {
            if (!selectionFilter[i].length) {
              this._removeFilterByIndex(selectionFilter, i, isSelectAll);
            } else if (selectionFilter[i].length === 1) {
              selectionFilter[i] = selectionFilter[i][0];
            }
            return _filterIndex;
          }
        }
      }
      return -1;
    }
  };
  _proto.getSelectAllState = function getSelectAllState() {
    var filter = this.options.filter();
    var selectionFilter = this.options.selectionFilter;
    if (!selectionFilter) return true;
    if (!selectionFilter.length) return false;
    if (!filter || !filter.length) return undefined;
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }
    if (this._isLastSubFilter(selectionFilter, ['!', filter])) {
      return false;
    }
    return undefined;
  };
  _proto.loadSelectedItemsWithFilter = function loadSelectedItemsWithFilter() {
    var componentFilter = this.options.filter();
    var selectionFilter = this.options.selectionFilter;
    var filter = componentFilter ? [componentFilter, 'and', selectionFilter] : selectionFilter;
    return this._loadFilteredData(filter);
  };
  return DeferredStrategy;
}(_selection.default);
exports["default"] = DeferredStrategy;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 34344:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _query = _interopRequireDefault(__webpack_require__(96687));
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SelectionStrategy = /*#__PURE__*/function () {
  function SelectionStrategy(options) {
    this.options = options;
    this._setOption('disabledItemKeys', []);
    this._clearItemKeys();
  }
  var _proto = SelectionStrategy.prototype;
  _proto._clearItemKeys = function _clearItemKeys() {
    this._setOption('addedItemKeys', []);
    this._setOption('removedItemKeys', []);
    this._setOption('removedItems', []);
    this._setOption('addedItems', []);
  };
  _proto.validate = function validate() {};
  _proto._setOption = function _setOption(name, value) {
    this.options[name] = value;
  };
  _proto.onSelectionChanged = function onSelectionChanged() {
    var addedItemKeys = this.options.addedItemKeys;
    var removedItemKeys = this.options.removedItemKeys;
    var addedItems = this.options.addedItems;
    var removedItems = this.options.removedItems;
    var selectedItems = this.options.selectedItems;
    var selectedItemKeys = this.options.selectedItemKeys;
    var onSelectionChanged = this.options.onSelectionChanged || _common.noop;
    this._clearItemKeys();
    onSelectionChanged({
      selectedItems: selectedItems,
      selectedItemKeys: selectedItemKeys,
      addedItemKeys: addedItemKeys,
      removedItemKeys: removedItemKeys,
      addedItems: addedItems,
      removedItems: removedItems
    });
  };
  _proto.equalKeys = function equalKeys(key1, key2) {
    if (this.options.equalByReference) {
      if ((0, _type.isObject)(key1) && (0, _type.isObject)(key2)) {
        return key1 === key2;
      }
    }
    return (0, _common.equalByValue)(key1, key2);
  };
  _proto.getSelectableItems = function getSelectableItems(items) {
    return items.filter(function (item) {
      return !(item !== null && item !== void 0 && item.disabled);
    });
  };
  _proto._clearSelection = function _clearSelection(keys, preserve, isDeselect, isSelectAll) {
    keys = keys || [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  };
  _proto._removeTemplateProperty = function _removeTemplateProperty(remoteFilter) {
    var _this = this;
    if (Array.isArray(remoteFilter)) {
      return remoteFilter.map(function (f) {
        return _this._removeTemplateProperty(f);
      });
    }
    if ((0, _type.isObject)(remoteFilter)) {
      delete remoteFilter.template;
    }
    return remoteFilter;
  };
  _proto._loadFilteredData = function _loadFilteredData(remoteFilter, localFilter, select, isSelectAll) {
    var filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
    var needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    var deferred = new _deferred.Deferred();
    var loadOptions = {
      filter: needLoadAllData ? undefined : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    };
    if (remoteFilter && remoteFilter.length === 0) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done(function (items) {
        var filteredItems = (0, _type.isPlainObject)(items) ? items.data : items;
        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = (0, _query.default)(filteredItems).filter(remoteFilter).toArray();
        }
        deferred.resolve(filteredItems);
      }).fail(deferred.reject.bind(deferred));
    }
    return deferred;
  };
  _proto.updateSelectedItemKeyHash = function updateSelectedItemKeyHash(keys) {
    for (var i = 0; i < keys.length; i++) {
      var keyHash = (0, _common.getKeyHash)(keys[i]);
      if (!(0, _type.isObject)(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        var keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  };
  _proto._isAnyItemSelected = function _isAnyItemSelected(items) {
    for (var i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return undefined;
      }
    }
    return false;
  };
  _proto._getFullSelectAllState = function _getFullSelectAllState() {
    var items = this.options.plainItems();
    var dataFilter = this.options.filter();
    var selectedItems = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter(function (item) {
      return !(item !== null && item !== void 0 && item.disabled);
    });
    if (dataFilter) {
      selectedItems = (0, _query.default)(selectedItems).filter(dataFilter).toArray();
    }
    var selectedItemsLength = selectedItems.length;
    var disabledItemsLength = items.length - this.getSelectableItems(items).length;
    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }
    if (selectedItemsLength >= this.options.totalCount() - disabledItemsLength) {
      return true;
    }
    return undefined;
  };
  _proto._getVisibleSelectAllState = function _getVisibleSelectAllState() {
    var items = this.getSelectableItems(this.options.plainItems());
    var hasSelectedItems = false;
    var hasUnselectedItems = false;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var itemData = this.options.getItemData(item);
      var key = this.options.keyOf(itemData);
      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }
    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : undefined;
    } else {
      return false;
    }
  };
  return SelectionStrategy;
}();
exports["default"] = SelectionStrategy;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 78600:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _array = __webpack_require__(89386);
var _array_compare = __webpack_require__(34671);
var _query = _interopRequireDefault(__webpack_require__(96687));
var _deferred = __webpack_require__(62754);
var _selection_filter = __webpack_require__(49601);
var _ui = _interopRequireDefault(__webpack_require__(96688));
var _selection = _interopRequireDefault(__webpack_require__(34344));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
var StandardStrategy = /*#__PURE__*/function (_SelectionStrategy) {
  _inheritsLoose(StandardStrategy, _SelectionStrategy);
  function StandardStrategy(options) {
    var _this;
    _this = _SelectionStrategy.call(this, options) || this;
    _this._initSelectedItemKeyHash();
    return _this;
  }
  var _proto = StandardStrategy.prototype;
  _proto._initSelectedItemKeyHash = function _initSelectedItemKeyHash() {
    this._setOption('keyHashIndices', this.options.equalByReference ? null : {});
  };
  _proto.getSelectedItemKeys = function getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  };
  _proto.getSelectedItems = function getSelectedItems() {
    return this.options.selectedItems.slice(0);
  };
  _proto._preserveSelectionUpdate = function _preserveSelectionUpdate(items, isDeselect) {
    var keyOf = this.options.keyOf;
    var keyIndicesToRemoveMap;
    var keyIndex;
    var i;
    if (!keyOf) return;
    var isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }
    for (i = 0; i < items.length; i++) {
      var item = items[i];
      var key = keyOf(item);
      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap, item === null || item === void 0 ? void 0 : item.disabled);
        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }
    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  };
  _proto._batchRemoveSelectedItems = function _batchRemoveSelectedItems(keyIndicesToRemoveMap) {
    var selectedItemKeys = this.options.selectedItemKeys.slice(0);
    var selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;
    for (var i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }
    this._initSelectedItemKeyHash();
    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  };
  _proto._loadSelectedItemsCore = function _loadSelectedItemsCore(keys, isDeselect, isSelectAll, filter) {
    var forceCombinedFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var deferred = new _deferred.Deferred();
    var key = this.options.key();
    if (!keys.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }
    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }
    var selectionFilterCreator = new _selection_filter.SelectionFilterCreator(keys, isSelectAll);
    var combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter, forceCombinedFilter);
    var deselectedItems = [];
    if (isDeselect) {
      var selectedItems = this.options.selectedItems;
      deselectedItems = combinedFilter && keys.length !== selectedItems.length ? (0, _query.default)(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0);
    }
    var filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    var localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);
    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }
    return deferred;
  };
  _proto._replaceSelectionUpdate = function _replaceSelectionUpdate(items) {
    var internalKeys = [];
    var keyOf = this.options.keyOf;
    if (!keyOf) return;
    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      var key = keyOf(item);
      internalKeys.push(key);
    }
    this.setSelectedItems(internalKeys, items);
  };
  _proto._warnOnIncorrectKeys = function _warnOnIncorrectKeys(keys) {
    var allowNullValue = this.options.allowNullValue;
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if ((!allowNullValue || key !== null) && !this.isItemKeySelected(key)) {
        _ui.default.log('W1002', key);
      }
    }
  };
  _proto._isMultiSelectEnabled = function _isMultiSelectEnabled() {
    var mode = this.options.mode;
    return mode === 'all' || mode === 'multiple';
  };
  _proto._requestInProgress = function _requestInProgress() {
    var _this$_lastLoadDeferr;
    return ((_this$_lastLoadDeferr = this._lastLoadDeferred) === null || _this$_lastLoadDeferr === void 0 ? void 0 : _this$_lastLoadDeferr.state()) === 'pending';
  };
  _proto._concatRequestsItems = function _concatRequestsItems(keys, isDeselect, oldRequestItems, updatedKeys) {
    var selectedItems;
    var deselectedItems = isDeselect ? keys : [];
    if (updatedKeys) {
      selectedItems = updatedKeys;
    } else {
      selectedItems = (0, _array.removeDuplicates)(keys, this.options.selectedItemKeys);
    }
    return {
      addedItems: oldRequestItems.added.concat(selectedItems),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys: keys
    };
  };
  _proto._collectLastRequestData = function _collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys) {
    var isDeselectAll = isDeselect && isSelectAll;
    var oldRequestItems = {
      added: [],
      removed: []
    };
    var multiSelectEnabled = this._isMultiSelectEnabled();
    var lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
    if (multiSelectEnabled) {
      if (this._shouldMergeWithLastRequest) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();
          lastRequestData = {};
        } else if (!(0, _array_compare.isKeysEqual)(keys, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;
          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        }
      }
      lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? undefined : updatedKeys);
    }
    return lastRequestData;
  };
  _proto._updateKeysByLastRequestData = function _updateKeysByLastRequestData(keys, isDeselect, isSelectAll) {
    var currentKeys = keys;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;
      currentKeys = (0, _array.removeDuplicates)(keys.concat((_this$_lastRequestDat = this._lastRequestData) === null || _this$_lastRequestDat === void 0 ? void 0 : _this$_lastRequestDat.addedItems), (_this$_lastRequestDat2 = this._lastRequestData) === null || _this$_lastRequestDat2 === void 0 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = (0, _array.getUniqueValues)(currentKeys);
    }
    return currentKeys;
  };
  _proto._loadSelectedItems = function _loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys) {
    var forceCombinedFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var that = this;
    var deferred = new _deferred.Deferred();
    var filter = that.options.filter();
    this._shouldMergeWithLastRequest = this._requestInProgress();
    this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
    (0, _deferred.when)(that._lastLoadDeferred).always(function () {
      var currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
      that._shouldMergeWithLastRequest = false;
      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll, filter, forceCombinedFilter).done(deferred.resolve).fail(deferred.reject);
    });
    that._lastLoadDeferred = deferred;
    return deferred;
  };
  _proto.selectedItemKeys = function selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    var forceCombinedFilter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var that = this;
    var deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys, forceCombinedFilter);
    deferred.done(function (items) {
      if (preserve) {
        that._preserveSelectionUpdate(items, isDeselect);
      } else {
        that._replaceSelectionUpdate(items);
      }
      that.onSelectionChanged();
    });
    return deferred;
  };
  _proto.addSelectedItem = function addSelectedItem(key, itemData) {
    if ((0, _type.isDefined)(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
      if (this.options.disabledItemKeys.indexOf(key) === -1) {
        this.options.disabledItemKeys.push(key);
      }
      return;
    }
    var keyHash = this._getKeyHash(key);
    if (this._indexOfSelectedItemKey(keyHash) === -1) {
      if (!(0, _type.isObject)(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }
      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  };
  _proto._getSelectedIndexByKey = function _getSelectedIndexByKey(key, ignoreIndicesMap) {
    var selectedItemKeys = this.options.selectedItemKeys;
    for (var index = 0; index < selectedItemKeys.length; index++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index]) && this.equalKeys(selectedItemKeys[index], key)) {
        return index;
      }
    }
    return -1;
  };
  _proto._getSelectedIndexByHash = function _getSelectedIndexByHash(key, ignoreIndicesMap) {
    var indices = this.options.keyHashIndices[key];
    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter(function (index) {
        return !ignoreIndicesMap[index];
      });
    }
    return indices && indices[0] >= 0 ? indices[0] : -1;
  };
  _proto._indexOfSelectedItemKey = function _indexOfSelectedItemKey(key, ignoreIndicesMap) {
    var selectedIndex;
    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if ((0, _type.isObject)(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }
    return selectedIndex;
  };
  _proto._shiftSelectedKeyIndices = function _shiftSelectedKeyIndices(keyIndex) {
    for (var currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      var currentKey = this.options.selectedItemKeys[currentKeyIndex];
      var currentKeyHash = (0, _common.getKeyHash)(currentKey);
      var currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) continue;
      for (var i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  };
  _proto.removeSelectedItem = function removeSelectedItem(key, keyIndicesToRemoveMap, isDisabled) {
    if (!this.options.ignoreDisabledItems && isDisabled) {
      return;
    }
    var keyHash = this._getKeyHash(key);
    var isBatchDeselect = !!keyIndicesToRemoveMap;
    var keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
    if (keyIndex < 0) {
      return keyIndex;
    }
    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);
    if (isBatchDeselect) {
      return keyIndex;
    }
    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);
    if ((0, _type.isObject)(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }
    var keyIndices = this.options.keyHashIndices[keyHash];
    if (!keyIndices) {
      return keyIndex;
    }
    keyIndices.shift();
    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }
    this._shiftSelectedKeyIndices(keyIndex);
    return keyIndex;
  };
  _proto._updateAddedItemKeys = function _updateAddedItemKeys(keys, items) {
    for (var i = 0; i < keys.length; i++) {
      if (!this.isItemKeySelected(keys[i])) {
        this.options.addedItemKeys.push(keys[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  };
  _proto._updateRemovedItemKeys = function _updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems) {
    for (var i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  };
  _proto._isItemSelectionInProgress = function _isItemSelectionInProgress(key, checkPending) {
    var shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
    if (shouldCheckPending) {
      var _this$_lastRequestDat3;
      var addedItems = (_this$_lastRequestDat3 = this._lastRequestData.addedItems) !== null && _this$_lastRequestDat3 !== void 0 ? _this$_lastRequestDat3 : [];
      return addedItems.includes(key);
    } else {
      return false;
    }
  };
  _proto._getKeyHash = function _getKeyHash(key) {
    return this.options.equalByReference ? key : (0, _common.getKeyHash)(key);
  };
  _proto.setSelectedItems = function setSelectedItems(keys, items) {
    this._updateAddedItemKeys(keys, items);
    var oldSelectedKeys = this.options.selectedItemKeys;
    var oldSelectedItems = this.options.selectedItems;
    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();
      this.updateSelectedItemKeyHash(keys);
    }
    this._setOption('selectedItemKeys', keys);
    this._setOption('selectedItems', items);
    this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
  };
  _proto.isItemDataSelected = function isItemDataSelected(itemData) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options);
  };
  _proto.isItemKeySelected = function isItemKeySelected(key) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var result = this._isItemSelectionInProgress(key, options.checkPending);
    if (!result) {
      var keyHash = this._getKeyHash(key);
      var index = this._indexOfSelectedItemKey(keyHash);
      result = index !== -1;
    }
    return result;
  };
  _proto.getSelectAllState = function getSelectAllState(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    } else {
      return this._getFullSelectAllState();
    }
  };
  _proto.loadSelectedItemsWithFilter = function loadSelectedItemsWithFilter() {
    var keyExpr = this.options.key();
    var keys = this.getSelectedItemKeys();
    var filter = this.options.filter();
    if (!keys.length) {
      return (0, _deferred.Deferred)().resolve([]);
    }
    var selectionFilterCreator = new _selection_filter.SelectionFilterCreator(keys);
    var combinedFilter = selectionFilterCreator.getCombinedFilter(keyExpr, filter, true);
    return this._loadFilteredData(combinedFilter);
  };
  return StandardStrategy;
}(_selection.default);
exports["default"] = StandardStrategy;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 18740:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var DEFAULT_DATE_INTERVAL = ['year', 'month', 'day'];
var DEFAULT_DATETIME_INTERVAL = ['year', 'month', 'day', 'hour', 'minute'];
var isDateType = function isDateType(dataType) {
  return dataType === 'date' || dataType === 'datetime';
};
var getGroupInterval = function getGroupInterval(column) {
  var index;
  var result = [];
  var dateIntervals = ['year', 'month', 'day', 'hour', 'minute', 'second'];
  var groupInterval = column.headerFilter && column.headerFilter.groupInterval;
  var interval = groupInterval === 'quarter' ? 'month' : groupInterval;
  if (isDateType(column.dataType) && groupInterval !== null) {
    result = column.dataType === 'datetime' ? DEFAULT_DATETIME_INTERVAL : DEFAULT_DATE_INTERVAL;
    index = dateIntervals.indexOf(interval);
    if (index >= 0) {
      result = dateIntervals.slice(0, index);
      result.push(groupInterval);
      return result;
    }
    return result;
  } else if ((0, _type.isDefined)(groupInterval)) {
    return Array.isArray(groupInterval) ? groupInterval : [groupInterval];
  }
};
var _default = function () {
  var getFilterSelector = function getFilterSelector(column, target) {
    var selector = column.dataField || column.selector;
    if (target === 'search') {
      selector = column.displayField || column.calculateDisplayValue || selector;
    }
    return selector;
  };
  var isZeroTime = function isZeroTime(date) {
    return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1;
  };
  var getDateValues = function getDateValues(dateValue) {
    if ((0, _type.isDate)(dateValue)) {
      return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
    }
    return (0, _iterator.map)(('' + dateValue).split('/'), function (value, index) {
      return index === 1 ? Number(value) - 1 : Number(value);
    });
  };
  var getFilterExpressionByRange = function getFilterExpressionByRange(filterValue, target) {
    var column = this;
    var endFilterValue;
    var startFilterExpression;
    var endFilterExpression;
    var selector = getFilterSelector(column, target);
    if (Array.isArray(filterValue) && (0, _type.isDefined)(filterValue[0]) && (0, _type.isDefined)(filterValue[1])) {
      startFilterExpression = [selector, '>=', filterValue[0]];
      endFilterExpression = [selector, '<=', filterValue[1]];
      if (isDateType(column.dataType) && isZeroTime(filterValue[1])) {
        endFilterValue = new Date(filterValue[1].getTime());
        if (column.dataType === 'date') {
          endFilterValue.setDate(filterValue[1].getDate() + 1);
        }
        endFilterExpression = [selector, '<', endFilterValue];
      }
      return [startFilterExpression, 'and', endFilterExpression];
    }
  };
  var getFilterExpressionForDate = function getFilterExpressionForDate(filterValue, selectedFilterOperation, target) {
    var column = this;
    var dateStart;
    var dateEnd;
    var dateInterval;
    var values = getDateValues(filterValue);
    var selector = getFilterSelector(column, target);
    if (target === 'headerFilter') {
      dateInterval = getGroupInterval(column)[values.length - 1];
    } else if (column.dataType === 'datetime') {
      dateInterval = 'minute';
    }
    switch (dateInterval) {
      case 'year':
        dateStart = new Date(values[0], 0, 1);
        dateEnd = new Date(values[0] + 1, 0, 1);
        break;
      case 'month':
        dateStart = new Date(values[0], values[1], 1);
        dateEnd = new Date(values[0], values[1] + 1, 1);
        break;
      case 'quarter':
        dateStart = new Date(values[0], 3 * values[1], 1);
        dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
        break;
      case 'hour':
        dateStart = new Date(values[0], values[1], values[2], values[3]);
        dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
        break;
      case 'minute':
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
        break;
      case 'second':
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
        break;
      default:
        dateStart = new Date(values[0], values[1], values[2]);
        dateEnd = new Date(values[0], values[1], values[2] + 1);
    }
    switch (selectedFilterOperation) {
      case '<':
        return [selector, '<', dateStart];
      case '<=':
        return [selector, '<', dateEnd];
      case '>':
        return [selector, '>=', dateEnd];
      case '>=':
        return [selector, '>=', dateStart];
      case '<>':
        return [[selector, '<', dateStart], 'or', [selector, '>=', dateEnd]];
      default:
        return [[selector, '>=', dateStart], 'and', [selector, '<', dateEnd]];
    }
  };
  var getFilterExpressionForNumber = function getFilterExpressionForNumber(filterValue, selectedFilterOperation, target) {
    var column = this;
    var selector = getFilterSelector(column, target);
    var groupInterval = getGroupInterval(column);
    if (target === 'headerFilter' && groupInterval && (0, _type.isDefined)(filterValue)) {
      var values = ('' + filterValue).split('/');
      var value = Number(values[values.length - 1]);
      var interval = groupInterval[values.length - 1];
      var startFilterValue = [selector, '>=', value];
      var endFilterValue = [selector, '<', value + interval];
      var condition = [startFilterValue, 'and', endFilterValue];
      return condition;
    }
    return [selector, selectedFilterOperation || '=', filterValue];
  };
  return {
    defaultCalculateFilterExpression: function defaultCalculateFilterExpression(filterValue, selectedFilterOperation, target) {
      var column = this;
      var selector = getFilterSelector(column, target);
      var isSearchByDisplayValue = column.calculateDisplayValue && target === 'search';
      var dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType;
      var filter = null;
      if ((target === 'headerFilter' || target === 'filterBuilder') && filterValue === null) {
        filter = [selector, selectedFilterOperation || '=', null];
        if (dataType === 'string') {
          filter = [filter, selectedFilterOperation === '=' ? 'or' : 'and', [selector, selectedFilterOperation || '=', '']];
        }
      } else if (dataType === 'string' && (!column.lookup || isSearchByDisplayValue)) {
        filter = [selector, selectedFilterOperation || 'contains', filterValue];
      } else if (selectedFilterOperation === 'between') {
        return getFilterExpressionByRange.apply(column, [filterValue, target]);
      } else if (isDateType(dataType) && (0, _type.isDefined)(filterValue)) {
        return getFilterExpressionForDate.apply(column, arguments);
      } else if (dataType === 'number') {
        return getFilterExpressionForNumber.apply(column, arguments);
      } else {
        filter = [selector, selectedFilterOperation || '=', filterValue];
      }
      return filter;
    },
    getGroupInterval: getGroupInterval
  };
}();
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 75811:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.attachCssClasses = attachCssClasses;
exports.current = current;
exports["default"] = void 0;
exports.detachCssClasses = detachCssClasses;
exports.init = init;
exports.initialized = initialized;
exports.isCompact = isCompact;
exports.isDark = isDark;
exports.isGeneric = isGeneric;
exports.isMaterial = isMaterial;
exports.isPendingThemeLoaded = isPendingThemeLoaded;
exports.isWebFontLoaded = isWebFontLoaded;
exports.ready = themeReady;
exports.resetTheme = resetTheme;
exports.setDefaultTimeout = setDefaultTimeout;
exports.waitForThemeLoad = waitForThemeLoad;
exports.waitWebFont = waitWebFont;
var _size = __webpack_require__(58664);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _deferred = __webpack_require__(62754);
var _html_parser = __webpack_require__(61371);
var _iterator = __webpack_require__(95479);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _view_port = __webpack_require__(77695);
var _window = __webpack_require__(58201);
var _themes_callback = __webpack_require__(89729);
var _ui = _interopRequireDefault(__webpack_require__(96688));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var window = (0, _window.getWindow)();
var ready = _ready_callbacks.default.add;
var viewPort = _view_port.value;
var viewPortChanged = _view_port.changeCallback;
var initDeferred = new _deferred.Deferred();
var DX_LINK_SELECTOR = 'link[rel=dx-theme]';
var THEME_ATTR = 'data-theme';
var ACTIVE_ATTR = 'data-active';
var DX_HAIRLINES_CLASS = 'dx-hairlines';
var ANY_THEME = 'any';
var context;
var $activeThemeLink;
var knownThemes;
var currentThemeName;
var pendingThemeName;
var defaultTimeout = 15000;
var THEME_MARKER_PREFIX = 'dx.';
function readThemeMarker() {
  if (!(0, _window.hasWindow)()) {
    return null;
  }
  var element = (0, _renderer.default)('<div>', context).addClass('dx-theme-marker').appendTo(context.documentElement);
  var result;
  try {
    result = window.getComputedStyle(element.get(0))['fontFamily'];
    if (!result) {
      return null;
    }
    result = result.replace(/["']/g, '');
    if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {
      return null;
    }
    return result.substr(THEME_MARKER_PREFIX.length);
  } finally {
    element.remove();
  }
}

// FYI
// http://stackoverflow.com/q/2635814
// http://stackoverflow.com/a/3078636
function waitForThemeLoad(themeName) {
  var waitStartTime;
  var timerId;
  var intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    _themes_callback.themeReadyCallback.fire();
    _themes_callback.themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function () {
      var isLoaded = isPendingThemeLoaded();
      var isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        _ui.default.log('W0004', pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  var anyThemePending = pendingThemeName === ANY_THEME;
  if (initDeferred.state() === 'resolved' && anyThemePending) {
    return true;
  }
  var themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  var $allThemeLinks = (0, _renderer.default)(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = (0, _renderer.default)((0, _html_parser.parseHTML)('<link rel=stylesheet>'), context);
  $allThemeLinks.each(function () {
    var link = (0, _renderer.default)(this, context);
    var fullThemeName = link.attr(THEME_ATTR);
    var url = link.attr('href');
    var isActive = link.attr(ACTIVE_ATTR) === 'true';
    knownThemes[fullThemeName] = {
      url: url,
      isActive: isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  var desiredThemeParts = desiredThemeName ? desiredThemeName.split('.') : [];
  var result = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    (0, _iterator.each)(knownThemes, function (knownThemeName, themeData) {
      var knownThemeParts = knownThemeName.split('.');
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result || themeData.isActive) {
        result = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    // Cross-origin permission error
    knownThemes = null;
  }
  context = newContext;
}
function init(options) {
  options = options || {};
  initContext(options.context || _dom_adapter.default.getDocument());
  if (!context) return;
  processMarkup();
  currentThemeName = undefined;
  current(options);
}
function current(options) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options = options || {};
  if (typeof options === 'string') {
    options = {
      theme: options
    };
  }
  var isAutoInit = options._autoInit;
  var loadCallback = options.loadCallback;
  var currentThemeData;
  currentThemeName = resolveFullThemeName(options.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    _themes_callback.themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr('href', knownThemes[currentThemeName].url);
    if (_themes_callback.themeReadyCallback.has() || initDeferred.state() !== 'resolved' || options._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else {
    if (isAutoInit) {
      if ((0, _window.hasWindow)()) {
        waitForThemeLoad(ANY_THEME);
      }
      _themes_callback.themeReadyCallback.fire();
      _themes_callback.themeReadyCallback.empty();
    } else {
      throw _ui.default.Error('E0021', currentThemeName);
    }
  }
  initDeferred.done(function () {
    return attachCssClasses((0, _view_port.originalViewPort)(), currentThemeName);
  });
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  var result = [];
  var themeNameParts = themeName && themeName.split('.');
  if (themeNameParts) {
    result.push('dx-theme-' + themeNameParts[0], 'dx-theme-' + themeNameParts[0] + '-typography');
    if (themeNameParts.length > 1) {
      result.push('dx-color-scheme-' + themeNameParts[1] + (isMaterial(themeName) ? '-' + themeNameParts[2] : ''));
    }
  }
  return result;
}
var themeClasses;
function attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(' ');
  (0, _renderer.default)(element).addClass(themeClasses);
  var activateHairlines = function activateHairlines() {
    var pixelRatio = (0, _window.hasWindow)() && window.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    var $tester = (0, _renderer.default)('<div>');
    $tester.css('border', '.5px solid transparent');
    (0, _renderer.default)('body').append($tester);
    if ((0, _size.getOuterHeight)($tester) === 1) {
      (0, _renderer.default)(element).addClass(DX_HAIRLINES_CLASS);
      themeClasses += ' ' + DX_HAIRLINES_CLASS;
    }
    $tester.remove();
  };
  activateHairlines();
}
function detachCssClasses(element) {
  (0, _renderer.default)(element).removeClass(themeClasses);
}
function themeReady(callback) {
  _themes_callback.themeReadyCallback.add(callback);
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterial(themeName) {
  return isTheme('material', themeName);
}
function isGeneric(themeName) {
  return isTheme('generic', themeName);
}
function isDark(themeName) {
  return isTheme('dark', themeName);
}
function isCompact(themeName) {
  return isTheme('compact', themeName);
}
function isWebFontLoaded(text, fontWeight) {
  var testedFont = 'Roboto, RobotoFallback, Arial';
  var etalonFont = 'Arial';
  var document = _dom_adapter.default.getDocument();
  var testElement = document.createElement('span');
  testElement.style.position = 'absolute';
  testElement.style.top = '-9999px';
  testElement.style.left = '-9999px';
  testElement.style.visibility = 'hidden';
  testElement.style.fontFamily = etalonFont;
  testElement.style.fontSize = '250px';
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document.body.appendChild(testElement);
  var etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = testedFont;
  var testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  var interval = 15;
  var timeout = 2000;
  return new Promise(function (resolve) {
    var check = function check() {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    };
    var clear = function clear() {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    var intervalId = setInterval(check, interval);
    var timeoutId = setTimeout(clear, timeout);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if ((0, _renderer.default)(DX_LINK_SELECTOR, context).length) {
    throw _ui.default.Error('E0022');
  }
}
if ((0, _window.hasWindow)()) {
  autoInit();
} else {
  ready(autoInit);
}
viewPortChanged.add(function (viewPort, prevViewPort) {
  initDeferred.done(function () {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort);
  });
});
_devices.default.changed.add(function () {
  init({
    _autoInit: true
  });
});
function resetTheme() {
  $activeThemeLink && $activeThemeLink.attr('href', 'about:blank');
  currentThemeName = null;
  pendingThemeName = null;
  initDeferred = new _deferred.Deferred();
}
function initialized(callback) {
  initDeferred.done(callback);
}
function setDefaultTimeout(timeout) {
  defaultTimeout = timeout;
}

/**
 * Added default export according to our documentation
 * https://js.devexpress.com/Documentation/ApiReference/Common/Utils/ui/themes/
 * */
var _default = {
  setDefaultTimeout,
  initialized,
  resetTheme,
  ready: themeReady,
  waitWebFont,
  isWebFontLoaded,
  isCompact,
  isDark,
  isGeneric,
  isMaterial,
  detachCssClasses,
  attachCssClasses,
  current,
  waitForThemeLoad,
  isPendingThemeLoaded
};
exports["default"] = _default;

/***/ }),

/***/ 89729:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.themeReadyCallback = void 0;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var themeReadyCallback = (0, _callbacks.default)();
exports.themeReadyCallback = themeReadyCallback;

/***/ }),

/***/ 90964:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _events_strategy = __webpack_require__(80566);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _number = _interopRequireDefault(__webpack_require__(18016));
var _message = _interopRequireDefault(__webpack_require__(28109));
var _deferred = __webpack_require__(62754);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// STYLE validation

var STATUS = {
  valid: 'valid',
  invalid: 'invalid',
  pending: 'pending'
};
var BaseRuleValidator = /*#__PURE__*/function () {
  function BaseRuleValidator() {
    this.NAME = 'base';
  }
  var _proto = BaseRuleValidator.prototype;
  _proto.defaultMessage = function defaultMessage(value) {
    return _message.default.getFormatter("validation-".concat(this.NAME))(value);
  };
  _proto.defaultFormattedMessage = function defaultFormattedMessage(value) {
    return _message.default.getFormatter("validation-".concat(this.NAME, "-formatted"))(value);
  };
  _proto._isValueEmpty = function _isValueEmpty(value) {
    return !rulesValidators.required.validate(value, {});
  };
  _proto.validate = function validate(value, rule) {
    var _this = this;
    var valueArray = Array.isArray(value) ? value : [value];
    var result = true;
    if (valueArray.length) {
      valueArray.every(function (itemValue) {
        result = _this._validate(itemValue, rule);
        return result;
      });
    } else {
      result = this._validate(null, rule);
    }
    return result;
  };
  return BaseRuleValidator;
}();
var RequiredRuleValidator = /*#__PURE__*/function (_BaseRuleValidator) {
  _inheritsLoose(RequiredRuleValidator, _BaseRuleValidator);
  function RequiredRuleValidator() {
    var _this2;
    _this2 = _BaseRuleValidator.call(this) || this;
    _this2.NAME = 'required';
    return _this2;
  }
  var _proto2 = RequiredRuleValidator.prototype;
  _proto2._validate = function _validate(value, rule) {
    if (!(0, _type.isDefined)(value)) return false;
    if (value === false) {
      return false;
    }
    value = String(value);
    if (rule.trim || !(0, _type.isDefined)(rule.trim)) {
      value = value.trim();
    }
    return value !== '';
  };
  return RequiredRuleValidator;
}(BaseRuleValidator);
var NumericRuleValidator = /*#__PURE__*/function (_BaseRuleValidator2) {
  _inheritsLoose(NumericRuleValidator, _BaseRuleValidator2);
  function NumericRuleValidator() {
    var _this3;
    _this3 = _BaseRuleValidator2.call(this) || this;
    _this3.NAME = 'numeric';
    return _this3;
  }
  var _proto3 = NumericRuleValidator.prototype;
  _proto3._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    if (rule.useCultureSettings && (0, _type.isString)(value)) {
      return !isNaN(_number.default.parse(value));
    } else {
      return (0, _type.isNumeric)(value);
    }
  };
  return NumericRuleValidator;
}(BaseRuleValidator);
var RangeRuleValidator = /*#__PURE__*/function (_BaseRuleValidator3) {
  _inheritsLoose(RangeRuleValidator, _BaseRuleValidator3);
  function RangeRuleValidator() {
    var _this4;
    _this4 = _BaseRuleValidator3.call(this) || this;
    _this4.NAME = 'range';
    return _this4;
  }
  var _proto4 = RangeRuleValidator.prototype;
  _proto4._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    var validNumber = rulesValidators['numeric'].validate(value, rule);
    var validValue = (0, _type.isDefined)(value) && value !== '';
    var number = validNumber ? parseFloat(value) : validValue && value.valueOf();
    var min = rule.min;
    var max = rule.max;
    if (!(validNumber || (0, _type.isDate)(value)) && !validValue) {
      return false;
    }
    if ((0, _type.isDefined)(min)) {
      if ((0, _type.isDefined)(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    } else {
      if ((0, _type.isDefined)(max)) {
        return number <= max;
      } else {
        throw _errors.default.Error('E0101');
      }
    }
  };
  return RangeRuleValidator;
}(BaseRuleValidator);
var StringLengthRuleValidator = /*#__PURE__*/function (_BaseRuleValidator4) {
  _inheritsLoose(StringLengthRuleValidator, _BaseRuleValidator4);
  function StringLengthRuleValidator() {
    var _this5;
    _this5 = _BaseRuleValidator4.call(this) || this;
    _this5.NAME = 'stringLength';
    return _this5;
  }
  var _proto5 = StringLengthRuleValidator.prototype;
  _proto5._validate = function _validate(value, rule) {
    var _value;
    value = String((_value = value) !== null && _value !== void 0 ? _value : '');
    if (rule.trim || !(0, _type.isDefined)(rule.trim)) {
      value = value.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    return rulesValidators.range.validate(value.length, (0, _extend.extend)({}, rule));
  };
  return StringLengthRuleValidator;
}(BaseRuleValidator);
var CustomRuleValidator = /*#__PURE__*/function (_BaseRuleValidator5) {
  _inheritsLoose(CustomRuleValidator, _BaseRuleValidator5);
  function CustomRuleValidator() {
    var _this6;
    _this6 = _BaseRuleValidator5.call(this) || this;
    _this6.NAME = 'custom';
    return _this6;
  }
  var _proto6 = CustomRuleValidator.prototype;
  _proto6.validate = function validate(value, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    var validator = rule.validator;
    var dataGetter = validator && (0, _type.isFunction)(validator.option) && validator.option('dataGetter');
    var extraParams = (0, _type.isFunction)(dataGetter) && dataGetter();
    var params = {
      value: value,
      validator: validator,
      rule: rule
    };
    if (extraParams) {
      (0, _extend.extend)(params, extraParams);
    }
    return rule.validationCallback(params);
  };
  return CustomRuleValidator;
}(BaseRuleValidator);
var AsyncRuleValidator = /*#__PURE__*/function (_CustomRuleValidator) {
  _inheritsLoose(AsyncRuleValidator, _CustomRuleValidator);
  function AsyncRuleValidator() {
    var _this7;
    _this7 = _CustomRuleValidator.call(this) || this;
    _this7.NAME = 'async';
    return _this7;
  }
  var _proto7 = AsyncRuleValidator.prototype;
  _proto7.validate = function validate(value, rule) {
    if (!(0, _type.isDefined)(rule.reevaluate)) {
      (0, _extend.extend)(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    var validator = rule.validator;
    var dataGetter = validator && (0, _type.isFunction)(validator.option) && validator.option('dataGetter');
    var extraParams = (0, _type.isFunction)(dataGetter) && dataGetter();
    var params = {
      value: value,
      validator: validator,
      rule: rule
    };
    if (extraParams) {
      (0, _extend.extend)(params, extraParams);
    }
    var callbackResult = rule.validationCallback(params);
    if (!(0, _type.isPromise)(callbackResult)) {
      throw _errors.default.Error('E0103');
    }
    return this._getWrappedPromise((0, _deferred.fromPromise)(callbackResult).promise());
  };
  _proto7._getWrappedPromise = function _getWrappedPromise(promise) {
    var deferred = new _deferred.Deferred();
    promise.then(function (res) {
      deferred.resolve(res);
    }, function (err) {
      var res = {
        isValid: false
      };
      if ((0, _type.isDefined)(err)) {
        if ((0, _type.isString)(err)) {
          res.message = err;
        } else if ((0, _type.isObject)(err) && (0, _type.isDefined)(err.message) && (0, _type.isString)(err.message)) {
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    });
    return deferred.promise();
  };
  return AsyncRuleValidator;
}(CustomRuleValidator);
var CompareRuleValidator = /*#__PURE__*/function (_BaseRuleValidator6) {
  _inheritsLoose(CompareRuleValidator, _BaseRuleValidator6);
  function CompareRuleValidator() {
    var _this8;
    _this8 = _BaseRuleValidator6.call(this) || this;
    _this8.NAME = 'compare';
    return _this8;
  }
  var _proto8 = CompareRuleValidator.prototype;
  _proto8._validate = function _validate(value, rule) {
    if (!rule.comparisonTarget) {
      throw _errors.default.Error('E0102');
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value)) {
      return true;
    }
    (0, _extend.extend)(rule, {
      reevaluate: true
    });
    var otherValue = rule.comparisonTarget();
    var type = rule.comparisonType || '==';
    switch (type) {
      case '==':
        return value == otherValue;
      // eslint-disable-line eqeqeq
      case '!=':
        return value != otherValue;
      // eslint-disable-line eqeqeq
      case '===':
        return value === otherValue;
      case '!==':
        return value !== otherValue;
      case '>':
        return value > otherValue;
      case '>=':
        return value >= otherValue;
      case '<':
        return value < otherValue;
      case '<=':
        return value <= otherValue;
    }
  };
  return CompareRuleValidator;
}(BaseRuleValidator);
var PatternRuleValidator = /*#__PURE__*/function (_BaseRuleValidator7) {
  _inheritsLoose(PatternRuleValidator, _BaseRuleValidator7);
  function PatternRuleValidator() {
    var _this9;
    _this9 = _BaseRuleValidator7.call(this) || this;
    _this9.NAME = 'pattern';
    return _this9;
  }
  var _proto9 = PatternRuleValidator.prototype;
  _proto9._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    var pattern = rule.pattern;
    if ((0, _type.isString)(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value);
  };
  return PatternRuleValidator;
}(BaseRuleValidator);
var EmailRuleValidator = /*#__PURE__*/function (_BaseRuleValidator8) {
  _inheritsLoose(EmailRuleValidator, _BaseRuleValidator8);
  function EmailRuleValidator() {
    var _this10;
    _this10 = _BaseRuleValidator8.call(this) || this;
    _this10.NAME = 'email';
    return _this10;
  }
  var _proto10 = EmailRuleValidator.prototype;
  _proto10._validate = function _validate(value, rule) {
    if (rule.ignoreEmptyValue !== false && this._isValueEmpty(value)) {
      return true;
    }
    return rulesValidators.pattern.validate(value, (0, _extend.extend)({}, rule, {
      pattern: /^[\d\w._-]+@[\d\w._-]+\.[\w]+$/i
    }));
  };
  return EmailRuleValidator;
}(BaseRuleValidator);
var rulesValidators = {
  'required': new RequiredRuleValidator(),
  'numeric': new NumericRuleValidator(),
  'range': new RangeRuleValidator(),
  'stringLength': new StringLengthRuleValidator(),
  'custom': new CustomRuleValidator(),
  'async': new AsyncRuleValidator(),
  'compare': new CompareRuleValidator(),
  'pattern': new PatternRuleValidator(),
  'email': new EmailRuleValidator()
};
var GroupConfig = _class.default.inherit({
  ctor(group) {
    this.group = group;
    this.validators = [];
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new _events_strategy.EventsStrategy(this);
  },
  validate() {
    var _this11 = this;
    var result = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    (0, _iterator.each)(this.validators, function (_, validator) {
      var validatorResult = validator.validate();
      result.isValid = result.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result.brokenRules = result.brokenRules.concat(validatorResult.brokenRules);
      }
      result.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        _this11._addPendingValidator(validator);
      }
      _this11._subscribeToChangeEvents(validator);
    });
    if (this._pendingValidators.length) {
      result.status = STATUS.pending;
    } else {
      result.status = result.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result);
    }
    this._updateValidationInfo(result);
    return (0, _extend.extend)({}, this._validationInfo.result);
  },
  _subscribeToChangeEvents(validator) {
    validator.on('validating', this._onValidatorStatusChanged);
    validator.on('validated', this._onValidatorStatusChanged);
  },
  _unsubscribeFromChangeEvents(validator) {
    validator.off('validating', this._onValidatorStatusChanged);
    validator.off('validated', this._onValidatorStatusChanged);
  },
  _unsubscribeFromAllChangeEvents() {
    var _this12 = this;
    (0, _iterator.each)(this.validators, function (_, validator) {
      _this12._unsubscribeFromChangeEvents(validator);
    });
  },
  _updateValidationInfo(result) {
    this._validationInfo.result = result;
    if (result.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = new _deferred.Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  },
  _addPendingValidator(validator) {
    var foundValidator = (0, _common.grep)(this._pendingValidators, function (val) {
      return val === validator;
    })[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  },
  _removePendingValidator(validator) {
    var index = this._pendingValidators.indexOf(validator);
    if (index >= 0) {
      this._pendingValidators.splice(index, 1);
    }
  },
  _orderBrokenRules(brokenRules) {
    var orderedRules = [];
    (0, _iterator.each)(this.validators, function (_, validator) {
      var foundRules = (0, _common.grep)(brokenRules, function (rule) {
        return rule.validator === validator;
      });
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  },
  _updateBrokenRules(result) {
    if (!this._validationInfo.result) {
      return;
    }
    var brokenRules = this._validationInfo.result.brokenRules;
    var rules = (0, _common.grep)(brokenRules, function (rule) {
      return rule.validator !== result.validator;
    });
    if (result.brokenRules) {
      brokenRules = rules.concat(result.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  },
  _onValidatorStatusChanged(result) {
    if (result.status === STATUS.pending) {
      this._addPendingValidator(result.validator);
      return;
    }
    this._resolveIfComplete(result);
  },
  _resolveIfComplete(result) {
    this._removePendingValidator(result.validator);
    this._updateBrokenRules(result);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = this._validationInfo.result.brokenRules.length === 0 ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      var res = (0, _extend.extend)({}, this._validationInfo.result, {
        complete: null
      });
      var deferred = this._validationInfo.deferred;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout(function () {
        deferred.resolve(res);
      });
    }
  },
  _raiseValidatedEvent(result) {
    this._eventsStrategy.fireEvent('validated', [result]);
  },
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  },
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  },
  removeRegisteredValidator(validator) {
    var index = this.validators.indexOf(validator);
    if (index > -1) {
      this.validators.splice(index, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  },
  registerValidator(validator) {
    if (!this.validators.includes(validator)) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  },
  reset() {
    (0, _iterator.each)(this.validators, function (_, validator) {
      validator.reset();
    });
    this._pendingValidators = [];
    this._resetValidationInfo();
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
var ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    var result = (0, _common.grep)(this.groups, function (config) {
      return config.group === group;
    });
    if (result.length) {
      return result[0];
    }
  },
  findGroup($element, model) {
    var _$element$data, _$element$data$dxComp;
    var hasValidationGroup = (_$element$data = $element.data()) === null || _$element$data === void 0 ? void 0 : (_$element$data$dxComp = _$element$data.dxComponents) === null || _$element$data$dxComp === void 0 ? void 0 : _$element$data$dxComp.includes('dxValidationGroup');
    var validationGroup = hasValidationGroup && $element.dxValidationGroup('instance');
    if (validationGroup) {
      return validationGroup;
    }
    // try to find out if this control is child of validation group
    var $dxGroup = $element.parents('.dx-validationgroup').first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup('instance');
    }

    // Trick to be able to securely get ViewModel instance ($data) in Knockout
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup();
  },
  addGroup(group) {
    var config = this.getGroupConfig(group);
    if (!config) {
      config = new GroupConfig(group);
      this.groups.push(config);
    }
    return config;
  },
  removeGroup(group) {
    var config = this.getGroupConfig(group);
    var index = this.groups.indexOf(config);
    if (index > -1) {
      this.groups.splice(index, 1);
    }
    return config;
  },
  _setDefaultMessage(info) {
    var rule = info.rule,
      validator = info.validator,
      name = info.name;
    if (!(0, _type.isDefined)(rule.message)) {
      if (validator.defaultFormattedMessage && (0, _type.isDefined)(name)) {
        rule.message = validator.defaultFormattedMessage(name);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    var result = info.result,
      rule = info.rule;
    if (!result.brokenRule) {
      result.brokenRule = rule;
    }
    if (!result.brokenRules) {
      result.brokenRules = [];
    }
    result.brokenRules.push(rule);
  },
  validate(value, rules, name) {
    var _rules$,
      _this13 = this;
    var result = {
      name: name,
      value: value,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    var validator = rules === null || rules === void 0 ? void 0 : (_rules$ = rules[0]) === null || _rules$ === void 0 ? void 0 : _rules$.validator;
    var asyncRuleItems = [];
    (0, _iterator.each)(rules || [], function (_, rule) {
      var ruleValidator = rulesValidators[rule.type];
      var ruleValidationResult;
      if (ruleValidator) {
        if ((0, _type.isDefined)(rule.isValid) && rule.value === value && !rule.reevaluate) {
          if (!rule.isValid) {
            result.isValid = false;
            _this13._addBrokenRule({
              result,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value;
        if (rule.type === 'async') {
          asyncRuleItems.push({
            rule: rule,
            ruleValidator: ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result.isValid = false;
          _this13._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name
          });
          _this13._addBrokenRule({
            result,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw _errors.default.Error('E0100');
      }
    });
    if (result.isValid && !result.brokenRules && asyncRuleItems.length) {
      result = this._validateAsyncRules({
        value,
        items: asyncRuleItems,
        result,
        name
      });
    }
    this._synchronizeGroupValidationInfo(validator, result);
    result.status = result.pendingRules ? STATUS.pending : result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  _synchronizeGroupValidationInfo(validator, result) {
    var _result$brokenRules;
    if (!validator) {
      return;
    }
    var groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: (_result$brokenRules = result.brokenRules) !== null && _result$brokenRules !== void 0 ? _result$brokenRules : []
    });
  },
  _validateAsyncRules(_ref) {
    var _this14 = this;
    var result = _ref.result,
      value = _ref.value,
      items = _ref.items,
      name = _ref.name;
    var asyncResults = [];
    (0, _iterator.each)(items, function (_, item) {
      var validateResult = item.ruleValidator.validate(value, item.rule);
      if (!(0, _type.isPromise)(validateResult)) {
        _this14._updateRuleConfig({
          rule: item.rule,
          ruleResult: _this14._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name
        });
      } else {
        if (!result.pendingRules) {
          result.pendingRules = [];
        }
        result.pendingRules.push(item.rule);
        var asyncResult = validateResult.then(function (res) {
          var ruleResult = _this14._getPatchedRuleResult(res);
          _this14._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name
          });
          return ruleResult;
        });
        asyncResults.push(asyncResult);
      }
    });
    if (asyncResults.length) {
      result.complete = Promise.all(asyncResults).then(function (values) {
        return _this14._getAsyncRulesResult({
          result,
          values
        });
      });
    }
    return result;
  },
  _updateRuleConfig(_ref2) {
    var rule = _ref2.rule,
      ruleResult = _ref2.ruleResult,
      validator = _ref2.validator,
      name = _ref2.name;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if ((0, _type.isDefined)(ruleResult.message) && (0, _type.isString)(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator: validator,
          name
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    var result;
    var isValid = true;
    if ((0, _type.isObject)(ruleResult)) {
      result = (0, _extend.extend)({}, ruleResult);
      if (!(0, _type.isDefined)(result.isValid)) {
        result.isValid = isValid;
      }
    } else {
      result = {
        isValid: (0, _type.isBoolean)(ruleResult) ? ruleResult : isValid
      };
    }
    return result;
  },
  _getAsyncRulesResult(_ref3) {
    var _this15 = this;
    var values = _ref3.values,
      result = _ref3.result;
    (0, _iterator.each)(values, function (index, val) {
      if (val.isValid === false) {
        result.isValid = val.isValid;
        var rule = result.pendingRules[index];
        _this15._addBrokenRule({
          result,
          rule
        });
      }
    });
    result.pendingRules = null;
    result.complete = null;
    result.status = result.isValid ? STATUS.valid : STATUS.invalid;
    return result;
  },
  registerValidatorInGroup(group, validator) {
    var groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  _shouldRemoveGroup(group, validatorsInGroup) {
    var isDefaultGroup = group === undefined;
    var isValidationGroupInstance = group && group.NAME === 'dxValidationGroup';
    return !isDefaultGroup && !isValidationGroupInstance && !validatorsInGroup.length;
  },
  removeRegisteredValidator(group, validator) {
    var config = ValidationEngine.getGroupConfig(group);
    if (config) {
      config.removeRegisteredValidator.call(config, validator);
      var validatorsInGroup = config.validators;
      if (this._shouldRemoveGroup(group, validatorsInGroup)) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options) {
    var _this16 = this;
    var initedOptions = {};
    if (options) {
      var syncOptions = ['isValid', 'validationStatus', 'validationError', 'validationErrors'];
      syncOptions.forEach(function (prop) {
        if (prop in options) {
          (0, _extend.extend)(initedOptions, _this16.synchronizeValidationOptions({
            name: prop,
            value: options[prop]
          }, options));
        }
      });
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options) {
    var name = _ref4.name,
      value = _ref4.value;
    switch (name) {
      case 'validationStatus':
        {
          var isValid = value === STATUS.valid || value === STATUS.pending;
          return options.isValid !== isValid ? {
            isValid
          } : {};
        }
      case 'isValid':
        {
          var validationStatus = options.validationStatus;
          var newStatus = validationStatus;
          if (value && validationStatus === STATUS.invalid) {
            newStatus = STATUS.valid;
          } else if (!value && validationStatus !== STATUS.invalid) {
            newStatus = STATUS.invalid;
          }
          return newStatus !== validationStatus ? {
            validationStatus: newStatus
          } : {};
        }
      case 'validationErrors':
        {
          var validationError = !value || !value.length ? null : value[0];
          return options.validationError !== validationError ? {
            validationError
          } : {};
        }
      case 'validationError':
        {
          var validationErrors = options.validationErrors;
          if (!value && validationErrors) {
            return {
              validationErrors: null
            };
          } else if (value && !validationErrors) {
            return {
              validationErrors: [value]
            };
          } else if (value && validationErrors && value !== validationErrors[0]) {
            validationErrors[0] = value;
            return {
              validationErrors: validationErrors.slice()
            };
          }
        }
    }
    return {};
  },
  validateGroup(group) {
    var groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw _errors.default.Error('E0110');
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    var groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw _errors.default.Error('E0110');
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var _default = ValidationEngine;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 8336:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _size = __webpack_require__(58664);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _ui = _interopRequireDefault(__webpack_require__(89799));
var _extend = __webpack_require__(13306);
var _string = __webpack_require__(68752);
var _position = __webpack_require__(37518);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var INVALID_MESSAGE = 'dx-invalid-message';
var INVALID_MESSAGE_AUTO = 'dx-invalid-message-auto';
var INVALID_MESSAGE_ALWAYS = 'dx-invalid-message-always';
var INVALID_MESSAGE_CONTENT = 'dx-invalid-message-content';
var VALIDATION_MESSAGE_MIN_WIDTH = 100;
var ValidationMessage = _ui.default.inherit({
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: 'auto',
      height: 'auto',
      hideOnOutsideClick: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: '100%',
      container: this.$element(),
      target: undefined,
      mode: 'auto',
      validationErrors: undefined,
      preventScrollEvents: false,
      positionSide: 'top',
      boundary: undefined,
      offset: {
        h: 0,
        v: 0
      },
      contentId: undefined
    });
  },
  _init() {
    this.callBase();
    this.updateMaxWidth();
    this._updatePosition();
  },
  _initMarkup() {
    this.callBase();
    this._ensureMessageNotEmpty();
    this._updatePositionByTarget();
    this._toggleModeClass();
    this._updateContentId();
  },
  _updatePositionByTarget: function _updatePositionByTarget() {
    var _this$option = this.option(),
      target = _this$option.target;
    this.option('position.of', target);
  },
  _ensureMessageNotEmpty: function _ensureMessageNotEmpty() {
    this._textMarkup = this._getTextMarkup();
    var shouldShowMessage = this.option('visible') && this._textMarkup;
    this._toggleVisibilityClasses(shouldShowMessage);
  },
  _toggleVisibilityClasses: function _toggleVisibilityClasses(visible) {
    if (visible) {
      this.$element().addClass(INVALID_MESSAGE);
      this.$wrapper().addClass(INVALID_MESSAGE);
    } else {
      this.$element().removeClass(INVALID_MESSAGE);
      this.$wrapper().removeClass(INVALID_MESSAGE);
    }
  },
  _updateContentId() {
    var _this$option2 = this.option(),
      container = _this$option2.container,
      contentId = _this$option2.contentId;
    var id = contentId !== null && contentId !== void 0 ? contentId : (0, _renderer.default)(container).attr('aria-describedby');
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr('id', id);
  },
  _renderInnerHtml(element) {
    var $element = element && (0, _renderer.default)(element);
    $element === null || $element === void 0 ? void 0 : $element.html(this._textMarkup);
  },
  _getTextMarkup() {
    var _this$option3;
    var validationErrors = (_this$option3 = this.option('validationErrors')) !== null && _this$option3 !== void 0 ? _this$option3 : [];
    var validationErrorMessage = '';
    validationErrors.forEach(function (err) {
      var _err$message;
      var separator = validationErrorMessage ? '<br />' : '';
      validationErrorMessage += separator + (0, _string.encodeHtml)((_err$message = err === null || err === void 0 ? void 0 : err.message) !== null && _err$message !== void 0 ? _err$message : '');
    });
    return validationErrorMessage;
  },
  _toggleModeClass() {
    var mode = this.option('mode');
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, mode === 'auto').toggleClass(INVALID_MESSAGE_ALWAYS, mode === 'always');
  },
  updateMaxWidth() {
    var target = this.option('target');
    var targetWidth = (0, _size.getOuterWidth)(target);
    var maxWidth = '100%';
    if (targetWidth) {
      maxWidth = Math.max(targetWidth, VALIDATION_MESSAGE_MIN_WIDTH);
    }
    this.option({
      maxWidth
    });
  },
  _getPositionsArray: function _getPositionsArray(positionSide, rtlSide) {
    switch (positionSide) {
      case 'top':
        return ["".concat(rtlSide, " bottom"), "".concat(rtlSide, " top")];
      case 'left':
        return ['right', 'left'];
      case 'right':
        return ['left', 'right'];
      default:
        return ["".concat(rtlSide, " top"), "".concat(rtlSide, " bottom")];
    }
  },
  _updatePosition: function _updatePosition() {
    var _this$option4 = this.option(),
      positionSide = _this$option4.positionSide,
      rtlEnabled = _this$option4.rtlEnabled,
      componentOffset = _this$option4.offset,
      boundary = _this$option4.boundary;
    var rtlSide = (0, _position.getDefaultAlignment)(rtlEnabled);
    var positions = this._getPositionsArray(positionSide, rtlSide);
    var offset = _extends({}, componentOffset);
    this.$element().addClass("dx-invalid-message-".concat(positionSide));
    if (rtlEnabled && positionSide !== 'left' && positionSide !== 'right') offset.h = -offset.h;
    if (positionSide === 'top') offset.v = -offset.v;
    if (positionSide === 'left') offset.h = -offset.h;
    this.option('position', {
      offset,
      boundary,
      my: positions[0],
      at: positions[1],
      collision: 'none flip'
    });
  },
  _optionChanged(args) {
    var name = args.name,
      value = args.value,
      previousValue = args.previousValue;
    switch (name) {
      case 'target':
        this._updatePositionByTarget();
        this.updateMaxWidth();
        this.callBase(args);
        break;
      case 'boundary':
        this.option('position.boundary', value);
        break;
      case 'mode':
        this._toggleModeClass(value);
        break;
      case 'rtlEnabled':
      case 'offset':
      case 'positionSide':
        this.$element().removeClass("dx-invalid-message-".concat(previousValue));
        this._updatePosition();
        break;
      case 'container':
        this._updateContentId();
        this.callBase(args);
        break;
      case 'contentId':
        this._updateContentId();
        break;
      case 'validationErrors':
        this._ensureMessageNotEmpty();
        this._renderInnerHtml(this.$content());
        break;
      default:
        this.callBase(args);
    }
  }
});
(0, _component_registrator.default)('dxValidationMessage', ValidationMessage);
var _default = ValidationMessage;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 31421:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.tabbable = exports.focused = exports.focusable = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var focusableFn = function focusableFn(element, tabIndex) {
  if (!visible(element)) {
    return false;
  }
  var nodeName = element.nodeName.toLowerCase();
  var isTabIndexNotNaN = !isNaN(tabIndex);
  var isDisabled = element.disabled;
  var isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  var isHyperlink = nodeName === 'a';
  var isFocusable;
  var isContentEditable = element.isContentEditable;
  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else {
    if (isHyperlink) {
      isFocusable = element.href || isTabIndexNotNaN;
    } else {
      isFocusable = isTabIndexNotNaN;
    }
  }
  return isFocusable;
};
function visible(element) {
  var $element = (0, _renderer.default)(element);
  return $element.is(':visible') && $element.css('visibility') !== 'hidden' && $element.parents().css('visibility') !== 'hidden';
}
var focusable = function focusable(index, element) {
  return focusableFn(element, (0, _renderer.default)(element).attr('tabIndex'));
};
exports.focusable = focusable;
var tabbable = function tabbable(index, element) {
  var tabIndex = (0, _renderer.default)(element).attr('tabIndex');
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
};
// note: use this method instead of is(":focus")
exports.tabbable = tabbable;
var focused = function focused($element) {
  var element = (0, _renderer.default)($element).get(0);
  return _dom_adapter.default.getActiveElement(element) === element;
};
exports.focused = focused;

/***/ }),

/***/ 92591:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _view_port = __webpack_require__(77695);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var SWATCH_CONTAINER_CLASS_PREFIX = 'dx-swatch-';
var getSwatchContainer = function getSwatchContainer(element) {
  var $element = (0, _renderer.default)(element);
  var swatchContainer = $element.closest("[class^=\"".concat(SWATCH_CONTAINER_CLASS_PREFIX, "\"], [class*=\" ").concat(SWATCH_CONTAINER_CLASS_PREFIX, "\"]"));
  var viewport = (0, _view_port.value)();
  if (!swatchContainer.length) return viewport;
  var swatchClassRegex = new RegExp("(\\s|^)(".concat(SWATCH_CONTAINER_CLASS_PREFIX, ".*?)(\\s|$)"));
  var swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
  var viewportSwatchContainer = viewport.children('.' + swatchClass);
  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = (0, _renderer.default)('<div>').addClass(swatchClass).appendTo(viewport);
  }
  return viewportSwatchContainer;
};
var _default = {
  getSwatchContainer: getSwatchContainer
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 96688:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _error = _interopRequireDefault(__webpack_require__(95640));
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
* @docid
* @name ErrorsUIWidgets
*/
var _default = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsUIWidgets.E1001
  */
  E1001: 'Module \'{0}\'. Controller \'{1}\' is already registered',
  /**
  * @name ErrorsUIWidgets.E1002
  */
  E1002: 'Module \'{0}\'. Controller \'{1}\' does not inherit from DevExpress.ui.dxDataGrid.Controller',
  /**
  * @name ErrorsUIWidgets.E1003
  */
  E1003: 'Module \'{0}\'. View \'{1}\' is already registered',
  /**
  * @name ErrorsUIWidgets.E1004
  */
  E1004: 'Module \'{0}\'. View \'{1}\' does not inherit from DevExpress.ui.dxDataGrid.View',
  /**
  * @name ErrorsUIWidgets.E1005
  */
  E1005: 'Public method \'{0}\' is already registered',
  /**
  * @name ErrorsUIWidgets.E1006
  */
  E1006: 'Public method \'{0}.{1}\' does not exist',
  /**
  * @name ErrorsUIWidgets.E1007
  */
  E1007: 'State storing cannot be provided due to the restrictions of the browser',
  /**
  * @name ErrorsUIWidgets.E1010
  */
  E1010: 'The template does not contain the TextBox widget',
  /**
  * @name ErrorsUIWidgets.E1011
  */
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  /**
  * @name ErrorsUIWidgets.E1012
  */
  E1012: 'Editing type \'{0}\' with the name \'{1}\' is unsupported',
  /**
  * @name ErrorsUIWidgets.E1016
  */
  E1016: 'Unexpected type of data source is provided for a lookup column',
  /**
  * @name ErrorsUIWidgets.E1018
  */
  E1018: 'The \'collapseAll\' method cannot be called if you use a remote data source',
  /**
  * @name ErrorsUIWidgets.E1019
  */
  E1019: 'Search mode \'{0}\' is unavailable',
  /**
  * @name ErrorsUIWidgets.E1020
  */
  E1020: 'The type cannot be changed after initialization',
  /**
  * @name ErrorsUIWidgets.E1021
  */
  E1021: '{0} \'{1}\' you are trying to remove does not exist',
  /**
  * @name ErrorsUIWidgets.E1022
  */
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  /**
  * @name ErrorsUIWidgets.E1023
  */
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  /**
  * @name ErrorsUIWidgets.E1025
  */
  E1025: 'This layout is too complex to render',
  /**
  * @name ErrorsUIWidgets.E1026
  */
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  /**
  * @name ErrorsUIWidgets.E1031
  */
  E1031: 'Unknown subscription in the Scheduler widget: \'{0}\'',
  /**
  * @name ErrorsUIWidgets.E1032
  */
  E1032: 'Unknown start date in an appointment: \'{0}\'',
  /**
  * @name ErrorsUIWidgets.E1033
  */
  E1033: 'Unknown step in the date navigator: \'{0}\'',
  /**
  * @name ErrorsUIWidgets.E1034
  */
  E1034: 'The browser does not implement an API for saving files',
  /**
   * @name ErrorsUIWidgets.E1035
   */
  E1035: 'The editor cannot be created: {0}',
  /**
   * @name ErrorsUIWidgets.E1037
   */
  E1037: 'Invalid structure of grouped data',
  /**
   * @name ErrorsUIWidgets.E1038
   */
  E1038: 'The browser does not support local storages for local web pages',
  /**
  * @name ErrorsUIWidgets.E1039
  */
  E1039: 'A cell\'s position cannot be calculated',
  /**
   * @name ErrorsUIWidgets.E1040
   */
  E1040: 'The \'{0}\' key value is not unique within the data array',
  /**
   * @name ErrorsUIWidgets.E1041
   */
  E1041: 'The \'{0}\' script is referenced after the DevExtreme scripts or not referenced at all',
  /**
  * @name ErrorsUIWidgets.E1042
  */
  E1042: '{0} requires the key field to be specified',
  /**
  * @name ErrorsUIWidgets.E1043
  */
  E1043: 'Changes cannot be processed due to the incorrectly set key',
  /**
  * @name ErrorsUIWidgets.E1044
  */
  E1044: 'The key field specified by the keyExpr option does not match the key field specified in the data store',
  /**
  * @name ErrorsUIWidgets.E1045
  */
  E1045: 'Editing requires the key field to be specified in the data store',
  /**
  * @name ErrorsUIWidgets.E1046
  */
  E1046: 'The \'{0}\' key field is not found in data objects',
  /**
  * @name ErrorsUIWidgets.E1047
  */
  E1047: 'The "{0}" field is not found in the fields array',
  /**
  * @name ErrorsUIWidgets.E1048
  */
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  /**
  * @name ErrorsUIWidgets.E1049
  */
  E1049: 'Column \'{0}\': filtering is allowed but the \'dataField\' or \'name\' option is not specified',
  /**
  * @name ErrorsUIWidgets.E1050
  */
  E1050: 'The validationRules option does not apply to third-party editors defined in the editCellTemplate',
  /**
   * @name ErrorsUIWidgets.E1051
   */
  E1051: 'HtmlEditor\'s valueType is "{0}", but the {0} converter was not imported.',
  /**
  * @name ErrorsUIWidgets.E1052
  */
  E1052: '{0} should have the "dataSource" option specified',
  /**
  * @name ErrorsUIWidgets.E1053
  */
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  /**
  * @name ErrorsUIWidgets.E1054
  */
  E1054: 'All text editor buttons must have names',
  /**
  * @name ErrorsUIWidgets.E1055
  */
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  /**
  * @name ErrorsUIWidgets.E1056
  */
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  // NOTE:
  // E1057 is reserved. See https://js.devexpress.com/Documentation/19_2/ApiReference/UI_Widgets/Errors_and_Warnings/#E1057

  /**
  * @name ErrorsUIWidgets.E1058
  */
  E1058: 'The "startDayHour" must be earlier than the "endDayHour"',
  /**
  * @name ErrorsUIWidgets.E1059
  */
  E1059: 'The following column names are not unique: {0}',
  /**
  * @name ErrorsUIWidgets.E1060
  */
  E1060: 'All editable columns must have names',
  /**
  * @name ErrorsUIWidgets.W1001
  */
  W1001: 'The "key" option cannot be modified after initialization',
  /**
  * @name ErrorsUIWidgets.W1002
  */
  W1002: 'An item with the key \'{0}\' does not exist',
  /**
  * @name ErrorsUIWidgets.W1003
  */
  W1003: 'A group with the key \'{0}\' in which you are trying to select items does not exist',
  /**
  * @name ErrorsUIWidgets.W1004
  */
  W1004: 'The item \'{0}\' you are trying to select in the group \'{1}\' does not exist',
  /**
  * @name ErrorsUIWidgets.W1005
  */
  W1005: 'Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.',
  /**
  * @name ErrorsUIWidgets.W1006
  */
  W1006: 'The map service returned the following error: \'{0}\'',
  /**
   * @name ErrorsUIWidgets.W1007
   */
  W1007: 'No item with key {0} was found in the data source, but this key was used as the parent key for item {1}',
  /**
   * @name ErrorsUIWidgets.W1008
   */
  W1008: 'Cannot scroll to the \'{0}\' date because it does not exist on the current view',
  /**
   * @name ErrorsUIWidgets.W1009
   */
  W1009: 'Searching works only if data is specified using the dataSource option',
  /**
   * @name ErrorsUIWidgets.W1010
   */
  W1010: 'The capability to select all items works with source data of plain structure only',
  /**
   * @name ErrorsUIWidgets.W1011
   */
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: 'The \'{0}\' key field is not found in data objects',
  /**
  * @name ErrorsUIWidgets.W1013
  */
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  /**
  * @name ErrorsUIWidgets.W1014
  */
  W1014: 'The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.',
  /**
  * @name ErrorsUIWidgets.W1015
  */
  W1015: 'The "cellDuration" should divide the range from the "startDayHour" to the "endDayHour" into even intervals',
  /**
  * @name ErrorsUIWidgets.W1016
  */
  W1016: 'The \'{0}\' field in the HTML Editor toolbar item configuration was renamed to \'{1}\'. Please make a corresponding change in your code.',
  /**
  * @name ErrorsUIWidgets.W1017
  */
  W1017: 'The \'key\' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.',
  /**
  * @name ErrorsUIWidgets.W1018
  */
  W1018: 'Infinite scrolling may not work properly with multiple selection. To use these features together, set \'selection.deferred\' to true or set \'selection.selectAllMode\' to \'page\'.',
  /**
  * @name ErrorsUIWidgets.W1019
  */
  W1019: 'Filter query string exceeds maximum length limit of {0} characters.',
  /**
  * @name ErrorsUIWidgets.W1020
  */
  W1020: 'hideEvent is ignored when the shading property is true',
  /**
  * @name ErrorsUIWidgets.W1021
  */
  W1021: 'The \'{0}\' is not rendered because none of the DOM elements match the value of the "container" property.',
  /**
   * @name ErrorsUIWidgets.W1022
   */
  W1022: '{0} JSON parsing error: \'{1}\'',
  /**
   * @name ErrorsUIWidgets.W1023
   */
  W1023: 'Appointments require unique keys. Otherwise, the agenda view may not work correctly.',
  /**
   * @name ErrorsUIWidgets.W1024
   */
  W1024: 'The client-side export is enabled. Implement the \'onExporting\' function.'
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 14390:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _action = _interopRequireDefault(__webpack_require__(62414));
var _dom_component = _interopRequireDefault(__webpack_require__(13046));
var _short = __webpack_require__(72918);
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _selectors = __webpack_require__(31421);
var _type = __webpack_require__(35922);
var _devices = _interopRequireDefault(__webpack_require__(20530));
var _version = __webpack_require__(58020);
__webpack_require__(95429);
__webpack_require__(91633);
__webpack_require__(24028);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function setAttribute(name, value, target) {
  name = name === 'role' || name === 'id' ? name : "aria-".concat(name);
  value = (0, _type.isDefined)(value) ? value.toString() : null;
  target.attr(name, value);
}
var Widget = _dom_component.default.inherit({
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  _supportedKeys() {
    return {};
  },
  _getDefaultOptions() {
    return (0, _extend.extend)(this.callBase(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: undefined,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: undefined,
      /**
      * @section Utils
      * @type function
      * @default null
      * @type_function_param1 e:object
      * @type_function_param1_field1 component:this
      * @type_function_param1_field2 element:DxElement
      * @type_function_param1_field3 model:object
      * @name WidgetOptions.onFocusIn
      * @action
      * @hidden
      */
      onFocusIn: null,
      /**
      * @section Utils
      * @type function
      * @default null
      * @type_function_param1 e:object
      * @type_function_param1_field1 component:this
      * @type_function_param1_field2 element:DxElement
      * @type_function_param1_field3 model:object
      * @name WidgetOptions.onFocusOut
      * @action
      * @hidden
      */
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false,
      useResizeObserver: true
    });
  },
  _defaultOptionsRules: function _defaultOptionsRules() {
    return this.callBase().concat([{
      device: function device() {
        var device = _devices.default.real();
        var platform = device.platform;
        var version = device.version;
        return platform === 'ios' && (0, _version.compare)(version, '13.3') <= 0;
      },
      options: {
        useResizeObserver: false
      }
    }]);
  },
  _init() {
    this.callBase();
    this._initContentReadyAction();
  },
  _innerWidgetOptionChanged: function _innerWidgetOptionChanged(innerWidget, args) {
    var options = Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options);
    this._options.cache(args.name, options);
  },
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    var _this = this;
    var syncOptions = function syncOptions() {
      return _this._options.silent(optionsContainer, (0, _extend.extend)({}, innerWidget.option()));
    };
    syncOptions();
    innerWidget.on('optionChanged', syncOptions);
  },
  _getAriaTarget() {
    return this._focusTarget();
  },
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption('onContentReady', {
      excludeValidators: ['disabled', 'readOnly']
    });
  },
  _initMarkup() {
    var _this$option = this.option(),
      disabled = _this$option.disabled,
      visible = _this$option.visible;
    this.$element().addClass('dx-widget');
    this._toggleDisabledState(disabled);
    this._toggleVisibility(visible);
    this._renderHint();
    this._isFocusable() && this._renderFocusTarget();
    this.callBase();
  },
  _render() {
    this.callBase();
    this._renderContent();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
    this._toggleIndependentState();
  },
  _renderHint() {
    var _this$option2 = this.option(),
      hint = _this$option2.hint;
    this.$element().attr('title', hint || null);
  },
  _renderContent() {
    var _this2 = this;
    (0, _common.deferRender)(function () {
      return !_this2._disposed ? _this2._renderContentImpl() : void 0;
    }).done(function () {
      return !_this2._disposed ? _this2._fireContentReadyAction() : void 0;
    });
  },
  _renderContentImpl: _common.noop,
  _fireContentReadyAction: (0, _common.deferRenderer)(function () {
    return this._contentReadyAction();
  }),
  _dispose() {
    this._contentReadyAction = null;
    this._detachKeyboardEvents();
    this.callBase();
  },
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  },
  _clean() {
    this._cleanFocusState();
    this._resetActiveState();
    this.callBase();
    this.$element().empty();
  },
  _toggleVisibility(visible) {
    this.$element().toggleClass('dx-state-invisible', !visible);
  },
  _renderFocusState() {
    this._attachKeyboardEvents();
    if (this._isFocusable()) {
      this._renderFocusTarget();
      this._attachFocusEvents();
      this._renderAccessKey();
    }
  },
  _renderAccessKey() {
    var $el = this._focusTarget();
    var _this$option3 = this.option(),
      accessKey = _this$option3.accessKey;
    $el.attr('accesskey', accessKey);
  },
  _isFocusable() {
    var _this$option4 = this.option(),
      focusStateEnabled = _this$option4.focusStateEnabled,
      disabled = _this$option4.disabled;
    return focusStateEnabled && !disabled;
  },
  _eventBindingTarget() {
    return this.$element();
  },
  _focusTarget() {
    return this._getActiveElement();
  },
  _isFocusTarget: function _isFocusTarget(element) {
    var focusTargets = (0, _renderer.default)(this._focusTarget()).toArray();
    return focusTargets.includes(element);
  },
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit).not('.dx-state-disabled');
  },
  _getActiveElement() {
    var activeElement = this._eventBindingTarget();
    if (this._activeStateUnit) {
      return this._findActiveTarget(activeElement);
    }
    return activeElement;
  },
  _renderFocusTarget() {
    var _this$option5 = this.option(),
      tabIndex = _this$option5.tabIndex;
    this._focusTarget().attr('tabIndex', tabIndex);
  },
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  },
  _refreshFocusEvent() {
    this._detachFocusEvents();
    this._attachFocusEvents();
  },
  _focusEventTarget() {
    return this._focusTarget();
  },
  _focusInHandler(event) {
    var _this3 = this;
    if (!event.isDefaultPrevented()) {
      this._createActionByOption('onFocusIn', {
        beforeExecute: function beforeExecute() {
          return _this3._updateFocusState(event, true);
        },
        excludeValidators: ['readOnly']
      })({
        event
      });
    }
  },
  _focusOutHandler(event) {
    var _this4 = this;
    if (!event.isDefaultPrevented()) {
      this._createActionByOption('onFocusOut', {
        beforeExecute: function beforeExecute() {
          return _this4._updateFocusState(event, false);
        },
        excludeValidators: ['readOnly', 'disabled']
      })({
        event
      });
    }
  },
  _updateFocusState(_ref, isFocused) {
    var target = _ref.target;
    if (this._isFocusTarget(target)) {
      this._toggleFocusClass(isFocused, (0, _renderer.default)(target));
    }
  },
  _toggleFocusClass(isFocused, $element) {
    var $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass('dx-state-focused', isFocused);
  },
  _hasFocusClass(element) {
    var $focusTarget = (0, _renderer.default)(element || this._focusTarget());
    return $focusTarget.hasClass('dx-state-focused');
  },
  _isFocused() {
    return this._hasFocusClass();
  },
  _getKeyboardListeners() {
    return [];
  },
  _attachKeyboardEvents() {
    var _this5 = this;
    this._detachKeyboardEvents();
    var _this$option6 = this.option(),
      focusStateEnabled = _this$option6.focusStateEnabled,
      onKeyboardHandled = _this$option6.onKeyboardHandled;
    var hasChildListeners = this._getKeyboardListeners().length;
    var hasKeyboardEventHandler = !!onKeyboardHandled;
    var shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
    if (shouldAttach) {
      this._keyboardListenerId = _short.keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), function (opts) {
        return _this5._keyboardHandler(opts);
      });
    }
  },
  _keyboardHandler(options, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      var originalEvent = options.originalEvent,
        keyName = options.keyName,
        which = options.which;
      var keys = this._supportedKeys(originalEvent);
      var func = keys[keyName] || keys[which];
      if (func !== undefined) {
        var handler = func.bind(this);
        var result = handler(originalEvent, options);
        if (!result) {
          return false;
        }
      }
    }
    var keyboardListeners = this._getKeyboardListeners();
    var _this$option7 = this.option(),
      onKeyboardHandled = _this$option7.onKeyboardHandled;
    keyboardListeners.forEach(function (listener) {
      return listener && listener._keyboardHandler(options);
    });
    onKeyboardHandled && onKeyboardHandled(options);
    return true;
  },
  _refreshFocusState() {
    this._cleanFocusState();
    this._renderFocusState();
  },
  _cleanFocusState() {
    var $element = this._focusTarget();
    $element.removeAttr('tabIndex');
    this._toggleFocusClass(false);
    this._detachFocusEvents();
    this._detachKeyboardEvents();
  },
  _detachKeyboardEvents() {
    _short.keyboard.off(this._keyboardListenerId);
    this._keyboardListenerId = null;
  },
  _attachHoverEvents() {
    var _this6 = this;
    var _this$option8 = this.option(),
      hoverStateEnabled = _this$option8.hoverStateEnabled;
    var selector = this._activeStateUnit;
    var namespace = 'UIFeedback';
    var $el = this._eventBindingTarget();
    _short.hover.off($el, {
      selector,
      namespace
    });
    if (hoverStateEnabled) {
      _short.hover.on($el, new _action.default(function (_ref2) {
        var event = _ref2.event,
          element = _ref2.element;
        _this6._hoverStartHandler(event);
        _this6.option('hoveredElement', (0, _renderer.default)(element));
      }, {
        excludeValidators: ['readOnly']
      }), function (event) {
        _this6.option('hoveredElement', null);
        _this6._hoverEndHandler(event);
      }, {
        selector,
        namespace
      });
    }
  },
  _attachFeedbackEvents() {
    var _this7 = this;
    var _this$option9 = this.option(),
      activeStateEnabled = _this$option9.activeStateEnabled;
    var selector = this._activeStateUnit;
    var namespace = 'UIFeedback';
    var $el = this._eventBindingTarget();
    _short.active.off($el, {
      namespace,
      selector
    });
    if (activeStateEnabled) {
      _short.active.on($el, new _action.default(function (_ref3) {
        var event = _ref3.event,
          element = _ref3.element;
        return _this7._toggleActiveState((0, _renderer.default)(element), true, event);
      }), new _action.default(function (_ref4) {
        var event = _ref4.event,
          element = _ref4.element;
        return _this7._toggleActiveState((0, _renderer.default)(element), false, event);
      }, {
        excludeValidators: ['disabled', 'readOnly']
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector,
        namespace
      });
    }
  },
  _detachFocusEvents() {
    var $el = this._focusEventTarget();
    _short.focus.off($el, {
      namespace: "".concat(this.NAME, "Focus")
    });
  },
  _attachFocusEvents() {
    var _this8 = this;
    var $el = this._focusEventTarget();
    _short.focus.on($el, function (e) {
      return _this8._focusInHandler(e);
    }, function (e) {
      return _this8._focusOutHandler(e);
    }, {
      namespace: "".concat(this.NAME, "Focus"),
      isFocusable: function isFocusable(index, el) {
        return (0, _renderer.default)(el).is(_selectors.focusable);
      }
    });
  },
  _hoverStartHandler: _common.noop,
  _hoverEndHandler: _common.noop,
  _toggleActiveState($element, value) {
    this.option('isActive', value);
    $element.toggleClass('dx-state-active', value);
  },
  _updatedHover() {
    var hoveredElement = this._options.silent('hoveredElement');
    this._hover(hoveredElement, hoveredElement);
  },
  _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  },
  _hover($el, $previous) {
    var _this$option10 = this.option(),
      hoverStateEnabled = _this$option10.hoverStateEnabled,
      disabled = _this$option10.disabled,
      isActive = _this$option10.isActive;
    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass('dx-state-hover', false);
    if ($el && hoverStateEnabled && !disabled && !isActive) {
      var newHoveredElement = this._findHoverTarget($el);
      newHoveredElement && newHoveredElement.toggleClass('dx-state-hover', true);
    }
  },
  _toggleDisabledState(value) {
    this.$element().toggleClass('dx-state-disabled', Boolean(value));
    this.setAria('disabled', value || undefined);
  },
  _toggleIndependentState() {
    this.$element().toggleClass('dx-state-independent', this.option('ignoreParentReadOnly'));
  },
  _setWidgetOption(widgetName, args) {
    var _this9 = this;
    if (!this[widgetName]) {
      return;
    }
    if ((0, _type.isPlainObject)(args[0])) {
      (0, _iterator.each)(args[0], function (option, value) {
        return _this9._setWidgetOption(widgetName, [option, value]);
      });
      return;
    }
    var optionName = args[0];
    var value = args[1];
    if (args.length === 1) {
      value = this.option(optionName);
    }
    var widgetOptionMap = this["".concat(widgetName, "OptionMap")];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value);
  },
  _optionChanged(args) {
    var name = args.name,
      value = args.value,
      previousValue = args.previousValue;
    switch (name) {
      case 'disabled':
        this._toggleDisabledState(value);
        this._updatedHover();
        this._refreshFocusState();
        break;
      case 'hint':
        this._renderHint();
        break;
      case 'ignoreParentReadOnly':
        this._toggleIndependentState();
        break;
      case 'activeStateEnabled':
        this._attachFeedbackEvents();
        break;
      case 'hoverStateEnabled':
        this._attachHoverEvents();
        this._updatedHover();
        break;
      case 'tabIndex':
      case 'focusStateEnabled':
        this._refreshFocusState();
        break;
      case 'onFocusIn':
      case 'onFocusOut':
      case 'useResizeObserver':
        break;
      case 'accessKey':
        this._renderAccessKey();
        break;
      case 'hoveredElement':
        this._hover(value, previousValue);
        break;
      case 'isActive':
        this._updatedHover();
        break;
      case 'visible':
        this._toggleVisibility(value);
        if (this._isVisibilityChangeSupported()) {
          // TODO hiding works wrong
          this._checkVisibilityChanged(value ? 'shown' : 'hiding');
        }
        break;
      case 'onKeyboardHandled':
        this._attachKeyboardEvents();
        break;
      case 'onContentReady':
        this._initContentReadyAction();
        break;
      default:
        this.callBase(args);
    }
  },
  _isVisible() {
    var _this$option11 = this.option(),
      visible = _this$option11.visible;
    return this.callBase() && visible;
  },
  beginUpdate() {
    this._ready(false);
    this.callBase();
  },
  endUpdate() {
    this.callBase();
    if (this._initialized) {
      this._ready(true);
    }
  },
  _ready(value) {
    if (arguments.length === 0) {
      return this._isReady;
    }
    this._isReady = value;
  },
  setAria() {
    if (!(0, _type.isPlainObject)(arguments.length <= 0 ? undefined : arguments[0])) {
      setAttribute(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], (arguments.length <= 2 ? undefined : arguments[2]) || this._getAriaTarget());
    } else {
      var target = (arguments.length <= 1 ? undefined : arguments[1]) || this._getAriaTarget();
      (0, _iterator.each)(arguments.length <= 0 ? undefined : arguments[0], function (name, value) {
        return setAttribute(name, value, target);
      });
    }
  },
  isReady() {
    return this._ready();
  },
  repaint() {
    this._refresh();
  },
  focus() {
    _short.focus.trigger(this._focusTarget());
  },
  registerKeyHandler(key, handler) {
    var currentKeys = this._supportedKeys();
    this._supportedKeys = function () {
      return (0, _extend.extend)(currentKeys, {
        [key]: handler
      });
    };
  }
});
Widget.getOptionsFromContainer = function (_ref5) {
  var name = _ref5.name,
    fullName = _ref5.fullName,
    value = _ref5.value;
  var options = {};
  if (name === fullName) {
    options = value;
  } else {
    var option = fullName.split('.').pop();
    options[option] = value;
  }
  return options;
};
var _default = Widget;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 53805:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _default = {
  logarithmic: 'logarithmic',
  discrete: 'discrete',
  numeric: 'numeric',
  left: 'left',
  right: 'right',
  top: 'top',
  bottom: 'bottom',
  center: 'center',
  horizontal: 'horizontal',
  vertical: 'vertical',
  convertTicksToValues: function convertTicksToValues(ticks) {
    return (0, _utils.map)(ticks || [], function (item) {
      return item.value;
    });
  },
  validateOverlappingMode: function validateOverlappingMode(mode) {
    return mode === 'ignore' || mode === 'none' ? mode : 'hide';
  },
  getTicksCountInRange: function getTicksCountInRange(ticks, valueKey, range) {
    var i = 1;
    if (ticks.length > 1) {
      for (; i < ticks.length; i++) {
        if (Math.abs(ticks[i].coords[valueKey] - ticks[0].coords[valueKey]) >= range) {
          break;
        }
      }
    }
    return i;
  },
  areLabelsOverlap: function areLabelsOverlap(bBox1, bBox2, spacing, alignment) {
    var horizontalInverted = bBox1.x > bBox2.x;
    var verticalInverted = bBox1.y > bBox2.y;
    var x1 = bBox1.x;
    var x2 = bBox2.x;
    var width1 = bBox1.width;
    var width2 = bBox2.width;
    if (alignment === 'left') {
      x1 += width1 / 2;
      x2 += width2 / 2;
    } else if (alignment === 'right') {
      x1 -= width1 / 2;
      x2 -= width2 / 2;
    }
    var hasHorizontalOverlapping = horizontalInverted ? x2 + width2 + spacing > x1 : x1 + width1 + spacing > x2;
    var hasVerticalOverlapping = verticalInverted ? bBox2.y + bBox2.height > bBox1.y : bBox1.y + bBox1.height > bBox2.y;
    return hasHorizontalOverlapping && hasVerticalOverlapping;
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 32945:
/***/ (function(__unused_webpack_module, exports) {



exports.measureLabels = exports.calculateCanvasMargins = void 0;
var _max = Math.max;
var calculateCanvasMargins = function calculateCanvasMargins(bBoxes, canvas) {
  var cLeft = canvas.left;
  var cTop = canvas.top;
  var cRight = canvas.width - canvas.right;
  var cBottom = canvas.height - canvas.bottom;
  return bBoxes.reduce(function (margins, bBox) {
    if (!bBox || bBox.isEmpty) {
      return margins;
    }
    return {
      left: _max(margins.left, cLeft - bBox.x),
      top: _max(margins.top, cTop - bBox.y),
      right: _max(margins.right, bBox.x + bBox.width - cRight),
      bottom: _max(margins.bottom, bBox.y + bBox.height - cBottom)
    };
  }, {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  });
};
exports.calculateCanvasMargins = calculateCanvasMargins;
var measureLabels = function measureLabels(items) {
  items.forEach(function (item) {
    var label = item.getContentContainer();
    item.labelBBox = label ? label.getBBox() : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  });
};
exports.measureLabels = measureLabels;

/***/ }),

/***/ 41278:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Axis = void 0;
var _smart_formatter = __webpack_require__(41583);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
var _extend = __webpack_require__(13306);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _parse_utils = __webpack_require__(8587);
var _tick_generator = __webpack_require__(45971);
var _translator2d = __webpack_require__(87276);
var _range = __webpack_require__(21177);
var _tick = __webpack_require__(41013);
var _math2 = __webpack_require__(60810);
var _errors = _interopRequireDefault(__webpack_require__(17381));
var _date = _interopRequireDefault(__webpack_require__(91198));
var _common = __webpack_require__(20576);
var _xy_axes = _interopRequireDefault(__webpack_require__(99415));
var polarMethods = _interopRequireWildcard(__webpack_require__(4331));
var _constant_line = _interopRequireDefault(__webpack_require__(87713));
var _strip = _interopRequireDefault(__webpack_require__(54978));
var _deferred = __webpack_require__(62754);
var _axes_utils = __webpack_require__(32945);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var convertTicksToValues = _axes_constants.default.convertTicksToValues;
var _math = Math;
var _abs = _math.abs;
var _max = _math.max;
var _min = _math.min;
var _isArray = Array.isArray;
var DEFAULT_AXIS_LABEL_SPACING = 5;
var MAX_GRID_BORDER_ADHENSION = 4;
var TOP = _axes_constants.default.top;
var BOTTOM = _axes_constants.default.bottom;
var LEFT = _axes_constants.default.left;
var RIGHT = _axes_constants.default.right;
var CENTER = _axes_constants.default.center;
var KEEP = 'keep';
var SHIFT = 'shift';
var RESET = 'reset';
var ROTATE = 'rotate';
var DEFAULT_AXIS_DIVISION_FACTOR = 50;
var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
var SCROLL_THRESHOLD = 5;
var MIN_BAR_MARGIN = 5;
var MAX_MARGIN_VALUE = 0.8;
var dateIntervals = {
  day: 86400000,
  week: 604800000
};
function getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {
  var _options$workWeek;
  var allowNegatives = _ref.allowNegatives,
    linearThreshold = _ref.linearThreshold;
  return (0, _tick_generator.tickGenerator)({
    axisType: options.type,
    dataType: options.dataType,
    logBase: options.logarithmBase,
    allowNegatives,
    linearThreshold,
    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),
    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),
    numberMultipliers: options.numberMultipliers,
    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,
    allowDecimals: options.allowDecimals,
    endOnTick: options.endOnTick,
    incidentOccurred: incidentOccurred,
    firstDayOfWeek: (_options$workWeek = options.workWeek) === null || _options$workWeek === void 0 ? void 0 : _options$workWeek[0],
    skipTickGeneration: skipTickGeneration,
    skipCalculationLimits: options.skipCalculationLimits,
    generateExtraTick: options.generateExtraTick,
    minTickInterval: options.minTickInterval,
    rangeIsEmpty
  });
}
function createMajorTick(axis, renderer, skippedCategory) {
  var options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, options.tick, options.grid, skippedCategory, false);
}
function createMinorTick(axis, renderer) {
  var options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, options.minorTick, options.minorGrid);
}
function createBoundaryTick(axis, renderer, isFirst) {
  var options = axis.getOptions();
  return (0, _tick.tick)(axis, renderer, (0, _extend.extend)({}, options.tick, {
    visible: options.showCustomBoundaryTicks
  }), options.grid, undefined, false, isFirst ? -1 : 1);
}
function callAction(elements, action, actionArgument1, actionArgument2) {
  (elements || []).forEach(function (e) {
    return e[action](actionArgument1, actionArgument2);
  });
}
function initTickCoords(ticks) {
  callAction(ticks, 'initCoords');
}
function drawTickMarks(ticks, options) {
  callAction(ticks, 'drawMark', options);
}
function drawGrids(ticks, drawLine) {
  callAction(ticks, 'drawGrid', drawLine);
}
function updateTicksPosition(ticks, options, animate) {
  callAction(ticks, 'updateTickPosition', options, animate);
}
function updateGridsPosition(ticks, animate) {
  callAction(ticks, 'updateGridPosition', animate);
}
function cleanUpInvalidTicks(ticks) {
  var i = ticks.length - 1;
  for (i; i >= 0; i--) {
    if (!removeInvalidTick(ticks, i)) {
      break;
    }
  }
  for (i = 0; i < ticks.length; i++) {
    if (removeInvalidTick(ticks, i)) {
      i--;
    } else {
      break;
    }
  }
}
function removeInvalidTick(ticks, i) {
  if (ticks[i].coords.x === null || ticks[i].coords.y === null) {
    ticks.splice(i, 1);
    return true;
  }
  return false;
}
function validateAxisOptions(options) {
  var _labelOptions$minSpac;
  var labelOptions = options.label;
  var position = options.position;
  var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;
  var secondaryPosition = options.isHorizontal ? TOP : RIGHT;
  var labelPosition = labelOptions.position;
  if (position !== defaultPosition && position !== secondaryPosition) {
    position = defaultPosition;
  }
  if (!labelPosition || labelPosition === 'outside') {
    labelPosition = position;
  } else if (labelPosition === 'inside') {
    labelPosition = {
      [TOP]: BOTTOM,
      [BOTTOM]: TOP,
      [LEFT]: RIGHT,
      [RIGHT]: LEFT
    }[position];
  }
  if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {
    labelPosition = position;
  }
  if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {
    labelOptions.alignment = {
      [TOP]: CENTER,
      [BOTTOM]: CENTER,
      [LEFT]: RIGHT,
      [RIGHT]: LEFT
    }[labelPosition];
  }
  options.position = position;
  labelOptions.position = labelPosition;
  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : 'none';
  labelOptions.minSpacing = (_labelOptions$minSpac = labelOptions.minSpacing) !== null && _labelOptions$minSpac !== void 0 ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;
  options.type && (options.type = options.type.toLowerCase());
  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());
  options.valueType && (options.valueType = options.valueType.toLowerCase());
}
function getOptimalAngle(boxes, labelOpt) {
  var angle = _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) * 180 / _math.PI;
  return angle < 45 ? -45 : -90;
}
function updateLabels(ticks, step, func) {
  ticks.forEach(function (tick, index) {
    if (tick.getContentContainer()) {
      if (index % step !== 0) {
        tick.removeLabel();
      } else if (func) {
        func(tick, index);
      }
    }
  });
}
function getZoomBoundValue(optionValue, dataValue) {
  if (optionValue === undefined) {
    return dataValue;
  } else if (optionValue === null) {
    return undefined;
  } else {
    return optionValue;
  }
}
function configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {
  var tickGeneratorOptions = (0, _extend.extend)({}, options, {
    endOnTick: true,
    axisDivisionFactor,
    skipCalculationLimits: true,
    generateExtraTick: true,
    minTickInterval
  });
  return function (tickInterval, skipTickGeneration, min, max, breaks) {
    return getTickGenerator(tickGeneratorOptions, _common.noop, skipTickGeneration, viewPort.isEmpty(), function (v) {
      return v;
    }, viewPort)({
      min: min,
      max: max,
      categories: viewPort.categories,
      isSpacedMargin: viewPort.isSpacedMargin
    }, screenDelta, tickInterval, (0, _type.isDefined)(tickInterval), undefined, undefined, undefined, breaks);
  };
}
function getConstantLineSharpDirection(coord, axisCanvas) {
  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;
}
function checkDeprecatedOptions(isValueAxis, options) {
  if (isValueAxis && options.visualRangeUpdateMode === 'shift') {
    _errors.default.log('W0016', 'valueAxis.visualRangeUpdateMode', 'shift', '23.1', 'Specify another value');
  }
}
var Axis = function Axis(renderSettings) {
  var that = this;
  that._renderer = renderSettings.renderer;
  that._incidentOccurred = renderSettings.incidentOccurred;
  that._eventTrigger = renderSettings.eventTrigger;
  that._stripsGroup = renderSettings.stripsGroup;
  that._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;
  that._labelsAxesGroup = renderSettings.labelsAxesGroup;
  that._constantLinesGroup = renderSettings.constantLinesGroup;
  that._scaleBreaksGroup = renderSettings.scaleBreaksGroup;
  that._axesContainerGroup = renderSettings.axesContainerGroup;
  that._gridContainerGroup = renderSettings.gridGroup;
  that._axisCssPrefix = renderSettings.widgetClass + '-' + (renderSettings.axisClass ? renderSettings.axisClass + '-' : '');
  that._setType(renderSettings.axisType, renderSettings.drawingType);
  that._createAxisGroups();
  that._translator = that._createTranslator();
  that.isArgumentAxis = renderSettings.isArgumentAxis;
  that._viewport = {};
  that._prevDataInfo = {};
  that._firstDrawing = true;
  that._initRange = {};
  that._getTemplate = renderSettings.getTemplate;
};
exports.Axis = Axis;
Axis.prototype = {
  constructor: Axis,
  _drawAxis() {
    var options = this._options;
    if (!options.visible) {
      return;
    }
    this._axisElement = this._createAxisElement();
    this._updateAxisElementPosition();
    this._axisElement.attr({
      'stroke-width': options.width,
      stroke: options.color,
      'stroke-opacity': options.opacity
    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);
  },
  _createPathElement(points, attr, sharpDirection) {
    return this.sharp(this._renderer.path(points, 'line').attr(attr), sharpDirection);
  },
  sharp(svgElement) {
    var sharpDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return svgElement.sharp(this._getSharpParam(), sharpDirection);
  },
  customPositionIsAvailable() {
    return false;
  },
  getOrthogonalAxis: _common.noop,
  getCustomPosition: _common.noop,
  getCustomBoundaryPosition: _common.noop,
  resolveOverlappingForCustomPositioning: _common.noop,
  hasNonBoundaryPosition() {
    return false;
  },
  customPositionIsBoundaryOrthogonalAxis() {
    return false;
  },
  getResolvedBoundaryPosition() {
    return this.getOptions().position;
  },
  getAxisSharpDirection() {
    var position = this.getResolvedBoundaryPosition();
    return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1;
  },
  getSharpDirectionByCoords(coords) {
    var canvas = this._getCanvasStartEnd();
    var maxCoord = Math.max(canvas.start, canvas.end);
    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? 'x' : 'y'] ? 1 : -1;
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      var grid = that._getGridPoints(tick.coords);
      if (grid.points) {
        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));
      }
      return null;
    };
  },
  _getGridPoints: function _getGridPoints(coords) {
    var that = this;
    var isHorizontal = this._isHorizontal;
    var tickPositionField = isHorizontal ? 'x' : 'y';
    var orthogonalPositions = this._orthogonalPositions;
    var positionFrom = orthogonalPositions.start;
    var positionTo = orthogonalPositions.end;
    var borderOptions = that.borderOptions;
    var canvasStart = isHorizontal ? LEFT : TOP;
    var canvasEnd = isHorizontal ? RIGHT : BOTTOM;
    var axisCanvas = that.getCanvas();
    var canvas = {
      left: axisCanvas.left,
      right: axisCanvas.width - axisCanvas.right,
      top: axisCanvas.top,
      bottom: axisCanvas.height - axisCanvas.bottom
    };
    var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : undefined;
    var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : undefined;
    var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;
    var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;
    if (that.areCoordsOutsideAxis(coords) || coords[tickPositionField] === undefined || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {
      return {
        points: null
      };
    }
    return {
      points: isHorizontal ? coords[tickPositionField] !== null ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : coords[tickPositionField] !== null ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null
    };
  },
  _getConstantLinePos: function _getConstantLinePos(parsedValue, canvasStart, canvasEnd) {
    var value = this._getTranslatedCoord(parsedValue);
    if (!(0, _type.isDefined)(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {
      return undefined;
    }
    return value;
  },
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    var positionFrom = this._orthogonalPositions.start;
    var positionTo = this._orthogonalPositions.end;
    return {
      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]
    };
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));
  },
  _drawConstantLineLabelText: function _drawConstantLineLabelText(text, x, y, _ref2, group) {
    var font = _ref2.font,
      cssClass = _ref2.cssClass;
    return this._renderer.text(text, x, y).css((0, _utils.patchFontOptions)((0, _extend.extend)({}, this._options.label.font, font))).attr({
      align: 'center',
      'class': cssClass
    }).append(group);
  },
  _drawConstantLineLabels: function _drawConstantLineLabels(parsedValue, lineLabelOptions, value, group) {
    var _text;
    var that = this;
    var text = lineLabelOptions.text;
    var options = that._options;
    var labelOptions = options.label;
    that._checkAlignmentConstantLineLabels(lineLabelOptions);
    text = (_text = text) !== null && _text !== void 0 ? _text : that.formatLabel(parsedValue, labelOptions);
    var coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);
    return that._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);
  },
  _getStripPos: function _getStripPos(startValue, endValue, canvasStart, canvasEnd, range) {
    var isContinuous = !!(range.minVisible || range.maxVisible);
    var categories = (range.categories || []).reduce(function (result, cat) {
      result.push(cat.valueOf());
      return result;
    }, []);
    var start;
    var end;
    var swap;
    var startCategoryIndex;
    var endCategoryIndex;
    if (!isContinuous) {
      if ((0, _type.isDefined)(startValue) && (0, _type.isDefined)(endValue)) {
        var _parsedStartValue$val, _parsedEndValue$value;
        var parsedStartValue = this.parser(startValue);
        var parsedEndValue = this.parser(endValue);
        startCategoryIndex = categories.indexOf((_parsedStartValue$val = parsedStartValue === null || parsedStartValue === void 0 ? void 0 : parsedStartValue.valueOf()) !== null && _parsedStartValue$val !== void 0 ? _parsedStartValue$val : undefined);
        endCategoryIndex = categories.indexOf((_parsedEndValue$value = parsedEndValue === null || parsedEndValue === void 0 ? void 0 : parsedEndValue.valueOf()) !== null && _parsedEndValue$value !== void 0 ? _parsedEndValue$value : undefined);
        if (startCategoryIndex === -1 || endCategoryIndex === -1) {
          return {
            from: 0,
            to: 0,
            outOfCanvas: true
          };
        }
        if (startCategoryIndex > endCategoryIndex) {
          swap = endValue;
          endValue = startValue;
          startValue = swap;
        }
      }
    }
    if ((0, _type.isDefined)(startValue)) {
      startValue = this.validateUnit(startValue, 'E2105', 'strip');
      start = this._getTranslatedCoord(startValue, -1);
    } else {
      start = canvasStart;
    }
    if ((0, _type.isDefined)(endValue)) {
      endValue = this.validateUnit(endValue, 'E2105', 'strip');
      end = this._getTranslatedCoord(endValue, 1);
    } else {
      end = canvasEnd;
    }
    var stripPosition = start < end ? {
      from: start,
      to: end
    } : {
      from: end,
      to: start
    };
    var visibleArea = this.getVisibleArea();
    if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {
      stripPosition.outOfCanvas = true;
    }
    return stripPosition;
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {
    var x;
    var y;
    var width;
    var height;
    var orthogonalPositions = this._orthogonalPositions;
    var positionFrom = orthogonalPositions.start;
    var positionTo = orthogonalPositions.end;
    if (this._isHorizontal) {
      x = fromPoint;
      y = _min(positionFrom, positionTo);
      width = toPoint - fromPoint;
      height = _abs(positionFrom - positionTo);
    } else {
      x = _min(positionFrom, positionTo);
      y = fromPoint;
      width = _abs(positionFrom - positionTo);
      height = _abs(fromPoint - toPoint);
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  _createStrip: function _createStrip(attrs) {
    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);
  },
  _adjustStripLabels: function _adjustStripLabels() {
    var that = this;
    this._strips.forEach(function (strip) {
      if (strip.label) {
        strip.label.attr(that._getAdjustedStripLabelCoords(strip));
      }
    });
  },
  _adjustLabelsCoord(offset, maxWidth, checkCanvas) {
    var _this = this;
    var that = this;
    var getContainerAttrs = function getContainerAttrs(tick) {
      return _this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);
    };
    that._majorTicks.forEach(function (tick) {
      if (tick.label) {
        tick.updateMultilineTextAlignment();
        tick.label.attr(getContainerAttrs(tick));
      } else {
        tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick));
      }
    });
  },
  _adjustLabels: function _adjustLabels(offset) {
    var that = this;
    var options = that.getOptions();
    var positionsAreConsistent = options.position === options.label.position;
    var maxSize = that._majorTicks.reduce(function (size, tick) {
      if (!tick.getContentContainer()) return size;
      var bBox = tick.labelRotationAngle ? (0, _utils.rotateBBox)(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;
      return {
        width: _max(size.width || 0, bBox.width),
        height: _max(size.height || 0, bBox.height),
        offset: _max(size.offset || 0, tick.labelOffset || 0)
      };
    }, {});
    var additionalOffset = positionsAreConsistent ? that._isHorizontal ? maxSize.height : maxSize.width : 0;
    that._adjustLabelsCoord(offset, maxSize.width);
    return offset + additionalOffset + (additionalOffset && that._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0);
  },
  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick, offset, maxWidth) {
    offset = offset || 0;
    var that = this;
    var options = that._options;
    var templateBox = tick.templateContainer && tick.templateContainer.getBBox();
    var box = templateBox || (0, _utils.rotateBBox)(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);
    var textAlign = tick.labelAlignment || options.label.alignment;
    var isDiscrete = that._options.type === 'discrete';
    var isFlatLabel = tick.labelRotationAngle % 90 === 0;
    var indentFromAxis = options.label.indentFromAxis;
    var labelPosition = options.label.position;
    var axisPosition = that._axisPosition;
    var labelCoords = tick.labelCoords;
    var labelX = labelCoords.x;
    var translateX;
    var translateY;
    if (that._isHorizontal) {
      if (labelPosition === BOTTOM) {
        translateY = axisPosition + indentFromAxis - box.y + offset;
      } else {
        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;
      }
      if (textAlign === RIGHT) {
        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;
      } else if (textAlign === LEFT) {
        translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;
      } else {
        translateX = labelX - box.x - box.width / 2;
      }
    } else {
      translateY = labelCoords.y - box.y - box.height / 2;
      if (labelPosition === LEFT) {
        if (textAlign === LEFT) {
          translateX = axisPosition - indentFromAxis - maxWidth - box.x;
        } else if (textAlign === CENTER) {
          translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;
        } else {
          translateX = axisPosition - indentFromAxis - box.x - box.width;
        }
        translateX -= offset;
      } else {
        if (textAlign === RIGHT) {
          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;
        } else if (textAlign === CENTER) {
          translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;
        } else {
          translateX = axisPosition + indentFromAxis - box.x;
        }
        translateX += offset;
      }
    }
    return {
      translateX: translateX,
      translateY: translateY
    };
  },
  _createAxisConstantLineGroups: function _createAxisConstantLineGroups() {
    var that = this;
    var renderer = that._renderer;
    var classSelector = that._axisCssPrefix;
    var constantLinesClass = classSelector + 'constant-lines';
    var insideGroup = renderer.g().attr({
      'class': constantLinesClass
    });
    var outsideGroup1 = renderer.g().attr({
      'class': constantLinesClass
    });
    var outsideGroup2 = renderer.g().attr({
      'class': constantLinesClass
    });
    return {
      inside: insideGroup,
      outside1: outsideGroup1,
      left: outsideGroup1,
      top: outsideGroup1,
      outside2: outsideGroup2,
      right: outsideGroup2,
      bottom: outsideGroup2,
      remove: function remove() {
        this.inside.remove();
        this.outside1.remove();
        this.outside2.remove();
      },
      clear: function clear() {
        this.inside.clear();
        this.outside1.clear();
        this.outside2.clear();
      }
    };
  },
  _createAxisGroups: function _createAxisGroups() {
    var that = this;
    var renderer = that._renderer;
    var classSelector = that._axisCssPrefix;
    that._axisGroup = renderer.g().attr({
      'class': classSelector + 'axis'
    }).enableLinks();
    that._axisStripGroup = renderer.g().attr({
      'class': classSelector + 'strips'
    });
    that._axisGridGroup = renderer.g().attr({
      'class': classSelector + 'grid'
    });
    that._axisElementsGroup = renderer.g().attr({
      'class': classSelector + 'elements'
    });
    that._axisLineGroup = renderer.g().attr({
      'class': classSelector + 'line'
    }).linkOn(that._axisGroup, 'axisLine').linkAppend();
    that._axisTitleGroup = renderer.g().attr({
      'class': classSelector + 'title'
    }).append(that._axisGroup);
    that._axisConstantLineGroups = {
      above: that._createAxisConstantLineGroups(),
      under: that._createAxisConstantLineGroups()
    };
    that._axisStripLabelGroup = renderer.g().attr({
      'class': classSelector + 'axis-labels'
    });
  },
  _clearAxisGroups: function _clearAxisGroups() {
    var that = this;
    that._axisGroup.remove();
    that._axisStripGroup.remove();
    that._axisStripLabelGroup.remove();
    that._axisConstantLineGroups.above.remove();
    that._axisConstantLineGroups.under.remove();
    that._axisGridGroup.remove();
    that._axisTitleGroup.clear();
    if (!that._options.label.template || !that.isRendered()) {
      // for react async templates
      that._axisElementsGroup.remove();
      that._axisElementsGroup.clear();
    }
    that._axisLineGroup && that._axisLineGroup.clear();
    that._axisStripGroup && that._axisStripGroup.clear();
    that._axisGridGroup && that._axisGridGroup.clear();
    that._axisConstantLineGroups.above.clear();
    that._axisConstantLineGroups.under.clear();
    that._axisStripLabelGroup && that._axisStripLabelGroup.clear();
  },
  _getLabelFormatObject: function _getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks) {
    range = range || this._getViewportRange();
    var formatObject = {
      value: value,
      valueText: (0, _smart_formatter.smartFormatter)(value, {
        labelOptions: labelOptions,
        ticks: ticks || convertTicksToValues(this._majorTicks),
        tickInterval: tickInterval !== null && tickInterval !== void 0 ? tickInterval : this._tickInterval,
        dataType: this._options.dataType,
        logarithmBase: this._options.logarithmBase,
        type: this._options.type,
        showTransition: !this._options.marker.visible,
        point: point
      }) || '',
      // B252346
      min: range.minVisible,
      max: range.maxVisible
    };

    // for crosshair's customizeText
    if (point) {
      formatObject.point = point;
    }
    return formatObject;
  },
  formatLabel: function formatLabel(value, labelOptions, range, point, tickInterval, ticks) {
    var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);
    return (0, _type.isFunction)(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;
  },
  formatHint: function formatHint(value, labelOptions, range) {
    var formatObject = this._getLabelFormatObject(value, labelOptions, range);
    return (0, _type.isFunction)(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : undefined;
  },
  formatRange(startValue, endValue, interval, argumentFormat) {
    return (0, _smart_formatter.formatRange)({
      startValue,
      endValue,
      tickInterval: interval,
      argumentFormat,
      axisOptions: this.getOptions()
    });
  },
  _setTickOffset: function _setTickOffset() {
    var options = this._options;
    var discreteAxisDivisionMode = options.discreteAxisDivisionMode;
    this._tickOffset = +(discreteAxisDivisionMode !== 'crossLabels' || !discreteAxisDivisionMode);
  },
  // T1068023,T948359
  aggregatedPointBetweenTicks() {
    return this._options.aggregatedPointsPosition === 'crossTicks';
  },
  resetApplyingAnimation: function resetApplyingAnimation(isFirstDrawing) {
    this._resetApplyingAnimation = true;
    if (isFirstDrawing) {
      this._firstDrawing = true;
    }
  },
  isFirstDrawing() {
    return this._firstDrawing;
  },
  getMargins: function getMargins() {
    var that = this;
    var _that$_options = that._options,
      position = _that$_options.position,
      offset = _that$_options.offset,
      customPosition = _that$_options.customPosition,
      placeholderSize = _that$_options.placeholderSize,
      grid = _that$_options.grid,
      tick = _that$_options.tick,
      crosshairMargin = _that$_options.crosshairMargin;
    var isDefinedCustomPositionOption = (0, _type.isDefined)(customPosition);
    var boundaryPosition = that.getResolvedBoundaryPosition();
    var canvas = that.getCanvas();
    var cLeft = canvas.left;
    var cTop = canvas.top;
    var cRight = canvas.width - canvas.right;
    var cBottom = canvas.height - canvas.bottom;
    var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);
    var constantLineAboveSeries = that._axisConstantLineGroups.above;
    var constantLineUnderSeries = that._axisConstantLineGroups.under;
    var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(function (group) {
      return group && group.getBBox();
    }).concat(function (group) {
      var box = group && group.getBBox();
      if (!box || box.isEmpty) {
        return box;
      }
      if (that._isHorizontal) {
        box.x = cLeft;
        box.width = cRight - cLeft;
      } else {
        box.y = cTop;
        box.height = cBottom - cTop;
      }
      return box;
    }(that._axisTitleGroup));
    var margins = (0, _axes_utils.calculateCanvasMargins)(boxes, canvas);
    margins[position] += crosshairMargin;
    if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {
      margins[boundaryPosition] = 0;
    }
    if (placeholderSize) {
      margins[position] = placeholderSize;
    }
    if (edgeMarginCorrection) {
      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {
        margins.right = edgeMarginCorrection;
      }
      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {
        margins.bottom = edgeMarginCorrection;
      }
    }
    if (!isDefinedCustomPositionOption && (0, _type.isDefined)(offset)) {
      var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));
      margins[boundaryPosition] -= moveByOffset ? offset : 0;
    }
    return margins;
  },
  validateUnit: function validateUnit(unit, idError, parameters) {
    var that = this;
    unit = that.parser(unit);
    if (unit === undefined && idError) {
      that._incidentOccurred(idError, [parameters]);
    }
    return unit;
  },
  _setType: function _setType(axisType, drawingType) {
    var that = this;
    var axisTypeMethods;
    switch (axisType) {
      case 'xyAxes':
        axisTypeMethods = _xy_axes.default;
        break;
      case 'polarAxes':
        axisTypeMethods = polarMethods;
        break;
    }
    (0, _extend.extend)(that, axisTypeMethods[drawingType]);
  },
  _getSharpParam: function _getSharpParam() {
    return true;
  },
  _disposeBreaksGroup: _common.noop,
  // public
  dispose: function dispose() {
    var that = this;
    [that._axisElementsGroup, that._axisStripGroup, that._axisGroup].forEach(function (g) {
      g.dispose();
    });
    that._strips = that._title = null;
    that._axisStripGroup = that._axisConstantLineGroups = that._axisStripLabelGroup = that._axisBreaksGroup = null;
    that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;
    that._axisGroup = that._axisTitleGroup = null;
    that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = that._labelsAxesGroup = null;
    that._renderer = that._options = that._textOptions = that._textFontStyles = null;
    that._translator = null;
    that._majorTicks = that._minorTicks = null;
    that._disposeBreaksGroup();
    that._templatesRendered && that._templatesRendered.reject();
  },
  getOptions: function getOptions() {
    return this._options;
  },
  setPane: function setPane(pane) {
    this.pane = pane;
    this._options.pane = pane;
  },
  setTypes: function setTypes(type, axisType, typeSelector) {
    this._options.type = type || this._options.type;
    this._options[typeSelector] = axisType || this._options[typeSelector];
    this._updateTranslator();
  },
  resetTypes: function resetTypes(typeSelector) {
    this._options.type = this._initTypes.type;
    this._options[typeSelector] = this._initTypes[typeSelector];
  },
  getTranslator: function getTranslator() {
    return this._translator;
  },
  updateOptions: function updateOptions(options) {
    var that = this;
    var labelOpt = options.label;
    validateAxisOptions(options);
    checkDeprecatedOptions(!that.isArgumentAxis, options);
    that._options = options;
    options.tick = options.tick || {};
    options.minorTick = options.minorTick || {};
    options.grid = options.grid || {};
    options.minorGrid = options.minorGrid || {};
    options.title = options.title || {};
    options.marker = options.marker || {};
    that._initTypes = {
      type: options.type,
      argumentType: options.argumentType,
      valueType: options.valueType
    };
    that._setTickOffset();
    that._isHorizontal = options.isHorizontal;
    that.pane = options.pane;
    that.name = options.name;
    that.priority = options.priority;
    that._hasLabelFormat = labelOpt.format !== '' && (0, _type.isDefined)(labelOpt.format);
    that._textOptions = {
      opacity: labelOpt.opacity,
      align: 'center',
      'class': labelOpt.cssClass
    };
    that._textFontStyles = (0, _utils.patchFontOptions)(labelOpt.font);
    if (options.type === _axes_constants.default.logarithmic) {
      if (options.logarithmBaseError) {
        that._incidentOccurred('E2104');
        delete options.logarithmBaseError;
      }
    }
    that._updateTranslator();
    that._createConstantLines();
    that._strips = (options.strips || []).map(function (o) {
      return (0, _strip.default)(that, o);
    });
    that._majorTicks = that._minorTicks = null;
    that._firstDrawing = true;
  },
  calculateInterval: function calculateInterval(value, prevValue) {
    var options = this._options;
    if (!options || options.type !== _axes_constants.default.logarithmic) {
      return _abs(value - prevValue);
    }
    var _Range = new _range.Range(this.getTranslator().getBusinessRange()),
      allowNegatives = _Range.allowNegatives,
      linearThreshold = _Range.linearThreshold;
    return _abs((0, _utils.getLogExt)(value, options.logarithmBase, allowNegatives, linearThreshold) - (0, _utils.getLogExt)(prevValue, options.logarithmBase, allowNegatives, linearThreshold));
  },
  getCanvasRange() {
    var translator = this._translator;
    return {
      startValue: translator.from(translator.translate('canvas_position_start')),
      endValue: translator.from(translator.translate('canvas_position_end'))
    };
  },
  _processCanvas: function _processCanvas(canvas) {
    return canvas;
  },
  updateCanvas: function updateCanvas(canvas, canvasRedesign) {
    if (!canvasRedesign) {
      var positions = this._orthogonalPositions = {
        start: !this._isHorizontal ? canvas.left : canvas.top,
        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom
      };
      positions.center = positions.start + (positions.end - positions.start) / 2;
    } else {
      this._orthogonalPositions = null;
    }
    this._canvas = canvas;
    this._translator.updateCanvas(this._processCanvas(canvas));
    this._initAxisPositions();
  },
  getCanvas: function getCanvas() {
    return this._canvas;
  },
  getAxisShift() {
    return this._axisShift || 0;
  },
  hideTitle: function hideTitle() {
    var that = this;
    if (that._options.title.text) {
      that._incidentOccurred('W2105', [that._isHorizontal ? 'horizontal' : 'vertical']);
      that._axisTitleGroup.clear();
    }
  },
  getTitle: function getTitle() {
    return this._title;
  },
  hideOuterElements: function hideOuterElements() {
    var that = this;
    var options = that._options;
    if ((options.label.visible || that._outsideConstantLines.length) && !that._translator.getBusinessRange().isEmpty()) {
      that._incidentOccurred('W2106', [that._isHorizontal ? 'horizontal' : 'vertical']);
      that._axisElementsGroup.clear();
      callAction(that._outsideConstantLines, 'removeLabel');
    }
  },
  _resolveLogarithmicOptionsForRange(range) {
    var options = this._options;
    if (options.type === _axes_constants.default.logarithmic) {
      range.addRange({
        allowNegatives: options.allowNegatives !== undefined ? options.allowNegatives : range.min <= 0
      });
      if (!isNaN(options.linearThreshold)) {
        range.linearThreshold = options.linearThreshold;
      }
    }
  },
  adjustViewport(businessRange) {
    var that = this;
    var options = that._options;
    var isDiscrete = options.type === _axes_constants.default.discrete;
    var categories = that._seriesData && that._seriesData.categories || [];
    var wholeRange = that.adjustRange((0, _utils.getVizRangeObject)(options.wholeRange));
    var visualRange = that.getViewport() || {};
    var result = new _range.Range(businessRange);
    that._addConstantLinesToRange(result);
    var minDefined = (0, _type.isDefined)(visualRange.startValue);
    var maxDefined = (0, _type.isDefined)(visualRange.endValue);
    if (!isDiscrete) {
      minDefined = minDefined && (!(0, _type.isDefined)(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);
      maxDefined = maxDefined && (!(0, _type.isDefined)(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);
    }
    var minVisible = minDefined ? visualRange.startValue : result.minVisible;
    var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;
    if (!isDiscrete) {
      var _wholeRange$startValu, _wholeRange$endValue;
      result.min = (_wholeRange$startValu = wholeRange.startValue) !== null && _wholeRange$startValu !== void 0 ? _wholeRange$startValu : result.min;
      result.max = (_wholeRange$endValue = wholeRange.endValue) !== null && _wholeRange$endValue !== void 0 ? _wholeRange$endValue : result.max;
    } else {
      var categoriesInfo = (0, _utils.getCategoriesInfo)(categories, wholeRange.startValue, wholeRange.endValue);
      categories = categoriesInfo.categories;
      result.categories = categories;
    }
    var adjustedVisualRange = (0, _utils.adjustVisualRange)({
      axisType: options.type,
      dataType: options.dataType,
      base: options.logarithmBase
    }, {
      startValue: minDefined ? visualRange.startValue : undefined,
      endValue: maxDefined ? visualRange.endValue : undefined,
      length: visualRange.length
    }, {
      categories,
      min: wholeRange.startValue,
      max: wholeRange.endValue
    }, {
      categories,
      min: minVisible,
      max: maxVisible
    });
    result.minVisible = adjustedVisualRange.startValue;
    result.maxVisible = adjustedVisualRange.endValue;
    !(0, _type.isDefined)(result.min) && (result.min = result.minVisible);
    !(0, _type.isDefined)(result.max) && (result.max = result.maxVisible);
    result.addRange({}); // controlValuesByVisibleBounds
    that._resolveLogarithmicOptionsForRange(result);
    return result;
  },
  adjustRange(range) {
    range = range || {};
    var isDiscrete = this._options.type === _axes_constants.default.discrete;
    var isLogarithmic = this._options.type === _axes_constants.default.logarithmic;
    var disabledNegatives = this._options.allowNegatives === false;
    if (isLogarithmic) {
      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;
      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;
    }
    if (!isDiscrete && (0, _type.isDefined)(range.startValue) && (0, _type.isDefined)(range.endValue) && range.startValue > range.endValue) {
      var tmp = range.endValue;
      range.endValue = range.startValue;
      range.startValue = tmp;
    }
    return range;
  },
  _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {
    var value = this._options.visualRangeUpdateMode;
    var translator = this._translator;
    var range = this._seriesData;
    var prevDataInfo = this._prevDataInfo;
    if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {
      return KEEP;
    }
    if (!this.isArgumentAxis) {
      var _viewport = this.getViewport();
      if (!(0, _type.isDefined)(_viewport.startValue) && !(0, _type.isDefined)(_viewport.endValue) && !(0, _type.isDefined)(_viewport.length)) {
        return RESET;
      }
    }
    if (this.isArgumentAxis) {
      if ([SHIFT, KEEP, RESET].indexOf(value) === -1) {
        if (range.axisType === _axes_constants.default.discrete) {
          var categories = range.categories;
          var newCategories = newRange.categories;
          var visualRange = this.visualRange();
          if (categories && newCategories && categories.length && newCategories.map(function (c) {
            return c.valueOf();
          }).join(',').indexOf(categories.map(function (c) {
            return c.valueOf();
          }).join(',')) !== -1 && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {
            value = KEEP;
          } else {
            value = RESET;
          }
        } else {
          var minPoint = translator.translate(range.min);
          var minVisiblePoint = translator.translate(viewport.startValue);
          var maxPoint = translator.translate(range.max);
          var maxVisiblePoint = translator.translate(viewport.endValue);
          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {
            value = RESET;
          } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {
            value = SHIFT;
          } else {
            value = KEEP;
          }
        }
        if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {
          value = RESET;
        }
      }
    } else {
      if ([KEEP, RESET].indexOf(value) === -1) {
        if (oppositeValue === KEEP) {
          value = KEEP;
        } else {
          value = RESET;
        }
      }
    }
    return value;
  },
  _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {
    var that = this;
    var visualRange = this.visualRange();
    if (axisReinitialized || that._translator.getBusinessRange().isEmpty()) {
      return;
    }
    var visualRangeUpdateMode = that._lastVisualRangeUpdateMode = that._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);
    if (visualRangeUpdateMode === KEEP) {
      that._setVisualRange([visualRange.startValue, visualRange.endValue]);
    } else if (visualRangeUpdateMode === RESET) {
      that._setVisualRange([null, null]);
    } else if (visualRangeUpdateMode === SHIFT) {
      that._setVisualRange({
        length: that.getVisualRangeLength()
      });
    }
  },
  getVisualRangeLength(range) {
    var currentBusinessRange = range || this._translator.getBusinessRange();
    var type = this._options.type;
    var length;
    if (type === _axes_constants.default.logarithmic) {
      length = (0, _math2.adjust)(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));
    } else if (type === _axes_constants.default.discrete) {
      var categoriesInfo = (0, _utils.getCategoriesInfo)(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
      length = categoriesInfo.categories.length;
    } else {
      length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;
    }
    return length;
  },
  getVisualRangeCenter(range, useMerge) {
    var translator = this.getTranslator();
    var businessRange = translator.getBusinessRange();
    var currentBusinessRange = useMerge ? (0, _extend.extend)(true, {}, businessRange, range || {}) : range || businessRange;
    var _this$_options = this._options,
      type = _this$_options.type,
      logarithmBase = _this$_options.logarithmBase;
    var center;
    if (!(0, _type.isDefined)(currentBusinessRange.minVisible) || !(0, _type.isDefined)(currentBusinessRange.maxVisible)) {
      return;
    }
    if (type === _axes_constants.default.logarithmic) {
      var allowNegatives = currentBusinessRange.allowNegatives,
        linearThreshold = currentBusinessRange.linearThreshold,
        minVisible = currentBusinessRange.minVisible,
        maxVisible = currentBusinessRange.maxVisible;
      center = (0, _utils.raiseToExt)((0, _math2.adjust)((0, _utils.getLogExt)(maxVisible, logarithmBase, allowNegatives, linearThreshold) + (0, _utils.getLogExt)(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);
    } else if (type === _axes_constants.default.discrete) {
      var categoriesInfo = (0, _utils.getCategoriesInfo)(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);
      var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;
      center = businessRange.categories.indexOf(categoriesInfo.categories[index]);
    } else {
      center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2);
    }
    return center;
  },
  setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {
    var _that$_seriesData$min, _that$_seriesData$max;
    var that = this;
    var options = that._options;
    var isDiscrete = options.type === _axes_constants.default.discrete;
    that._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);
    that._seriesData = new _range.Range(range);
    var dataIsEmpty = that._seriesData.isEmpty();
    var rangeWithConstantLines = new _range.Range(that._seriesData);
    that._addConstantLinesToRange(rangeWithConstantLines);
    that._prevDataInfo = {
      isEmpty: dataIsEmpty,
      containsConstantLine: rangeWithConstantLines.containsConstantLine
    };
    that._seriesData.addRange({
      categories: options.categories,
      dataType: options.dataType,
      axisType: options.type,
      base: options.logarithmBase,
      invert: options.inverted
    });
    that._resolveLogarithmicOptionsForRange(that._seriesData);
    if (!isDiscrete) {
      if (!(0, _type.isDefined)(that._seriesData.min) && !(0, _type.isDefined)(that._seriesData.max)) {
        var visualRange = that.getViewport();
        visualRange && that._seriesData.addRange({
          min: visualRange.startValue,
          max: visualRange.endValue
        });
      }
      var synchronizedValue = options.synchronizedValue;
      if ((0, _type.isDefined)(synchronizedValue)) {
        that._seriesData.addRange({
          min: synchronizedValue,
          max: synchronizedValue
        });
      }
    }
    that._seriesData.minVisible = (_that$_seriesData$min = that._seriesData.minVisible) !== null && _that$_seriesData$min !== void 0 ? _that$_seriesData$min : that._seriesData.min;
    that._seriesData.maxVisible = (_that$_seriesData$max = that._seriesData.maxVisible) !== null && _that$_seriesData$max !== void 0 ? _that$_seriesData$max : that._seriesData.max;
    if (!that.isArgumentAxis && options.showZero) {
      that._seriesData.correctValueZeroLevel();
    }
    that._seriesData.sortCategories(that.getCategoriesSorter(argCategories));
    that._seriesData.userBreaks = that._seriesData.isEmpty() ? [] : that._getScaleBreaks(options, that._seriesData, that._series, that.isArgumentAxis);
    that._translator.updateBusinessRange(that._getViewportRange());
  },
  _addConstantLinesToRange(dataRange) {
    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(function (cl) {
      if (cl.options.extendAxis) {
        var value = cl.getParsedValue();
        dataRange.addRange({
          containsConstantLine: true,
          minVisible: value,
          maxVisible: value,
          min: !(0, _type.isDefined)(dataRange.min) ? value : dataRange.min,
          max: !(0, _type.isDefined)(dataRange.max) ? value : dataRange.max
        });
      }
    });
  },
  setGroupSeries: function setGroupSeries(series) {
    this._series = series;
  },
  getLabelsPosition: function getLabelsPosition() {
    var that = this;
    var options = that._options;
    var position = options.position;
    var labelShift = options.label.indentFromAxis + (that._axisShift || 0) + that._constantLabelOffset;
    var axisPosition = that._axisPosition;
    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;
  },
  getFormattedValue: function getFormattedValue(value, options, point) {
    var labelOptions = this._options.label;
    return (0, _type.isDefined)(value) ? this.formatLabel(value, (0, _extend.extend)(true, {}, labelOptions, options), undefined, point) : null;
  },
  _getBoundaryTicks: function _getBoundaryTicks(majors, viewPort) {
    var that = this;
    var length = majors.length;
    var options = that._options;
    var customBounds = options.customBoundTicks;
    var min = viewPort.minVisible;
    var max = viewPort.maxVisible;
    var addMinMax = options.showCustomBoundaryTicks ? that._boundaryTicksVisibility : {};
    var boundaryTicks = [];
    if (options.type === _axes_constants.default.discrete) {
      if (that._tickOffset && majors.length !== 0) {
        boundaryTicks = [majors[0], majors[majors.length - 1]];
      }
    } else {
      if (customBounds) {
        if (addMinMax.min && (0, _type.isDefined)(customBounds[0])) {
          boundaryTicks.push(customBounds[0]);
        }
        if (addMinMax.max && (0, _type.isDefined)(customBounds[1])) {
          boundaryTicks.push(customBounds[1]);
        }
      } else {
        if (addMinMax.min && (length === 0 || majors[0] > min)) {
          boundaryTicks.push(min);
        }
        if (addMinMax.max && (length === 0 || majors[length - 1] < max)) {
          boundaryTicks.push(max);
        }
      }
    }
    return boundaryTicks;
  },
  setPercentLabelFormat: function setPercentLabelFormat() {
    if (!this._hasLabelFormat) {
      this._options.label.format = 'percent';
    }
  },
  resetAutoLabelFormat: function resetAutoLabelFormat() {
    if (!this._hasLabelFormat) {
      delete this._options.label.format;
    }
  },
  getMultipleAxesSpacing: function getMultipleAxesSpacing() {
    return this._options.multipleAxesSpacing || 0;
  },
  getTicksValues: function getTicksValues() {
    return {
      majorTicksValues: convertTicksToValues(this._majorTicks),
      minorTicksValues: convertTicksToValues(this._minorTicks)
    };
  },
  estimateTickInterval: function estimateTickInterval(canvas) {
    var that = this;
    that.updateCanvas(canvas);
    return that._tickInterval !== that._getTicks(that._getViewportRange(), _common.noop, true).tickInterval;
  },
  setTicks: function setTicks(ticks) {
    var majors = ticks.majorTicks || [];
    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));
    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));
    this._isSynchronized = true;
  },
  _adjustDivisionFactor: function _adjustDivisionFactor(val) {
    return val;
  },
  _getTicks: function _getTicks(viewPort, incidentOccurred, skipTickGeneration) {
    var that = this;
    var options = that._options;
    var customTicks = options.customTicks;
    var customMinorTicks = options.customMinorTicks;
    return getTickGenerator(options, incidentOccurred || that._incidentOccurred, skipTickGeneration, that._translator.getBusinessRange().isEmpty(), that._adjustDivisionFactor.bind(that), viewPort)({
      min: viewPort.minVisible,
      max: viewPort.maxVisible,
      categories: viewPort.categories,
      isSpacedMargin: viewPort.isSpacedMargin
    }, that._getScreenDelta(), options.tickInterval, options.label.overlappingBehavior === 'ignore' || options.forceUserTickInterval, {
      majors: customTicks,
      minors: customMinorTicks
    }, options.minorTickInterval, options.minorTickCount, that._initialBreaks);
  },
  _createTicksAndLabelFormat: function _createTicksAndLabelFormat(range, incidentOccurred) {
    var options = this._options;
    var ticks = this._getTicks(range, incidentOccurred, false);
    if (!range.isEmpty() && options.type === _axes_constants.default.discrete && options.dataType === 'datetime' && !this._hasLabelFormat && ticks.ticks.length) {
      options.label.format = _format_helper.default.getDateFormatByTicks(ticks.ticks);
    }
    return ticks;
  },
  getAggregationInfo(useAllAggregatedPoints, range) {
    var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;
    var that = this;
    var options = that._options;
    var marginOptions = that._marginOptions;
    var businessRange = new _range.Range(that.getTranslator().getBusinessRange()).addRange(range);
    var visualRange = that.getViewport();
    var minVisible = (_visualRange$startVal = visualRange === null || visualRange === void 0 ? void 0 : visualRange.startValue) !== null && _visualRange$startVal !== void 0 ? _visualRange$startVal : businessRange.minVisible;
    var maxVisible = (_visualRange$endValue = visualRange === null || visualRange === void 0 ? void 0 : visualRange.endValue) !== null && _visualRange$endValue !== void 0 ? _visualRange$endValue : businessRange.maxVisible;
    var ticks = [];
    if (options.type === _axes_constants.default.discrete && options.aggregateByCategory) {
      return {
        aggregateByCategory: true
      };
    }
    var aggregationInterval = options.aggregationInterval;
    var aggregationGroupWidth = options.aggregationGroupWidth;
    if (!aggregationGroupWidth && marginOptions) {
      if (marginOptions.checkInterval) {
        aggregationGroupWidth = options.axisDivisionFactor;
      }
      if (marginOptions.sizePointNormalState) {
        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);
      }
    }
    var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;
    var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, that._getScreenDelta(), minInterval);
    var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, (_that$_seriesData = that._seriesData) === null || _that$_seriesData === void 0 ? void 0 : _that$_seriesData.breaks).tickInterval;
    if (options.type !== _axes_constants.default.discrete) {
      var min = useAllAggregatedPoints ? businessRange.min : minVisible;
      var max = useAllAggregatedPoints ? businessRange.max : maxVisible;
      if ((0, _type.isDefined)(min) && (0, _type.isDefined)(max)) {
        var add = (0, _utils.getAddFunction)({
          base: options.logarithmBase,
          axisType: options.type,
          dataType: options.dataType
        }, false);
        var start = min;
        var end = max;
        if (!useAllAggregatedPoints && (0, _type.isDefined)(tickInterval)) {
          var maxMinDistance = Math.max(that.calculateInterval(max, min), options.dataType === 'datetime' ? _date.default.dateToMilliseconds(tickInterval) : tickInterval);
          start = add(min, maxMinDistance, -1);
          end = add(max, maxMinDistance);
        }
        start = start < businessRange.min ? businessRange.min : start;
        end = end > businessRange.max ? businessRange.max : end;
        var breaks = that._getScaleBreaks(options, {
          minVisible: start,
          maxVisible: end
        }, that._series, that.isArgumentAxis);
        var filteredBreaks = that._filterBreaks(breaks, {
          minVisible: start,
          maxVisible: end
        }, options.breakStyle);
        ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks;
      }
    }
    that._aggregationInterval = tickInterval;
    return {
      interval: tickInterval,
      ticks: ticks
    };
  },
  getTickInterval() {
    return this._tickInterval;
  },
  getAggregationInterval() {
    return this._aggregationInterval;
  },
  createTicks: function createTicks(canvas) {
    var that = this;
    var renderer = that._renderer;
    var options = that._options;
    if (!canvas) {
      return;
    }
    that._isSynchronized = false;
    that.updateCanvas(canvas);
    var range = that._getViewportRange();
    that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);
    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _common.noop, true).tickInterval; // tickInterval calculation

    var margins = this._calculateValueMargins();
    range.addRange({
      minVisible: margins.minValue,
      maxVisible: margins.maxValue,
      isSpacedMargin: margins.isSpacedMargin
    });
    var ticks = that._createTicksAndLabelFormat(range);
    var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());
    if (options.showCustomBoundaryTicks && boundaryTicks.length) {
      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));
      if (boundaryTicks.length > 1) {
        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));
      }
    } else {
      that._boundaryTicks = [];
    }
    var minors = (ticks.minorTicks || []).filter(function (minor) {
      return !boundaryTicks.some(function (boundary) {
        return (0, _utils.valueOf)(boundary) === (0, _utils.valueOf)(minor);
      });
    });
    that._tickInterval = ticks.tickInterval;
    that._minorTickInterval = ticks.minorTickInterval;
    var oldMajorTicks = that._majorTicks || [];
    var majorTicksByValues = oldMajorTicks.reduce(function (r, t) {
      r[t.value.valueOf()] = t;
      return r;
    }, {});
    var sameType = (0, _type.type)(ticks.ticks[0]) === (0, _type.type)(oldMajorTicks[0] && oldMajorTicks[0].value);
    var skippedCategory = that._getSkippedCategory(ticks.ticks);
    var majorTicks = ticks.ticks.map(function (v) {
      var tick = majorTicksByValues[v.valueOf()];
      if (tick && sameType) {
        delete majorTicksByValues[v.valueOf()];
        tick.setSkippedCategory(skippedCategory);
        return tick;
      } else {
        return createMajorTick(that, renderer, skippedCategory)(v);
      }
    });
    that._majorTicks = majorTicks;
    var oldMinorTicks = that._minorTicks || [];
    that._minorTicks = minors.map(function (v, i) {
      var minorTick = oldMinorTicks[i];
      if (minorTick) {
        minorTick.updateValue(v);
        return minorTick;
      }
      return createMinorTick(that, renderer)(v);
    });
    that._ticksToRemove = Object.keys(majorTicksByValues).map(function (k) {
      return majorTicksByValues[k];
    }).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));
    that._ticksToRemove.forEach(function (t) {
      var _t$label;
      return (_t$label = t.label) === null || _t$label === void 0 ? void 0 : _t$label.removeTitle();
    });
    if (ticks.breaks) {
      that._seriesData.breaks = ticks.breaks;
    }
    that._reinitTranslator(that._getViewportRange());
  },
  _reinitTranslator: function _reinitTranslator(range) {
    var that = this;
    var translator = that._translator;
    if (that._isSynchronized) {
      return;
    }
    translator.updateBusinessRange(range);
  },
  _getViewportRange() {
    return this.adjustViewport(this._seriesData);
  },
  setMarginOptions: function setMarginOptions(options) {
    this._marginOptions = options;
  },
  getMarginOptions() {
    var _this$_marginOptions;
    return (_this$_marginOptions = this._marginOptions) !== null && _this$_marginOptions !== void 0 ? _this$_marginOptions : {};
  },
  _calculateRangeInterval: function _calculateRangeInterval(interval) {
    var isDateTime = this._options.dataType === 'datetime';
    var minArgs = [];
    var addToArgs = function addToArgs(value) {
      (0, _type.isDefined)(value) && minArgs.push(isDateTime ? _date.default.dateToMilliseconds(value) : value);
    };
    addToArgs(this._tickInterval);
    addToArgs(this._estimatedTickInterval);
    (0, _type.isDefined)(interval) && minArgs.push(interval);
    addToArgs(this._aggregationInterval);
    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));
  },
  _calculateWorkWeekInterval(businessInterval) {
    var options = this._options;
    if (options.dataType === 'datetime' && options.workdaysOnly && businessInterval) {
      var workWeek = options.workWeek.length * dateIntervals.day;
      var weekend = dateIntervals.week - workWeek;
      if (workWeek !== businessInterval && weekend < businessInterval) {
        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);
        businessInterval = businessInterval - weekend * weekendsCount;
      } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {
        businessInterval = dateIntervals.day;
      }
    }
    return businessInterval;
  },
  _getConvertIntervalCoefficient(intervalInPx, screenDelta) {
    var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();
    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));
  },
  _calculateValueMargins(ticks) {
    this._resetMargins();
    var that = this;
    var margins = that.getMarginOptions();
    var marginSize = (margins.size || 0) / 2;
    var options = that._options;
    var dataRange = that._getViewportRange();
    var viewPort = that.getViewport();
    var screenDelta = that._getScreenDelta();
    var isDiscrete = (options.type || '').indexOf(_axes_constants.default.discrete) !== -1;
    var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !that.customPositionIsBoundaryOrthogonalAxis();
    var translator = that._translator;
    var minValueMargin = options.minValueMargin;
    var maxValueMargin = options.maxValueMargin;
    var minPadding = 0;
    var maxPadding = 0;
    var interval = 0;
    var rangeInterval;
    if (dataRange.stubData || !screenDelta) {
      return {
        startPadding: 0,
        endPadding: 0
      };
    }
    if (that.isArgumentAxis && margins.checkInterval) {
      rangeInterval = that._calculateRangeInterval(dataRange.interval);
      var pxInterval = translator.getInterval(rangeInterval);
      if (isFinite(pxInterval)) {
        interval = Math.ceil(pxInterval / (2 * that._getConvertIntervalCoefficient(pxInterval, screenDelta)));
      } else {
        rangeInterval = 0;
      }
    }
    var minPercentPadding;
    var maxPercentPadding;
    var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;
    if (valueMarginsEnabled) {
      if ((0, _type.isDefined)(minValueMargin)) {
        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;
      } else if (!that.isArgumentAxis && margins.checkInterval && (0, _utils.valueOf)(dataRange.minVisible) > 0 && (0, _utils.valueOf)(dataRange.minVisible) === (0, _utils.valueOf)(dataRange.min)) {
        minPadding = MIN_BAR_MARGIN;
      } else {
        minPadding = Math.max(marginSize, interval);
        minPadding = Math.min(maxPaddingValue, minPadding);
      }
      if ((0, _type.isDefined)(maxValueMargin)) {
        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;
      } else if (!that.isArgumentAxis && margins.checkInterval && (0, _utils.valueOf)(dataRange.maxVisible) < 0 && (0, _utils.valueOf)(dataRange.maxVisible) === (0, _utils.valueOf)(dataRange.max)) {
        maxPadding = MIN_BAR_MARGIN;
      } else {
        maxPadding = Math.max(marginSize, interval);
        maxPadding = Math.min(maxPaddingValue, maxPadding);
      }
    }
    var percentStick = margins.percentStick && !this.isArgumentAxis;
    if (percentStick) {
      if (_abs(dataRange.max) === 1) {
        maxPadding = 0;
      }
      if (_abs(dataRange.min) === 1) {
        minPadding = 0;
      }
    }
    var canvasStartEnd = that._getCanvasStartEnd();
    var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);
    var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;
    if (minPercentPadding !== undefined || maxPercentPadding !== undefined) {
      if (minPercentPadding !== undefined) {
        minPadding = screenDeltaWithMargins * minPercentPadding;
      }
      if (maxPercentPadding !== undefined) {
        maxPadding = screenDeltaWithMargins * maxPercentPadding;
      }
    }
    var minValue;
    var maxValue;
    if (options.type !== _axes_constants.default.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && options.endOnTick !== false) {
      var length = ticks.length;
      var firstTickPosition = translator.translate(ticks[0].value);
      var lastTickPosition = translator.translate(ticks[length - 1].value);
      var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;
      var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);
      var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);
      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {
        var commonPadding = maxTickPadding + minTickPadding;
        var coeff = that._getConvertIntervalCoefficient(commonPadding, screenDelta);
        if (minTickPadding >= minPadding) {
          minValue = ticks[0].value;
        }
        if (maxTickPadding >= maxPadding) {
          maxValue = ticks[length - 1].value;
        }
        minPadding = _max(minTickPadding, minPadding) / coeff;
        maxPadding = _max(maxTickPadding, maxPadding) / coeff;
      }
    }
    minPercentPadding = minPercentPadding === undefined ? minPadding / screenDeltaWithMargins : minPercentPadding;
    maxPercentPadding = maxPercentPadding === undefined ? maxPadding / screenDeltaWithMargins : maxPercentPadding;
    if (!isDiscrete) {
      if (this._translator.isInverted()) {
        var _minValue, _maxValue;
        minValue = (_minValue = minValue) !== null && _minValue !== void 0 ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);
        maxValue = (_maxValue = maxValue) !== null && _maxValue !== void 0 ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);
      } else {
        var _minValue2, _maxValue2;
        minValue = (_minValue2 = minValue) !== null && _minValue2 !== void 0 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);
        maxValue = (_maxValue2 = maxValue) !== null && _maxValue2 !== void 0 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);
      }
    }
    var _that$getCorrectedVal = that.getCorrectedValuesToZero(minValue, maxValue),
      correctedMin = _that$getCorrectedVal.correctedMin,
      correctedMax = _that$getCorrectedVal.correctedMax,
      start = _that$getCorrectedVal.start,
      end = _that$getCorrectedVal.end;
    minPadding = start !== null && start !== void 0 ? start : minPadding;
    maxPadding = end !== null && end !== void 0 ? end : maxPadding;
    return {
      startPadding: translator.isInverted() ? maxPadding : minPadding,
      endPadding: translator.isInverted() ? minPadding : maxPadding,
      minValue: correctedMin !== null && correctedMin !== void 0 ? correctedMin : minValue,
      maxValue: correctedMax !== null && correctedMax !== void 0 ? correctedMax : maxValue,
      interval: rangeInterval,
      isSpacedMargin: minPadding === maxPadding && minPadding !== 0
    };
  },
  getCorrectedValuesToZero(minValue, maxValue) {
    var that = this;
    var translator = that._translator;
    var canvasStartEnd = that._getCanvasStartEnd();
    var dataRange = that._getViewportRange();
    var screenDelta = that._getScreenDelta();
    var options = that._options;
    var start;
    var end;
    var correctedMin;
    var correctedMax;
    var correctZeroLevel = function correctZeroLevel(minPoint, maxPoint) {
      var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);
      var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);
      var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);
      start = minExpectedPadding / coeff;
      end = maxExpectedPadding / coeff;
    };
    if (!that.isArgumentAxis && options.dataType !== 'datetime') {
      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {
        correctZeroLevel(translator.translate(0), translator.translate(maxValue));
        correctedMin = 0;
      }
      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {
        correctZeroLevel(translator.translate(minValue), translator.translate(0));
        correctedMax = 0;
      }
    }
    return {
      start: isFinite(start) ? start : null,
      end: isFinite(end) ? end : null,
      correctedMin,
      correctedMax
    };
  },
  applyMargins() {
    if (this._isSynchronized) {
      return;
    }
    var margins = this._calculateValueMargins(this._majorTicks);
    var canvas = (0, _extend.extend)({}, this._canvas, {
      startPadding: margins.startPadding,
      endPadding: margins.endPadding
    });
    this._translator.updateCanvas(this._processCanvas(canvas));
    if (isFinite(margins.interval)) {
      var br = this._translator.getBusinessRange();
      br.addRange({
        interval: margins.interval
      });
      this._translator.updateBusinessRange(br);
    }
  },
  _resetMargins: function _resetMargins() {
    this._reinitTranslator(this._getViewportRange());
    if (this._canvas) {
      this._translator.updateCanvas(this._processCanvas(this._canvas));
    }
  },
  _createConstantLines() {
    var _this2 = this;
    var constantLines = (this._options.constantLines || []).map(function (o) {
      return (0, _constant_line.default)(_this2, o);
    });
    this._outsideConstantLines = constantLines.filter(function (l) {
      return l.labelPosition === 'outside';
    });
    this._insideConstantLines = constantLines.filter(function (l) {
      return l.labelPosition === 'inside';
    });
  },
  draw: function draw(canvas, borderOptions) {
    var that = this;
    var options = this._options;
    that.borderOptions = borderOptions || {
      visible: false
    };
    that._resetMargins();
    that.createTicks(canvas);
    that.applyMargins();
    that._clearAxisGroups();
    initTickCoords(that._majorTicks);
    initTickCoords(that._minorTicks);
    initTickCoords(that._boundaryTicks);
    that._axisGroup.append(that._axesContainerGroup);
    that._drawAxis();
    that._drawTitle();
    drawTickMarks(that._majorTicks, options.tick);
    drawTickMarks(that._minorTicks, options.minorTick);
    drawTickMarks(that._boundaryTicks, options.tick);
    var drawGridLine = that._getGridLineDrawer();
    drawGrids(that._majorTicks, drawGridLine);
    drawGrids(that._minorTicks, drawGridLine);
    callAction(that._majorTicks, 'drawLabel', that._getViewportRange(), that._getTemplate(options.label.template));
    that._templatesRendered && that._templatesRendered.reject();
    that._templatesRendered = new _deferred.Deferred();
    that._majorTicks.forEach(function (tick) {
      tick.labelRotationAngle = 0;
      tick.labelAlignment = undefined;
      tick.labelOffset = 0;
    });
    callAction(that._outsideConstantLines.concat(that._insideConstantLines), 'draw');
    callAction(that._strips, 'draw');
    that._dateMarkers = that._drawDateMarkers() || [];
    that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);
    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);
    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);
    that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);
    if (that._constantLinesGroup) {
      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);
      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);
      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);
      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);
      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);
      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);
    }
    that._measureTitle();
    (0, _axes_utils.measureLabels)(that._majorTicks);
    !options.label.template && that._applyWordWrap();
    (0, _axes_utils.measureLabels)(that._outsideConstantLines);
    (0, _axes_utils.measureLabels)(that._insideConstantLines);
    (0, _axes_utils.measureLabels)(that._strips);
    (0, _axes_utils.measureLabels)(that._dateMarkers);
    that._adjustConstantLineLabels(that._insideConstantLines);
    that._adjustStripLabels();
    var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);
    if (!that._translator.getBusinessRange().isEmpty()) {
      that._setLabelsPlacement();
      offset = that._adjustLabels(offset);
    }
    _deferred.when.apply(this, that._majorTicks.map(function (tick) {
      return tick.getTemplateDeferred();
    })).done(function () {
      that._templatesRendered.resolve();
    });
    offset = that._adjustDateMarkers(offset);
    that._adjustTitle(offset);
  },
  getTemplatesDef() {
    return this._templatesRendered;
  },
  setRenderedState(state) {
    this._drawn = state;
  },
  isRendered() {
    return this._drawn;
  },
  _applyWordWrap() {
    var that = this;
    var convertedTickInterval;
    var textWidth;
    var textHeight;
    var options = this._options;
    var tickInterval = that._tickInterval;
    if ((0, _type.isDefined)(tickInterval)) {
      convertedTickInterval = that.getTranslator().getInterval(options.dataType === 'datetime' ? _date.default.dateToMilliseconds(tickInterval) : tickInterval);
    }
    var displayMode = that._validateDisplayMode(options.label.displayMode);
    var overlappingMode = that._validateOverlappingMode(options.label.overlappingBehavior, displayMode);
    var wordWrapMode = options.label.wordWrap || 'none';
    var overflowMode = options.label.textOverflow || 'none';
    if ((wordWrapMode !== 'none' || overflowMode !== 'none') && displayMode !== ROTATE && overlappingMode !== ROTATE && overlappingMode !== 'auto') {
      var usefulSpace = (0, _type.isDefined)(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : undefined;
      if (that._isHorizontal) {
        textWidth = convertedTickInterval;
        textHeight = usefulSpace;
      } else {
        textWidth = usefulSpace;
        textHeight = convertedTickInterval;
      }
      var correctByWidth = false;
      var correctByHeight = false;
      if (textWidth) {
        if (that._majorTicks.some(function (tick) {
          return tick.labelBBox.width > textWidth;
        })) {
          correctByWidth = true;
        }
      }
      if (textHeight) {
        if (that._majorTicks.some(function (tick) {
          return tick.labelBBox.height > textHeight;
        })) {
          correctByHeight = true;
        }
      }
      if (correctByWidth || correctByHeight) {
        that._majorTicks.forEach(function (tick) {
          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);
        });
        (0, _axes_utils.measureLabels)(that._majorTicks);
      }
    }
  },
  _measureTitle: _common.noop,
  animate() {
    callAction(this._majorTicks, 'animateLabels');
  },
  updateSize(canvas, animate) {
    var updateTitle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var that = this;
    that.updateCanvas(canvas);
    if (updateTitle) {
      that._checkTitleOverflow();
      that._measureTitle();
      that._updateTitleCoords();
    }
    that._reinitTranslator(that._getViewportRange());
    that.applyMargins();
    var animationEnabled = !that._firstDrawing && animate;
    var options = that._options;
    initTickCoords(that._majorTicks);
    initTickCoords(that._minorTicks);
    initTickCoords(that._boundaryTicks);
    if (that._resetApplyingAnimation && !that._firstDrawing) {
      that._resetStartCoordinates();
    }
    cleanUpInvalidTicks(that._majorTicks);
    cleanUpInvalidTicks(that._minorTicks);
    cleanUpInvalidTicks(that._boundaryTicks);
    if (that._axisElement) {
      that._updateAxisElementPosition();
    }
    updateTicksPosition(that._majorTicks, options.tick, animationEnabled);
    updateTicksPosition(that._minorTicks, options.minorTick, animationEnabled);
    updateTicksPosition(that._boundaryTicks, options.tick);
    callAction(that._majorTicks, 'updateLabelPosition', animationEnabled);
    that._outsideConstantLines.concat(that._insideConstantLines || []).forEach(function (l) {
      return l.updatePosition(animationEnabled);
    });
    callAction(that._strips, 'updatePosition', animationEnabled);
    updateGridsPosition(that._majorTicks, animationEnabled);
    updateGridsPosition(that._minorTicks, animationEnabled);
    if (animationEnabled) {
      callAction(that._ticksToRemove || [], 'fadeOutElements');
    }
    that.prepareAnimation();
    that._ticksToRemove = null;
    if (!that._translator.getBusinessRange().isEmpty()) {
      that._firstDrawing = false;
    }
    that._resetApplyingAnimation = false;
    that._updateLabelsPosition();
  },
  _updateLabelsPosition: _common.noop,
  prepareAnimation() {
    var that = this;
    var action = 'saveCoords';
    callAction(that._majorTicks, action);
    callAction(that._minorTicks, action);
    callAction(that._insideConstantLines, action);
    callAction(that._outsideConstantLines, action);
    callAction(that._strips, action);
  },
  _resetStartCoordinates() {
    var that = this;
    var action = 'resetCoordinates';
    callAction(that._majorTicks, action);
    callAction(that._minorTicks, action);
    callAction(that._insideConstantLines, action);
    callAction(that._outsideConstantLines, action);
    callAction(that._strips, action);
  },
  applyClipRects: function applyClipRects(elementsClipID, canvasClipID) {
    this._axisGroup.attr({
      'clip-path': canvasClipID
    });
    this._axisStripGroup.attr({
      'clip-path': elementsClipID
    });
    this._axisElementsGroup.attr({
      'clip-path': canvasClipID
    });
  },
  _validateVisualRange(optionValue) {
    var range = (0, _utils.getVizRangeObject)(optionValue);
    if (range.startValue !== undefined) {
      range.startValue = this.validateUnit(range.startValue);
    }
    if (range.endValue !== undefined) {
      range.endValue = this.validateUnit(range.endValue);
    }
    return (0, _utils.convertVisualRangeObject)(range, !_isArray(optionValue));
  },
  _validateOptions(options) {
    options.wholeRange = this._validateVisualRange(options.wholeRange);
    options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);
    this._setVisualRange(options._customVisualRange);
  },
  validate() {
    var that = this;
    var options = that._options;
    var dataType = that.isArgumentAxis ? options.argumentType : options.valueType;
    var parser = dataType ? (0, _parse_utils.getParser)(dataType) : function (unit) {
      return unit;
    };
    that.parser = parser;
    options.dataType = dataType;
    that._validateOptions(options);
  },
  resetVisualRange(isSilent) {
    this._seriesData.minVisible = this._seriesData.min;
    this._seriesData.maxVisible = this._seriesData.max;
    this.handleZooming([null, null], {
      start: !!isSilent,
      end: !!isSilent
    });
  },
  _setVisualRange(visualRange, allowPartialUpdate) {
    var range = this.adjustRange((0, _utils.getVizRangeObject)(visualRange));
    if (allowPartialUpdate) {
      (0, _type.isDefined)(range.startValue) && (this._viewport.startValue = range.startValue);
      (0, _type.isDefined)(range.endValue) && (this._viewport.endValue = range.endValue);
    } else {
      this._viewport = range;
    }
  },
  _applyZooming(visualRange, allowPartialUpdate) {
    var that = this;
    that._resetVisualRangeOption();
    that._setVisualRange(visualRange, allowPartialUpdate);
    var viewPort = that.getViewport();
    that._seriesData.userBreaks = that._getScaleBreaks(that._options, {
      minVisible: viewPort.startValue,
      maxVisible: viewPort.endValue
    }, that._series, that.isArgumentAxis);
    that._translator.updateBusinessRange(that._getViewportRange());
  },
  getZoomStartEventArg(event, actionType) {
    return {
      axis: this,
      range: this.visualRange(),
      cancel: false,
      event,
      actionType
    };
  },
  _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {
    var newRange = this.visualRange();
    return {
      axis: this,
      previousRange,
      range: newRange,
      cancel: false,
      event,
      actionType,
      zoomFactor,
      shift,
      // backwards
      rangeStart: newRange.startValue,
      rangeEnd: newRange.endValue
    };
  },
  getZoomBounds() {
    var wholeRange = (0, _utils.getVizRangeObject)(this._options.wholeRange);
    var range = this.getTranslator().getBusinessRange();
    var secondPriorityRange = {
      startValue: getZoomBoundValue(this._initRange.startValue, range.min),
      endValue: getZoomBoundValue(this._initRange.endValue, range.max)
    };
    return {
      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),
      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)
    };
  },
  setInitRange() {
    this._initRange = {};
    if (Object.keys(this._options.wholeRange || {}).length === 0) {
      this._initRange = this.getZoomBounds();
    }
  },
  _resetVisualRangeOption() {
    this._options._customVisualRange = {};
  },
  getTemplatesGroups() {
    var ticks = this._majorTicks;
    if (ticks) {
      return this._majorTicks.map(function (tick) {
        return tick.templateContainer;
      }).filter(function (item) {
        return (0, _type.isDefined)(item);
      });
    } else {
      return [];
    }
  },
  setCustomVisualRange(range) {
    this._options._customVisualRange = range;
  },
  // API
  visualRange() {
    var that = this;
    var args = arguments;
    var visualRange;
    if (args.length === 0) {
      var adjustedRange = that._getAdjustedBusinessRange();
      var startValue = adjustedRange.minVisible;
      var endValue = adjustedRange.maxVisible;
      if (that._options.type === _axes_constants.default.discrete) {
        var _startValue, _endValue;
        startValue = (_startValue = startValue) !== null && _startValue !== void 0 ? _startValue : adjustedRange.categories[0];
        endValue = (_endValue = endValue) !== null && _endValue !== void 0 ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];
        return {
          startValue,
          endValue,
          categories: (0, _utils.getCategoriesInfo)(adjustedRange.categories, startValue, endValue).categories
        };
      }
      return {
        startValue,
        endValue
      };
    } else if (_isArray(args[0])) {
      visualRange = args[0];
    } else if ((0, _type.isPlainObject)(args[0])) {
      visualRange = (0, _extend.extend)({}, args[0]);
    } else {
      visualRange = [args[0], args[1]];
    }
    var zoomResults = that.handleZooming(visualRange, args[1]);
    if (!zoomResults.isPrevented) {
      that._visualRange(that, zoomResults);
    }
  },
  handleZooming(visualRange, preventEvents, domEvent, action) {
    var that = this;
    preventEvents = preventEvents || {};
    if ((0, _type.isDefined)(visualRange)) {
      visualRange = that._validateVisualRange(visualRange);
      visualRange.action = action;
    }
    var zoomStartEvent = that.getZoomStartEventArg(domEvent, action);
    var previousRange = zoomStartEvent.range;
    !preventEvents.start && that._eventTrigger('zoomStart', zoomStartEvent);
    var zoomResults = {
      isPrevented: zoomStartEvent.cancel,
      skipEventRising: preventEvents.skipEventRising,
      range: visualRange || zoomStartEvent.range
    };
    if (!zoomStartEvent.cancel) {
      (0, _type.isDefined)(visualRange) && that._applyZooming(visualRange, preventEvents.allowPartialUpdate);
      if (!(0, _type.isDefined)(that._storedZoomEndParams)) {
        that._storedZoomEndParams = {
          startRange: previousRange,
          type: this.getOptions().type
        };
      }
      that._storedZoomEndParams.event = domEvent;
      that._storedZoomEndParams.action = action;
      that._storedZoomEndParams.prevent = !!preventEvents.end;
    }
    return zoomResults;
  },
  handleZoomEnd() {
    var that = this;
    if ((0, _type.isDefined)(that._storedZoomEndParams) && !that._storedZoomEndParams.prevent) {
      var previousRange = that._storedZoomEndParams.startRange;
      var domEvent = that._storedZoomEndParams.event;
      var action = that._storedZoomEndParams.action;
      var previousBusinessRange = {
        minVisible: previousRange.startValue,
        maxVisible: previousRange.endValue,
        categories: previousRange.categories
      };
      var typeIsNotChanged = that.getOptions().type === that._storedZoomEndParams.type;
      var shift = typeIsNotChanged ? (0, _math2.adjust)(that.getVisualRangeCenter() - that.getVisualRangeCenter(previousBusinessRange, false)) : NaN;
      var zoomFactor = typeIsNotChanged ? +(Math.round(that.getVisualRangeLength(previousBusinessRange) / (that.getVisualRangeLength() || 1) + 'e+2') + 'e-2') : NaN;
      var zoomEndEvent = that._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);
      zoomEndEvent.cancel = that.checkZoomingLowerLimitOvercome(zoomFactor === 1 ? 'pan' : 'zoom', zoomFactor).stopInteraction;
      that._eventTrigger('zoomEnd', zoomEndEvent);
      if (zoomEndEvent.cancel) {
        that._restorePreviousVisualRange(previousRange);
      }
      that._storedZoomEndParams = null;
    }
  },
  _restorePreviousVisualRange(previousRange) {
    var that = this;
    that._storedZoomEndParams = null;
    that._applyZooming(previousRange);
    that._visualRange(that, previousRange);
  },
  checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {
    var that = this;
    var options = that._options;
    var translator = that._translator;
    var minZoom = options.minVisualRangeLength;
    var correctedRange = range;
    var visualRange;
    var isOvercoming = actionType === 'zoom' && zoomFactor >= 1;
    var businessRange = translator.getBusinessRange();
    if (range) {
      visualRange = that.adjustRange((0, _utils.getVizRangeObject)(range));
      visualRange = {
        minVisible: visualRange.startValue,
        maxVisible: visualRange.endValue,
        categories: businessRange.categories
      };
    }
    var beforeVisualRangeLength = that.getVisualRangeLength(businessRange);
    var afterVisualRangeLength = that.getVisualRangeLength(visualRange);
    if ((0, _type.isDefined)(minZoom) || options.type === 'discrete') {
      minZoom = translator.convert(minZoom);
      if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {
        correctedRange = (0, _utils.getVizRangeObject)(translator.getRangeByMinZoomValue(minZoom, visualRange));
        isOvercoming = false;
      } else {
        isOvercoming &= minZoom > afterVisualRangeLength;
      }
    } else {
      var canvasLength = that._translator.canvasLength;
      var fullRange = {
        minVisible: businessRange.min,
        maxVisible: businessRange.max,
        categories: businessRange.categories
      };
      isOvercoming &= that.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength;
    }
    return {
      stopInteraction: !!isOvercoming,
      correctedRange: correctedRange
    };
  },
  isExtremePosition(isMax) {
    var extremeDataValue;
    var seriesData;
    if (this._options.type === 'discrete') {
      seriesData = this._translator.getBusinessRange();
      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];
    } else {
      seriesData = this.getZoomBounds(); // T702708
      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;
    }
    var translator = this.getTranslator();
    var extremePoint = translator.translate(extremeDataValue);
    var visualRange = this.visualRange();
    var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);
    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;
  },
  getViewport() {
    return this._viewport;
  },
  getFullTicks: function getFullTicks() {
    var majors = this._majorTicks || [];
    if (this._options.type === _axes_constants.default.discrete) {
      return convertTicksToValues(majors);
    } else {
      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {
        return (0, _utils.valueOf)(a) - (0, _utils.valueOf)(b);
      });
    }
  },
  measureLabels: function measureLabels(canvas, withIndents) {
    var that = this;
    var options = that._options;
    var widthAxis = options.visible ? options.width : 0;
    var ticks;
    var indent = withIndents ? options.label.indentFromAxis + options.tick.length * 0.5 : 0;
    var tickInterval;
    var viewportRange = that._getViewportRange();
    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {
      return {
        height: widthAxis,
        width: widthAxis,
        x: 0,
        y: 0
      };
    }
    if (that._majorTicks) {
      ticks = convertTicksToValues(that._majorTicks);
    } else {
      that.updateCanvas(canvas);
      ticks = that._createTicksAndLabelFormat(viewportRange, _common.noop);
      tickInterval = ticks.tickInterval;
      ticks = ticks.ticks;
    }
    var maxText = ticks.reduce(function (prevLabel, tick, index) {
      var label = that.formatLabel(tick, options.label, viewportRange, undefined, tickInterval, ticks);
      if (prevLabel.length < label.length) {
        return label;
      } else {
        return prevLabel;
      }
    }, that.formatLabel(ticks[0], options.label, viewportRange, undefined, tickInterval, ticks));
    var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);
    var box = text.getBBox();
    text.remove();
    return {
      x: box.x,
      y: box.y,
      width: box.width + indent,
      height: box.height + indent
    };
  },
  _setLabelsPlacement: function _setLabelsPlacement() {
    if (!this._options.label.visible) {
      return;
    }
    var that = this;
    var labelOpt = that._options.label;
    var displayMode = that._validateDisplayMode(labelOpt.displayMode);
    var overlappingMode = that._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);
    var ignoreOverlapping = overlappingMode === 'none' || overlappingMode === 'ignore';
    var behavior = {
      rotationAngle: labelOpt.rotationAngle,
      staggeringSpacing: labelOpt.staggeringSpacing
    };
    var notRecastStep;
    var boxes = that._majorTicks.map(function (tick) {
      return tick.labelBBox;
    });
    var step = that._getStep(boxes);
    switch (displayMode) {
      case ROTATE:
        if (ignoreOverlapping) {
          notRecastStep = true;
          step = 1;
        }
        that._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);
        break;
      case 'stagger':
        if (ignoreOverlapping) {
          step = 2;
        }
        that._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);
        break;
      default:
        that._applyLabelOverlapping(boxes, overlappingMode, step, behavior);
    }
  },
  _applyLabelOverlapping: function _applyLabelOverlapping(boxes, mode, step, behavior) {
    var that = this;
    var labelOpt = that._options.label;
    var majorTicks = that._majorTicks;
    if (mode === 'none' || mode === 'ignore') {
      return;
    }
    var checkLabels = function checkLabels(box, index, array) {
      if (index === 0) {
        return false;
      }
      return _axes_constants.default.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);
    };
    if (step > 1 && boxes.some(checkLabels)) {
      that._applyLabelMode(mode, step, boxes, behavior);
    }
    that._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);
    that._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment);
  },
  _applyLabelMode: function _applyLabelMode(mode, step, boxes, behavior, notRecastStep) {
    var that = this;
    var majorTicks = that._majorTicks;
    var labelOpt = that._options.label;
    var angle = behavior.rotationAngle;
    var labelHeight;
    var alignment;
    var func;
    switch (mode) {
      case ROTATE:
        if (!labelOpt.userAlignment) {
          alignment = angle < 0 ? RIGHT : LEFT;
          if (angle % 90 === 0) {
            alignment = CENTER;
          }
        }
        step = notRecastStep ? step : that._getStep(boxes, angle);
        func = function func(tick) {
          var contentContainer = tick.getContentContainer();
          if (!contentContainer) {
            return;
          }
          contentContainer.rotate(angle);
          tick.labelRotationAngle = angle;
          alignment && (tick.labelAlignment = alignment);
        };
        updateLabels(majorTicks, step, func);
        break;
      case 'stagger':
        labelHeight = that._getMaxLabelHeight(boxes, behavior.staggeringSpacing);
        func = function func(tick, index) {
          if (index / (step - 1) % 2 !== 0) {
            tick.labelOffset = labelHeight;
          }
        };
        updateLabels(majorTicks, step - 1, func);
        break;
      case 'auto':
      case '_auto':
        if (step === 2) {
          that._applyLabelMode('stagger', step, boxes, behavior);
        } else {
          that._applyLabelMode(ROTATE, step, boxes, {
            rotationAngle: getOptimalAngle(boxes, labelOpt)
          });
        }
        break;
      default:
        updateLabels(majorTicks, step);
        break;
    }
  },
  getMarkerTrackers: _common.noop,
  _drawDateMarkers: _common.noop,
  _adjustDateMarkers: _common.noop,
  coordsIn: _common.noop,
  areCoordsOutsideAxis: _common.noop,
  _getSkippedCategory: _common.noop,
  _initAxisPositions: _common.noop,
  _drawTitle: _common.noop,
  _updateTitleCoords: _common.noop,
  _adjustConstantLineLabels: _common.noop,
  _createTranslator: function _createTranslator() {
    return new _translator2d.Translator2D({}, {}, {});
  },
  _updateTranslator: function _updateTranslator() {
    var translator = this._translator;
    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());
  },
  _getTranslatorOptions: function _getTranslatorOptions() {
    var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;
    var options = this._options;
    return {
      isHorizontal: this._isHorizontal,
      shiftZeroValue: !this.isArgumentAxis,
      interval: options.semiDiscreteInterval,
      firstDayOfWeek: (_options$workWeek2 = options.workWeek) === null || _options$workWeek2 === void 0 ? void 0 : _options$workWeek2[0],
      stick: this._getStick(),
      breaksSize: (_options$breakStyle$w = (_options$breakStyle = options.breakStyle) === null || _options$breakStyle === void 0 ? void 0 : _options$breakStyle.width) !== null && _options$breakStyle$w !== void 0 ? _options$breakStyle$w : 0
    };
  },
  getVisibleArea() {
    var canvas = this._getCanvasStartEnd();
    return [canvas.start, canvas.end].sort(function (a, b) {
      return a - b;
    });
  },
  _getCanvasStartEnd: function _getCanvasStartEnd() {
    var isHorizontal = this._isHorizontal;
    var canvas = this._canvas || {};
    var invert = this._translator.getBusinessRange().invert;
    var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];
    invert && coords.reverse();
    return {
      start: coords[0],
      end: coords[1]
    };
  },
  _getScreenDelta: function _getScreenDelta() {
    var that = this;
    var canvas = that._getCanvasStartEnd();
    var breaks = that._seriesData ? that._seriesData.breaks || [] : [];
    var breaksLength = breaks.length;
    var screenDelta = _abs(canvas.start - canvas.end);
    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);
  },
  _getScaleBreaks: function _getScaleBreaks() {
    return [];
  },
  _filterBreaks: function _filterBreaks() {
    return [];
  },
  _adjustTitle: _common.noop,
  _checkTitleOverflow: _common.noop,
  getSpiderTicks: _common.noop,
  setSpiderTicks: _common.noop,
  _checkBoundedLabelsOverlapping: _common.noop,
  _checkShiftedLabels: _common.noop,
  drawScaleBreaks: _common.noop,
  _visualRange: _common.noop,
  _rotateConstantLine: _common.noop,
  applyVisualRangeSetter(visualRangeSetter) {
    this._visualRange = visualRangeSetter;
  },
  // T642779, T714928, T810801
  getCategoriesSorter(argCategories) {
    var sort;
    if (this.isArgumentAxis) {
      sort = argCategories;
    } else {
      var categoriesSortingMethod = this._options.categoriesSortingMethod;
      sort = categoriesSortingMethod !== null && categoriesSortingMethod !== void 0 ? categoriesSortingMethod : this._options.categories;
    }
    return sort;
  },
  _getAdjustedBusinessRange() {
    return this.adjustViewport(this._translator.getBusinessRange());
  }
};

/***/ }),

/***/ 87713:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = createConstantLine;
var _type = __webpack_require__(35922);
function createConstantLine(axis, options) {
  var labelOptions = options.label || {};
  var labelPosition = labelOptions.position || 'inside';
  var parsedValue;
  var valueIsParsed = false;
  var lastStoredCoordinates;
  axis._checkAlignmentConstantLineLabels(labelOptions);
  var storedCoord;
  return {
    options,
    labelOptions,
    labelPosition,
    label: null,
    line: null,
    getParsedValue() {
      if (!valueIsParsed) {
        parsedValue = axis.validateUnit(options.value, 'E2105', 'constantLine');
        valueIsParsed = true;
        return parsedValue;
      }
      return parsedValue;
    },
    draw() {
      if (!(0, _type.isDefined)(options.value) || axis._translator.getBusinessRange().isEmpty()) {
        return this;
      }
      var canvas = axis._getCanvasStartEnd();
      var parsedValue = this.getParsedValue();
      this.coord = axis._getConstantLinePos(parsedValue, canvas.start, canvas.end);
      var rootGroup = options.displayBehindSeries ? axis._axisConstantLineGroups.under : axis._axisConstantLineGroups.above;
      var group = rootGroup[labelPosition];
      if (!group) {
        var side = axis._isHorizontal ? labelOptions.verticalAlignment : labelOptions.horizontalAlignment;
        group = rootGroup[side];
      }
      if (!(0, _type.isDefined)(this.coord)) {
        return this;
      }
      var path = axis._createConstantLine(this.coord, {
        stroke: options.color,
        'stroke-width': options.width,
        dashStyle: options.dashStyle
      });
      this.line = path.append(rootGroup.inside);
      this.label = labelOptions.visible ? axis._drawConstantLineLabels(parsedValue, labelOptions, this.coord, group) : null;
      this.updatePosition();
      return this;
    },
    getContentContainer() {
      return this.label;
    },
    removeLabel() {
      this.label && this.label.remove();
    },
    updatePosition(animate) {
      var canvas = axis._getCanvasStartEnd();
      var coord = axis._getConstantLinePos(this.getParsedValue(), canvas.start, canvas.end);
      if (!(0, _type.isDefined)(coord)) {
        return;
      }
      this.coord = coord;
      if (animate && storedCoord) {
        this.label && this.label.attr(axis._getConstantLineLabelsCoords(storedCoord, this.labelOptions));
        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(storedCoord));
        this.label && this.label.animate(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
        this.line && this.line.animate(axis._getConstantLineGraphicAttributes(this.coord));
      } else {
        this.label && this.label.attr(axis._getConstantLineLabelsCoords(this.coord, this.labelOptions));
        this.line && this.line.attr(axis._getConstantLineGraphicAttributes(this.coord));
        axis._rotateConstantLine(this.line, this.coord);
      }
    },
    saveCoords() {
      lastStoredCoordinates = storedCoord;
      storedCoord = this.coord;
    },
    resetCoordinates() {
      storedCoord = lastStoredCoordinates;
    }
  };
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 89530:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.generateDateBreaks = generateDateBreaks;
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var days = [0, 1, 2, 3, 4, 5, 6];
function getWeekendDays(workdays) {
  return days.filter(function (day) {
    return !workdays.some(function (workDay) {
      return workDay === day;
    });
  });
}
function getNextDayIndex(dayIndex) {
  return (dayIndex + 1) % 7;
}
function dayBetweenWeekend(weekend, day) {
  var start = weekend.start;
  var end = weekend.end;
  while (start !== end) {
    if (start === day) {
      return true;
    }
    start = getNextDayIndex(start);
  }
  return false;
}
function getDaysDistance(day, end) {
  var length = 0;
  while (day !== end) {
    day = getNextDayIndex(day);
    length++;
  }
  return length;
}
function separateBreak(scaleBreak, day) {
  var result = [];
  var dayEnd = new Date(day);
  dayEnd.setDate(day.getDate() + 1);
  if (day > scaleBreak.from) {
    result.push({
      from: scaleBreak.from,
      to: day
    });
  }
  if (dayEnd < scaleBreak.to) {
    result.push({
      from: dayEnd,
      to: scaleBreak.to
    });
  }
  return result;
}
function getWeekEndDayIndices(workDays) {
  var indices = getWeekendDays(workDays);
  if (indices.length < 7) {
    while (getNextDayIndex(indices[indices.length - 1]) === indices[0]) {
      indices.unshift(indices.pop());
    }
  }
  return indices;
}
function generateDateBreaksForWeekend(min, max, weekendDayIndices) {
  var day = min.getDate();
  var breaks = [];
  var weekends = weekendDayIndices.reduce(function (obj, day) {
    var currentWeekEnd = obj[1];
    if (currentWeekEnd.start === undefined) {
      currentWeekEnd = {
        start: day,
        end: getNextDayIndex(day)
      };
      obj[0].push(currentWeekEnd);
      return [obj[0], currentWeekEnd];
    } else if (currentWeekEnd.end === day) {
      currentWeekEnd.end = getNextDayIndex(day);
      return obj;
    }
    currentWeekEnd = {
      start: day,
      end: getNextDayIndex(day)
    };
    obj[0].push(currentWeekEnd);
    return [obj[0], currentWeekEnd];
  }, [[], {}]);
  weekends[0].forEach(function (weekend) {
    var currentDate = new Date(min);
    currentDate = _date.default.trimTime(currentDate);
    while (currentDate < max) {
      day = currentDate.getDay();
      var date = currentDate.getDate();
      if (dayBetweenWeekend(weekend, day)) {
        var from = new Date(currentDate);
        currentDate.setDate(date + getDaysDistance(day, weekend.end));
        var to = new Date(currentDate);
        breaks.push({
          from: from,
          to: to
        });
      }
      currentDate.setDate(currentDate.getDate() + 1);
    }
  });
  return breaks;
}
function excludeWorkDaysFromWeekEndBreaks(breaks, exactWorkDays) {
  var result = breaks.slice();
  var i;
  var processWorkDay = function processWorkDay(workday) {
    workday = _date.default.trimTime(new Date(workday));
    if (result[i].from <= workday && result[i].to > workday) {
      var separatedBreak = separateBreak(result[i], workday);
      if (separatedBreak.length === 2) {
        result.splice(i, 1, separatedBreak[0], separatedBreak[1]);
      } else if (separatedBreak.length === 1) {
        result.splice(i, 1, separatedBreak[0]);
      } else {
        result.splice(i, 1);
      }
    }
  };
  for (i = 0; i < result.length; i++) {
    exactWorkDays.forEach(processWorkDay);
  }
  return result;
}
function generateBreaksForHolidays(min, max, holidays, weekendDayIndices) {
  var day;
  var dayInWeekend = function dayInWeekend(dayIndex) {
    return dayIndex === day;
  };
  var adjustedMin = _date.default.trimTime(min);
  var adjustedMax = _date.default.trimTime(max);
  adjustedMax.setDate(max.getDate() + 1);
  return holidays.reduce(function (breaks, holiday) {
    var holidayStart;
    var holidayEnd;
    holiday = new Date(holiday);
    day = holiday.getDay();
    if (!weekendDayIndices.some(dayInWeekend) && holiday >= adjustedMin && holiday <= adjustedMax) {
      holidayStart = _date.default.trimTime(holiday);
      holidayEnd = new Date(holidayStart);
      holidayEnd.setDate(holidayStart.getDate() + 1);
      breaks.push({
        from: holidayStart,
        to: holidayEnd
      });
    }
    return breaks;
  }, []);
}
function calculateGaps(breaks) {
  return breaks.map(function (b) {
    return {
      from: b.from,
      to: b.to,
      gapSize: _date.default.convertMillisecondsToDateUnits(b.to - b.from)
    };
  });
}
function generateDateBreaks(min, max, workWeek, singleWorkdays, holidays) {
  var weekendDayIndices = getWeekEndDayIndices(workWeek);
  var breaks = generateDateBreaksForWeekend(min, max, weekendDayIndices);
  breaks.push.apply(breaks, generateBreaksForHolidays(min, max, holidays || [], weekendDayIndices));
  return calculateGaps(excludeWorkDaysFromWeekEndBreaks(breaks, singleWorkdays || []));
}

/***/ }),

/***/ 4331:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.linearSpider = exports.linear = exports.circularSpider = exports.circular = void 0;
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
var _xy_axes = _interopRequireDefault(__webpack_require__(99415));
var _tick = __webpack_require__(41013);
var _axes_utils = __webpack_require__(32945);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var PI = Math.PI,
  abs = Math.abs,
  atan = Math.atan,
  round = Math.round;
var _min = Math.min;
var _max = Math.max;
var xyAxesLinear = _xy_axes.default.linear;
var HALF_PI_ANGLE = 90;
function getPolarQuarter(angle) {
  var quarter;
  angle = (0, _utils.normalizeAngle)(angle);
  if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {
    quarter = 1;
  } else if (angle >= 45 && angle < 135) {
    quarter = 2;
  } else if (angle >= 135 && angle < 225) {
    quarter = 3;
  } else if (angle >= 225 && angle < 315) {
    quarter = 4;
  }
  return quarter;
}
var circularAxes = {
  _calculateValueMargins(ticks) {
    var _this$_getViewportRan = this._getViewportRange(),
      minVisible = _this$_getViewportRan.minVisible,
      maxVisible = _this$_getViewportRan.maxVisible;
    if (ticks && ticks.length > 1) {
      minVisible = minVisible < ticks[0].value ? minVisible : ticks[0].value;
      maxVisible = minVisible > ticks[ticks.length - 1].value ? maxVisible : ticks[ticks.length - 1].value;
    }
    return {
      minValue: minVisible,
      maxValue: maxVisible
    };
  },
  applyMargins() {
    var margins = this._calculateValueMargins(this._majorTicks);
    var br = this._translator.getBusinessRange();
    br.addRange({
      minVisible: margins.minValue,
      maxVisible: margins.maxValue,
      interval: this._calculateRangeInterval(br.interval)
    });
    this._translator.updateBusinessRange(br);
  },
  _getTranslatorOptions: function _getTranslatorOptions() {
    return {
      isHorizontal: true,
      conversionValue: true,
      addSpiderCategory: this._getSpiderCategoryOption(),
      stick: this._getStick()
    };
  },
  getCenter: function getCenter() {
    return this._center;
  },
  getRadius: function getRadius() {
    return this._radius;
  },
  getAngles: function getAngles() {
    var options = this._options;
    return [options.startAngle, options.endAngle];
  },
  _updateRadius(canvas) {
    var rad = _min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2;
    this._radius = rad < 0 ? 0 : rad;
  },
  _updateCenter: function _updateCenter(canvas) {
    this._center = {
      x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,
      y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2
    };
  },
  _processCanvas: function _processCanvas(canvas) {
    this._updateRadius(canvas);
    this._updateCenter(canvas);
    return {
      left: 0,
      right: 0,
      width: this._getScreenDelta()
    };
  },
  _createAxisElement: function _createAxisElement() {
    return this._renderer.circle();
  },
  _updateAxisElementPosition: function _updateAxisElementPosition() {
    var center = this.getCenter();
    this._axisElement.attr({
      cx: center.x,
      cy: center.y,
      r: this.getRadius()
    });
  },
  _boundaryTicksVisibility: {
    min: true
  },
  _getSpiderCategoryOption: function _getSpiderCategoryOption() {
    // TODO rename spider
    return this._options.firstPointOnStartAngle;
  },
  _validateOptions(options) {
    var that = this;
    var originValue = options.originValue;
    var wholeRange = options.wholeRange = {};
    var period = options.period;
    if ((0, _type.isDefined)(originValue)) {
      originValue = that.validateUnit(originValue);
    }
    if (period > 0 && options.argumentType === _axes_constants.default.numeric) {
      originValue = originValue || 0;
      wholeRange.endValue = originValue + period;
      that._viewport = (0, _utils.getVizRangeObject)([originValue, wholeRange.endValue]);
    }
    if ((0, _type.isDefined)(originValue)) {
      wholeRange.startValue = originValue;
    }
  },
  getMargins() {
    var tickOptions = this._options.tick;
    var tickOuterLength = _max(tickOptions.visible ? tickOptions.length / 2 + tickOptions.shift : 0, 0);
    var radius = this.getRadius();
    var _this$_center = this._center,
      x = _this$_center.x,
      y = _this$_center.y;
    var labelBoxes = this._majorTicks.map(function (t) {
      return t.label && t.label.getBBox();
    }).filter(function (b) {
      return b;
    });
    var canvas = (0, _extend.extend)({}, this._canvas, {
      left: x - radius,
      top: y - radius,
      right: this._canvas.width - (x + radius),
      bottom: this._canvas.height - (y + radius)
    });
    var margins = (0, _axes_utils.calculateCanvasMargins)(labelBoxes, canvas);
    Object.keys(margins).forEach(function (k) {
      return margins[k] = margins[k] < tickOuterLength ? tickOuterLength : margins[k];
    });
    return margins;
  },
  _updateLabelsPosition() {
    var that = this;
    (0, _axes_utils.measureLabels)(that._majorTicks);
    that._adjustLabelsCoord(0, 0, true);
    that._checkBoundedLabelsOverlapping(this._majorTicks, this._majorTicks.map(function (t) {
      return t.labelBBox;
    }));
  },
  _setVisualRange: _common.noop,
  applyVisualRangeSetter: _common.noop,
  _getStick: function _getStick() {
    return this._options.firstPointOnStartAngle || this._options.type !== _axes_constants.default.discrete;
  },
  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
    return this._translator.translate(value, offset) - HALF_PI_ANGLE;
  },
  _getCanvasStartEnd: function _getCanvasStartEnd() {
    return {
      start: 0 - HALF_PI_ANGLE,
      end: 360 - HALF_PI_ANGLE
    };
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromAngle, toAngle) {
    var center = this.getCenter();
    var angle = this.getAngles()[0];
    var r = this.getRadius();
    return {
      x: center.x,
      y: center.y,
      innerRadius: 0,
      outerRadius: r,
      startAngle: -toAngle - angle,
      endAngle: -fromAngle - angle
    };
  },
  _createStrip: function _createStrip(coords) {
    return this._renderer.arc(coords.x, coords.y, coords.innerRadius, coords.outerRadius, coords.startAngle, coords.endAngle);
  },
  _getStripLabelCoords: function _getStripLabelCoords(from, to) {
    var that = this;
    var coords = that._getStripGraphicAttributes(from, to);
    var angle = coords.startAngle + (coords.endAngle - coords.startAngle) / 2;
    var cosSin = (0, _utils.getCosAndSin)(angle);
    var halfRad = that.getRadius() / 2;
    var center = that.getCenter();
    var x = round(center.x + halfRad * cosSin.cos);
    var y = round(center.y - halfRad * cosSin.sin);
    return {
      x: x,
      y: y,
      align: _axes_constants.default.center
    };
  },
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    var center = this.getCenter();
    var r = this.getRadius();
    return {
      points: [center.x, center.y, center.x + r, center.y]
    };
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);
  },
  _rotateConstantLine(line, value) {
    var _this$getCenter = this.getCenter(),
      x = _this$getCenter.x,
      y = _this$getCenter.y;
    line.rotate(value + this.getAngles()[0], x, y);
  },
  _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value) {
    var that = this;
    var cosSin = (0, _utils.getCosAndSin)(-value - that.getAngles()[0]);
    var halfRad = that.getRadius() / 2;
    var center = that.getCenter();
    var x = round(center.x + halfRad * cosSin.cos);
    var y = round(center.y - halfRad * cosSin.sin);
    return {
      x: x,
      y: y
    };
  },
  _checkAlignmentConstantLineLabels: _common.noop,
  _adjustDivisionFactor: function _adjustDivisionFactor(val) {
    return val * 180 / (this.getRadius() * PI);
  },
  _getScreenDelta: function _getScreenDelta() {
    var angles = this.getAngles();
    return abs(angles[0] - angles[1]);
  },
  _getTickMarkPoints: function _getTickMarkPoints(coords, length, _ref) {
    var _ref$shift = _ref.shift,
      shift = _ref$shift === void 0 ? 0 : _ref$shift;
    var center = this.getCenter();
    var corrections = {
      inside: -1,
      center: -0.5,
      outside: 0
    };
    var radiusWithTicks = this.getRadius() + length * corrections[this._options.tickOrientation || 'center'];
    return [center.x + radiusWithTicks + shift, center.y, center.x + radiusWithTicks + length + shift, center.y];
  },
  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick, _offset, _maxWidth, checkCanvas) {
    var that = this;
    var labelCoords = tick.labelCoords;
    var labelY = labelCoords.y;
    var labelAngle = labelCoords.angle;
    var cosSin = (0, _utils.getCosAndSin)(labelAngle);
    var cos = cosSin.cos;
    var sin = cosSin.sin;
    var box = tick.labelBBox;
    var halfWidth = box.width / 2;
    var halfHeight = box.height / 2;
    var indentFromAxis = that._options.label.indentFromAxis || 0;
    var x = labelCoords.x + indentFromAxis * cos;
    var y = labelY + (labelY - box.y - halfHeight) + indentFromAxis * sin;
    var shiftX = 0;
    var shiftY = 0;
    switch (getPolarQuarter(labelAngle)) {
      case 1:
        shiftX = halfWidth;
        shiftY = halfHeight * sin;
        break;
      case 2:
        shiftX = halfWidth * cos;
        shiftY = halfHeight;
        break;
      case 3:
        shiftX = -halfWidth;
        shiftY = halfHeight * sin;
        break;
      case 4:
        shiftX = halfWidth * cos;
        shiftY = -halfHeight;
        break;
    }
    if (checkCanvas) {
      var canvas = that._canvas;
      var boxShiftX = x - labelCoords.x + shiftX;
      var boxShiftY = y - labelCoords.y + shiftY;
      if (box.x + boxShiftX < canvas.originalLeft) {
        shiftX -= box.x + boxShiftX - canvas.originalLeft;
      }
      if (box.x + box.width + boxShiftX > canvas.width - canvas.originalRight) {
        shiftX -= box.x + box.width + boxShiftX - (canvas.width - canvas.originalRight);
      }
      if (box.y + boxShiftY < canvas.originalTop) {
        shiftY -= box.y + boxShiftY - canvas.originalTop;
      }
      if (box.y + box.height + boxShiftY > canvas.height - canvas.originalBottom) {
        shiftY -= box.y + box.height + boxShiftY - (canvas.height - canvas.originalBottom);
      }
    }
    return {
      x: x + shiftX,
      y: y + shiftY
    };
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      var center = that.getCenter();
      return that._createPathElement(that._getGridPoints().points, gridStyle).rotate(tick.coords.angle, center.x, center.y);
    };
  },
  _getGridPoints: function _getGridPoints() {
    var r = this.getRadius();
    var center = this.getCenter();
    return {
      points: [center.x, center.y, center.x + r, center.y]
    };
  },
  _getTranslatedValue: function _getTranslatedValue(value, offset) {
    var startAngle = this.getAngles()[0];
    var angle = this._translator.translate(value, -offset);
    var coords = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, angle, this.getRadius());
    return {
      x: coords.x,
      y: coords.y,
      angle: this.getTranslatedAngle(angle)
    };
  },
  _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {
    var box = strip.labelBBox;
    return {
      translateY: strip.label.attr('y') - box.y - box.height / 2
    };
  },
  coordsIn: function coordsIn(x, y) {
    return (0, _utils.convertXYToPolar)(this.getCenter(), x, y).r > this.getRadius();
  },
  _rotateTick: function _rotateTick(element, coords) {
    var center = this.getCenter();
    element.rotate(coords.angle, center.x, center.y);
  },
  _validateOverlappingMode: function _validateOverlappingMode(mode) {
    return _axes_constants.default.validateOverlappingMode(mode);
  },
  _validateDisplayMode: function _validateDisplayMode() {
    return 'standard';
  },
  _getStep: function _getStep(boxes) {
    var that = this;
    var radius = that.getRadius() + (that._options.label.indentFromAxis || 0);
    var maxLabelBox = boxes.reduce(function (prevValue, box) {
      var curValue = prevValue;
      if (prevValue.width < box.width) {
        curValue.width = box.width;
      }
      if (prevValue.height < box.height) {
        curValue.height = box.height;
      }
      return curValue;
    }, {
      width: 0,
      height: 0
    });
    var angle1 = abs(2 * atan(maxLabelBox.height / (2 * radius - maxLabelBox.width)) * 180 / PI);
    var angle2 = abs(2 * atan(maxLabelBox.width / (2 * radius - maxLabelBox.height)) * 180 / PI);
    return _axes_constants.default.getTicksCountInRange(that._majorTicks, 'angle', _max(angle1, angle2));
  },
  _checkBoundedLabelsOverlapping: function _checkBoundedLabelsOverlapping(majorTicks, boxes, mode) {
    var labelOpt = this._options.label;
    mode = mode || this._validateOverlappingMode(labelOpt.overlappingBehavior);
    if (mode !== 'hide') {
      return;
    }
    var lastVisibleLabelIndex = majorTicks.reduce(function (lastVisibleLabelIndex, tick, index) {
      return tick.label ? index : lastVisibleLabelIndex;
    }, null);
    if (!lastVisibleLabelIndex) {
      return;
    }
    if (_axes_constants.default.areLabelsOverlap(boxes[0], boxes[lastVisibleLabelIndex], labelOpt.minSpacing, _axes_constants.default.center)) {
      labelOpt.hideFirstOrLast === 'first' ? majorTicks[0].removeLabel() : majorTicks[lastVisibleLabelIndex].removeLabel();
    }
  },
  shift: function shift(margins) {
    this._axisGroup.attr({
      translateX: margins.right,
      translateY: margins.bottom
    });
    this._axisElementsGroup.attr({
      translateX: margins.right,
      translateY: margins.bottom
    });
  },
  getTranslatedAngle(angle) {
    var startAngle = this.getAngles()[0];
    return angle + startAngle - HALF_PI_ANGLE;
  }
};
var circular = circularAxes;
exports.circular = circular;
var circularSpider = (0, _extend.extend)({}, circularAxes, {
  _createAxisElement: function _createAxisElement() {
    return this._renderer.path([], 'area');
  },
  _updateAxisElementPosition: function _updateAxisElementPosition() {
    this._axisElement.attr({
      points: (0, _utils.map)(this.getSpiderTicks(), function (tick) {
        return {
          x: tick.coords.x,
          y: tick.coords.y
        };
      })
    });
  },
  _getStick: function _getStick() {
    return true;
  },
  _getSpiderCategoryOption: function _getSpiderCategoryOption() {
    return true;
  },
  getSpiderTicks: function getSpiderTicks() {
    var that = this;
    var ticks = that.getFullTicks();
    that._spiderTicks = ticks.map((0, _tick.tick)(that, that.renderer, {}, {}, that._getSkippedCategory(ticks), true));
    that._spiderTicks.forEach(function (tick) {
      tick.initCoords();
    });
    return that._spiderTicks;
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromAngle, toAngle) {
    var center = this.getCenter();
    var spiderTicks = this.getSpiderTicks();
    var firstTick;
    var lastTick;
    var nextTick;
    var tick;
    var points = [];
    var i = 0;
    var len = spiderTicks.length;
    while (i < len) {
      tick = spiderTicks[i].coords;
      if (tick.angle >= fromAngle && tick.angle <= toAngle) {
        if (!firstTick) {
          firstTick = (spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1]).coords;
          points.push((tick.x + firstTick.x) / 2, (tick.y + firstTick.y) / 2);
        }
        points.push(tick.x, tick.y);
        nextTick = (spiderTicks[i + 1] || spiderTicks[0]).coords;
        lastTick = {
          x: (tick.x + nextTick.x) / 2,
          y: (tick.y + nextTick.y) / 2
        };
      }
      i++;
    }
    points.push(lastTick.x, lastTick.y);
    points.push(center.x, center.y);
    return {
      points: points
    };
  },
  _createStrip: function _createStrip(_ref2) {
    var points = _ref2.points;
    return this._renderer.path(points, 'area');
  },
  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
    return this._translator.translate(value, offset) - HALF_PI_ANGLE;
  },
  _setTickOffset: function _setTickOffset() {
    this._tickOffset = false;
  }
});
exports.circularSpider = circularSpider;
var linear = {
  _resetMargins() {
    this._reinitTranslator(this._getViewportRange());
  },
  _getStick: xyAxesLinear._getStick,
  _getSpiderCategoryOption: _common.noop,
  _getTranslatorOptions: function _getTranslatorOptions() {
    return {
      isHorizontal: true,
      stick: this._getStick()
    };
  },
  getRadius: circularAxes.getRadius,
  getCenter: circularAxes.getCenter,
  getAngles: circularAxes.getAngles,
  _updateRadius: circularAxes._updateRadius,
  _updateCenter: circularAxes._updateCenter,
  _processCanvas(canvas) {
    this._updateRadius(canvas);
    this._updateCenter(canvas);
    return {
      left: 0,
      right: 0,
      startPadding: canvas.startPadding,
      endPadding: canvas.endPadding,
      width: this.getRadius()
    };
  },
  _createAxisElement: xyAxesLinear._createAxisElement,
  _updateAxisElementPosition: function _updateAxisElementPosition() {
    var centerCoord = this.getCenter();
    this._axisElement.attr({
      points: [centerCoord.x, centerCoord.y, centerCoord.x + this.getRadius(), centerCoord.y]
    }).rotate(this.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y);
  },
  _getScreenDelta: function _getScreenDelta() {
    return this.getRadius();
  },
  _getTickMarkPoints: function _getTickMarkPoints(coords, length) {
    return [coords.x - length / 2, coords.y, coords.x + length / 2, coords.y];
  },
  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick) {
    var that = this;
    var labelCoords = tick.labelCoords;
    var labelY = labelCoords.y;
    var cosSin = (0, _utils.getCosAndSin)(labelCoords.angle);
    var indentFromAxis = that._options.label.indentFromAxis || 0;
    var box = tick.labelBBox;
    var x = labelCoords.x - abs(indentFromAxis * cosSin.sin) + abs(box.width / 2 * cosSin.cos) - box.width / 2;
    var y = labelY + (labelY - box.y) - abs(box.height / 2 * cosSin.sin) + abs(indentFromAxis * cosSin.cos);
    return {
      x: x,
      y: y
    };
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      var grid = that._getGridPoints(tick.coords);
      return that._renderer.circle(grid.cx, grid.cy, grid.r).attr(gridStyle).sharp();
    };
  },
  _getGridPoints: function _getGridPoints(coords) {
    var pos = this.getCenter();
    var radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);
    if (radius > this.getRadius()) {
      return {
        cx: null,
        cy: null,
        r: null
      };
    }
    return {
      cx: pos.x,
      cy: pos.y,
      r: radius
    };
  },
  _getTranslatedValue: function _getTranslatedValue(value, offset) {
    var startAngle = this.getAngles()[0];
    var xy = (0, _utils.convertPolarToXY)(this.getCenter(), startAngle, 0, this._translator.translate(value, offset));
    return {
      x: xy.x,
      y: xy.y,
      angle: startAngle - HALF_PI_ANGLE
    };
  },
  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
    return this._translator.translate(value, offset);
  },
  _getCanvasStartEnd() {
    var invert = this.getTranslator().getBusinessRange().invert;
    var coords = [0, this.getRadius()];
    invert && coords.reverse();
    return {
      start: coords[0],
      end: coords[1]
    };
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {
    var center = this.getCenter();
    return {
      x: center.x,
      y: center.y,
      innerRadius: fromPoint,
      outerRadius: toPoint
    };
  },
  _createStrip: function _createStrip(attrs) {
    return this._renderer.arc(attrs.x, attrs.y, attrs.innerRadius, attrs.outerRadius, 0, 360);
  },
  _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,
  _getStripLabelCoords: function _getStripLabelCoords(from, to) {
    var that = this;
    var labelPos = from + (to - from) / 2;
    var center = that.getCenter();
    var y = round(center.y - labelPos);
    return {
      x: center.x,
      y: y,
      align: _axes_constants.default.center
    };
  },
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    var center = this.getCenter();
    return {
      cx: center.x,
      cy: center.y,
      r: value
    };
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    var attrs = this._getConstantLineGraphicAttributes(value);
    return this._renderer.circle(attrs.cx, attrs.cy, attrs.r).attr(attr).sharp();
  },
  _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value) {
    var that = this;
    var center = that.getCenter();
    var y = round(center.y - value);
    return {
      x: center.x,
      y: y
    };
  },
  _checkAlignmentConstantLineLabels: _common.noop,
  _rotateTick: function _rotateTick(element, coords, isGridLine) {
    !isGridLine && element.rotate(coords.angle + HALF_PI_ANGLE, coords.x, coords.y);
  },
  _validateOverlappingMode: circularAxes._validateOverlappingMode,
  _validateDisplayMode: circularAxes._validateDisplayMode,
  _getStep: function _getStep(boxes) {
    var quarter = getPolarQuarter(this.getAngles()[0]);
    var spacing = this._options.label.minSpacing;
    var func = quarter === 2 || quarter === 4 ? function (box) {
      return box.width + spacing;
    } : function (box) {
      return box.height;
    };
    var maxLabelLength = boxes.reduce(function (prevValue, box) {
      return _max(prevValue, func(box));
    }, 0);
    return _axes_constants.default.getTicksCountInRange(this._majorTicks, quarter === 2 || quarter === 4 ? 'x' : 'y', maxLabelLength);
  }
};
exports.linear = linear;
var linearSpider = (0, _extend.extend)({}, linear, {
  _createPathElement: function _createPathElement(points, attr) {
    return this._renderer.path(points, 'area').attr(attr).sharp();
  },
  setSpiderTicks: function setSpiderTicks(ticks) {
    this._spiderTicks = ticks;
  },
  _getGridLineDrawer: function _getGridLineDrawer() {
    var that = this;
    return function (tick, gridStyle) {
      return that._createPathElement(that._getGridPoints(tick.coords).points, gridStyle);
    };
  },
  _getGridPoints: function _getGridPoints(coords) {
    var pos = this.getCenter();
    var radius = (0, _utils.getDistance)(pos.x, pos.y, coords.x, coords.y);
    return this._getGridPointsByRadius(radius);
  },
  _getGridPointsByRadius: function _getGridPointsByRadius(radius) {
    var pos = this.getCenter();
    if (radius > this.getRadius()) {
      return {
        points: null
      };
    }
    return {
      points: (0, _utils.map)(this._spiderTicks, function (tick) {
        var cosSin = (0, _utils.getCosAndSin)(tick.coords.angle);
        return {
          x: round(pos.x + radius * cosSin.cos),
          y: round(pos.y + radius * cosSin.sin)
        };
      })
    };
  },
  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {
    var innerPoints = this._getGridPointsByRadius(toPoint).points;
    var outerPoints = this._getGridPointsByRadius(fromPoint).points;
    return {
      points: [outerPoints, innerPoints.reverse()]
    };
  },
  _createStrip: circularSpider._createStrip,
  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {
    return this._getGridPointsByRadius(value);
  },
  _createConstantLine: function _createConstantLine(value, attr) {
    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);
  }
});
exports.linearSpider = linearSpider;

/***/ }),

/***/ 41583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.formatRange = formatRange;
exports.smartFormatter = smartFormatter;
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _math = __webpack_require__(60810);
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _format = _format_helper.default.format;
var abs = Math.abs,
  floor = Math.floor;
var EXPONENTIAL = 'exponential';
var formats = ['fixedPoint', 'thousands', 'millions', 'billions', 'trillions', EXPONENTIAL];
var dateUnitIntervals = ['millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'];
var INTERVALS_MAP = {
  'week': 'day',
  'quarter': 'month',
  'shorttime': 'hour',
  'longtime': 'second'
};
function patchFirstTickDiff(differences, tickFormatIndex) {
  for (var i = tickFormatIndex; i < dateUnitIntervals.length - 1; i++) {
    var dateUnitInterval = dateUnitIntervals[i];
    if (i === tickFormatIndex) {
      setDateUnitInterval(differences, tickFormatIndex + (differences['millisecond'] ? 2 : 1));
      break;
    } else if (differences[dateUnitInterval] && differences.count > 1) {
      resetDateUnitInterval(differences, i);
      break;
    }
  }
}
function patchTickDiff(differences, tickFormatIndex) {
  var patched = false;
  for (var i = dateUnitIntervals.length - 1; i >= tickFormatIndex; i--) {
    var dateUnitInterval = dateUnitIntervals[i];
    if (differences[dateUnitInterval]) {
      if (i - tickFormatIndex > 1) {
        for (var j = 0; j <= tickFormatIndex; j++) {
          resetDateUnitInterval(differences, j);
          patched = true;
        }
        break;
      }
    }
  }
  return patched;
}
function getDatesDifferences(prevDate, curDate, nextDate, tickIntervalFormat) {
  tickIntervalFormat = INTERVALS_MAP[tickIntervalFormat] || tickIntervalFormat;
  var tickFormatIndex = dateUnitIntervals.indexOf(tickIntervalFormat);
  if (nextDate) {
    var nextDifferences = _date.default.getDatesDifferences(curDate, nextDate);
    if (nextDifferences[tickIntervalFormat]) {
      patchFirstTickDiff(nextDifferences, tickFormatIndex);
    }
    return nextDifferences;
  } else {
    var prevDifferences = _date.default.getDatesDifferences(prevDate, curDate);
    var patched = patchTickDiff(prevDifferences, tickFormatIndex);
    if (!patched && prevDifferences.count === 1) {
      setDateUnitInterval(prevDifferences, tickFormatIndex);
    }
    return prevDifferences;
  }
}
function resetDateUnitInterval(differences, intervalIndex) {
  var dateUnitInterval = dateUnitIntervals[intervalIndex];
  if (differences[dateUnitInterval]) {
    differences[dateUnitInterval] = false;
    differences.count--;
  }
}
function setDateUnitInterval(differences, intervalIndex) {
  var dateUnitInterval = dateUnitIntervals[intervalIndex];
  if (differences[dateUnitInterval] === false) {
    differences[dateUnitInterval] = true;
    differences.count++;
  }
}
function getNoZeroIndex(str) {
  return str.length - parseInt(str).toString().length;
}
function getTransitionTickIndex(ticks, value) {
  var i;
  var curDiff;
  var minDiff;
  var nearestTickIndex = 0;
  minDiff = abs(value - ticks[0]);
  for (i = 1; i < ticks.length; i++) {
    curDiff = abs(value - ticks[i]);
    if (curDiff < minDiff) {
      minDiff = curDiff;
      nearestTickIndex = i;
    }
  }
  return nearestTickIndex;
}
function splitDecimalNumber(value) {
  return value.toString().split('.');
}
function createFormat(type) {
  var formatter;
  if ((0, _type.isFunction)(type)) {
    formatter = type;
    type = null;
  }
  return {
    type,
    formatter
  };
}
function formatLogarithmicNumber(tick) {
  var log10Tick = (0, _utils.getAdjustedLog10)(abs(tick));
  var type;
  if (log10Tick > 0) {
    type = formats[floor(log10Tick / 3)] || EXPONENTIAL;
  } else {
    if (log10Tick < -4) {
      type = EXPONENTIAL;
    } else {
      return _format((0, _math.adjust)(tick));
    }
  }
  return _format(tick, {
    type,
    precision: 0
  });
}
function getDateTimeFormat(tick, _ref) {
  var showTransition = _ref.showTransition,
    ticks = _ref.ticks,
    tickInterval = _ref.tickInterval;
  var typeFormat = _date.default.getDateFormatByTickInterval(tickInterval);
  var prevDateIndex;
  var nextDateIndex;
  if (showTransition && ticks.length) {
    var indexOfTick = ticks.map(Number).indexOf(+tick);
    if (ticks.length === 1 && indexOfTick === 0) {
      typeFormat = _format_helper.default.getDateFormatByTicks(ticks);
    } else {
      if (indexOfTick === -1) {
        prevDateIndex = getTransitionTickIndex(ticks, tick);
      } else {
        prevDateIndex = indexOfTick === 0 ? ticks.length - 1 : indexOfTick - 1;
        nextDateIndex = indexOfTick === 0 ? 1 : -1;
      }
      var datesDifferences = getDatesDifferences(ticks[prevDateIndex], tick, ticks[nextDateIndex], typeFormat);
      typeFormat = _format_helper.default.getDateFormatByDifferences(datesDifferences, typeFormat);
    }
  }
  return createFormat(typeFormat);
}
function getFormatExponential(tick, tickInterval) {
  var stringTick = abs(tick).toString();
  if ((0, _type.isExponential)(tick)) {
    return Math.max(abs((0, _math.getExponent)(tick) - (0, _math.getExponent)(tickInterval)), abs((0, _math.getPrecision)(tick) - (0, _math.getPrecision)(tickInterval)));
  } else {
    return abs(getNoZeroIndex(stringTick.split('.')[1]) - (0, _math.getExponent)(tickInterval) + 1);
  }
}
function getFormatWithModifier(tick, tickInterval) {
  var tickIntervalIndex = floor((0, _utils.getAdjustedLog10)(tickInterval));
  var tickIndex;
  var precision = 0;
  var actualIndex = tickIndex = floor((0, _utils.getAdjustedLog10)(abs(tick)));
  if (tickIndex - tickIntervalIndex >= 2) {
    actualIndex = tickIntervalIndex;
  }
  var indexOfFormat = floor(actualIndex / 3);
  var offset = indexOfFormat * 3;
  if (indexOfFormat < 0) {
    indexOfFormat = 0;
  }
  var typeFormat = formats[indexOfFormat] || formats[formats.length - 1];
  if (offset > 0) {
    var separatedTickInterval = splitDecimalNumber(tickInterval / Math.pow(10, offset));
    if (separatedTickInterval[1]) {
      precision = separatedTickInterval[1].length;
    }
  }
  return {
    precision,
    type: typeFormat
  };
}
function getHighDiffFormat(diff) {
  var stop = false;
  for (var i in diff) {
    if (diff[i] === true || i === 'hour' || stop) {
      diff[i] = false;
      stop = true;
    } else if (diff[i] === false) {
      diff[i] = true;
    }
  }
  return createFormat(_format_helper.default.getDateFormatByDifferences(diff));
}
function getHighAndSelfDiffFormat(diff, interval) {
  var stop = false;
  for (var i in diff) {
    if (stop) {
      diff[i] = false;
    } else if (i === interval) {
      stop = true;
    } else {
      diff[i] = true;
    }
  }
  return createFormat(_format_helper.default.getDateFormatByDifferences(diff));
}
function formatDateRange(startValue, endValue, tickInterval) {
  var diff = getDatesDifferences(startValue, endValue);
  var typeFormat = _date.default.getDateFormatByTickInterval(tickInterval);
  var diffFormatType = _format_helper.default.getDateFormatByDifferences(diff, typeFormat);
  var diffFormat = createFormat(diffFormatType);
  var values = [];
  if (tickInterval in diff) {
    var rangeFormat = getHighAndSelfDiffFormat(getDatesDifferences(startValue, endValue), tickInterval);
    var value = _format(startValue, rangeFormat);
    if (value) {
      values.push(value);
    }
  } else {
    var _rangeFormat = getHighDiffFormat(getDatesDifferences(startValue, endValue));
    var highValue = _format(startValue, _rangeFormat);
    if (highValue) {
      values.push(highValue);
    }
    values.push("".concat(_format(startValue, diffFormat), " - ").concat(_format(endValue, diffFormat)));
  }
  return values.join(', ');
}
function processDateInterval(interval) {
  if ((0, _type.isObject)(interval)) {
    var dateUnits = Object.keys(interval);
    var sum = dateUnits.reduce(function (sum, k) {
      return interval[k] + sum;
    }, 0);
    if (sum === 1) {
      var dateUnit = dateUnits.filter(function (k) {
        return interval[k] === 1;
      })[0];
      return dateUnit.slice(0, dateUnit.length - 1);
    }
  }
  return interval;
}
function smartFormatter(tick, options) {
  var tickInterval = options.tickInterval;
  var stringTick = abs(tick).toString();
  var format = options.labelOptions.format;
  var ticks = options.ticks;
  var isLogarithmic = options.type === 'logarithmic';
  if (ticks.length === 1 && ticks.indexOf(tick) === 0 && !(0, _type.isDefined)(tickInterval)) {
    tickInterval = abs(tick) >= 1 ? 1 : (0, _math.adjust)(1 - abs(tick), tick);
  }
  if (Object.is(tick, -0)) {
    tick = 0;
  }
  if (!(0, _type.isDefined)(format) && options.type !== 'discrete' && tick && (options.logarithmBase === 10 || !isLogarithmic)) {
    if (options.dataType !== 'datetime' && (0, _type.isDefined)(tickInterval)) {
      if (ticks.length && ticks.indexOf(tick) === -1) {
        var indexOfTick = getTransitionTickIndex(ticks, tick);
        tickInterval = (0, _math.adjust)(abs(tick - ticks[indexOfTick]), tick);
      }
      if (isLogarithmic) {
        return formatLogarithmicNumber(tick);
      } else {
        var separatedTickInterval = splitDecimalNumber(tickInterval);
        if (separatedTickInterval < 2) {
          separatedTickInterval = splitDecimalNumber(tick);
        }
        if (separatedTickInterval.length > 1 && !(0, _type.isExponential)(tickInterval)) {
          format = {
            type: formats[0],
            precision: separatedTickInterval[1].length
          };
        } else {
          if ((0, _type.isExponential)(tickInterval) && (stringTick.indexOf('.') !== -1 || (0, _type.isExponential)(tick))) {
            format = {
              type: EXPONENTIAL,
              precision: getFormatExponential(tick, tickInterval)
            };
          } else {
            format = getFormatWithModifier(tick, tickInterval);
          }
        }
      }
    } else if (options.dataType === 'datetime') {
      format = getDateTimeFormat(tick, options);
    }
  }
  return _format(tick, format);
}
function formatRange(_ref2) {
  var startValue = _ref2.startValue,
    endValue = _ref2.endValue,
    tickInterval = _ref2.tickInterval,
    argumentFormat = _ref2.argumentFormat,
    _ref2$axisOptions = _ref2.axisOptions,
    dataType = _ref2$axisOptions.dataType,
    type = _ref2$axisOptions.type,
    logarithmBase = _ref2$axisOptions.logarithmBase;
  if (type === 'discrete') {
    return '';
  }
  if (dataType === 'datetime') {
    return formatDateRange(startValue, endValue, processDateInterval(tickInterval));
  }
  var formatOptions = {
    ticks: [],
    type,
    dataType,
    tickInterval,
    logarithmBase,
    labelOptions: {
      format: argumentFormat
    }
  };
  return "".concat(smartFormatter(startValue, formatOptions), " - ").concat(smartFormatter(endValue, formatOptions));
}

/***/ }),

/***/ 54978:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = createStrip;
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
function createStrip(axis, options) {
  var storedCoord;
  var lastStoredCoordinates;
  var labelOptions = options.label || {};
  return {
    options,
    label: null,
    rect: null,
    _getCoord() {
      var canvas = axis._getCanvasStartEnd();
      var range = axis._translator.getBusinessRange();
      return axis._getStripPos(options.startValue, options.endValue, canvas.start, canvas.end, range);
    },
    _drawLabel(coords) {
      return axis._renderer.text(labelOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)((0, _extend.extend)({}, axis.getOptions().label.font, labelOptions.font))).attr({
        align: 'center',
        'class': labelOptions.cssClass
      }).append(axis._axisStripLabelGroup);
    },
    draw() {
      if (axis._translator.getBusinessRange().isEmpty()) {
        return;
      }
      if (((0, _type.isDefined)(options.startValue) || (0, _type.isDefined)(options.endValue)) && (0, _type.isDefined)(options.color)) {
        var stripPos = this._getCoord();
        this.labelCoords = labelOptions.text ? axis._getStripLabelCoords(stripPos.from, stripPos.to, labelOptions) : null;
        if (stripPos.outOfCanvas || !(0, _type.isDefined)(stripPos.to) || !(0, _type.isDefined)(stripPos.from)) {
          return;
        }
        this.rect = axis._createStrip(axis._getStripGraphicAttributes(stripPos.from, stripPos.to)).attr({
          fill: options.color
        }).append(axis._axisStripGroup);
        this.label = labelOptions.text ? this._drawLabel(this.labelCoords) : null;
      }
    },
    getContentContainer() {
      return this.label;
    },
    removeLabel() {},
    updatePosition(animate) {
      var stripPos = this._getCoord();
      if (animate && storedCoord) {
        this.label && this.label.attr(axis._getStripLabelCoords(storedCoord.from, storedCoord.to, options.label));
        this.rect && this.rect.attr(axis._getStripGraphicAttributes(storedCoord.from, storedCoord.to));
        this.label && this.label.animate(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
        this.rect && this.rect.animate(axis._getStripGraphicAttributes(stripPos.from, stripPos.to));
      } else {
        this.label && this.label.attr(axis._getStripLabelCoords(stripPos.from, stripPos.to, options.label));
        this.rect && this.rect.attr(axis._getStripGraphicAttributes(stripPos.from, stripPos.to));
      }
    },
    saveCoords() {
      lastStoredCoordinates = storedCoord;
      storedCoord = this._getCoord();
    },
    resetCoordinates() {
      storedCoord = lastStoredCoordinates;
    }
  };
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 41013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.tick = createTick;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _deferred = __webpack_require__(62754);
function getPathStyle(options) {
  return {
    stroke: options.color,
    'stroke-width': options.width,
    'stroke-opacity': options.opacity,
    opacity: 1
  };
}
function createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {
  var tickOffset = offset || axis._tickOffset;
  var lineGroup = axis._axisLineGroup;
  var elementsGroup = axis._axisElementsGroup;
  var tickStyle = getPathStyle(tickOptions);
  var gridStyle = getPathStyle(gridOptions);
  var emptyStrRegExp = /^\s+$/;
  var axisOptions = axis.getOptions();
  var labelOptions = axisOptions.label;
  var labelStyle = axis._textOptions;
  function getLabelFontStyle(tick) {
    var fontStyle = axis._textFontStyles;
    var customizeColor = labelOptions.customizeColor;
    if (customizeColor && customizeColor.call) {
      fontStyle = (0, _extend.extend)({}, axis._textFontStyles, {
        fill: customizeColor.call(tick, tick)
      });
    }
    return fontStyle;
  }
  function createLabelHint(tick, range) {
    var labelHint = axis.formatHint(tick.value, labelOptions, range);
    if ((0, _type.isDefined)(labelHint) && labelHint !== '') {
      tick.getContentContainer().setTitle(labelHint);
    }
  }
  return function (value) {
    var tick = {
      value: value,
      updateValue(newValue) {
        this.value = value = newValue;
      },
      initCoords: function initCoords() {
        this.coords = axis._getTranslatedValue(value, tickOffset);
        this.labelCoords = axis._getTranslatedValue(value);
      },
      saveCoords() {
        this._lastStoredCoordinates = {
          coords: this._storedCoords,
          labelCoords: this._storedLabelsCoords
        };
        this._storedCoords = this.coords;
        this._storedLabelsCoords = this.templateContainer ? this._getTemplateCoords() : this.labelCoords;
      },
      resetCoordinates() {
        if (this._lastStoredCoordinates) {
          this._storedCoords = this._lastStoredCoordinates.coords;
          this._storedLabelsCoords = this._lastStoredCoordinates.labelCoords;
        }
      },
      drawMark(options) {
        if (!tickOptions.visible || skippedCategory === value) {
          return;
        }
        if (axis.areCoordsOutsideAxis(this.coords)) {
          return;
        }
        if (this.mark) {
          this.mark.append(lineGroup);
          axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));
          this.updateTickPosition(options);
        } else {
          this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);
          this.updateTickPosition(options);
        }
      },
      setSkippedCategory(category) {
        skippedCategory = category;
      },
      _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {
        if (!lineElement) {
          return;
        }
        if (settings.points === null || settings.r === null) {
          lineElement.remove();
          return;
        }
        if (animate && storedSettings && storedSettings.points !== null) {
          settings.opacity = 1;
          lineElement.attr(storedSettings);
          lineElement.animate(settings);
        } else {
          settings.opacity = animate ? 0 : 1;
          lineElement.attr(settings);
          animate && lineElement.animate({
            opacity: 1
          }, {
            delay: 0.5,
            partitionDuration: 0.5
          });
        }
        this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine);
      },
      updateTickPosition: function updateTickPosition(options, animate) {
        this._updateLine(this.mark, {
          points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)
        }, this._storedCoords && {
          points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)
        }, animate, false);
      },
      drawLabel: function drawLabel(range, template) {
        var _this = this;
        if (this.templateContainer && axis.isRendered()) {
          this.updateLabelPosition();
          return;
        }
        var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);
        if (!labelIsVisible) {
          if (this.label) {
            this.removeLabel();
          }
          return;
        }
        var templateOption = labelOptions.template;
        var text = axis.formatLabel(value, labelOptions, range);
        if (this.label) {
          this.label.attr({
            text,
            rotate: 0
          }).append(elementsGroup);
          createLabelHint(this, range);
          this.updateLabelPosition();
          return;
        }
        if (templateOption) {
          this.templateContainer = renderer.g().append(elementsGroup);
          this._templateDef && this._templateDef.reject();
          this._templateDef = new _deferred.Deferred();
          template.render({
            model: {
              valueText: text,
              value: this.value,
              labelFontStyle: getLabelFontStyle(this),
              labelStyle
            },
            container: this.templateContainer.element,
            onRendered: function onRendered() {
              _this.updateLabelPosition();
              _this._templateDef && _this._templateDef.resolve();
            }
          });
        } else {
          if ((0, _type.isDefined)(text) && text !== '' && !emptyStrRegExp.test(text)) {
            this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).append(elementsGroup);
            this.updateLabelPosition();
            createLabelHint(this, range);
          }
        }
        var containerForData = this.getContentContainer();
        containerForData && containerForData.data('chart-data-argument', this.value);
        this.templateContainer && createLabelHint(this, range);
      },
      getTemplateDeferred() {
        return this._templateDef;
      },
      getContentContainer() {
        return this.templateContainer || this.label;
      },
      fadeOutElements() {
        var startSettings = {
          opacity: 1
        };
        var endSettings = {
          opacity: 0
        };
        var animationSettings = {
          partitionDuration: 0.5
        };
        if (this.getContentContainer()) {
          this._fadeOutLabel();
        }
        if (this.grid) {
          this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings);
        }
        if (this.mark) {
          this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings);
        }
      },
      _fadeInLabel() {
        var group = axis._renderer.g().attr({
          opacity: 0
        }).append(axis._axisElementsGroup).animate({
          opacity: 1
        }, {
          delay: 0.5,
          partitionDuration: 0.5
        });
        this.getContentContainer().append(group);
      },
      _fadeOutLabel() {
        var group = axis._renderer.g().attr({
          opacity: 1
        }).animate({
          opacity: 0
        }, {
          partitionDuration: 0.5
        }).append(axis._axisElementsGroup).toBackground();
        this.getContentContainer().append(group);
      },
      _getTemplateCoords() {
        return axis._getLabelAdjustedCoord(this, (axis._constantLabelOffset || 0) + (tick.labelOffset || 0));
      },
      updateLabelPosition: function updateLabelPosition(animate) {
        var templateContainer = this.templateContainer;
        if (!this.getContentContainer()) {
          return;
        }
        if (animate && this._storedLabelsCoords) {
          if (templateContainer) {
            templateContainer.attr(this._storedLabelsCoords);
            var lCoords = this._getTemplateCoords();
            templateContainer.animate(lCoords);
          } else {
            this.label.attr({
              x: this._storedLabelsCoords.x,
              y: this._storedLabelsCoords.y
            });
            this.label.animate({
              x: this.labelCoords.x,
              y: this.labelCoords.y
            });
          }
        } else {
          if (templateContainer) {
            var _lCoords = this._getTemplateCoords();
            templateContainer.attr(_lCoords);
          } else {
            this.label.attr({
              x: this.labelCoords.x,
              y: this.labelCoords.y
            });
          }
          if (animate) {
            this._fadeInLabel();
          }
        }
      },
      updateMultilineTextAlignment() {
        if (labelOptions.template || !this.label) {
          return;
        }
        this.label.attr({
          textsAlignment: this.labelAlignment || axis.getOptions().label.alignment
        });
      },
      drawGrid: function drawGrid(drawLine) {
        if (gridOptions.visible && skippedCategory !== this.value) {
          if (this.grid) {
            this.grid.append(axis._axisGridGroup);
            axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));
            this.updateGridPosition();
          } else {
            this.grid = drawLine(this, gridStyle);
            this.grid && this.grid.append(axis._axisGridGroup);
          }
        }
      },
      updateGridPosition: function updateGridPosition(animate) {
        this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true);
      },
      removeLabel() {
        var contentContainer = this.getContentContainer();
        contentContainer && contentContainer.remove();
        this._templateDef && this._templateDef.reject();
        this._templateDef = this.templateContainer = this.label = null;
      }
    };
    return tick;
  };
}

/***/ }),

/***/ 45971:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.tickGenerator = void 0;
var _utils = __webpack_require__(19157);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
var _extend = __webpack_require__(13306);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var convertDateUnitToMilliseconds = _date.default.convertDateUnitToMilliseconds;
var dateToMilliseconds = _date.default.dateToMilliseconds;
var math = Math;
var mathAbs = math.abs;
var mathFloor = math.floor;
var mathCeil = math.ceil;
var mathPow = math.pow;
var NUMBER_MULTIPLIERS = [1, 2, 2.5, 5];
var LOGARITHMIC_MULTIPLIERS = [1, 2, 3, 5];
var DATETIME_MULTIPLIERS = {
  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
  second: [1, 2, 3, 5, 10, 15, 20, 30],
  minute: [1, 2, 3, 5, 10, 15, 20, 30],
  hour: [1, 2, 3, 4, 6, 8, 12],
  day: [1, 2],
  week: [1, 2],
  month: [1, 2, 3, 6]
};
var DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND = (0, _extend.extend)({}, DATETIME_MULTIPLIERS, {
  day: [1]
});
var DATETIME_MINOR_MULTIPLIERS = {
  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],
  second: [1, 2, 3, 5, 10, 15, 20, 30],
  minute: [1, 2, 3, 5, 10, 15, 20, 30],
  hour: [1, 2, 3, 4, 6, 8, 12],
  day: [1, 2, 3, 7, 14],
  month: [1, 2, 3, 6]
};
var MINOR_DELIMITERS = [2, 4, 5, 8, 10];
var VISIBILITY_DELIMITER = 3;
var MINUTE = 60 * 1000;
function dummyGenerator(options) {
  return function (data, screenDelta, tickInterval, forceTickInterval) {
    var count = mathFloor(screenDelta / options.axisDivisionFactor);
    count = count < 1 ? 1 : count;
    var interval = screenDelta / count;
    return {
      ticks: interval > 0 ? Array.apply(null, new Array(count + 1)).map(function (_, i) {
        return interval * i;
      }) : [],
      tickInterval: interval
    };
  };
}
function discreteGenerator(options) {
  return function (data, screenDelta, tickInterval, forceTickInterval) {
    var categories = (0, _utils.getCategoriesInfo)(data.categories, data.min, data.max).categories;
    return {
      ticks: categories,
      tickInterval: mathCeil(categories.length * options.axisDivisionFactor / screenDelta)
    };
  };
}
var getValue = function getValue(value) {
  return value;
};
var getLogValue = function getLogValue(base, allowNegatives, linearThreshold) {
  return function (value) {
    return (0, _utils.getLogExt)(value, base, allowNegatives, linearThreshold);
  };
};
var raiseTo = function raiseTo(base, allowNegatives, linearThreshold) {
  return function (value) {
    return (0, _utils.raiseToExt)(value, base, allowNegatives, linearThreshold);
  };
};
var mathRaiseTo = function mathRaiseTo(base) {
  return function (value) {
    return (0, _utils.raiseTo)(value, base);
  };
};
var logAbsValue = function logAbsValue(base) {
  return function (value) {
    return value === 0 ? 0 : (0, _utils.getLog)(mathAbs(value), base);
  };
};
var correctValueByInterval = function correctValueByInterval(post, round, getValue) {
  return function (value, interval) {
    return (0, _math.adjust)(post(round((0, _math.adjust)(getValue(value) / interval)) * interval));
  };
};
function correctMinValueByEndOnTick(floorFunc, ceilFunc, resolveEndOnTick, endOnTick) {
  if ((0, _type.isDefined)(endOnTick)) {
    return endOnTick ? floorFunc : ceilFunc;
  }
  return function (value, interval, businessViewInfo, forceEndOnTick) {
    var floorTickValue = floorFunc(value, interval);
    if (value - floorTickValue === 0 || !(0, _type.isDefined)(businessViewInfo) || resolveEndOnTick(value, floorTickValue, interval, businessViewInfo) || forceEndOnTick) {
      return floorTickValue;
    }
    return ceilFunc(value, interval);
  };
}
function resolveEndOnTick(curValue, tickValue, interval, businessViewInfo) {
  var prevTickDataDiff = interval - mathAbs(tickValue - curValue);
  var intervalCount = math.max(mathCeil(businessViewInfo.businessDelta / interval), 2);
  var businessRatio = businessViewInfo.screenDelta / (intervalCount * interval);
  var potentialTickScreenDiff = math.round(businessRatio * prevTickDataDiff);
  var delimiterFactor = (0, _utils.getLogExt)(businessRatio * interval / businessViewInfo.axisDivisionFactor, 2) + 1;
  var delimiterMultiplier = (businessViewInfo.isSpacedMargin ? 2 : 1) * delimiterFactor;
  var screenDelimiter = math.round(VISIBILITY_DELIMITER * delimiterMultiplier);
  return businessViewInfo.businessDelta > businessViewInfo.interval && potentialTickScreenDiff >= screenDelimiter;
}
function resolveEndOnTickLog(base) {
  return function (curValue, tickValue, interval, businessViewInfo) {
    return resolveEndOnTick((0, _utils.getLogExt)(curValue, base), (0, _utils.getLogExt)(tickValue, base), interval, businessViewInfo);
  };
}
function resolveEndOnTickDate(curValue, tickValue, interval, businessViewInfo) {
  return resolveEndOnTick(curValue.valueOf(), tickValue.valueOf(), dateToMilliseconds(interval), businessViewInfo);
}
function getBusinessDelta(data, breaks) {
  var spacing = 0;
  if (breaks) {
    spacing = breaks.reduce(function (prev, item) {
      return prev + (item.to - item.from);
    }, 0);
  }
  return mathAbs(data.max - data.min - spacing);
}
function getBusinessDeltaLog(base, allowNegatives, linearThreshold) {
  var getLog = getLogValue(base, allowNegatives, linearThreshold);
  return function (data, breaks) {
    var spacing = 0;
    if (breaks) {
      spacing = breaks.reduce(function (prev, item) {
        return prev + mathAbs(getLog(item.to / item.from));
      }, 0);
    }
    return mathCeil(mathAbs(getLog(data.max) - getLog(data.min)) - spacing);
  };
}
function getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount) {
  var count = screenDelta / axisDivisionFactor - (addTickCount || 0);
  count = count < 1 ? 1 : count;
  return businessDelta / count;
}
function getMultiplierFactor(interval, factorDelta) {
  return mathPow(10, mathFloor((0, _utils.getLogExt)(interval, 10)) + (factorDelta || 0));
}
function calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, _, minTickInterval) {
  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount);
  var result = 1;
  var onlyIntegers = allowDecimals === false;
  if (!forceTickInterval || !tickInterval) {
    if (interval >= 1 || !onlyIntegers && interval > 0) {
      result = adjustInterval(interval, multipliers, onlyIntegers);
    }
    if (!tickInterval || !forceTickInterval && tickInterval < result) {
      tickInterval = result;
    }
  }
  if (!forceTickInterval && minTickInterval) {
    minTickInterval = adjustInterval(minTickInterval, multipliers, onlyIntegers);
    if (minTickInterval > tickInterval) {
      tickInterval = minTickInterval;
    }
  }
  return tickInterval;
}
function adjustInterval(interval, multipliers, onlyIntegers) {
  var factor = getMultiplierFactor(interval, -1);
  var result = 1;
  multipliers = multipliers || NUMBER_MULTIPLIERS;
  if (interval > 0) {
    interval /= factor;
    result = multipliers.concat(multipliers[0] * 10).map(function (m) {
      return 10 * m;
    }).reduce(function (r, m) {
      if (factor === 0.1 && onlyIntegers && m === 25) {
        return r;
      }
      return r < interval ? m : r;
    }, 0);
    result = (0, _math.adjust)(result * factor, factor);
  }
  return result;
}
function calculateMinorTickInterval(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
  return tickInterval || MINOR_DELIMITERS.reduce(function (r, d) {
    var cur = businessDelta / d;
    return cur >= interval ? cur : r;
  }, 0);
}
function getCalculateTickIntervalLog(skipCalculationLimits) {
  return function (businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, _, __, minTickInterval) {
    var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);
    var result = 0;
    var adjustInterval = getAdjustIntervalLog(skipCalculationLimits);
    if (!forceTickInterval || !tickInterval) {
      if (interval > 0) {
        result = adjustInterval(interval, multipliers);
      }
      if (!tickInterval || !forceTickInterval && tickInterval < result) {
        tickInterval = result;
      }
    }
    if (!forceTickInterval && minTickInterval) {
      minTickInterval = adjustInterval(minTickInterval, multipliers);
      if (minTickInterval > tickInterval) {
        tickInterval = minTickInterval;
      }
    }
    return tickInterval;
  };
}
function getAdjustIntervalLog(skipCalculationLimits) {
  return function (interval, multipliers) {
    var factor = getMultiplierFactor(interval);
    multipliers = multipliers || LOGARITHMIC_MULTIPLIERS;
    if (!skipCalculationLimits && factor < 1) {
      factor = 1;
    }
    return multipliers.concat(multipliers[0] * 10).reduce(function (r, m) {
      return r < interval ? m * factor : r;
    }, 0);
  };
}
function getDataTimeMultipliers(gapSize) {
  if (gapSize && gapSize > 2) {
    return DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND;
  } else {
    return DATETIME_MULTIPLIERS;
  }
}
function numbersReducer(interval, key) {
  return function (r, m) {
    if (!r && interval <= convertDateUnitToMilliseconds(key, m)) {
      r = {};
      r[key + 's'] = m;
    }
    return r;
  };
}
function yearsReducer(interval, factor) {
  return function (r, m) {
    var years = factor * m;
    if (!r && interval <= convertDateUnitToMilliseconds('year', years) && years !== 2.5) {
      r = {
        years: years
      };
    }
    return r;
  };
}
function calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, gapSize, minTickInterval) {
  if (!forceTickInterval || !tickInterval) {
    var result = adjustIntervalDateTime(getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor), multipliers, null, gapSize);
    if (!tickInterval || !forceTickInterval && dateToMilliseconds(tickInterval) <= dateToMilliseconds(result)) {
      tickInterval = result;
    }
  }
  if (!forceTickInterval && minTickInterval) {
    minTickInterval = adjustIntervalDateTime(minTickInterval, multipliers, null, gapSize);
    if (dateToMilliseconds(minTickInterval) > dateToMilliseconds(tickInterval)) {
      tickInterval = minTickInterval;
    }
  }
  return tickInterval;
}
function adjustIntervalDateTime(interval, multipliers, _, gapSize) {
  var result;
  multipliers = multipliers || getDataTimeMultipliers(gapSize);
  for (var key in multipliers) {
    result = multipliers[key].reduce(numbersReducer(interval, key), result);
    if (result) {
      break;
    }
  }
  if (!result) {
    for (var factor = 1;; factor *= 10) {
      result = NUMBER_MULTIPLIERS.reduce(yearsReducer(interval, factor), result);
      if (result) {
        break;
      }
    }
  }
  return result;
}
function calculateMinorTickIntervalDateTime(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {
  return calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, true, axisDivisionFactor, DATETIME_MINOR_MULTIPLIERS);
}
function getTickIntervalByCustomTicks(getValue, postProcess) {
  return function (ticks) {
    return ticks ? postProcess(mathAbs((0, _math.adjust)(getValue(ticks[1]) - getValue(ticks[0])))) || undefined : undefined;
  };
}
function addInterval(value, interval, isNegative) {
  return _date.default.addInterval(value, interval, isNegative);
}
function addIntervalLog(log, raise) {
  return function (value, interval, isNegative) {
    return raise(addInterval(log(value), interval, isNegative));
  };
}
function addIntervalDate(value, interval, isNegative) {
  return addInterval(value, interval, isNegative);
}
function addIntervalWithBreaks(addInterval, breaks, correctValue) {
  breaks = breaks.filter(function (b) {
    return !b.gapSize;
  });
  return function (value, interval, isNegative) {
    var breakSize;
    value = addInterval(value, interval, isNegative);
    if (!breaks.every(function (item) {
      if (value >= addInterval(item.from, interval) && addInterval(value, interval) < item.to) {
        breakSize = item.to - item.from - 2 * (addInterval(item.from, interval) - item.from);
      }
      return !breakSize;
    })) {
      value = correctValue(addInterval(value, breakSize), interval);
    }
    return value;
  };
}
function calculateTicks(addInterval, correctMinValue, adjustInterval, resolveEndOnTick) {
  return function (data, tickInterval, endOnTick, gaps, breaks, businessDelta, screenDelta, axisDivisionFactor, generateExtraTick) {
    var correctTickValue = correctTickValueOnGapSize(addInterval, gaps);
    var min = data.min;
    var max = data.max;
    var businessViewInfo = {
      screenDelta: screenDelta,
      businessDelta: businessDelta,
      axisDivisionFactor: axisDivisionFactor,
      isSpacedMargin: data.isSpacedMargin,
      interval: tickInterval
    };
    var cur = correctMinValue(min, tickInterval, businessViewInfo);
    var ticks = [];
    if (breaks !== null && breaks !== void 0 && breaks.length) {
      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);
    }
    if (cur > max) {
      cur = correctMinValue(min, adjustInterval(businessDelta / 2), businessViewInfo);
      if (cur > max) {
        endOnTick = true;
        cur = correctMinValue(min, tickInterval, businessViewInfo, endOnTick);
      }
    }
    cur = correctTickValue(cur);
    var prev;
    while (cur < max && cur !== prev || generateExtraTick && cur <= max) {
      ticks.push(cur);
      prev = cur;
      cur = correctTickValue(addInterval(cur, tickInterval));
    }
    if (endOnTick || cur - max === 0 || !(0, _type.isDefined)(endOnTick) && resolveEndOnTick(max, cur, tickInterval, businessViewInfo)) {
      ticks.push(cur);
    }
    return ticks;
  };
}
function calculateMinorTicks(updateTickInterval, addInterval, correctMinValue, correctTickValue, ceil) {
  return function (min, max, majorTicks, minorTickInterval, tickInterval, breaks, maxCount) {
    var factor = tickInterval / minorTickInterval;
    var lastMajor = majorTicks[majorTicks.length - 1];
    var firstMajor = majorTicks[0];
    var tickBalance = maxCount - 1;
    if (breaks !== null && breaks !== void 0 && breaks.length) {
      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);
    }
    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, firstMajor, factor);
    if (minorTickInterval === 0) {
      return [];
    }

    // min to first tick
    var cur = correctTickValue(correctMinValue(min, tickInterval, min), minorTickInterval);
    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, cur, factor);
    var ticks = [];
    while (cur < firstMajor && (!tickBalance || tickBalance > 0)) {
      cur >= min && ticks.push(cur);
      tickBalance--;
      cur = addInterval(cur, minorTickInterval);
    }

    // between ticks
    var middleTicks = majorTicks.reduce(function (r, tick) {
      tickBalance = maxCount - 1;
      if (r.prevTick === null) {
        r.prevTick = tick;
        return r;
      }
      minorTickInterval = updateTickInterval(minorTickInterval, tick, r.prevTick, factor);
      var cur = correctTickValue(r.prevTick, minorTickInterval);
      while (cur < tick && (!tickBalance || tickBalance > 0)) {
        cur !== r.prevTick && r.minors.push(cur);
        tickBalance--;
        cur = addInterval(cur, minorTickInterval);
      }
      r.prevTick = tick;
      return r;
    }, {
      prevTick: null,
      minors: []
    });
    ticks = ticks.concat(middleTicks.minors);

    // last tick to max
    var maxValue = ceil(max, tickInterval, min);
    minorTickInterval = updateTickInterval(minorTickInterval, maxValue, maxValue, factor);
    cur = correctTickValue(lastMajor, minorTickInterval);
    var prev;
    while (cur < max && cur !== prev) {
      ticks.push(cur);
      prev = cur;
      cur = addInterval(cur, minorTickInterval);
    }
    if (lastMajor - max !== 0 && cur - max === 0) {
      ticks.push(cur);
    }
    return ticks;
  };
}
function filterTicks(ticks, breaks) {
  if (breaks.length) {
    var result = breaks.reduce(function (result, b) {
      var tmpTicks = [];
      var i;
      for (i = result[1]; i < ticks.length; i++) {
        var tickValue = ticks[i];
        if (tickValue < b.from) {
          tmpTicks.push(tickValue);
        }
        if (tickValue >= b.to) {
          break;
        }
      }
      return [result[0].concat(tmpTicks), i];
    }, [[], 0]);
    return result[0].concat(ticks.slice(result[1]));
  }
  return ticks;
}
function correctTickValueOnGapSize(addInterval, breaks) {
  return function (value) {
    var gapSize;
    if (!breaks.every(function (item) {
      if (value >= item.from && value < item.to) {
        gapSize = item.gapSize;
      }
      return !gapSize;
    })) {
      value = addInterval(value, gapSize);
    }
    return value;
  };
}
function generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, getMajorTickIntervalByCustomTicks, getMinorTickIntervalByCustomTicks, convertTickInterval, calculateTicks, calculateMinorTicks, processScaleBreaks) {
  function processCustomTicks(customTicks) {
    return {
      tickInterval: getMajorTickIntervalByCustomTicks(customTicks.majors),
      ticks: customTicks.majors || [],
      minorTickInterval: getMinorTickIntervalByCustomTicks(customTicks.minors),
      minorTicks: customTicks.minors || []
    };
  }
  function correctUserTickInterval(tickInterval, businessDelta, limit) {
    if (tickInterval && businessDelta / convertTickInterval(tickInterval) >= limit + 1) {
      options.incidentOccurred('W2003');
      tickInterval = undefined;
    }
    return tickInterval;
  }
  function generateMajorTicks(ticks, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks) {
    if (customTicks.majors) {
      ticks.breaks = breaks;
      return ticks;
    }
    var gaps = breaks.filter(function (b) {
      return b.gapSize;
    });
    var majorTicks;
    tickInterval = options.skipCalculationLimits ? tickInterval : correctUserTickInterval(tickInterval, businessDelta, screenDelta);
    tickInterval = calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, options.axisDivisionFactor, options.numberMultipliers, options.allowDecimals, breaks.length, gaps[0] && gaps[0].gapSize.days, options.minTickInterval);
    if (!options.skipTickGeneration) {
      majorTicks = calculateTicks(data, tickInterval, options.endOnTick, gaps, breaks, businessDelta, screenDelta, options.axisDivisionFactor, options.generateExtraTick);
      breaks = processScaleBreaks(breaks, majorTicks, tickInterval);
      majorTicks = filterTicks(majorTicks, breaks);
      ticks.breaks = breaks;
      ticks.ticks = ticks.ticks.concat(majorTicks);
    }
    ticks.tickInterval = tickInterval;
    return ticks;
  }
  function generateMinorTicks(ticks, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks) {
    if (!options.calculateMinors) {
      return ticks;
    }
    if (customTicks.minors) {
      return ticks;
    }
    var minorBusinessDelta = convertTickInterval(ticks.tickInterval);
    var minorScreenDelta = screenDelta * minorBusinessDelta / businessDelta;
    var breaks = ticks.breaks;
    if (!minorTickInterval && minorTickCount) {
      minorTickInterval = getMinorTickIntervalByCustomTicks([minorBusinessDelta / (minorTickCount + 1), minorBusinessDelta / (minorTickCount + 1) * 2]);
    } else {
      minorTickCount = undefined;
    }
    minorTickInterval = correctUserTickInterval(minorTickInterval, minorBusinessDelta, minorScreenDelta);
    minorTickInterval = calculateMinorTickInterval(minorBusinessDelta, minorScreenDelta, minorTickInterval, options.minorAxisDivisionFactor);
    ticks.minorTicks = filterTicks(ticks.minorTicks.concat(calculateMinorTicks(data.min, data.max, ticks.ticks, minorTickInterval, ticks.tickInterval, breaks, minorTickCount)), breaks);
    ticks.minorTickInterval = minorTickInterval;
    return ticks;
  }
  return function (data, screenDelta, tickInterval, forceTickInterval, customTicks, minorTickInterval, minorTickCount, breaks) {
    customTicks = customTicks || {};
    var businessDelta = getBusinessDelta(data, breaks);
    var result = processCustomTicks(customTicks);
    if (!isNaN(businessDelta)) {
      if (businessDelta === 0 && !customTicks.majors) {
        result.ticks = [data.min];
      } else {
        result = generateMajorTicks(result, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks || []);
        if (!options.skipTickGeneration && businessDelta > 0) {
          result = generateMinorTicks(result, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks);
        }
      }
    }
    return result;
  };
}
function getBaseTick(breakValue, _ref, interval, getValue) {
  var _ref2 = _slicedToArray(_ref, 2),
    tick = _ref2[0],
    insideTick = _ref2[1];
  if (!(0, _type.isDefined)(tick) || mathAbs(getValue(breakValue) - getValue(tick)) / interval > 0.25) {
    if ((0, _type.isDefined)(insideTick) && mathAbs(getValue(insideTick) - getValue(tick)) / interval < 2) {
      tick = insideTick;
    } else if (!(0, _type.isDefined)(tick)) {
      tick = breakValue;
    }
  }
  return tick;
}
function getScaleBreaksProcessor(convertTickInterval, getValue, addCorrection) {
  return function (breaks, ticks, tickInterval) {
    var interval = convertTickInterval(tickInterval);
    var correction = interval * 0.5;
    return breaks.reduce(function (result, b) {
      var breakTicks = ticks.filter(function (tick) {
        return tick <= b.from;
      });
      var from = addCorrection(getBaseTick(b.from, [].concat(breakTicks[breakTicks.length - 1], ticks[breakTicks.length]), interval, getValue), correction);
      breakTicks = ticks.filter(function (tick) {
        return tick >= b.to;
      });
      var to = addCorrection(getBaseTick(b.to, [].concat(breakTicks[0], ticks[ticks.length - breakTicks.length - 1]), interval, getValue), -correction);
      if (getValue(to) - getValue(from) < interval && !b.gapSize) {
        return result;
      }
      if (b.gapSize) {
        return result.concat([b]);
      }
      return result.concat([{
        from: from,
        to: to,
        cumulativeWidth: b.cumulativeWidth
      }]);
    }, []);
  };
}
function numericGenerator(options) {
  var floor = correctValueByInterval(getValue, mathFloor, getValue);
  var ceil = correctValueByInterval(getValue, mathCeil, getValue);
  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, getValue);
  return generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, getValue, calculateTicks(addInterval, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTick, options.endOnTick), adjustInterval, resolveEndOnTick), calculateMinorTicks(getValue, addInterval, floor, addInterval, getValue), getScaleBreaksProcessor(getValue, getValue, function (value, correction) {
    return value + correction;
  }));
}
var correctValueByIntervalLog = function correctValueByIntervalLog(post, getRound, getValue) {
  return function (value, interval) {
    return (0, _math.sign)(value) * (0, _math.adjust)(post(getRound(value)((0, _math.adjust)(getValue(value) / interval)) * interval));
  };
};
function logarithmicGenerator(options) {
  var base = options.logBase;
  var raise = raiseTo(base, options.allowNegatives, options.linearThreshold);
  var log = getLogValue(base, options.allowNegatives, options.linearThreshold);
  var absLog = logAbsValue(base);
  var absRaise = mathRaiseTo(base);
  var absFloor = function absFloor(value) {
    return value < 0 ? mathCeil : mathFloor;
  };
  var absCeil = function absCeil(value) {
    return value < 0 ? mathFloor : mathCeil;
  };
  var floor = correctValueByIntervalLog(absRaise, absFloor, absLog);
  var ceil = correctValueByIntervalLog(absRaise, absCeil, absLog);
  var ceilNumber = correctValueByInterval(getValue, mathCeil, getValue);
  return generator(options, getBusinessDeltaLog(base, options.allowNegatives, options.linearThreshold), getCalculateTickIntervalLog(options.skipCalculationLimits), calculateMinorTickInterval, getTickIntervalByCustomTicks(log, getValue), getTickIntervalByCustomTicks(getValue, getValue), getValue, calculateTicks(addIntervalLog(log, raise), correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickLog(base), options.endOnTick), getAdjustIntervalLog(options.skipCalculationLimits), resolveEndOnTickLog(base)), calculateMinorTicks(function (_, tick, prevTick, factor) {
    return Math.max(Math.abs(tick), Math.abs(prevTick)) / factor;
  }, addInterval, floor, ceilNumber, ceil), getScaleBreaksProcessor(getValue, log, function (value, correction) {
    return raise(log(value) + correction);
  }));
}
function dateGenerator(options) {
  function floor(value, interval) {
    var floorNumber = correctValueByInterval(getValue, mathFloor, getValue);
    var intervalObject = (0, _type.isString)(interval) ? _date.default.getDateIntervalByString(interval.toLowerCase()) : interval;
    var divider = dateToMilliseconds(interval);
    if (intervalObject.days % 7 === 0 || interval.quarters) {
      intervalObject = adjustIntervalDateTime(divider);
    }
    var correctDateWithUnitBeginning = function correctDateWithUnitBeginning(v) {
      return _date.default.correctDateWithUnitBeginning(v, intervalObject, null, options.firstDayOfWeek);
    };
    var floorAtStartDate = function floorAtStartDate(v) {
      return new Date(mathFloor((v.getTime() - v.getTimezoneOffset() * MINUTE) / divider) * divider + v.getTimezoneOffset() * MINUTE);
    };
    value = correctDateWithUnitBeginning(value);
    if ('years' in intervalObject) {
      value.setFullYear(floorNumber(value.getFullYear(), intervalObject.years));
    } else if ('quarters' in intervalObject) {
      value = correctDateWithUnitBeginning(floorAtStartDate(value));
    } else if ('months' in intervalObject) {
      value.setMonth(floorNumber(value.getMonth(), intervalObject.months));
    } else if ('weeks' in intervalObject || 'days' in intervalObject) {
      value = correctDateWithUnitBeginning(floorAtStartDate(value));
    } else if ('hours' in intervalObject) {
      value.setHours(floorNumber(value.getHours(), intervalObject.hours));
    } else if ('minutes' in intervalObject) {
      value.setMinutes(floorNumber(value.getMinutes(), intervalObject.minutes));
    } else if ('seconds' in intervalObject) {
      value.setSeconds(floorNumber(value.getSeconds(), intervalObject.seconds));
    } else if ('milliseconds' in intervalObject) {
      value = floorAtStartDate(value);
    }
    return value;
  }
  function ceil(value, interval) {
    var newValue = floor(value, interval);
    while (value - newValue > 0) {
      newValue = addIntervalDate(newValue, interval);
    }
    return newValue;
  }
  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, _date.default.convertMillisecondsToDateUnits);
  return generator(options, getBusinessDelta, calculateTickIntervalDateTime, calculateMinorTickIntervalDateTime, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, dateToMilliseconds, calculateTicks(addIntervalDate, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickDate, options.endOnTick), adjustIntervalDateTime, resolveEndOnTickDate), calculateMinorTicks(getValue, addIntervalDate, floor, addIntervalDate, getValue), getScaleBreaksProcessor(dateToMilliseconds, getValue, function (value, correction) {
    return new Date(value.getTime() + correction);
  }));
}
var tickGenerator = function tickGenerator(options) {
  var result;
  if (options.rangeIsEmpty) {
    result = dummyGenerator(options);
  } else if (options.axisType === 'discrete') {
    result = discreteGenerator(options);
  } else if (options.axisType === 'logarithmic') {
    result = logarithmicGenerator(options);
  } else if (options.dataType === 'datetime') {
    result = dateGenerator(options);
  } else {
    result = numericGenerator(options);
  }
  return result;
};
exports.tickGenerator = tickGenerator;

/***/ }),

/***/ 99415:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _range = __webpack_require__(21177);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _date = _interopRequireDefault(__webpack_require__(91198));
var _extend = __webpack_require__(13306);
var _datetime_breaks = __webpack_require__(89530);
var _common = __webpack_require__(20576);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var getNextDateUnit = _date.default.getNextDateUnit;
var correctDateWithUnitBeginning = _date.default.correctDateWithUnitBeginning;
var _math = Math;
var _max = _math.max;
var TOP = _axes_constants.default.top;
var BOTTOM = _axes_constants.default.bottom;
var LEFT = _axes_constants.default.left;
var RIGHT = _axes_constants.default.right;
var CENTER = _axes_constants.default.center;
var SCALE_BREAK_OFFSET = 3;
var RANGE_RATIO = 0.3;
var WAVED_LINE_CENTER = 2;
var WAVED_LINE_TOP = 0;
var WAVED_LINE_BOTTOM = 4;
var WAVED_LINE_LENGTH = 24;
var TICKS_CORRECTIONS = {
  left: -1,
  top: -1,
  right: 0,
  bottom: 0,
  center: -0.5
};
function prepareDatesDifferences(datesDifferences, tickInterval) {
  var dateUnitInterval;
  var i;
  if (tickInterval === 'week') {
    tickInterval = 'day';
  }
  if (tickInterval === 'quarter') {
    tickInterval = 'month';
  }
  if (datesDifferences[tickInterval]) {
    for (i = 0; i < _date.default.dateUnitIntervals.length; i++) {
      dateUnitInterval = _date.default.dateUnitIntervals[i];
      if (datesDifferences[dateUnitInterval]) {
        datesDifferences[dateUnitInterval] = false;
        datesDifferences.count--;
      }
      if (dateUnitInterval === tickInterval) {
        break;
      }
    }
  }
}
function sortingBreaks(breaks) {
  return breaks.sort(function (a, b) {
    return a.from - b.from;
  });
}
function getMarkerDates(min, max, markerInterval) {
  var origMin = min;
  var dates;
  min = correctDateWithUnitBeginning(min, markerInterval);
  max = correctDateWithUnitBeginning(max, markerInterval);
  dates = _date.default.getSequenceByInterval(min, max, markerInterval);
  if (dates.length && origMin > dates[0]) {
    dates = dates.slice(1);
  }
  return dates;
}
function getStripHorizontalAlignmentPosition(alignment) {
  var position = 'start';
  if (alignment === 'center') {
    position = 'center';
  }
  if (alignment === 'right') {
    position = 'end';
  }
  return position;
}
function getStripVerticalAlignmentPosition(alignment) {
  var position = 'start';
  if (alignment === 'center') {
    position = 'center';
  }
  if (alignment === 'bottom') {
    position = 'end';
  }
  return position;
}
function getMarkerInterval(tickInterval) {
  var markerInterval = getNextDateUnit(tickInterval);
  if (markerInterval === 'quarter') {
    markerInterval = getNextDateUnit(markerInterval);
  }
  return markerInterval;
}
function getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {
  var format = markerInterval;
  var datesDifferences = prevDate && _date.default.getDatesDifferences(prevDate, curDate);
  if (prevDate && tickInterval !== 'year') {
    prepareDatesDifferences(datesDifferences, tickInterval);
    format = _format_helper.default.getDateFormatByDifferences(datesDifferences);
  }
  return format;
}
function getMaxSide(act, boxes) {
  return boxes.reduce(function (prevValue, box) {
    return _max(prevValue, act(box));
  }, 0);
}
function getDistanceByAngle(bBox, rotationAngle) {
  rotationAngle = _math.abs(rotationAngle);
  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;
  var a = rotationAngle * (_math.PI / 180);
  if (a >= _math.atan(bBox.height / bBox.width)) {
    return bBox.height / _math.abs(_math.sin(a));
  } else {
    return bBox.width;
  }
}
function getMaxConstantLinePadding(constantLines) {
  return constantLines.reduce(function (padding, options) {
    return _max(padding, options.paddingTopBottom);
  }, 0);
}
function getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {
  return constantLines.some(function (options) {
    return options.label.verticalAlignment === alignment;
  }) && labelHeight || 0;
}
function getLeftMargin(bBox) {
  return _math.abs(bBox.x) || 0;
}
function getRightMargin(bBox) {
  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;
}
function generateRangesOnPoints(points, edgePoints, getRange) {
  var i;
  var length;
  var maxRange = null;
  var ranges = [];
  var curValue;
  var prevValue;
  var curRange;
  for (i = 1, length = points.length; i < length; i++) {
    curValue = points[i];
    prevValue = points[i - 1];
    curRange = getRange(curValue, prevValue);
    if (edgePoints.indexOf(curValue) >= 0) {
      if (!maxRange || curRange > maxRange.length) {
        maxRange = {
          start: curValue,
          end: prevValue,
          length: curRange
        };
      }
    } else {
      if (maxRange && curRange < maxRange.length) {
        ranges.push(maxRange);
      } else {
        ranges.push({
          start: curValue,
          end: prevValue,
          length: curRange
        });
      }
      maxRange = null;
    }
  }
  if (maxRange) {
    ranges.push(maxRange);
  }
  return ranges;
}
function generateAutoBreaks(_ref, series, _ref2) {
  var logarithmBase = _ref.logarithmBase,
    type = _ref.type,
    maxAutoBreakCount = _ref.maxAutoBreakCount;
  var minVisible = _ref2.minVisible,
    maxVisible = _ref2.maxVisible;
  var breaks = [];
  var getRange = type === 'logarithmic' ? function (min, max) {
    return (0, _utils.getLog)(max / min, logarithmBase);
  } : function (min, max) {
    return max - min;
  };
  var visibleRange = getRange(minVisible, maxVisible);
  var points = series.reduce(function (result, s) {
    var points = s.getPointsInViewPort();
    result[0] = result[0].concat(points[0]);
    result[1] = result[1].concat(points[1]);
    return result;
  }, [[], []]);
  var sortedAllPoints = points[0].concat(points[1]).sort(function (a, b) {
    return b - a;
  });
  var edgePoints = points[1].filter(function (p) {
    return points[0].indexOf(p) < 0;
  });
  var minDiff = RANGE_RATIO * visibleRange;
  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function (a, b) {
    return b.length - a.length;
  });
  var epsilon = _math.min.apply(null, ranges.map(function (r) {
    return r.length;
  })) / 1000;
  var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;
  for (var i = 0; i < _maxAutoBreakCount; i++) {
    if (ranges[i].length >= minDiff) {
      if (visibleRange <= ranges[i].length) {
        break;
      }
      visibleRange -= ranges[i].length;
      if (visibleRange > epsilon || visibleRange < -epsilon) {
        breaks.push({
          from: ranges[i].start,
          to: ranges[i].end
        });
        minDiff = RANGE_RATIO * visibleRange;
      }
    } else {
      break;
    }
  }
  sortingBreaks(breaks);
  return breaks;
}
var _default = {
  linear: {
    _getStep: function _getStep(boxes, rotationAngle) {
      var spacing = this._options.label.minSpacing;
      var func = this._isHorizontal ? function (box) {
        return box.width + spacing;
      } : function (box) {
        return box.height;
      };
      var maxLabelLength = getMaxSide(func, boxes);
      if (rotationAngle) {
        maxLabelLength = getDistanceByAngle({
          width: maxLabelLength,
          height: this._getMaxLabelHeight(boxes, 0)
        }, rotationAngle);
      }
      return _axes_constants.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? 'x' : 'y', maxLabelLength);
    },
    _getMaxLabelHeight: function _getMaxLabelHeight(boxes, spacing) {
      return getMaxSide(function (box) {
        return box.height;
      }, boxes) + spacing;
    },
    _validateOverlappingMode: function _validateOverlappingMode(mode, displayMode) {
      if (this._isHorizontal && (displayMode === 'rotate' || displayMode === 'stagger') || !this._isHorizontal) {
        return _axes_constants.default.validateOverlappingMode(mode);
      }
      return mode;
    },
    _validateDisplayMode: function _validateDisplayMode(mode) {
      return this._isHorizontal ? mode : 'standard';
    },
    getMarkerTrackers: function getMarkerTrackers() {
      return this._markerTrackers;
    },
    _getSharpParam: function _getSharpParam(opposite) {
      return this._isHorizontal ^ opposite ? 'h' : 'v';
    },
    _createAxisElement: function _createAxisElement() {
      return this._renderer.path([], 'line');
    },
    _updateAxisElementPosition: function _updateAxisElementPosition() {
      var axisCoord = this._axisPosition;
      var canvas = this._getCanvasStartEnd();
      this._axisElement.attr({
        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]
      });
    },
    _getTranslatedCoord: function _getTranslatedCoord(value, offset) {
      return this._translator.translate(value, offset);
    },
    _initAxisPositions() {
      var that = this;
      if (that.customPositionIsAvailable()) {
        that._customBoundaryPosition = that.getCustomBoundaryPosition();
      }
      if (!that.customPositionIsAvailable() || that.customPositionIsBoundary()) {
        that._axisPosition = that.getPredefinedPosition(that.getResolvedBoundaryPosition());
      } else {
        that._axisPosition = that.getCustomPosition();
      }
    },
    _getTickMarkPoints(coords, length, tickOptions) {
      var isHorizontal = this._isHorizontal;
      var tickOrientation = this._options.tickOrientation;
      var labelPosition = this._options.label.position;
      var tickStartCoord;
      if ((0, _type.isDefined)(tickOrientation)) {
        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length;
      } else {
        var shift = tickOptions.shift || 0;
        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {
          shift = -shift;
        }
        tickStartCoord = shift + this.getTickStartPositionShift(length);
      }
      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];
    },
    getTickStartPositionShift(length) {
      var width = this._options.width;
      var position = this.getResolvedBoundaryPosition();
      return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1);
    },
    _getTitleCoords: function _getTitleCoords() {
      var that = this;
      var horizontal = that._isHorizontal;
      var x = that._axisPosition;
      var y = that._axisPosition;
      var align = that._options.title.alignment;
      var canvas = that._getCanvasStartEnd();
      var fromStartToEnd = horizontal || that._options.position === LEFT;
      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;
      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;
      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;
      if (horizontal) {
        x = coord;
      } else {
        y = coord;
      }
      return {
        x: x,
        y: y
      };
    },
    _drawTitleText: function _drawTitleText(group, coords) {
      var options = this._options;
      var titleOptions = options.title;
      var attrs = {
        opacity: titleOptions.opacity,
        align: titleOptions.alignment,
        'class': titleOptions.cssClass
      };
      if (!titleOptions.text || !group) {
        return;
      }
      coords = coords || this._getTitleCoords();
      if (!this._isHorizontal) {
        attrs.rotate = options.position === LEFT ? 270 : 90;
      }
      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css((0, _utils.patchFontOptions)(titleOptions.font)).attr(attrs).append(group);
      this._checkTitleOverflow(text);
      return text;
    },
    _updateTitleCoords: function _updateTitleCoords() {
      this._title && this._title.element.attr(this._getTitleCoords());
    },
    _drawTitle: function _drawTitle() {
      var title = this._drawTitleText(this._axisTitleGroup);
      if (title) {
        this._title = {
          element: title
        };
      }
    },
    _measureTitle: function _measureTitle() {
      if (this._title) {
        if (this._title.bBox && !this._title.originalSize) {
          this._title.originalSize = this._title.bBox;
        }
        this._title.bBox = this._title.element.getBBox();
      }
    },
    _drawDateMarker: function _drawDateMarker(date, options, range) {
      var that = this;
      var markerOptions = that._options.marker;
      var invert = that._translator.getBusinessRange().invert;
      var textIndent = markerOptions.width + markerOptions.textLeftIndent;
      var pathElement;
      if (options.x === null) return;
      if (!options.withoutStick) {
        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], 'line').attr({
          'stroke-width': markerOptions.width,
          stroke: markerOptions.color,
          'stroke-opacity': markerOptions.opacity,
          sharp: 'h'
        }).append(that._axisElementsGroup);
      }
      var text = String(that.formatLabel(date, options.labelOptions, range));
      return {
        date: date,
        x: options.x,
        y: options.y,
        cropped: options.withoutStick,
        label: that._renderer.text(text, options.x, options.y).css((0, _utils.patchFontOptions)(markerOptions.label.font)).append(that._axisElementsGroup),
        line: pathElement,
        getContentContainer() {
          return this.label;
        },
        getEnd: function getEnd() {
          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);
        },
        setTitle: function setTitle() {
          this.title = text;
        },
        hideLabel: function hideLabel() {
          this.label.dispose();
          this.label = null;
          this.title = text;
        },
        hide: function hide() {
          if (pathElement) {
            pathElement.dispose();
            pathElement = null;
          }
          this.label.dispose();
          this.label = null;
          this.hidden = true;
        }
      };
    },
    _drawDateMarkers: function _drawDateMarkers() {
      var that = this;
      var options = that._options;
      var translator = that._translator;
      var viewport = that._getViewportRange();
      var minBound = viewport.minVisible;
      var dateMarkers = [];
      var dateMarker;
      function draw(markerDate, format, withoutStick) {
        return that._drawDateMarker(markerDate, {
          x: translator.translate(markerDate),
          y: markersAreaTop,
          labelOptions: that._getLabelFormatOptions(format),
          withoutStick: withoutStick
        }, viewport);
      }
      if (viewport.isEmpty() || !options.marker.visible || options.argumentType !== 'datetime' || options.type === 'discrete' || that._majorTicks.length <= 1) {
        return [];
      }
      var markersAreaTop = that._axisPosition + options.marker.topIndent;
      var tickInterval = _date.default.getDateUnitInterval(this._tickInterval);
      var markerInterval = getMarkerInterval(tickInterval);
      var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);
      if (markerDates.length > 1 || markerDates.length === 1 && minBound < markerDates[0]) {
        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {
          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));
          marker && markers.push(marker);
          return markers;
        }, []);
        if (minBound < markerDates[0]) {
          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);
          dateMarker && dateMarkers.unshift(dateMarker);
        }
      }
      return dateMarkers;
    },
    _adjustDateMarkers: function _adjustDateMarkers(offset) {
      offset = offset || 0;
      var that = this;
      var markerOptions = this._options.marker;
      var textIndent = markerOptions.width + markerOptions.textLeftIndent;
      var invert = this._translator.getBusinessRange().invert;
      var canvas = that._getCanvasStartEnd();
      var dateMarkers = this._dateMarkers;
      if (!dateMarkers.length) {
        return offset;
      }
      if (dateMarkers[0].cropped) {
        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {
          dateMarkers[0].hideLabel();
        }
      }
      var prevDateMarker;
      dateMarkers.forEach(function (marker, i, markers) {
        if (marker.cropped) {
          return;
        }
        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {
          marker.hideLabel();
        } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {
          prevDateMarker = marker;
        } else {
          marker.hide();
        }
      });
      this._dateMarkers.forEach(function (marker) {
        if (marker.label) {
          var labelBBox = marker.labelBBox;
          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;
          marker.label.attr({
            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,
            translateY: dy + offset
          });
        }
        if (marker.line) {
          marker.line.attr({
            translateY: offset
          });
        }
      });
      that._initializeMarkersTrackers(offset);
      return offset + markerOptions.topIndent + markerOptions.separatorHeight;
    },
    _checkMarkersPosition: function _checkMarkersPosition(invert, dateMarker, prevDateMarker) {
      if (prevDateMarker === undefined) {
        return true;
      }
      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();
    },
    _initializeMarkersTrackers: function _initializeMarkersTrackers(offset) {
      var that = this;
      var separatorHeight = that._options.marker.separatorHeight;
      var renderer = that._renderer;
      var businessRange = this._translator.getBusinessRange();
      var canvas = that._getCanvasStartEnd();
      var group = that._axisElementsGroup;
      that._markerTrackers = this._dateMarkers.filter(function (marker) {
        return !marker.hidden;
      }).map(function (marker, i, markers) {
        var nextMarker = markers[i + 1] || {
          x: canvas.end,
          date: businessRange.max
        };
        var x = marker.x;
        var y = marker.y + offset;
        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], 'area').attr({
          'stroke-width': 1,
          stroke: 'grey',
          fill: 'grey',
          opacity: 0.0001
        }).append(group);
        markerTracker.data('range', {
          startValue: marker.date,
          endValue: nextMarker.date
        });
        if (marker.title) {
          markerTracker.setTitle(marker.title);
        }
        return markerTracker;
      });
    },
    _getLabelFormatOptions: function _getLabelFormatOptions(formatString) {
      var that = this;
      var markerLabelOptions = that._markerLabelOptions;
      if (!markerLabelOptions) {
        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label);
      }
      if (!(0, _type.isDefined)(that._options.marker.label.format)) {
        markerLabelOptions.format = formatString;
      }
      return markerLabelOptions;
    },
    _adjustConstantLineLabels: function _adjustConstantLineLabels(constantLines) {
      var that = this;
      var axisPosition = that._options.position;
      var canvas = that.getCanvas();
      var canvasLeft = canvas.left;
      var canvasRight = canvas.width - canvas.right;
      var canvasTop = canvas.top;
      var canvasBottom = canvas.height - canvas.bottom;
      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;
      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;
      var maxLabel = 0;
      constantLines.forEach(function (item) {
        var isHorizontal = that._isHorizontal;
        var linesOptions = item.options;
        var paddingTopBottom = linesOptions.paddingTopBottom;
        var paddingLeftRight = linesOptions.paddingLeftRight;
        var labelOptions = linesOptions.label;
        var labelVerticalAlignment = labelOptions.verticalAlignment;
        var labelHorizontalAlignment = labelOptions.horizontalAlignment;
        var labelIsInside = labelOptions.position === 'inside';
        var label = item.label;
        var box = item.labelBBox;
        var translateX;
        var translateY;
        if (label === null || box.isEmpty) {
          return;
        }
        if (isHorizontal) {
          if (labelIsInside) {
            if (labelHorizontalAlignment === LEFT) {
              translateX = item.coord - paddingLeftRight - box.x - box.width;
            } else {
              translateX = item.coord + paddingLeftRight - box.x;
            }
            switch (labelVerticalAlignment) {
              case CENTER:
                translateY = verticalCenter - box.y - box.height / 2;
                break;
              case BOTTOM:
                translateY = canvasBottom - paddingTopBottom - box.y - box.height;
                break;
              default:
                translateY = canvasTop + paddingTopBottom - box.y;
                break;
            }
          } else {
            if (axisPosition === labelVerticalAlignment) {
              maxLabel = _max(maxLabel, box.height + paddingTopBottom);
            }
            translateX = item.coord - box.x - box.width / 2;
            if (labelVerticalAlignment === BOTTOM) {
              translateY = canvasBottom + paddingTopBottom - box.y;
            } else {
              translateY = canvasTop - paddingTopBottom - box.y - box.height;
            }
          }
        } else {
          if (labelIsInside) {
            if (labelVerticalAlignment === BOTTOM) {
              translateY = item.coord + paddingTopBottom - box.y;
            } else {
              translateY = item.coord - paddingTopBottom - box.y - box.height;
            }
            switch (labelHorizontalAlignment) {
              case CENTER:
                translateX = horizontalCenter - box.x - box.width / 2;
                break;
              case RIGHT:
                translateX = canvasRight - paddingLeftRight - box.x - box.width;
                break;
              default:
                translateX = canvasLeft + paddingLeftRight - box.x;
                break;
            }
          } else {
            if (axisPosition === labelHorizontalAlignment) {
              maxLabel = _max(maxLabel, box.width + paddingLeftRight);
            }
            translateY = item.coord - box.y - box.height / 2;
            if (labelHorizontalAlignment === RIGHT) {
              translateX = canvasRight + paddingLeftRight - box.x;
            } else {
              translateX = canvasLeft - paddingLeftRight - box.x - box.width;
            }
          }
        }
        label.attr({
          translateX: translateX,
          translateY: translateY
        });
      });
      return maxLabel;
    },
    _drawConstantLinesForEstimating: function _drawConstantLinesForEstimating(constantLines) {
      var that = this;
      var renderer = this._renderer;
      var group = renderer.g();
      constantLines.forEach(function (options) {
        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({
          align: 'center'
        });
      });
      return group.append(renderer.root);
    },
    _estimateLabelHeight: function _estimateLabelHeight(bBox, labelOptions) {
      var height = bBox.height;
      var drawingType = labelOptions.drawingType;
      if (this._validateDisplayMode(drawingType) === 'stagger' || this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType) === 'stagger') {
        height = height * 2 + labelOptions.staggeringSpacing;
      }
      if (this._validateDisplayMode(drawingType) === 'rotate' || this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType) === 'rotate') {
        var sinCos = (0, _utils.getCosAndSin)(labelOptions.rotationAngle);
        height = height * sinCos.cos + bBox.width * sinCos.sin;
      }
      return height && (height + labelOptions.indentFromAxis || 0) || 0;
    },
    estimateMargins: function estimateMargins(canvas) {
      this.updateCanvas(canvas);
      var that = this;
      var range = that._getViewportRange();
      var ticksData = this._createTicksAndLabelFormat(range);
      var ticks = ticksData.ticks;
      var tickInterval = ticksData.tickInterval;
      var options = this._options;
      var constantLineOptions = that._outsideConstantLines.filter(function (l) {
        return l.labelOptions.visible;
      }).map(function (l) {
        return l.options;
      });
      var rootElement = that._renderer.root;
      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;
      var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, undefined, undefined, tickInterval, ticks);
      var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);
      var titleElement = that._drawTitleText(rootElement, {
        x: 0,
        y: 0
      });
      var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);
      var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var titleBox = titleElement && titleElement.getBBox() || {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var constantLinesBox = constantLinesLabelsElement.getBBox();
      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;
      var labelHeight = that._estimateLabelHeight(labelBox, options.label);
      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;
      var height = labelHeight + titleHeight;
      var margins = {
        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),
        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),
        top: (options.position === 'top' ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, 'top', constantLinesHeight),
        bottom: (options.position !== 'top' ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, 'bottom', constantLinesHeight)
      };
      labelElement && labelElement.remove();
      titleElement && titleElement.remove();
      constantLinesLabelsElement && constantLinesLabelsElement.remove();
      return margins;
    },
    _checkAlignmentConstantLineLabels: function _checkAlignmentConstantLineLabels(labelOptions) {
      var position = labelOptions.position;
      var verticalAlignment = (labelOptions.verticalAlignment || '').toLowerCase();
      var horizontalAlignment = (labelOptions.horizontalAlignment || '').toLowerCase();
      if (this._isHorizontal) {
        if (position === 'outside') {
          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = CENTER;
        } else {
          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;
        }
      } else {
        if (position === 'outside') {
          verticalAlignment = CENTER;
          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;
        } else {
          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;
          horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;
        }
      }
      labelOptions.verticalAlignment = verticalAlignment;
      labelOptions.horizontalAlignment = horizontalAlignment;
    },
    _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value, lineLabelOptions) {
      var that = this;
      var x = value;
      var y = value;
      if (that._isHorizontal) {
        y = that._orthogonalPositions[lineLabelOptions.verticalAlignment === 'top' ? 'start' : 'end'];
      } else {
        x = that._orthogonalPositions[lineLabelOptions.horizontalAlignment === 'right' ? 'end' : 'start'];
      }
      return {
        x: x,
        y: y
      };
    },
    _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {
      var stripOptions = strip.options;
      var paddingTopBottom = stripOptions.paddingTopBottom;
      var paddingLeftRight = stripOptions.paddingLeftRight;
      var horizontalAlignment = stripOptions.label.horizontalAlignment;
      var verticalAlignment = stripOptions.label.verticalAlignment;
      var box = strip.labelBBox;
      var labelHeight = box.height;
      var labelWidth = box.width;
      var labelCoords = strip.labelCoords;
      var y = labelCoords.y - box.y;
      var x = labelCoords.x - box.x;
      if (verticalAlignment === TOP) {
        y += paddingTopBottom;
      } else if (verticalAlignment === CENTER) {
        y -= labelHeight / 2;
      } else if (verticalAlignment === BOTTOM) {
        y -= paddingTopBottom + labelHeight;
      }
      if (horizontalAlignment === LEFT) {
        x += paddingLeftRight;
      } else if (horizontalAlignment === CENTER) {
        x -= labelWidth / 2;
      } else if (horizontalAlignment === RIGHT) {
        x -= paddingLeftRight + labelWidth;
      }
      return {
        translateX: x,
        translateY: y
      };
    },
    _adjustTitle: function _adjustTitle(offset) {
      offset = offset || 0;
      if (!this._title) {
        return;
      }
      var that = this;
      var options = that._options;
      var position = options.position;
      var margin = options.title.margin;
      var title = that._title;
      var boxTitle = title.bBox;
      var x = boxTitle.x;
      var y = boxTitle.y;
      var width = boxTitle.width;
      var height = boxTitle.height;
      var axisPosition = that._axisPosition;
      var loCoord = axisPosition - margin - offset;
      var hiCoord = axisPosition + margin + offset;
      var params = {};
      if (that._isHorizontal) {
        if (position === TOP) {
          params.translateY = loCoord - (y + height);
        } else {
          params.translateY = hiCoord - y;
        }
      } else {
        if (position === LEFT) {
          params.translateX = loCoord - (x + width);
        } else {
          params.translateX = hiCoord - x;
        }
      }
      title.element.attr(params);
    },
    _checkTitleOverflow: function _checkTitleOverflow(titleElement) {
      if (!this._title && !titleElement) {
        return;
      }
      var canvasLength = this._getScreenDelta();
      var title = titleElement ? {
        bBox: titleElement.getBBox(),
        element: titleElement
      } : this._title;
      var titleOptions = this._options.title;
      var boxTitle = title.bBox;
      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {
        title.element.setMaxSize(canvasLength, undefined, {
          wordWrap: titleOptions.wordWrap || 'none',
          textOverflow: titleOptions.textOverflow || 'ellipsis'
        });
        this._wrapped = titleOptions.wordWrap && titleOptions.wordWrap !== 'none';
      } else {
        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);
        !this._wrapped && moreThanOriginalSize && title.element.restoreText();
      }
    },
    coordsIn: function coordsIn(x, y) {
      var canvas = this.getCanvas();
      var isHorizontal = this._options.isHorizontal;
      var position = this._options.position;
      var coord = isHorizontal ? y : x;
      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {
        return false;
      }
      if (isHorizontal && position === _axes_constants.default.top || !isHorizontal && position === _axes_constants.default.left) {
        return coord < canvas[position];
      }
      return coord > canvas[isHorizontal ? 'height' : 'width'] - canvas[position];
    },
    _boundaryTicksVisibility: {
      min: true,
      max: true
    },
    adjust() {
      var that = this;
      var seriesData = that._seriesData;
      var viewport = that._series.filter(function (s) {
        return s.isVisible();
      }).reduce(function (range, s) {
        var seriesRange = s.getViewport();
        range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;
        range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;
        if (s.showZero) {
          range = new _range.Range(range);
          range.correctValueZeroLevel();
        }
        return range;
      }, {});
      if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {
        seriesData.minVisible = viewport.min;
        seriesData.maxVisible = viewport.max;
      }
      seriesData.userBreaks = that._getScaleBreaks(that._options, {
        minVisible: seriesData.minVisible,
        maxVisible: seriesData.maxVisible
      }, that._series, that.isArgumentAxis);
      that._translator.updateBusinessRange(that._getViewportRange());
    },
    hasWrap() {
      return this._wrapped;
    },
    getAxisPosition() {
      return this._axisPosition;
    },
    _getStick: function _getStick() {
      return !this._options.valueMarginsEnabled;
    },
    _getStripLabelCoords: function _getStripLabelCoords(from, to, stripLabelOptions) {
      var that = this;
      var orthogonalPositions = that._orthogonalPositions;
      var isHorizontal = that._isHorizontal;
      var horizontalAlignment = stripLabelOptions.horizontalAlignment;
      var verticalAlignment = stripLabelOptions.verticalAlignment;
      var x;
      var y;
      if (isHorizontal) {
        if (horizontalAlignment === CENTER) {
          x = from + (to - from) / 2;
        } else if (horizontalAlignment === LEFT) {
          x = from;
        } else if (horizontalAlignment === RIGHT) {
          x = to;
        }
        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];
      } else {
        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];
        if (verticalAlignment === TOP) {
          y = from;
        } else if (verticalAlignment === CENTER) {
          y = to + (from - to) / 2;
        } else if (verticalAlignment === BOTTOM) {
          y = to;
        }
      }
      return {
        x: x,
        y: y
      };
    },
    _getTranslatedValue: function _getTranslatedValue(value, offset) {
      var pos1 = this._translator.translate(value, offset, this._options.type === 'semidiscrete' && this._options.tickInterval);
      var pos2 = this._axisPosition;
      var isHorizontal = this._isHorizontal;
      return {
        x: isHorizontal ? pos1 : pos2,
        y: isHorizontal ? pos2 : pos1
      };
    },
    areCoordsOutsideAxis: function areCoordsOutsideAxis(coords) {
      var coord = this._isHorizontal ? coords.x : coords.y;
      var visibleArea = this.getVisibleArea();
      if (coord < visibleArea[0] || coord > visibleArea[1]) {
        return true;
      }
      return false;
    },
    _getSkippedCategory: function _getSkippedCategory(ticks) {
      var skippedCategory;
      if (this._options.type === _axes_constants.default.discrete && this._tickOffset && ticks.length !== 0) {
        skippedCategory = ticks[ticks.length - 1];
      }
      return skippedCategory;
    },
    _filterBreaks: function _filterBreaks(breaks, viewport, breakStyle) {
      var minVisible = viewport.minVisible;
      var maxVisible = viewport.maxVisible;
      var breakSize = breakStyle ? breakStyle.width : 0;
      return breaks.reduce(function (result, currentBreak) {
        var from = currentBreak.from;
        var to = currentBreak.to;
        var lastResult = result[result.length - 1];
        var newBreak;
        if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {
          return result;
        }
        if (from > to) {
          to = [from, from = to][0];
        }
        if (result.length && from < lastResult.to) {
          if (to > lastResult.to) {
            lastResult.to = to > maxVisible ? maxVisible : to;
            if (lastResult.gapSize) {
              lastResult.gapSize = undefined;
              lastResult.cumulativeWidth += breakSize;
            }
          }
        } else {
          if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {
            from = from >= minVisible ? from : minVisible;
            to = to <= maxVisible ? to : maxVisible;
            if (to - from < maxVisible - minVisible) {
              var _lastResult$cumulativ;
              newBreak = {
                from: from,
                to: to,
                cumulativeWidth: ((_lastResult$cumulativ = lastResult === null || lastResult === void 0 ? void 0 : lastResult.cumulativeWidth) !== null && _lastResult$cumulativ !== void 0 ? _lastResult$cumulativ : 0) + breakSize
              };
              if (currentBreak.gapSize) {
                var _lastResult$cumulativ2;
                newBreak.gapSize = _date.default.convertMillisecondsToDateUnits(to - from);
                newBreak.cumulativeWidth = (_lastResult$cumulativ2 = lastResult === null || lastResult === void 0 ? void 0 : lastResult.cumulativeWidth) !== null && _lastResult$cumulativ2 !== void 0 ? _lastResult$cumulativ2 : 0;
              }
              result.push(newBreak);
            }
          }
        }
        return result;
      }, []);
    },
    _getScaleBreaks: function _getScaleBreaks(axisOptions, viewport, series, isArgumentAxis) {
      var that = this;
      var breaks = (axisOptions.breaks || []).map(function (b) {
        return {
          from: that.parser(b.startValue),
          to: that.parser(b.endValue)
        };
      });
      if (axisOptions.type !== 'discrete' && axisOptions.dataType === 'datetime' && axisOptions.workdaysOnly) {
        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));
      }
      if (!isArgumentAxis && axisOptions.type !== 'discrete' && axisOptions.dataType !== 'datetime' && axisOptions.autoBreaksEnabled && axisOptions.maxAutoBreakCount !== 0) {
        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));
      }
      return sortingBreaks(breaks);
    },
    _drawBreak: function _drawBreak(translatedEnd, positionFrom, positionTo, width, options, group) {
      var that = this;
      var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);
      var attr = {
        'stroke-width': 1,
        stroke: options.borderColor,
        sharp: !options.isWaved ? options.isHorizontal ? 'h' : 'v' : undefined
      };
      var spaceAttr = {
        stroke: options.color,
        'stroke-width': width
      };
      var getPoints = that._isHorizontal ? rotateLine : function (p) {
        return p;
      };
      var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);
      drawer(width / 2, spaceAttr);
      drawer(0, attr);
      drawer(width, attr);
    },
    _createBreakClipRect: function _createBreakClipRect(from, to) {
      var that = this;
      var canvas = that._canvas;
      var clipWidth = to - from;
      var clipRect;
      if (that._isHorizontal) {
        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);
      } else {
        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);
      }
      that._breaksElements = that._breaksElements || [];
      that._breaksElements.push(clipRect);
      return clipRect.id;
    },
    _createBreaksGroup: function _createBreaksGroup(clipFrom, clipTo) {
      var that = this;
      var group = that._renderer.g().attr({
        'class': that._axisCssPrefix + 'breaks',
        'clip-path': that._createBreakClipRect(clipFrom, clipTo)
      }).append(that._scaleBreaksGroup);
      that._breaksElements = that._breaksElements || [];
      that._breaksElements.push(group);
      return group;
    },
    _disposeBreaksGroup: function _disposeBreaksGroup() {
      (this._breaksElements || []).forEach(function (clipRect) {
        clipRect.dispose();
      });
      this._breaksElements = null;
    },
    drawScaleBreaks: function drawScaleBreaks(customCanvas) {
      var that = this;
      var options = that._options;
      var breakStyle = options.breakStyle;
      var position = options.position;
      var positionFrom;
      var positionTo;
      var breaks = that._translator.getBusinessRange().breaks || [];
      var additionGroup;
      var additionBreakFrom;
      var additionBreakTo;
      that._disposeBreaksGroup();
      if (!(breaks && breaks.length)) {
        return;
      }
      var breakOptions = {
        color: that._options.containerColor,
        borderColor: breakStyle.color,
        isHorizontal: that._isHorizontal,
        isWaved: breakStyle.line.toLowerCase() !== 'straight'
      };
      if (customCanvas) {
        positionFrom = customCanvas.start;
        positionTo = customCanvas.end;
      } else {
        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);
        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0);
      }
      var mainGroup = that._createBreaksGroup(positionFrom, positionTo);
      if (that._axisShift && options.visible) {
        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;
        additionBreakTo = additionBreakFrom + SCALE_BREAK_OFFSET * 2;
        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);
      }
      breaks.forEach(function (br) {
        if (!br.gapSize) {
          var breakCoord = that._getTranslatedCoord(br.to);
          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);
          if (that._axisShift && options.visible) {
            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);
          }
        }
      });
    },
    _getSpiderCategoryOption: _common.noop,
    shift: function shift(margins) {
      var that = this;
      var options = that._options;
      var isHorizontal = options.isHorizontal;
      var axesSpacing = that.getMultipleAxesSpacing();
      var constantLinesGroups = that._axisConstantLineGroups;
      function shiftGroup(side, group) {
        var attr = {
          translateX: 0,
          translateY: 0
        };
        var shift = margins[side] ? margins[side] + axesSpacing : 0;
        attr[isHorizontal ? 'translateY' : 'translateX'] = (side === LEFT || side === TOP ? -1 : 1) * shift;
        (group[side] || group).attr(attr);
        return shift;
      }
      that._axisShift = shiftGroup(options.position, that._axisGroup);
      shiftGroup(options.position, that._axisElementsGroup);
      (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(function (side) {
        shiftGroup(side, constantLinesGroups.above);
        shiftGroup(side, constantLinesGroups.under);
      });
    },
    getCustomPosition(position) {
      var that = this;
      var orthogonalAxis = that.getOrthogonalAxis();
      var resolvedPosition = position !== null && position !== void 0 ? position : that.getResolvedPositionOption();
      var offset = that.getOptions().offset;
      var orthogonalTranslator = orthogonalAxis.getTranslator();
      var orthogonalAxisType = orthogonalAxis.getOptions().type;
      var validPosition = orthogonalAxis.validateUnit(resolvedPosition);
      var currentPosition;
      if (orthogonalAxisType === 'discrete' && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {
        validPosition = undefined;
      }
      if (that.positionIsBoundary(resolvedPosition)) {
        currentPosition = that.getPredefinedPosition(resolvedPosition);
      } else if (!(0, _type.isDefined)(validPosition)) {
        currentPosition = that.getPredefinedPosition(that.getOptions().position);
      } else {
        currentPosition = orthogonalTranslator.to(validPosition, -1);
      }
      if (isFinite(currentPosition) && isFinite(offset)) {
        currentPosition += offset;
      }
      return currentPosition;
    },
    getCustomBoundaryPosition(position) {
      var that = this;
      var _that$getOptions = that.getOptions(),
        customPosition = _that$getOptions.customPosition,
        offset = _that$getOptions.offset;
      var resolvedPosition = position !== null && position !== void 0 ? position : that.getResolvedPositionOption();
      var orthogonalAxis = that.getOrthogonalAxis();
      var orthogonalTranslator = orthogonalAxis.getTranslator();
      var visibleArea = orthogonalTranslator.getCanvasVisibleArea();
      if (!(0, _type.isDefined)(orthogonalAxis._orthogonalPositions) || orthogonalTranslator.canvasLength === 0) {
        return undefined;
      }
      var currentPosition = that.getCustomPosition(resolvedPosition);
      if (!(0, _type.isDefined)(currentPosition)) {
        return that.getResolvedBoundaryPosition();
      } else if ((0, _type.isDefined)(customPosition)) {
        if (currentPosition <= visibleArea.min) {
          return that._isHorizontal ? TOP : LEFT;
        } else if (currentPosition >= visibleArea.max) {
          return that._isHorizontal ? BOTTOM : RIGHT;
        }
      } else if ((0, _type.isDefined)(offset)) {
        if (currentPosition <= that._orthogonalPositions.start) {
          return that._isHorizontal ? TOP : LEFT;
        } else if (currentPosition >= that._orthogonalPositions.end) {
          return that._isHorizontal ? BOTTOM : RIGHT;
        }
      }
      return currentPosition;
    },
    getResolvedPositionOption() {
      var _options$customPositi;
      var options = this.getOptions();
      return (_options$customPositi = options.customPosition) !== null && _options$customPositi !== void 0 ? _options$customPositi : options.position;
    },
    customPositionIsAvailable() {
      var options = this.getOptions();
      return (0, _type.isDefined)(this.getOrthogonalAxis()) && ((0, _type.isDefined)(options.customPosition) || isFinite(options.offset));
    },
    hasNonBoundaryPosition() {
      return this.customPositionIsAvailable() && !this.customPositionIsBoundary();
    },
    getResolvedBoundaryPosition() {
      return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position;
    },
    customPositionEqualsToPredefined() {
      return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position;
    },
    customPositionIsBoundary() {
      return this.positionIsBoundary(this._customBoundaryPosition);
    },
    positionIsBoundary(position) {
      return [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0;
    },
    getPredefinedPosition(position) {
      var _this$_orthogonalPosi;
      return (_this$_orthogonalPosi = this._orthogonalPositions) === null || _this$_orthogonalPosi === void 0 ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? 'start' : 'end'];
    },
    resolveOverlappingForCustomPositioning(oppositeAxes) {
      var that = this;
      if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(function (a) {
        return a.hasNonBoundaryPosition();
      })) {
        return;
      }
      var overlappingObj = {
        axes: [],
        ticks: []
      };
      oppositeAxes.filter(function (orthogonalAxis) {
        return orthogonalAxis.pane === that.pane;
      }).forEach(function (orthogonalAxis) {
        for (var i = 0; i < that._majorTicks.length; i++) {
          var tick = that._majorTicks[i];
          var label = tick.label;
          if (label) {
            if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {
              overlappingObj.axes.push(orthogonalAxis);
              that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis);
            }
            for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {
              var oppositeTick = orthogonalAxis._majorTicks[j];
              var oppositeLabel = oppositeTick.label;
              if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {
                overlappingObj.ticks.push(tick);
                that._shiftThroughAxisOverlappedTick(tick);
                i = that._majorTicks.length;
                break;
              }
            }
          }
          if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {
            if (that._isHorizontal && tick.mark.attr('translateY')) {
              tick.mark.attr({
                translateY: 0
              });
            } else if (!that._isHorizontal && tick.mark.attr('translateX')) {
              tick.mark.attr({
                translateX: 0
              });
            }
          }
        }
      });
    },
    _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {
      var that = this;
      var labelBBox = label.getBBox();
      var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();
      var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;
      var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;
      var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;
      var translateCoordName = that._isHorizontal ? 'translateX' : 'translateY';
      var defaultOrthogonalAxisLabelPosition = that._isHorizontal ? LEFT : TOP;
      var translate = label.attr(translateCoordName);
      var labelCoord = (that._isHorizontal ? labelBBox.x : labelBBox.y) + translate;
      var labelSize = that._isHorizontal ? labelBBox.width : labelBBox.height;
      var outsidePart = orthogonalAxisPosition - labelCoord;
      var insidePart = labelCoord + labelSize - orthogonalAxisPosition;
      var attr = {};
      attr[translateCoordName] = translate;
      if (outsidePart > 0 && insidePart > 0) {
        if (insidePart - outsidePart > 1) {
          attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent;
        } else if (outsidePart - insidePart > 1) {
          attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent;
        } else {
          attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent);
        }
        label.attr(attr);
      }
    },
    _shiftThroughAxisOverlappedTick(tick) {
      var _tick$mark;
      var that = this;
      var label = tick.label;
      if (!label) {
        return;
      }
      var labelBBox = label.getBBox();
      var tickMarkBBox = (_tick$mark = tick.mark) === null || _tick$mark === void 0 ? void 0 : _tick$mark.getBBox();
      var axisPosition = that.getAxisPosition();
      var labelOptions = that.getOptions().label;
      var labelIndent = labelOptions.indentFromAxis;
      var labelPosition = labelOptions.position;
      var defaultLabelPosition = that._isHorizontal ? TOP : LEFT;
      var translateCoordName = that._isHorizontal ? 'translateY' : 'translateX';
      var translate = label.attr(translateCoordName);
      var labelCoord = (that._isHorizontal ? labelBBox.y : labelBBox.x) + translate;
      var labelSize = that._isHorizontal ? labelBBox.height : labelBBox.width;
      var attr = {};
      attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));
      label.attr(attr);
      if (tick.mark) {
        var markerSize = that._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;
        var dir = labelPosition === defaultLabelPosition ? 1 : -1;
        attr[translateCoordName] = dir * (markerSize - 1);
        tick.mark.attr(attr);
      }
    },
    _detectElementsOverlapping(element1, element2) {
      if (!element1 || !element2) {
        return false;
      }
      var bBox1 = element1.getBBox();
      var x1 = bBox1.x + element1.attr('translateX');
      var y1 = bBox1.y + element1.attr('translateY');
      var bBox2 = element2.getBBox();
      var x2 = bBox2.x + element2.attr('translateX');
      var y2 = bBox2.y + element2.attr('translateY');
      return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height);
    }
  }
};
exports["default"] = _default;
function getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {
  var elementType = isWaved ? 'bezier' : 'line';
  var group = renderer.g().append(root);
  return function (offset, attr) {
    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);
  };
}
function getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {
  if (!isWaved) {
    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];
  }
  breakStart += offset;
  var currentPosition;
  var topPoint = breakStart + WAVED_LINE_TOP;
  var centerPoint = breakStart + WAVED_LINE_CENTER;
  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;
  var points = [[positionFrom, centerPoint]];
  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {
    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);
  }
  return [].concat.apply([], points);
}
function rotateLine(lineCoords) {
  var points = [];
  var i;
  for (i = 0; i < lineCoords.length; i += 2) {
    points.push(lineCoords[i + 1]);
    points.push(lineCoords[i]);
  }
  return points;
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 45888:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _bar_gauge = __webpack_require__(44898);
var _default = _bar_gauge.dxBarGauge;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88950:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _bullet = _interopRequireDefault(__webpack_require__(59989));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _bullet.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99511:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_chart = _interopRequireDefault(__webpack_require__(4096));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _m_chart.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Crosshair = Crosshair;
exports.getMargins = getMargins;
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
var math = Math;
var mathAbs = math.abs;
var mathMin = math.min;
var mathMax = math.max;
var mathFloor = math.floor;
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var LABEL_BACKGROUND_PADDING_X = 8;
var LABEL_BACKGROUND_PADDING_Y = 4;
var CENTER = 'center';
var RIGHT = 'right';
var LEFT = 'left';
var TOP = 'top';
var BOTTOM = 'bottom';
function getMargins() {
  return {
    x: LABEL_BACKGROUND_PADDING_X,
    y: LABEL_BACKGROUND_PADDING_Y
  };
}
function getRectangleBBox(bBox) {
  return {
    x: bBox.x - LABEL_BACKGROUND_PADDING_X,
    y: bBox.y - LABEL_BACKGROUND_PADDING_Y,
    width: bBox.width + LABEL_BACKGROUND_PADDING_X * 2,
    height: bBox.height + LABEL_BACKGROUND_PADDING_Y * 2
  };
}
function getLabelCheckerPosition(x, y, isHorizontal, canvas) {
  var params = isHorizontal ? ['x', 'width', 'y', 'height', y, 0] : ['y', 'height', 'x', 'width', x, 1];
  return function (bBox, position, coord) {
    var labelCoord = {
      x: coord.x,
      y: coord.y
    };
    var rectangleBBox = getRectangleBBox(bBox);
    var delta = isHorizontal ? coord.y - bBox.y - bBox.height / 2 : coord.y - bBox.y;
    labelCoord.y = isHorizontal || !isHorizontal && position === BOTTOM ? coord.y + delta : coord.y;
    if (rectangleBBox[params[0]] < 0) {
      labelCoord[params[0]] -= rectangleBBox[params[0]];
    } else if (rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] > canvas[params[1]]) {
      labelCoord[params[0]] -= rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] - canvas[params[1]];
    }
    if (params[4] - rectangleBBox[params[3]] / 2 < 0) {
      labelCoord[params[2]] -= params[4] - rectangleBBox[params[3]] / 2;
    } else if (params[4] + rectangleBBox[params[3]] / 2 > canvas[params[3]]) {
      labelCoord[params[2]] -= params[4] + rectangleBBox[params[3]] / 2 - canvas[params[3]];
    }
    return labelCoord;
  };
}
function Crosshair(renderer, options, params, group) {
  var that = this;
  that._renderer = renderer;
  that._crosshairGroup = group;
  that._options = {};
  that.update(options, params);
}
Crosshair.prototype = {
  constructor: Crosshair,
  update: function update(options, params) {
    var that = this;
    var canvas = params.canvas;
    that._canvas = {
      top: canvas.top,
      bottom: canvas.height - canvas.bottom,
      left: canvas.left,
      right: canvas.width - canvas.right,
      width: canvas.width,
      height: canvas.height
    };
    that._axes = params.axes;
    that._panes = params.panes;
    that._prepareOptions(options, HORIZONTAL);
    that._prepareOptions(options, VERTICAL);
  },
  dispose: function dispose() {
    var that = this;
    that._renderer = that._crosshairGroup = that._options = that._axes = that._canvas = that._horizontalGroup = that._verticalGroup = that._horizontal = that._vertical = that._circle = that._panes = null;
  },
  _prepareOptions: function _prepareOptions(options, direction) {
    var lineOptions = options[direction + 'Line'];
    this._options[direction] = {
      visible: lineOptions.visible,
      line: {
        stroke: lineOptions.color || options.color,
        'stroke-width': lineOptions.width || options.width,
        dashStyle: lineOptions.dashStyle || options.dashStyle,
        opacity: lineOptions.opacity || options.opacity,
        'stroke-linecap': 'butt'
      },
      label: (0, _extend.extend)(true, {}, options.label, lineOptions.label)
    };
  },
  _createLines: function _createLines(options, sharpParam, group) {
    var lines = [];
    var canvas = this._canvas;
    var points = [canvas.left, canvas.top, canvas.left, canvas.top];
    for (var i = 0; i < 2; i++) {
      lines.push(this._renderer.path(points, 'line').attr(options).sharp(sharpParam).append(group));
    }
    return lines;
  },
  render: function render() {
    var that = this;
    var renderer = that._renderer;
    var options = that._options;
    var verticalOptions = options.vertical;
    var horizontalOptions = options.horizontal;
    var extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line;
    var circleOptions = {
      stroke: extraOptions.stroke,
      'stroke-width': extraOptions['stroke-width'],
      dashStyle: extraOptions.dashStyle,
      opacity: extraOptions.opacity
    };
    var canvas = that._canvas;
    that._horizontal = {};
    that._vertical = {};
    that._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(that._crosshairGroup);
    that._horizontalGroup = renderer.g().append(that._crosshairGroup);
    that._verticalGroup = renderer.g().append(that._crosshairGroup);
    if (verticalOptions.visible) {
      that._vertical.lines = that._createLines(verticalOptions.line, 'h', that._verticalGroup);
      that._vertical.labels = that._createLabels(that._axes[0], verticalOptions, false, that._verticalGroup);
    }
    if (horizontalOptions.visible) {
      that._horizontal.lines = that._createLines(horizontalOptions.line, 'v', that._horizontalGroup);
      that._horizontal.labels = that._createLabels(that._axes[1], horizontalOptions, true, that._horizontalGroup);
    }
    that.hide();
  },
  _createLabels: function _createLabels(axes, options, isHorizontal, group) {
    var that = this;
    var canvas = that._canvas;
    var renderer = that._renderer;
    var x;
    var y;
    var text;
    var labels = [];
    var background;
    var currentLabelPos;
    var labelOptions = options.label;
    if (labelOptions.visible) {
      axes.forEach(function (axis) {
        var position = axis.getOptions().position;
        if (axis.getTranslator().getBusinessRange().isEmpty()) {
          return;
        }
        currentLabelPos = axis.getLabelsPosition();
        if (isHorizontal) {
          y = canvas.top;
          x = currentLabelPos;
        } else {
          x = canvas.left;
          y = currentLabelPos;
        }
        var align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;
        background = renderer.rect(0, 0, 0, 0).attr({
          fill: labelOptions.backgroundColor || options.line.stroke
        }).append(group);
        text = renderer.text('0', 0, 0).css((0, _utils.patchFontOptions)(options.label.font)).attr({
          align: align,
          'class': labelOptions.cssClass
        }).append(group);
        labels.push({
          text: text,
          background: background,
          axis: axis,
          options: labelOptions,
          pos: {
            coord: currentLabelPos,
            side: position
          },
          startXY: {
            x: x,
            y: y
          }
        });
      });
    }
    return labels;
  },
  _updateText: function _updateText(value, axisName, labels, point, func) {
    var that = this;
    labels.forEach(function (label) {
      var axis = label.axis;
      var coord = label.startXY;
      var textElement = label.text;
      var backgroundElement = label.background;
      var text = '';
      if (!axis.name || axis.name === axisName) {
        text = axis.getFormattedValue(value, label.options, point);
      }
      if (text) {
        textElement.attr({
          text: text,
          x: coord.x,
          y: coord.y
        });
        textElement.attr(func(textElement.getBBox(), label.pos.side, coord));
        that._updateLinesCanvas(label);
        backgroundElement.attr(getRectangleBBox(textElement.getBBox()));
      } else {
        textElement.attr({
          text: ''
        });
        backgroundElement.attr({
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
    });
  },
  hide: function hide() {
    this._crosshairGroup.attr({
      visibility: 'hidden'
    });
  },
  _updateLinesCanvas: function _updateLinesCanvas(label) {
    var position = label.pos.side;
    var labelCoord = label.pos.coord;
    var coords = this._linesCanvas;
    var canvas = this._canvas;
    coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelCoord - canvas[position]) ? coords[position] : labelCoord;
  },
  _updateLines: function _updateLines(lines, x, y, r, isHorizontal) {
    var coords = this._linesCanvas;
    var canvas = this._canvas;
    var points = isHorizontal ? [[mathMin(x - r, coords.left), canvas.top, x - r, canvas.top], [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]] : [[canvas.left, mathMin(coords.top, y - r), canvas.left, y - r], [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]];
    for (var i = 0; i < 2; i++) {
      lines[i].attr({
        points: points[i]
      }).sharp(isHorizontal ? 'v' : 'h', isHorizontal ? y === canvas.bottom ? -1 : 1 : x === canvas.right ? -1 : 1);
    }
  },
  _resetLinesCanvas: function _resetLinesCanvas() {
    var canvas = this._canvas;
    this._linesCanvas = {
      left: canvas.left,
      right: canvas.right,
      top: canvas.top,
      bottom: canvas.bottom
    };
  },
  _getClipRectForPane: function _getClipRectForPane(x, y) {
    var panes = this._panes;
    var i;
    var coords;
    for (i = 0; i < panes.length; i++) {
      coords = panes[i].coords;
      if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {
        return panes[i].clipRect;
      }
    }
    return {
      id: null
    };
  },
  show: function show(data) {
    var that = this;
    var point = data.point;
    var pointData = point.getCrosshairData(data.x, data.y);
    var r = point.getPointRadius();
    var horizontal = that._horizontal;
    var vertical = that._vertical;
    var rad = !r ? 0 : r + 3;
    var canvas = that._canvas;
    var x = mathFloor(pointData.x);
    var y = mathFloor(pointData.y);
    if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {
      that._crosshairGroup.attr({
        visibility: 'visible'
      });
      that._resetLinesCanvas();
      that._circle.attr({
        cx: x,
        cy: y,
        r: rad,
        'clip-path': that._getClipRectForPane(x, y).id
      });
      if (horizontal.lines) {
        that._updateText(pointData.yValue, pointData.axis, horizontal.labels, point, getLabelCheckerPosition(x, y, true, canvas));
        that._updateLines(horizontal.lines, x, y, rad, true);
        that._horizontalGroup.attr({
          translateY: y - canvas.top
        });
      }
      if (vertical.lines) {
        that._updateText(pointData.xValue, pointData.axis, vertical.labels, point, getLabelCheckerPosition(x, y, false, canvas));
        that._updateLines(vertical.lines, x, y, rad, false);
        that._verticalGroup.attr({
          translateX: x - canvas.left
        });
      }
    } else {
      that.hide();
    }
  }
};

/***/ }),

/***/ 21495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LayoutManager = LayoutManager;
var _type = __webpack_require__(35922);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _layout_element = __webpack_require__(73711);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var floor = Math.floor,
  sqrt = Math.sqrt;
var _min = Math.min;
var _max = Math.max;
var DEFAULT_INNER_RADIUS = 0.5;
var RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;
function getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {
  var nearestCoord;
  if (pointCenterCoord < firstCoord) {
    nearestCoord = firstCoord;
  } else if (secondCoord < pointCenterCoord) {
    nearestCoord = secondCoord;
  } else {
    nearestCoord = pointCenterCoord;
  }
  return nearestCoord;
}
function getLabelLayout(point) {
  if (point._label.isVisible() && point._label.getLayoutOptions().position !== 'inside') {
    return point._label.getBoundingRect();
  }
}
function getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {
  series.some(function (singleSeries) {
    return singleSeries.getVisiblePoints().reduce(function (radiusIsFound, point) {
      var labelBBox = getLabelLayout(point);
      if (labelBBox) {
        var xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX);
        var yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);
        accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - RADIAL_LABEL_INDENT, minR), accessibleRadius);
        radiusIsFound = true;
      }
      return radiusIsFound;
    }, false);
  });
  return accessibleRadius;
}
function getSizeLabels(series) {
  return series.reduce(function (res, singleSeries) {
    var maxWidth = singleSeries.getVisiblePoints().reduce(function (width, point) {
      var labelBBox = getLabelLayout(point);
      if (labelBBox && labelBBox.width > width) {
        width = labelBBox.width;
      }
      return width;
    }, 0);
    var rWidth = maxWidth;
    if (maxWidth) {
      res.outerLabelsCount++;
      if (res.outerLabelsCount > 1) {
        maxWidth += _consts.default.pieLabelSpacing;
      }
      rWidth += _consts.default.pieLabelSpacing;
    }
    res.sizes.push(maxWidth);
    res.rSizes.push(rWidth);
    res.common += maxWidth;
    return res;
  }, {
    sizes: [],
    rSizes: [],
    common: 0,
    outerLabelsCount: 0
  });
}
function correctLabelRadius(labelSizes, radius, series, canvas, averageWidthLabels, centerX) {
  var curRadius;
  var i;
  var runningWidth = 0;
  var sizes = labelSizes.sizes;
  var rSizes = labelSizes.rSizes;
  for (i = 0; i < series.length; i++) {
    if (sizes[i] === 0) {
      curRadius && (curRadius += rSizes[i - 1]);
      continue;
    }
    curRadius = floor(curRadius ? curRadius + rSizes[i - 1] : radius);
    series[i].correctLabelRadius(curRadius);
    runningWidth += averageWidthLabels || sizes[i];
    rSizes[i] = averageWidthLabels || rSizes[i];
    series[i].setVisibleArea({
      left: floor(centerX - radius - runningWidth),
      right: floor(canvas.width - (centerX + radius + runningWidth)),
      top: canvas.top,
      bottom: canvas.bottom,
      width: canvas.width,
      height: canvas.height
    });
  }
}
function getLengthFromCenter(x, y, paneCenterX, paneCenterY) {
  return sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY));
}
function getInnerRadius(_ref) {
  var type = _ref.type,
    innerRadius = _ref.innerRadius;
  return type === 'pie' ? 0 : (0, _type.isNumeric)(innerRadius) ? Number(innerRadius) : DEFAULT_INNER_RADIUS;
}
function LayoutManager() {}
function getAverageLabelWidth(centerX, radius, canvas, sizeLabels) {
  return (centerX - radius - RADIAL_LABEL_INDENT - canvas.left) / sizeLabels.outerLabelsCount;
}
function getFullRadiusWithLabels(centerX, canvas, sizeLabels) {
  return centerX - canvas.left - (sizeLabels.outerLabelsCount > 0 ? sizeLabels.common + RADIAL_LABEL_INDENT : 0);
}
function correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY) {
  var sizeLabels = getSizeLabels(series);
  var averageWidthLabels;
  var fullRadiusWithLabels = getFullRadiusWithLabels(paneCenterX, canvas, sizeLabels);
  if (fullRadiusWithLabels < minR) {
    availableRadius = minR;
    averageWidthLabels = getAverageLabelWidth(paneCenterX, availableRadius, canvas, sizeLabels);
  } else {
    availableRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, availableRadius, minR), fullRadiusWithLabels);
  }
  correctLabelRadius(sizeLabels, availableRadius + RADIAL_LABEL_INDENT, series, canvas, averageWidthLabels, paneCenterX);
  return availableRadius;
}
function toLayoutElementCoords(canvas) {
  return new _layout_element.WrapperLayoutElement(null, {
    x: canvas.left,
    y: canvas.top,
    width: canvas.width - canvas.left - canvas.right,
    height: canvas.height - canvas.top - canvas.bottom
  });
}
LayoutManager.prototype = {
  constructor: LayoutManager,
  setOptions: function setOptions(options) {
    this._options = options;
  },
  applyPieChartSeriesLayout: function applyPieChartSeriesLayout(canvas, series, hideLayoutLabels) {
    var paneSpaceHeight = canvas.height - canvas.top - canvas.bottom;
    var paneSpaceWidth = canvas.width - canvas.left - canvas.right;
    var paneCenterX = paneSpaceWidth / 2 + canvas.left;
    var paneCenterY = paneSpaceHeight / 2 + canvas.top;
    var piePercentage = this._options.piePercentage;
    var availableRadius;
    var minR;
    if ((0, _type.isNumeric)(piePercentage)) {
      availableRadius = minR = piePercentage * _min(canvas.height, canvas.width) / 2;
    } else {
      availableRadius = _min(paneSpaceWidth, paneSpaceHeight) / 2;
      minR = this._options.minPiePercentage * availableRadius;
    }
    if (!hideLayoutLabels) {
      availableRadius = correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY);
    }
    return {
      centerX: floor(paneCenterX),
      centerY: floor(paneCenterY),
      radiusInner: floor(availableRadius * getInnerRadius(series[0])),
      radiusOuter: floor(availableRadius)
    };
  },
  applyEqualPieChartLayout: function applyEqualPieChartLayout(series, layout) {
    var radius = layout.radius;
    return {
      centerX: floor(layout.x),
      centerY: floor(layout.y),
      radiusInner: floor(radius * getInnerRadius(series[0])),
      radiusOuter: floor(radius)
    };
  },
  correctPieLabelRadius: function correctPieLabelRadius(series, layout, canvas) {
    var sizeLabels = getSizeLabels(series);
    var averageWidthLabels;
    var radius = layout.radiusOuter + RADIAL_LABEL_INDENT;
    var availableLabelWidth = layout.centerX - canvas.left - radius;
    if (sizeLabels.common + RADIAL_LABEL_INDENT > availableLabelWidth) {
      averageWidthLabels = getAverageLabelWidth(layout.centerX, layout.radiusOuter, canvas, sizeLabels);
    }
    correctLabelRadius(sizeLabels, radius, series, canvas, averageWidthLabels, layout.centerX);
  },
  needMoreSpaceForPanesCanvas(panes, rotated, fixedSizeCallback) {
    var options = this._options;
    var width = options.width;
    var height = options.height;
    var piePercentage = options.piePercentage;
    var percentageIsValid = (0, _type.isNumeric)(piePercentage);
    var needHorizontalSpace = 0;
    var needVerticalSpace = 0;
    panes.forEach(function (pane) {
      var paneCanvas = pane.canvas;
      var minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : undefined;
      var paneSized = fixedSizeCallback ? fixedSizeCallback(pane) : {
        width: false,
        height: false
      };
      var needPaneHorizontalSpace = !paneSized.width ? (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right) : 0;
      var needPaneVerticalSpace = !paneSized.height ? (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom) : 0;
      if (rotated) {
        needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;
        needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace);
      } else {
        needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);
        needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0;
      }
    });
    return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {
      width: needHorizontalSpace,
      height: needVerticalSpace
    } : false;
  },
  layoutInsideLegend: function layoutInsideLegend(legend, canvas) {
    var inverseAlign = {
      left: 'right',
      right: 'left',
      top: 'bottom',
      bottom: 'top',
      center: 'center'
    };
    var layoutOptions = legend.getLayoutOptions();
    if (!layoutOptions) {
      return;
    }
    var position = layoutOptions.position;
    var cutSide = layoutOptions.cutSide;
    var my = {
      horizontal: position.horizontal,
      vertical: position.vertical
    };
    canvas[layoutOptions.cutLayoutSide] += layoutOptions.cutSide === 'horizontal' ? layoutOptions.width : layoutOptions.height;
    my[cutSide] = inverseAlign[my[cutSide]];
    legend.position({
      of: toLayoutElementCoords(canvas),
      my: my,
      at: position
    });
  }
};

/***/ }),

/***/ 42597:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _console = __webpack_require__(30869);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _math2 = __webpack_require__(60810);
var _math = Math;
var _floor = _math.floor;
var _max = _math.max;
var _abs = _math.abs;
function getValueAxesPerPanes(valueAxes) {
  var result = {};
  valueAxes.forEach(function (axis) {
    var pane = axis.pane;
    if (!result[pane]) {
      result[pane] = [];
    }
    result[pane].push(axis);
  });
  return result;
}
var linearConverter = function linearConverter(br) {
  return {
    transform: function transform(v, b) {
      return (0, _math2.adjust)((0, _utils.getLogExt)(v, b, br.allowNegatives, br.linearThreshold));
    },
    getTicks: function getTicks(interval, tickValues, base) {
      var ticks = [];
      var tick = this.transform(tickValues[0], base);
      while (ticks.length < tickValues.length) {
        ticks.push(tick);
        tick = (0, _math2.adjust)(tick + interval);
      }
      return ticks;
    }
  };
};
var logConverter = function logConverter(br) {
  return {
    transform: function transform(v, b) {
      return (0, _math2.adjust)((0, _utils.raiseToExt)(v, b, br.allowNegatives, br.linearThreshold));
    },
    getTicks: function getTicks(interval, tickValues, base) {
      var ticks = [];
      var tick;
      for (var i = 0; i < tickValues.length; i += 1) {
        tick = this.transform(tickValues[i], base);
        ticks.push(tick);
      }
      return ticks;
    }
  };
};
function convertAxisInfo(axisInfo, converter) {
  if (!axisInfo.isLogarithmic) {
    return;
  }
  var base = axisInfo.logarithmicBase;
  var tickValues = axisInfo.tickValues;
  axisInfo.minValue = converter.transform(axisInfo.minValue, base);
  axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);
  axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);
  axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);
  axisInfo.tickInterval = _math.round(axisInfo.tickInterval);
  if (axisInfo.tickInterval < 1) {
    axisInfo.tickInterval = 1;
  }
  var ticks = converter.getTicks(axisInfo.tickInterval, tickValues, base);
  ticks.tickInterval = axisInfo.tickInterval;
  axisInfo.tickValues = ticks;
}
function populateAxesInfo(axes) {
  return axes.reduce(function (result, axis) {
    var ticksValues = axis.getTicksValues();
    var majorTicks = ticksValues.majorTicksValues;
    var options = axis.getOptions();
    var businessRange = axis.getTranslator().getBusinessRange();
    var visibleArea = axis.getVisibleArea();
    var axisInfo;
    var tickInterval = axis._tickInterval;
    var synchronizedValue = options.synchronizedValue;
    var action = axis.getViewport().action;
    if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && options.type !== 'discrete' && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && action !== 'zoom' && action !== 'pan') {
      axis.applyMargins();
      var startValue = axis.getTranslator().from(visibleArea[0]);
      var endValue = axis.getTranslator().from(visibleArea[1]);
      var minValue = startValue < endValue ? startValue : endValue;
      var maxValue = startValue < endValue ? endValue : startValue;
      if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {
        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;
        minValue = majorTicks[0] - tickInterval;
        maxValue = majorTicks[0] + tickInterval;
      }
      axisInfo = {
        axis: axis,
        isLogarithmic: options.type === 'logarithmic',
        logarithmicBase: businessRange.base,
        tickValues: majorTicks,
        minorValues: ticksValues.minorTicksValues,
        minorTickInterval: axis._minorTickInterval,
        minValue: minValue,
        oldMinValue: minValue,
        maxValue: maxValue,
        oldMaxValue: maxValue,
        inverted: businessRange.invert,
        tickInterval: tickInterval,
        synchronizedValue: synchronizedValue
      };
      convertAxisInfo(axisInfo, linearConverter(axis.getTranslator().getBusinessRange()));
      result.push(axisInfo);
    }
    return result;
  }, []);
}
function updateTickValues(axesInfo) {
  var maxTicksCount = axesInfo.reduce(function (max, axisInfo) {
    return _max(max, axisInfo.tickValues.length);
  }, 0);
  axesInfo.forEach(function (axisInfo) {
    var ticksMultiplier;
    var ticksCount;
    var additionalStartTicksCount = 0;
    var synchronizedValue = axisInfo.synchronizedValue;
    var tickValues = axisInfo.tickValues;
    var tickInterval = axisInfo.tickInterval;
    if ((0, _type.isDefined)(synchronizedValue)) {
      axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;
      axisInfo.tickValues = [axisInfo.baseTickValue];
    } else {
      if (tickValues.length > 1 && tickInterval) {
        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);
        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;
        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);
        while (additionalStartTicksCount > 0 && tickValues[0] !== 0) {
          tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));
          additionalStartTicksCount--;
        }
        while (tickValues.length < ticksCount) {
          tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval));
        }
        axisInfo.tickInterval = tickInterval / ticksMultiplier;
      }
      axisInfo.baseTickValue = tickValues[0];
      axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1];
    }
  });
}
function getAxisRange(axisInfo) {
  return axisInfo.maxValue - axisInfo.minValue || 1; // T153054
}

function getMainAxisInfo(axesInfo) {
  for (var i = 0; i < axesInfo.length; i++) {
    if (!axesInfo[i].stubData) {
      return axesInfo[i];
    }
  }
  return null;
}
function correctMinMaxValues(axesInfo) {
  var mainAxisInfo = getMainAxisInfo(axesInfo);
  var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;
  axesInfo.forEach(function (axisInfo) {
    var scale;
    var move;
    var mainAxisBaseValueOffset;
    var valueFromAxisInfo;
    if (axisInfo !== mainAxisInfo) {
      if (mainAxisInfoTickInterval && axisInfo.tickInterval) {
        if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {
          axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
          axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;
        }
        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);
        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale;
      }
      if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {
        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;
      } else {
        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;
      }
      valueFromAxisInfo = getAxisRange(axisInfo);
      move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;
      axisInfo.minValue -= move;
      axisInfo.maxValue -= move;
    }
  });
}
function calculatePaddings(axesInfo) {
  var minPadding;
  var maxPadding;
  var startPadding = 0;
  var endPadding = 0;
  axesInfo.forEach(function (axisInfo) {
    var inverted = axisInfo.inverted;
    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;
    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;
    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);
    endPadding = _max(endPadding, inverted ? minPadding : maxPadding);
  });
  return {
    start: startPadding,
    end: endPadding
  };
}
function correctMinMaxValuesByPaddings(axesInfo, paddings) {
  axesInfo.forEach(function (info) {
    var range = getAxisRange(info);
    var inverted = info.inverted;
    info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? 'end' : 'start'] * range);
    info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? 'start' : 'end'] * range);
  });
}
function updateTickValuesIfSynchronizedValueUsed(axesInfo) {
  var hasSynchronizedValue = false;
  axesInfo.forEach(function (info) {
    hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue);
  });
  axesInfo.forEach(function (info) {
    var tickInterval = info.tickInterval;
    var tickValues = info.tickValues;
    var maxValue = info.maxValue;
    var minValue = info.minValue;
    var tick;
    if (hasSynchronizedValue && tickInterval) {
      while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {
        tickValues.unshift(tick);
      }
      tick = tickValues[tickValues.length - 1];
      while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {
        tickValues.push(tick);
      }
    }
    while (tickValues[0] + tickInterval / 10 < minValue) {
      tickValues.shift();
    }
    while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {
      tickValues.pop();
    }
  });
}
function applyMinMaxValues(axesInfo) {
  axesInfo.forEach(function (info) {
    var axis = info.axis;
    var range = axis.getTranslator().getBusinessRange();
    if (range.min === range.minVisible) {
      range.min = info.minValue;
    }
    if (range.max === range.maxVisible) {
      range.max = info.maxValue;
    }
    range.minVisible = info.minValue;
    range.maxVisible = info.maxValue;
    if (range.min > range.minVisible) {
      range.min = range.minVisible;
    }
    if (range.max < range.maxVisible) {
      range.max = range.maxVisible;
    }
    axis.getTranslator().updateBusinessRange(range);
    axis.setTicks({
      majorTicks: info.tickValues,
      minorTicks: info.minorValues
    });
  });
}
function correctAfterSynchronize(axesInfo) {
  var invalidAxisInfo = [];
  var correctValue;
  axesInfo.forEach(function (info) {
    if (info.oldMaxValue - info.oldMinValue === 0) {
      invalidAxisInfo.push(info);
    } else {
      if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {
        correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));
      }
    }
  });
  if (!(0, _type.isDefined)(correctValue)) {
    return;
  }
  invalidAxisInfo.forEach(function (info) {
    var firstTick = info.tickValues[0];
    var correctedTick = firstTick * correctValue;
    if (firstTick > 0) {
      info.maxValue = correctedTick;
      info.minValue = 0;
    } else if (firstTick < 0) {
      info.minValue = correctedTick;
      info.maxValue = 0;
    }
  });
}
function updateMinorTicks(axesInfo) {
  axesInfo.forEach(function (axisInfo) {
    if (!axisInfo.minorTickInterval) {
      return;
    }
    var ticks = [];
    var interval = axisInfo.minorTickInterval;
    var tickCount = axisInfo.tickInterval / interval - 1;
    for (var i = 1; i < axisInfo.tickValues.length; i++) {
      var tick = axisInfo.tickValues[i - 1];
      for (var j = 0; j < tickCount; j++) {
        tick += interval;
        ticks.push(tick);
      }
    }
    axisInfo.minorValues = ticks;
  });
}
function correctPaddings(axesInfo, paddings) {
  return axesInfo.reduce(function (prev, info) {
    var inverted = info.inverted;
    var _info$axis$getCorrect = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue),
      start = _info$axis$getCorrect.start,
      end = _info$axis$getCorrect.end;
    if ((0, _type.isDefined)(start) || (0, _type.isDefined)(end)) {
      return inverted ? {
        start: prev.start,
        end: Math.min(prev.end, end)
      } : {
        start: Math.min(prev.start, start),
        end: prev.end
      };
    }
    return prev;
  }, paddings);
}
var multiAxesSynchronizer = {
  synchronize: function synchronize(valueAxes) {
    (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function (_, axes) {
      var axesInfo;
      var paddings;
      if (axes.length > 1) {
        axesInfo = populateAxesInfo(axes);
        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) return;
        updateTickValues(axesInfo);
        correctMinMaxValues(axesInfo);
        paddings = calculatePaddings(axesInfo);
        paddings = correctPaddings(axesInfo, paddings);
        correctMinMaxValuesByPaddings(axesInfo, paddings);
        correctAfterSynchronize(axesInfo);
        updateTickValuesIfSynchronizedValueUsed(axesInfo);
        updateMinorTicks(axesInfo);
        axesInfo.forEach(function (info) {
          convertAxisInfo(info, logConverter(info.axis.getTranslator().getBusinessRange()));
        });
        applyMinMaxValues(axesInfo);
      }
    });
  }
};
var _default = multiAxesSynchronizer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97882:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ScrollBar = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _index = __webpack_require__(39611);
var _extend = __webpack_require__(13306);
var _translator2d = __webpack_require__(87276);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _drag = __webpack_require__(23174);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _min = Math.min;
var _max = Math.max;
var MIN_SCROLL_BAR_SIZE = 2;
var ScrollBar = function ScrollBar(renderer, group) {
  this._translator = new _translator2d.Translator2D({}, {}, {});
  this._scroll = renderer.rect().append(group);
  this._addEvents();
};
exports.ScrollBar = ScrollBar;
function _getXCoord(canvas, pos, offset, width) {
  var x = 0;
  if (pos === 'right') {
    x = canvas.width - canvas.right + offset;
  } else if (pos === 'left') {
    x = canvas.left - offset - width;
  }
  return x;
}
function _getYCoord(canvas, pos, offset, width) {
  var y = 0;
  if (pos === 'top') {
    y = canvas.top - offset;
  } else if (pos === 'bottom') {
    y = canvas.height - canvas.bottom + width + offset;
  }
  return y;
}
ScrollBar.prototype = {
  _addEvents: function _addEvents() {
    var _this = this;
    var scrollElement = this._scroll.element;
    _events_engine.default.on(scrollElement, _drag.start, function (e) {
      (0, _index.fireEvent)({
        type: 'dxc-scroll-start',
        originalEvent: e,
        target: scrollElement
      });
    });
    _events_engine.default.on(scrollElement, _drag.move, function (e) {
      var dX = -e.offset.x * _this._scale;
      var dY = -e.offset.y * _this._scale;
      var lx = _this._offset - (_this._layoutOptions.vertical ? dY : dX) / _this._scale;
      _this._applyPosition(lx, lx + _this._translator.canvasLength / _this._scale);
      (0, _index.fireEvent)({
        type: 'dxc-scroll-move',
        originalEvent: e,
        target: scrollElement,
        offset: {
          x: dX,
          y: dY
        }
      });
    });
    _events_engine.default.on(scrollElement, _drag.end, function (e) {
      (0, _index.fireEvent)({
        type: 'dxc-scroll-end',
        originalEvent: e,
        target: scrollElement,
        offset: {
          x: -e.offset.x * _this._scale,
          y: -e.offset.y * _this._scale
        }
      });
    });
  },
  update: function update(options) {
    var that = this;
    var position = options.position;
    var isVertical = options.rotated;
    var defaultPosition = isVertical ? 'right' : 'top';
    var secondaryPosition = isVertical ? 'left' : 'bottom';
    if (position !== defaultPosition && position !== secondaryPosition) {
      position = defaultPosition;
    }
    that._scroll.attr({
      rotate: !options.rotated ? -90 : 0,
      rotateX: 0,
      rotateY: 0,
      fill: options.color,
      width: options.width,
      opacity: options.opacity
    });
    that._layoutOptions = {
      width: options.width,
      offset: options.offset,
      vertical: isVertical,
      position: position
    };
    return that;
  },
  init: function init(range, stick) {
    var that = this;
    var isDiscrete = range.axisType === 'discrete';
    that._translateWithOffset = isDiscrete && !stick && 1 || 0;
    that._translator.update((0, _extend.extend)({}, range, {
      minVisible: null,
      maxVisible: null,
      visibleCategories: null
    }, isDiscrete && {
      min: null,
      max: null
    } || {}), that._canvas, {
      isHorizontal: !that._layoutOptions.vertical,
      stick: stick
    });
    return that;
  },
  getOptions: function getOptions() {
    return this._layoutOptions;
  },
  setPane: function setPane(panes) {
    var position = this._layoutOptions.position;
    var pane;
    if (position === 'left' || position === 'top') {
      pane = panes[0];
    } else {
      pane = panes[panes.length - 1];
    }
    this.pane = pane.name;
    return this;
  },
  updateSize: function updateSize(canvas) {
    this._canvas = (0, _extend.extend)({}, canvas);
    var options = this._layoutOptions;
    var pos = options.position;
    var offset = options.offset;
    var width = options.width;
    this._scroll.attr({
      translateX: _getXCoord(canvas, pos, offset, width),
      translateY: _getYCoord(canvas, pos, offset, width)
    });
  },
  getMultipleAxesSpacing: function getMultipleAxesSpacing() {
    return 0;
  },
  estimateMargins: function estimateMargins() {
    return this.getMargins();
  },
  getMargins: function getMargins() {
    var options = this._layoutOptions;
    var margins = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    margins[options.position] = options.width + options.offset;
    return margins;
  },
  shift: function shift(margins) {
    var _that$_scroll$attr, _that$_scroll$attr2;
    var that = this;
    var options = that._layoutOptions;
    var side = options.position;
    var isVertical = options.vertical;
    var attr = {
      translateX: (_that$_scroll$attr = that._scroll.attr('translateX')) !== null && _that$_scroll$attr !== void 0 ? _that$_scroll$attr : 0,
      translateY: (_that$_scroll$attr2 = that._scroll.attr('translateY')) !== null && _that$_scroll$attr2 !== void 0 ? _that$_scroll$attr2 : 0
    };
    var shift = margins[side];
    attr[isVertical ? 'translateX' : 'translateY'] += (side === 'left' || side === 'top' ? -1 : 1) * shift;
    that._scroll.attr(attr);
  },
  // Axis like functions
  hideTitle: _common.noop,
  hideOuterElements: _common.noop,
  // Axis like functions

  setPosition: function setPosition(min, max) {
    var that = this;
    var translator = that._translator;
    var minPoint = (0, _type.isDefined)(min) ? translator.translate(min, -that._translateWithOffset) : translator.translate('canvas_position_start');
    var maxPoint = (0, _type.isDefined)(max) ? translator.translate(max, that._translateWithOffset) : translator.translate('canvas_position_end');
    that._offset = _min(minPoint, maxPoint);
    that._scale = translator.getScale(min, max);
    that._applyPosition(_min(minPoint, maxPoint), _max(minPoint, maxPoint));
  },
  customPositionIsAvailable() {
    return false;
  },
  dispose: function dispose() {
    this._scroll.dispose();
    this._scroll = this._translator = null;
  },
  _applyPosition: function _applyPosition(x1, x2) {
    var that = this;
    var visibleArea = that._translator.getCanvasVisibleArea();
    x1 = _max(x1, visibleArea.min);
    x1 = _min(x1, visibleArea.max);
    x2 = _min(x2, visibleArea.max);
    x2 = _max(x2, visibleArea.min);
    var height = Math.abs(x2 - x1);
    that._scroll.attr({
      y: x1,
      height: height < MIN_SCROLL_BAR_SIZE ? MIN_SCROLL_BAR_SIZE : height
    });
  }
};

/***/ }),

/***/ 70714:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _drag = __webpack_require__(23174);
var SHUTTER_EVENTS_NS = '.shutter-zoom';
var DRAG_START_EVENT_NAME = _drag.start + SHUTTER_EVENTS_NS;
var DRAG_UPDATE_EVENT_NAME = _drag.move + SHUTTER_EVENTS_NS;
var DRAG_END_EVENT_NAME = _drag.end + SHUTTER_EVENTS_NS;
function getPointerCoord(rootOffset, canvas, rotated, e) {
  var coord = Math.floor(rotated ? e.pageY - rootOffset.top : e.pageX - rootOffset.left);
  var min = rotated ? canvas.y1 : canvas.x1;
  var max = rotated ? canvas.y2 : canvas.x2;
  if (coord < min) {
    coord = min;
  } else if (coord > max) {
    coord = max;
  }
  return coord;
}
function checkCoords(rootOffset, canvas, e) {
  var x = e.pageX - rootOffset.left;
  var y = e.pageY - rootOffset.top;
  return x >= canvas.x1 && x <= canvas.x2 && y >= canvas.y1 && y <= canvas.y2;
}
function dragStartHandler(ctx) {
  return function (e) {
    var offset = ctx.getRootOffset();
    var canvas = ctx.getCanvas();
    if (!checkCoords(offset, canvas, e)) {
      e.cancel = true;
      return;
    }
    ctx.rootOffset = offset;
    ctx.canvas = canvas;
    ctx.startCoord = getPointerCoord(offset, canvas, ctx.rotated, e);
    ctx.triggerStart();
    ctx.rect.attr({
      x: canvas.x1,
      y: canvas.y1,
      width: canvas.width,
      height: canvas.height
    }).append(ctx.root);
  };
}
function dragHandler(ctx) {
  return function (e) {
    var curCoord = getPointerCoord(ctx.rootOffset, ctx.canvas, ctx.rotated, e);
    var attr = {};
    ctx.curCoord = curCoord;
    attr[ctx.rotated ? 'y' : 'x'] = Math.min(ctx.startCoord, curCoord);
    attr[ctx.rotated ? 'height' : 'width'] = Math.abs(ctx.startCoord - curCoord);
    ctx.rect.attr(attr);
  };
}
function dragEndHandler(ctx) {
  return function (e) {
    ctx.triggerEnd();
    ctx.rect.remove();
  };
}
function shutterZoom(options) {
  var chart = options.chart;
  var renderer = options.renderer;
  var rotated = options.rotated;
  var rect = renderer.rect(0, 0, 0, 0).attr(options.shutterOptions);
  var shutter = {
    rect: rect,
    root: renderer.root,
    rotated: rotated,
    triggerStart: function triggerStart() {
      chart._eventTrigger('zoomStart');
    },
    triggerEnd: function triggerEnd() {
      var tr = chart._argumentAxes[0].getTranslator();
      var rangeStart = Math.min(this.startCoord, this.curCoord);
      var rangeEnd = Math.max(this.startCoord, this.curCoord);
      chart._eventTrigger('zoomEnd', {
        rangeStart: tr.from(rangeStart),
        rangeEnd: tr.from(rangeEnd)
      });
    },
    dispose: function dispose() {
      renderer.root.off(SHUTTER_EVENTS_NS);
      rect.dispose();
    },
    getRootOffset: function getRootOffset() {
      return renderer.getRootOffset();
    },
    getCanvas: function getCanvas() {
      var canvas = chart._canvas;
      var panes = chart.panes;
      var firstPane = panes[0].canvas;
      var lastPane = panes[panes.length - 1].canvas;
      return {
        x1: firstPane.left,
        y1: firstPane.top,
        x2: canvas.width - lastPane.right,
        y2: canvas.height - lastPane.bottom,
        width: canvas.width - firstPane.left - lastPane.right,
        height: canvas.height - firstPane.top - lastPane.bottom
      };
    }
  };
  renderer.root.off(SHUTTER_EVENTS_NS).on(DRAG_START_EVENT_NAME, {
    direction: rotated ? 'vertical' : 'horizontal',
    immediate: true
  }, dragStartHandler(shutter)).on(DRAG_UPDATE_EVENT_NAME, dragHandler(shutter)).on(DRAG_END_EVENT_NAME, dragEndHandler(shutter));
  return shutter;
}
var _default = {
  name: 'shutter_zoom',
  init: function init() {
    var options = this.option('shutterZoom') || {};
    if (!options.enabled) {
      return;
    }
    this._shutterZoom = shutterZoom({
      chart: this,
      renderer: this._renderer,
      rotated: this.option('rotated'),
      shutterOptions: options
    });
  },
  dispose: function dispose() {
    this._shutterZoom && this._shutterZoom.dispose();
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 19957:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.PieTracker = exports.ChartTracker = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _click = __webpack_require__(95429);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _utils = __webpack_require__(19157);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _index = __webpack_require__(39611);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _floor = Math.floor;
var eventsConsts = _consts.default.events;
var statesConsts = _consts.default.states;
var HOVER_STATE = statesConsts.hoverMark;
var NORMAL_STATE = statesConsts.normalMark;
var EVENT_NS = 'dxChartTracker';
var DOT_EVENT_NS = '.' + EVENT_NS;
var POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
var LEGEND_CLICK = 'legendClick';
var SERIES_CLICK = 'seriesClick';
var POINT_CLICK = 'pointClick';
var POINT_DATA = 'chart-data-point';
var SERIES_DATA = 'chart-data-series';
var ARG_DATA = 'chart-data-argument';
var DELAY = 100;
var HOLD_TIMEOUT = 300;
var NONE_MODE = 'none';
var ALL_ARGUMENT_POINTS_MODE = 'allargumentpoints';
var INCLUDE_POINTS_MODE = 'includepoints';
var EXLUDE_POINTS_MODE = 'excludepoints';
var LEGEND_HOVER_MODES = [INCLUDE_POINTS_MODE, EXLUDE_POINTS_MODE, NONE_MODE];
function getData(event, dataKey, tryCheckParent) {
  var target = event.target;
  if (target.tagName === 'tspan') {
    return target.parentNode[dataKey];
  }
  var data = target[dataKey];
  if (tryCheckParent && !(0, _type.isDefined)(data)) {
    var getParentData = function getParentData(node) {
      if (node.parentNode) {
        if ((0, _type.isDefined)(node.parentNode[dataKey])) {
          return node.parentNode[dataKey];
        } else {
          return getParentData(node.parentNode);
        }
      }
      return undefined;
    };
    return getParentData(target);
  }
  return data;
}
function eventCanceled(_ref, target, clickTarget) {
  var event = _ref.event,
    cancel = _ref.cancel;
  var deprecatedCancel = event.cancel; // DEPRECATED_22_1
  var eventCanceled = cancel || deprecatedCancel;
  if (deprecatedCancel) {
    _errors.default.log('W0003', "".concat(clickTarget, "Click handler argument"), 'event.cancel', '22.1', 'Use the \'cancel\' field instead');
  }
  return eventCanceled || !target.getOptions();
}
function correctLegendHoverMode(mode) {
  if (LEGEND_HOVER_MODES.indexOf(mode) > -1) {
    return mode;
  } else {
    return INCLUDE_POINTS_MODE;
  }
}
function correctHoverMode(target) {
  var mode = target.getOptions().hoverMode;
  return mode === NONE_MODE ? mode : ALL_ARGUMENT_POINTS_MODE;
}
var baseTrackerPrototype = {
  ctor: function ctor(options) {
    var that = this;
    var data = {
      tracker: that
    };
    that._renderer = options.renderer;
    that._legend = options.legend;
    that._tooltip = options.tooltip;
    that._eventTrigger = options.eventTrigger;
    that._seriesGroup = options.seriesGroup;
    options.seriesGroup.off(DOT_EVENT_NS).on((0, _index.addNamespace)(eventsConsts.showPointTooltip, EVENT_NS), data, that._showPointTooltip).on((0, _index.addNamespace)(eventsConsts.hidePointTooltip, EVENT_NS), data, that._hidePointTooltip);
    that._renderer.root.off(DOT_EVENT_NS).on(POINTER_ACTION, data, that._pointerHandler).on((0, _index.addNamespace)(_pointer.default.up, EVENT_NS), function () {
      return clearTimeout(that._holdTimer);
    }).on((0, _index.addNamespace)(_click.name, EVENT_NS), data, that._clickHandler);
  },
  update: function update(options) {
    this._chart = options.chart;
  },
  updateSeries(series, resetDecorations) {
    var that = this;
    var noHoveredSeries = !(series !== null && series !== void 0 && series.some(function (s) {
      return s === that.hoveredSeries;
    }) || that._hoveredPoint && that._hoveredPoint.series);
    if (that._storedSeries !== series) {
      that._storedSeries = series || [];
    }
    if (noHoveredSeries) {
      that._clean();
      that._renderer.initDefsElements();
    }
    if (resetDecorations) {
      that.clearSelection();
      if (!noHoveredSeries) {
        that._hideTooltip(that.pointAtShownTooltip);
        that.clearHover();
      }
    }
  },
  setCanvases: function setCanvases(mainCanvas, paneCanvases) {
    this._mainCanvas = mainCanvas;
    this._canvases = paneCanvases;
  },
  repairTooltip: function repairTooltip() {
    var point = this.pointAtShownTooltip;
    if (!point || !point.series || !point.isVisible()) {
      this._hideTooltip(point, true);
    } else {
      this._showTooltip(point);
    }
  },
  _setHoveredPoint: function _setHoveredPoint(point) {
    if (point === this._hoveredPoint) {
      return;
    }
    this._releaseHoveredPoint();
    point.hover();
    this._hoveredPoint = point;
  },
  _releaseHoveredPoint: function _releaseHoveredPoint(isPointerOut) {
    if (this._hoveredPoint && this._hoveredPoint.getOptions()) {
      this._hoveredPoint.clearHover();
      this._hoveredPoint = null;
      if (this._tooltip.isEnabled()) {
        this._hideTooltip(this._hoveredPoint, false, isPointerOut);
      }
    }
  },
  _setHoveredSeries: function _setHoveredSeries(series, mode) {
    this._releaseHoveredSeries();
    this._releaseHoveredPoint();
    series.hover(mode);
    this.hoveredSeries = series;
  },
  _releaseHoveredSeries() {
    // hoveredPoint only for T273289
    if (this.hoveredSeries) {
      this.hoveredSeries.clearHover();
      this.hoveredSeries = null;
    }
  },
  clearSelection() {
    this._storedSeries.forEach(function (series) {
      if (series) {
        series.clearSelection();
        series.getPoints().forEach(function (point) {
          return point.clearSelection();
        });
      }
    });
  },
  _clean: function _clean() {
    var that = this;
    that.hoveredPoint = that.hoveredSeries = that._hoveredArgumentPoints = null;
    that._hideTooltip(that.pointAtShownTooltip);
  },
  clearHover: function clearHover(isPointerOut) {
    this._resetHoveredArgument();
    this._releaseHoveredSeries();
    this._releaseHoveredPoint(isPointerOut);
  },
  _hideTooltip: function _hideTooltip(point, silent, isPointerOut) {
    var that = this;
    if (!that._tooltip || point && that.pointAtShownTooltip !== point) {
      return;
    }
    if (!silent && that.pointAtShownTooltip) {
      that.pointAtShownTooltip = null;
    }
    that._tooltip.hide(!!isPointerOut);
  },
  _showTooltip: function _showTooltip(point) {
    var that = this;
    var tooltipFormatObject;
    var eventData = {
      target: point
    };
    if (point !== null && point !== void 0 && point.getOptions()) {
      tooltipFormatObject = point.getTooltipFormatObject(that._tooltip, that._tooltip.isShared() && that._chart.getStackedPoints(point));
      if (!(0, _type.isDefined)(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {
        return;
      }
      var coords = point.getTooltipParams(that._tooltip.getLocation());
      var rootOffset = that._renderer.getRootOffset();
      coords.x += rootOffset.left;
      coords.y += rootOffset.top;
      var callback = function callback(result) {
        result && (that.pointAtShownTooltip = point);
      };
      callback(that._tooltip.show(tooltipFormatObject, coords, eventData, undefined, callback));
    }
  },
  _showPointTooltip: function _showPointTooltip(event, point) {
    var that = event.data.tracker;
    var pointWithTooltip = that.pointAtShownTooltip;
    if (pointWithTooltip && pointWithTooltip !== point) {
      that._hideTooltip(pointWithTooltip);
    }
    that._showTooltip(point);
  },
  _hidePointTooltip: function _hidePointTooltip(event, point) {
    event.data.tracker._hideTooltip(point, false, true);
  },
  _enableOutHandler: function _enableOutHandler() {
    if (this._outHandler) {
      return;
    }
    var that = this;
    var handler = function handler(e) {
      var rootOffset = that._renderer.getRootOffset();
      var x = _floor(e.pageX - rootOffset.left);
      var y = _floor(e.pageY - rootOffset.top);
      if (!(0, _utils.pointInCanvas)(that._mainCanvas, x, y) && !that._isCursorOnTooltip(e)) {
        that._pointerOut();
        that._disableOutHandler();
      }
    };
    _events_engine.default.on(_dom_adapter.default.getDocument(), POINTER_ACTION, handler);
    this._outHandler = handler;
  },
  _isCursorOnTooltip: function _isCursorOnTooltip(e) {
    return this._tooltip.isEnabled() && this._tooltip.isCursorOnTooltip(e.pageX, e.pageY);
  },
  _disableOutHandler: function _disableOutHandler() {
    this._outHandler && _events_engine.default.off(_dom_adapter.default.getDocument(), POINTER_ACTION, this._outHandler);
    this._outHandler = null;
  },
  stopCurrentHandling: function stopCurrentHandling() {
    this._pointerOut(true);
  },
  _pointerOut: function _pointerOut(force) {
    this.clearHover(true);
    (force || this._tooltip.isEnabled()) && this._hideTooltip(this.pointAtShownTooltip, false, true);
  },
  _triggerLegendClick: function _triggerLegendClick(eventArgs, elementClick) {
    var eventTrigger = this._eventTrigger;
    eventTrigger(LEGEND_CLICK, eventArgs, function () {
      !eventCanceled(eventArgs, eventArgs.target, 'legend') && eventTrigger(elementClick, eventArgs);
    });
  },
  _hoverLegendItem: function _hoverLegendItem(x, y) {
    var that = this;
    var item = that._legend.getItemByCoord(x, y);
    var series;
    var legendHoverMode = correctLegendHoverMode(that._legend.getOptions().hoverMode);
    if (item) {
      series = that._storedSeries[item.id];
      if (!series.isHovered() || series.lastHoverMode !== legendHoverMode) {
        that._setHoveredSeries(series, legendHoverMode);
      }
      that._tooltip.isEnabled() && that._hideTooltip(that.pointAtShownTooltip);
    } else {
      that.clearHover();
    }
  },
  _hoverArgument: function _hoverArgument(argument, argumentIndex) {
    var that = this;
    var hoverMode = that._getArgumentHoverMode();
    if ((0, _type.isDefined)(argument)) {
      that._releaseHoveredPoint();
      that._hoveredArgument = argument;
      that._argumentIndex = argumentIndex;
      that._notifySeries({
        action: 'pointHover',
        notifyLegend: that._notifyLegendOnHoverArgument,
        target: {
          argument: argument,
          fullState: HOVER_STATE,
          argumentIndex: argumentIndex,
          getOptions: function getOptions() {
            return {
              hoverMode: hoverMode
            };
          }
        }
      });
    }
  },
  _resetHoveredArgument: function _resetHoveredArgument() {
    var that = this;
    var hoverMode;
    if ((0, _type.isDefined)(that._hoveredArgument)) {
      hoverMode = that._getArgumentHoverMode();
      that._notifySeries({
        action: 'clearPointHover',
        notifyLegend: that._notifyLegendOnHoverArgument,
        target: {
          fullState: NORMAL_STATE,
          argumentIndex: that._argumentIndex,
          argument: that._hoveredArgument,
          getOptions: function getOptions() {
            return {
              hoverMode: hoverMode
            };
          }
        }
      });
      that._hoveredArgument = null;
    }
  },
  _notifySeries: function _notifySeries(data) {
    this._storedSeries.forEach(function (series) {
      series.notify(data);
    });
  },
  _pointerHandler: function _pointerHandler(e) {
    var _series;
    var that = e.data.tracker;
    var rootOffset = that._renderer.getRootOffset();
    var x = _floor(e.pageX - rootOffset.left);
    var y = _floor(e.pageY - rootOffset.top);
    var canvas = that._getCanvas(x, y);
    var series = getData(e, SERIES_DATA);
    var point = getData(e, POINT_DATA) || ((_series = series) === null || _series === void 0 ? void 0 : _series.getPointByCoord(x, y));
    that._isHolding = false;
    clearTimeout(that._holdTimer);
    if (e.type === _pointer.default.down) {
      that._holdTimer = setTimeout(function () {
        return that._isHolding = true;
      }, HOLD_TIMEOUT);
    }
    if (point && !point.getMarkerVisibility()) {
      point = undefined;
    }
    that._enableOutHandler();
    if (that._legend.coordsIn(x, y)) {
      that._hoverLegendItem(x, y);
      return;
    }
    if (that.hoveredSeries && that.hoveredSeries !== that._stuckSeries) {
      that._releaseHoveredSeries();
    }
    if (that._hoverArgumentAxis(x, y, e)) {
      return;
    }
    if (that._isPointerOut(canvas, point)) {
      that._pointerOut();
    }
    if (!canvas && !point) {
      return;
    }
    if (series && !point) {
      point = series.getNeighborPoint(x, y);
      if (!that._stickyHovering && point && !point.coordsIn(x, y)) {
        point = null;
      }
      if (series !== that.hoveredSeries) {
        that._setTimeout(function () {
          that._setHoveredSeries(series);
          that._setStuckSeries(e, series, x, y);
          that._pointerComplete(point, x, y);
        }, series);
        return;
      }
    } else if (point) {
      if (e.type !== _pointer.default.move && e.pointerType !== 'touch') {
        return;
      }
      if (that.hoveredSeries) {
        that._setTimeout(function () {
          return that._pointerOnPoint(point, x, y, e);
        }, point);
      } else {
        that._pointerOnPoint(point, x, y, e);
      }
      return;
    } else if (that._setStuckSeries(e, undefined, x, y) && that._stickyHovering) {
      var _point;
      series = that._stuckSeries;
      point = series.getNeighborPoint(x, y);
      that._releaseHoveredSeries();
      ((_point = point) === null || _point === void 0 ? void 0 : _point.getMarkerVisibility()) && that._setHoveredPoint(point);
    } else if (!that._stickyHovering) {
      that._pointerOut();
    }
    that._pointerComplete(point, x, y);
  },
  _pointerOnPoint: function _pointerOnPoint(point, x, y) {
    this._resetHoveredArgument();
    this._setHoveredPoint(point);
    this._pointerComplete(point, x, y);
  },
  _pointerComplete: function _pointerComplete(point) {
    this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point);
  },
  _clickHandler: function _clickHandler(e) {
    var _point2;
    var that = e.data.tracker;
    if (that._isHolding) {
      return;
    }
    var rootOffset = that._renderer.getRootOffset();
    var x = _floor(e.pageX - rootOffset.left);
    var y = _floor(e.pageY - rootOffset.top);
    var point = getData(e, POINT_DATA);
    var series = that._stuckSeries || getData(e, SERIES_DATA) || ((_point2 = point) === null || _point2 === void 0 ? void 0 : _point2.series);
    var axis = that._argumentAxis;
    if (that._legend.coordsIn(x, y)) {
      var item = that._legend.getItemByCoord(x, y);
      if (item) {
        that._legendClick(item, e);
      }
    } else if (axis !== null && axis !== void 0 && axis.coordsIn(x, y)) {
      var argument = getData(e, ARG_DATA, true);
      if ((0, _type.isDefined)(argument)) {
        that._eventTrigger('argumentAxisClick', {
          argument: argument,
          event: e
        });
      }
    } else if (series) {
      var _point3;
      point = point || series.getPointByCoord(x, y);
      if ((_point3 = point) !== null && _point3 !== void 0 && _point3.getMarkerVisibility()) {
        that._pointClick(point, e);
      } else {
        getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {
          target: series,
          event: e
        });
      }
    }
  },
  dispose: function dispose() {
    var that = this;
    that._disableOutHandler();
    that._renderer.root.off(DOT_EVENT_NS);
    that._seriesGroup.off(DOT_EVENT_NS);
  }
};
var ChartTracker = function ChartTracker(options) {
  this.ctor(options);
};
exports.ChartTracker = ChartTracker;
(0, _extend.extend)(ChartTracker.prototype, baseTrackerPrototype, {
  _pointClick: function _pointClick(point, event) {
    var that = this;
    var eventTrigger = that._eventTrigger;
    var series = point.series;
    var eventArgs = {
      target: point,
      event: event
    };
    eventTrigger(POINT_CLICK, eventArgs, function () {
      !eventCanceled(eventArgs, series, 'point') && eventTrigger(SERIES_CLICK, {
        target: series,
        event: event
      });
    });
  },
  update: function update(options) {
    var that = this;
    baseTrackerPrototype.update.call(this, options);
    that._argumentAxis = options.argumentAxis || {};
    that._axisHoverEnabled = that._argumentAxis && (0, _utils.normalizeEnum)(that._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENT_POINTS_MODE;
    that._rotated = options.rotated;
    that._crosshair = options.crosshair;
    that._stickyHovering = options.stickyHovering;
  },
  _getCanvas: function _getCanvas(x, y) {
    var that = this;
    var canvases = that._canvases || [];
    for (var i = 0; i < canvases.length; i++) {
      var c = canvases[i];
      if ((0, _utils.pointInCanvas)(c, x, y)) {
        return c;
      }
    }
    return null;
  },
  _isPointerOut: function _isPointerOut(canvas) {
    return !canvas && this._stuckSeries;
  },
  _hideCrosshair: function _hideCrosshair() {
    var _this$_crosshair;
    (_this$_crosshair = this._crosshair) === null || _this$_crosshair === void 0 ? void 0 : _this$_crosshair.hide();
  },
  _moveCrosshair: function _moveCrosshair(point, x, y) {
    if (this._crosshair && point !== null && point !== void 0 && point.isVisible()) {
      this._crosshair.show({
        point: point,
        x: x,
        y: y
      });
    }
  },
  _clean: function _clean() {
    var that = this;
    baseTrackerPrototype._clean.call(that);
    that._resetTimer();
    that._stuckSeries = null;
  },
  _getSeriesForShared: function _getSeriesForShared(x, y) {
    var _point4;
    var that = this;
    var points = [];
    var point = null;
    var distance = Infinity;
    if (that._tooltip.isShared() && !that.hoveredSeries) {
      (0, _iterator.each)(that._storedSeries, function (_, series) {
        var point = series.getNeighborPoint(x, y);
        point && points.push(point);
      });
      (0, _iterator.each)(points, function (_, p) {
        var coords = p.getCrosshairData(x, y);
        var d = (0, _utils.getDistance)(x, y, coords.x, coords.y);
        if (d < distance) {
          point = p;
          distance = d;
        }
      });
    }
    return (_point4 = point) === null || _point4 === void 0 ? void 0 : _point4.series;
  },
  _setTimeout: function _setTimeout(callback, keeper) {
    var that = this;
    if (that._timeoutKeeper !== keeper) {
      that._resetTimer();
      that._hoverTimeout = setTimeout(function () {
        callback();
        that._timeoutKeeper = null;
      }, DELAY);
      that._timeoutKeeper = keeper;
    }
  },
  _resetTimer: function _resetTimer() {
    clearTimeout(this._hoverTimeout);
    this._timeoutKeeper = this._hoverTimeout = null;
  },
  _stopEvent: function _stopEvent(e) {
    if (!(0, _type.isDefined)(e.cancelable) || e.cancelable) {
      e.preventDefault();
      e.stopPropagation(); // T249548
    }
  },

  _setStuckSeries: function _setStuckSeries(e, series, x, y) {
    if (e.pointerType !== 'mouse') {
      this._stuckSeries = null;
    } else {
      this._stuckSeries = series || this._stuckSeries || this._getSeriesForShared(x, y);
    }
    return !!this._stuckSeries;
  },
  _pointerOut: function _pointerOut() {
    var that = this;
    that._stuckSeries = null;
    that._hideCrosshair();
    that._resetTimer();
    baseTrackerPrototype._pointerOut.apply(that, arguments);
  },
  _hoverArgumentAxis: function _hoverArgumentAxis(x, y, e) {
    var that = this;
    that._resetHoveredArgument();
    if (that._axisHoverEnabled && that._argumentAxis.coordsIn(x, y)) {
      that._hoverArgument(getData(e, ARG_DATA, true));
      return true;
    }
  },
  _pointerComplete: function _pointerComplete(point, x, y) {
    var that = this;
    that.hoveredSeries && that.hoveredSeries.updateHover(x, y);
    that._resetTimer();
    that._moveCrosshair(point, x, y);
    baseTrackerPrototype._pointerComplete.call(that, point);
  },
  _legendClick: function _legendClick(item, e) {
    var series = this._storedSeries[item.id];
    this._triggerLegendClick({
      target: series,
      event: e
    }, SERIES_CLICK);
  },
  _hoverLegendItem: function _hoverLegendItem(x, y) {
    this._stuckSeries = null;
    this._hideCrosshair();
    baseTrackerPrototype._hoverLegendItem.call(this, x, y);
  },
  _pointerOnPoint: function _pointerOnPoint(point, x, y, e) {
    this._setStuckSeries(e, point.series, x, y);
    this._releaseHoveredSeries();
    baseTrackerPrototype._pointerOnPoint.call(this, point, x, y, e);
  },
  _notifyLegendOnHoverArgument: false,
  _getArgumentHoverMode: function _getArgumentHoverMode() {
    return correctHoverMode(this._argumentAxis);
  },
  dispose: function dispose() {
    this._resetTimer();
    baseTrackerPrototype.dispose.call(this);
  }
});
var PieTracker = function PieTracker(options) {
  this.ctor(options);
};
exports.PieTracker = PieTracker;
(0, _extend.extend)(PieTracker.prototype, baseTrackerPrototype, {
  _isPointerOut: function _isPointerOut(_, point) {
    return !point;
  },
  _legendClick: function _legendClick(item, e) {
    var that = this;
    var points = [];
    that._storedSeries.forEach(function (s) {
      return points.push.apply(points, s.getPointsByKeys(item.argument, item.argumentIndex));
    });
    that._eventTrigger(LEGEND_CLICK, {
      target: item.argument,
      points,
      event: e
    });
  },
  _pointClick: function _pointClick(point, e) {
    this._eventTrigger(POINT_CLICK, {
      target: point,
      event: e
    });
  },
  _hoverLegendItem: function _hoverLegendItem(x, y) {
    var that = this;
    var item = that._legend.getItemByCoord(x, y);
    if (item && that._hoveredArgument !== item.argument) {
      that._resetHoveredArgument();
      that._hoverArgument(item.argument, item.argumentIndex);
    } else if (!item) {
      that.clearHover();
    }
  },
  _getArgumentHoverMode: function _getArgumentHoverMode() {
    return correctHoverMode(this._legend);
  },
  _hoverArgumentAxis: _common.noop,
  _setStuckSeries: _common.noop,
  _getCanvas: _common.noop,
  _notifyLegendOnHoverArgument: true
});

/***/ }),

/***/ 59345:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _wheel = __webpack_require__(765);
var transformEvents = _interopRequireWildcard(__webpack_require__(91093));
var _drag = __webpack_require__(23174);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
var EVENTS_NS = '.zoomAndPanNS';
var DRAG_START_EVENT_NAME = _drag.start + EVENTS_NS;
var DRAG_EVENT_NAME = _drag.move + EVENTS_NS;
var DRAG_END_EVENT_NAME = _drag.end + EVENTS_NS;

/* eslint-disable import/namespace */
var PINCH_START_EVENT_NAME = transformEvents['pinchstart'] + EVENTS_NS;
var PINCH_EVENT_NAME = transformEvents['pinch'] + EVENTS_NS;
var PINCH_END_EVENT_NAME = transformEvents['pinchend'] + EVENTS_NS;
/* eslint-enable import/namespace */

var SCROLL_BAR_START_EVENT_NAME = 'dxc-scroll-start' + EVENTS_NS;
var SCROLL_BAR_MOVE_EVENT_NAME = 'dxc-scroll-move' + EVENTS_NS;
var SCROLL_BAR_END_EVENT_NAME = 'dxc-scroll-end' + EVENTS_NS;
var GESTURE_TIMEOUT = 300;
var MIN_DRAG_DELTA = 5;
var _min = Math.min;
var _max = Math.max;
var _abs = Math.abs;
function canvasToRect(canvas) {
  return {
    x: canvas.left,
    y: canvas.top,
    width: canvas.width - canvas.left - canvas.right,
    height: canvas.height - canvas.top - canvas.bottom
  };
}
function checkCoords(rect, coords) {
  var x = coords.x;
  var y = coords.y;
  return x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.height + rect.y;
}
function sortAxes(axes, onlyAxisToNotify) {
  if (onlyAxisToNotify) {
    axes = axes.sort(function (a, b) {
      if (a === onlyAxisToNotify) {
        return -1;
      }
      if (b === onlyAxisToNotify) {
        return 1;
      }
      return 0;
    });
  }
  return axes;
}
function getFilteredAxes(axes) {
  return axes.filter(function (a) {
    return !a.getTranslator().getBusinessRange().isEmpty();
  });
}
function isAxisAvailablePanning(axes) {
  return axes.some(function (axis) {
    return !axis.isExtremePosition(false) || !axis.isExtremePosition(true);
  });
}
function axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e) {
  var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;
  var range = getRange(axis);
  var _axis$checkZoomingLow = axis.checkZoomingLowerLimitOvercome(actionField, scale, range),
    stopInteraction = _axis$checkZoomingLow.stopInteraction,
    correctedRange = _axis$checkZoomingLow.correctedRange;
  var result = axis.handleZooming(stopInteraction ? null : correctedRange, getParameters(silent), e, actionField);
  stopInteraction && axis.handleZoomEnd();
  return {
    stopInteraction,
    result
  };
}
function zoomAxes(e, axes, getRange, zoom, params, onlyAxisToNotify) {
  axes = sortAxes(axes, onlyAxisToNotify);
  var zoomStarted = false;
  var getParameters = function getParameters(silent) {
    return {
      start: !!silent,
      end: !!silent
    };
  };
  getFilteredAxes(axes).some(function (axis) {
    var translator = axis.getTranslator();
    var scale = translator.getMinScale(zoom);
    var _axisZoom = axisZoom(axis, onlyAxisToNotify, getRange(_extends({
        scale,
        translator,
        axis
      }, params)), getParameters, 'zoom', scale, e),
      stopInteraction = _axisZoom.stopInteraction,
      result = _axisZoom.result;
    zoomStarted = !stopInteraction;
    return onlyAxisToNotify && result.isPrevented;
  });
  return zoomStarted;
}
function cancelEvent(e) {
  if (e.originalEvent) {
    cancelEvent(e.originalEvent);
  }
  if (e.cancelable !== false) {
    e.cancel = true;
  }
}
var _default = {
  name: 'zoom_and_pan',
  init: function init() {
    var chart = this;
    var renderer = this._renderer;
    function getAxesCopy(zoomAndPan, actionField) {
      var axes = [];
      var options = zoomAndPan.options;
      var actionData = zoomAndPan.actionData;
      if (options.argumentAxis[actionField]) {
        axes.push(chart.getArgumentAxis());
      }
      if (options.valueAxis[actionField]) {
        axes = axes.concat(actionData.valueAxes);
      }
      return axes;
    }
    function startAxesViewportChanging(zoomAndPan, actionField, e) {
      var axes = getAxesCopy(zoomAndPan, actionField);
      getFilteredAxes(axes).some(function (axis) {
        return axis.handleZooming(null, {
          end: true
        }, e, actionField).isPrevented;
      }) && cancelEvent(e);
    }
    function axesViewportChanging(zoomAndPan, actionField, e, offsetCalc, centerCalc) {
      function zoomAxes(axes, criteria, coordField, e, actionData) {
        var zoom = {
          zoomed: false
        };
        criteria && getFilteredAxes(axes).forEach(function (axis) {
          var options = axis.getOptions();
          var viewport = axis.visualRange();
          var scale = axis.getTranslator().getEventScale(e);
          var translate = -offsetCalc(e, actionData, coordField, scale);
          zoom = (0, _extend.extend)(true, zoom, axis.getTranslator().zoom(translate, scale, axis.getZoomBounds()));
          var range = axis.adjustRange((0, _utils.getVizRangeObject)([zoom.min, zoom.max]));
          var _axis$checkZoomingLow2 = axis.checkZoomingLowerLimitOvercome(actionField, scale, range),
            stopInteraction = _axis$checkZoomingLow2.stopInteraction,
            correctedRange = _axis$checkZoomingLow2.correctedRange;
          if (!(0, _type.isDefined)(viewport) || viewport.startValue.valueOf() !== correctedRange.startValue.valueOf() || viewport.endValue.valueOf() !== correctedRange.endValue.valueOf()) {
            axis.handleZooming(stopInteraction ? null : correctedRange, {
              start: true,
              end: true
            }, e, actionField);
            if (!stopInteraction) {
              zoom.zoomed = true;
              zoom.deltaTranslate = translate - zoom.translate;
            }
          } else if (e.pointerType === 'touch' && options.type === 'discrete') {
            var isMinPosition = axis.isExtremePosition(false);
            var isMaxPosition = axis.isExtremePosition(true);
            var zoomInEnabled = scale > 1 && !stopInteraction;
            var zoomOutEnabled = scale < 1 && (!isMinPosition || !isMaxPosition);
            var panningEnabled = scale === 1 && !(isMinPosition && (translate < 0 && !options.inverted || translate > 0 && options.inverted) || isMaxPosition && (translate > 0 && !options.inverted || translate < 0 && options.inverted));
            zoom.enabled = zoomInEnabled || zoomOutEnabled || panningEnabled;
          }
        });
        return zoom;
      }
      function storeOffset(e, actionData, zoom, coordField) {
        if (zoom.zoomed) {
          actionData.offset[coordField] = (e.offset ? e.offset[coordField] : actionData.offset[coordField]) + zoom.deltaTranslate;
        }
      }
      function storeCenter(center, actionData, zoom, coordField) {
        if (zoom.zoomed) {
          actionData.center[coordField] = center[coordField] + zoom.deltaTranslate;
        }
      }
      var rotated = chart.option('rotated');
      var actionData = zoomAndPan.actionData;
      var options = zoomAndPan.options;
      var argZoom = {};
      var valZoom = {};
      if (!actionData.fallback) {
        argZoom = zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? 'y' : 'x', e, actionData);
        valZoom = zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? 'x' : 'y', e, actionData);
        chart._requestChange(['VISUAL_RANGE']);
        storeOffset(e, actionData, argZoom, rotated ? 'y' : 'x');
        storeOffset(e, actionData, valZoom, rotated ? 'x' : 'y');
      }
      var center = centerCalc(e);
      storeCenter(center, actionData, argZoom, rotated ? 'y' : 'x');
      storeCenter(center, actionData, valZoom, rotated ? 'x' : 'y');
      if (!argZoom.zoomed && !valZoom.zoomed) {
        actionData.center = center;
      }
      return argZoom.zoomed || valZoom.zoomed || actionData.fallback || argZoom.enabled || valZoom.enabled;
    }
    function finishAxesViewportChanging(zoomAndPan, actionField, e, offsetCalc) {
      function zoomAxes(axes, coordField, actionData, onlyAxisToNotify) {
        var zoomStarted = false;
        var scale = e.scale || 1;
        var getRange = function getRange(axis) {
          var zoom = axis.getTranslator().zoom(-offsetCalc(e, actionData, coordField, scale), scale, axis.getZoomBounds());
          return {
            startValue: zoom.min,
            endValue: zoom.max
          };
        };
        var getParameters = function getParameters(silent) {
          return {
            start: true,
            end: silent
          };
        };
        getFilteredAxes(axes).forEach(function (axis) {
          zoomStarted = !axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e).stopInteraction;
        });
        return zoomStarted;
      }
      var rotated = chart.option('rotated');
      var actionData = zoomAndPan.actionData;
      var options = zoomAndPan.options;
      var zoomStarted = true;
      if (actionData.fallback) {
        zoomStarted &= options.argumentAxis[actionField] && zoomAxes(chart._argumentAxes, rotated ? 'y' : 'x', actionData, chart.getArgumentAxis());
        zoomStarted |= options.valueAxis[actionField] && zoomAxes(actionData.valueAxes, rotated ? 'x' : 'y', actionData);
      } else {
        var axes = getAxesCopy(zoomAndPan, actionField);
        getFilteredAxes(axes).forEach(function (axis) {
          axis.handleZooming(null, {
            start: true
          }, e, actionField);
        });
        zoomStarted = axes.length;
      }
      zoomStarted && chart._requestChange(['VISUAL_RANGE']);
    }
    function prepareActionData(coords, action) {
      var axes = chart._argumentAxes.filter(function (axis) {
        return checkCoords(canvasToRect(axis.getCanvas()), coords);
      });
      return {
        fallback: chart._lastRenderingTime > GESTURE_TIMEOUT,
        cancel: !axes.length || !(0, _type.isDefined)(action),
        action: action,
        curAxisRect: axes.length && canvasToRect(axes[0].getCanvas()),
        valueAxes: axes.length && chart._valueAxes.filter(function (axis) {
          return checkCoords(canvasToRect(axis.getCanvas()), coords);
        }),
        offset: {
          x: 0,
          y: 0
        },
        center: coords,
        startCenter: coords
      };
    }
    function getPointerCoord(rect, e) {
      var rootOffset = renderer.getRootOffset();
      return {
        x: _min(_max(e.pageX - rootOffset.left, rect.x), rect.width + rect.x),
        y: _min(_max(e.pageY - rootOffset.top, rect.y), rect.height + rect.y)
      };
    }
    function calcCenterForPinch(e) {
      var rootOffset = renderer.getRootOffset();
      var x1 = e.pointers[0].pageX;
      var x2 = e.pointers[1].pageX;
      var y1 = e.pointers[0].pageY;
      var y2 = e.pointers[1].pageY;
      return {
        x: _min(x1, x2) + _abs(x2 - x1) / 2 - rootOffset.left,
        y: _min(y1, y2) + _abs(y2 - y1) / 2 - rootOffset.top
      };
    }
    function calcCenterForDrag(e) {
      var rootOffset = renderer.getRootOffset();
      return {
        x: e.pageX - rootOffset.left,
        y: e.pageY - rootOffset.top
      };
    }
    function calcOffsetForDrag(e, actionData, coordField) {
      return e.offset[coordField] - actionData.offset[coordField];
    }
    function preventDefaults(e) {
      if (e.cancelable !== false) {
        e.preventDefault();
        e.stopPropagation();
      }
      chart._stopCurrentHandling();
    }
    var zoomAndPan = {
      dragStartHandler: function dragStartHandler(e) {
        var options = zoomAndPan.options;
        var isTouch = e.pointerType === 'touch';
        var wantPan = options.argumentAxis.pan || options.valueAxis.pan;
        var wantZoom = options.argumentAxis.zoom || options.valueAxis.zoom;
        var panKeyPressed = (0, _type.isDefined)(options.panKey) && e[(0, _utils.normalizeEnum)(options.panKey) + 'Key'];
        var dragToZoom = options.dragToZoom;
        var action;
        e._cancelPreventDefault = true;
        if (isTouch) {
          if (options.allowTouchGestures && wantPan) {
            var cancelPanning = !zoomAndPan.panningVisualRangeEnabled() || zoomAndPan.skipEvent;
            action = cancelPanning ? null : 'pan';
          }
        } else {
          if (dragToZoom && wantPan && panKeyPressed || !dragToZoom && wantPan) {
            action = 'pan';
          } else if (dragToZoom && wantZoom) {
            action = 'zoom';
          }
        }
        var actionData = prepareActionData(calcCenterForDrag(e), action);
        if (actionData.cancel) {
          zoomAndPan.skipEvent = false;
          if (e.cancelable !== false) {
            e.cancel = true;
          }
          return;
        }
        zoomAndPan.actionData = actionData;
        if (action === 'zoom') {
          actionData.startCoords = getPointerCoord(actionData.curAxisRect, e);
          actionData.rect = renderer.rect(0, 0, 0, 0).attr(options.dragBoxStyle).append(renderer.root);
        } else {
          startAxesViewportChanging(zoomAndPan, 'pan', e);
        }
      },
      dragHandler: function dragHandler(e) {
        var rotated = chart.option('rotated');
        var options = zoomAndPan.options;
        var actionData = zoomAndPan.actionData;
        var isTouch = e.pointerType === 'touch';
        e._cancelPreventDefault = true;
        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled()) {
          return;
        }
        if (actionData.action === 'zoom') {
          preventDefaults(e);
          var curCanvas = actionData.curAxisRect;
          var startCoords = actionData.startCoords;
          var curCoords = getPointerCoord(curCanvas, e);
          var zoomArg = options.argumentAxis.zoom;
          var zoomVal = options.valueAxis.zoom;
          var rect = {
            x: _min(startCoords.x, curCoords.x),
            y: _min(startCoords.y, curCoords.y),
            width: _abs(startCoords.x - curCoords.x),
            height: _abs(startCoords.y - curCoords.y)
          };
          if (!zoomArg || !zoomVal) {
            if (!zoomArg && !rotated || !zoomVal && rotated) {
              rect.x = curCanvas.x;
              rect.width = curCanvas.width;
            } else {
              rect.y = curCanvas.y;
              rect.height = curCanvas.height;
            }
          }
          actionData.rect.attr(rect);
        } else if (actionData.action === 'pan') {
          axesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag, function (e) {
            return e.offset;
          });
          var deltaOffsetY = Math.abs(e.offset.y - actionData.offset.y);
          var deltaOffsetX = Math.abs(e.offset.x - actionData.offset.x);
          if (isTouch && (deltaOffsetY > MIN_DRAG_DELTA && deltaOffsetY > Math.abs(actionData.offset.x) || deltaOffsetX > MIN_DRAG_DELTA && deltaOffsetX > Math.abs(actionData.offset.y))) {
            return;
          }
          preventDefaults(e);
        }
      },
      dragEndHandler: function dragEndHandler(e) {
        var rotated = chart.option('rotated');
        var options = zoomAndPan.options;
        var actionData = zoomAndPan.actionData;
        var isTouch = e.pointerType === 'touch';
        var getRange = function getRange(_ref) {
          var translator = _ref.translator,
            startCoord = _ref.startCoord,
            curCoord = _ref.curCoord;
          return function () {
            return [translator.from(startCoord), translator.from(curCoord)];
          };
        };
        var getCoords = function getCoords(curCoords, startCoords, field) {
          return {
            curCoord: curCoords[field],
            startCoord: startCoords[field]
          };
        };
        var needToZoom = function needToZoom(axisOption, coords) {
          return axisOption.zoom && _abs(coords.curCoord - coords.startCoord) > MIN_DRAG_DELTA;
        };
        var panIsEmpty = actionData && actionData.action === 'pan' && !actionData.fallback && actionData.offset.x === 0 && actionData.offset.y === 0;
        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled() || panIsEmpty) {
          return;
        }
        !isTouch && preventDefaults(e);
        if (actionData.action === 'zoom') {
          var curCoords = getPointerCoord(actionData.curAxisRect, e);
          var argumentCoords = getCoords(curCoords, actionData.startCoords, rotated ? 'y' : 'x');
          var valueCoords = getCoords(curCoords, actionData.startCoords, rotated ? 'x' : 'y');
          var argumentAxesZoomed = needToZoom(options.argumentAxis, argumentCoords) && zoomAxes(e, chart._argumentAxes, getRange, true, argumentCoords, chart.getArgumentAxis());
          var valueAxesZoomed = needToZoom(options.valueAxis, valueCoords) && zoomAxes(e, actionData.valueAxes, getRange, true, valueCoords);
          if (valueAxesZoomed || argumentAxesZoomed) {
            chart._requestChange(['VISUAL_RANGE']);
          }
          actionData.rect.dispose();
        } else if (actionData.action === 'pan') {
          finishAxesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag);
        }
        zoomAndPan.actionData = null;
      },
      pinchStartHandler: function pinchStartHandler(e) {
        var actionData = prepareActionData(calcCenterForPinch(e), 'zoom');
        if (actionData.cancel) {
          cancelEvent(e);
          return;
        }
        zoomAndPan.actionData = actionData;
        startAxesViewportChanging(zoomAndPan, 'zoom', e);
      },
      pinchHandler: function pinchHandler(e) {
        if (!zoomAndPan.actionData) {
          return;
        }
        axesViewportChanging(zoomAndPan, 'zoom', e, function (e, actionData, coordField, scale) {
          return calcCenterForPinch(e)[coordField] - actionData.center[coordField] + (actionData.center[coordField] - actionData.center[coordField] * scale);
        }, calcCenterForPinch);
        preventDefaults(e);
      },
      pinchEndHandler: function pinchEndHandler(e) {
        if (!zoomAndPan.actionData) {
          return;
        }
        finishAxesViewportChanging(zoomAndPan, 'zoom', e, function (e, actionData, coordField, scale) {
          return actionData.center[coordField] - actionData.startCenter[coordField] + (actionData.startCenter[coordField] - actionData.startCenter[coordField] * scale);
        });
        zoomAndPan.actionData = null;
      },
      mouseWheelHandler: function mouseWheelHandler(e) {
        var options = zoomAndPan.options;
        var rotated = chart.option('rotated');
        var getRange = function getRange(_ref2) {
          var translator = _ref2.translator,
            coord = _ref2.coord,
            scale = _ref2.scale,
            axis = _ref2.axis;
          return function () {
            var zoom = translator.zoom(-(coord - coord * scale), scale, axis.getZoomBounds());
            return {
              startValue: zoom.min,
              endValue: zoom.max
            };
          };
        };
        var coords = calcCenterForDrag(e);
        var axesZoomed = false;
        var targetAxes;
        if (options.valueAxis.zoom) {
          targetAxes = chart._valueAxes.filter(function (axis) {
            return checkCoords(canvasToRect(axis.getCanvas()), coords);
          });
          if (targetAxes.length === 0) {
            var targetCanvas = chart._valueAxes.reduce(function (r, axis) {
              if (!r && axis.coordsIn(coords.x, coords.y)) {
                r = axis.getCanvas();
              }
              return r;
            }, null);
            if (targetCanvas) {
              targetAxes = chart._valueAxes.filter(function (axis) {
                return checkCoords(canvasToRect(axis.getCanvas()), {
                  x: targetCanvas.left,
                  y: targetCanvas.top
                });
              });
            }
          }
          axesZoomed |= zoomAxes(e, targetAxes, getRange, e.delta > 0, {
            coord: rotated ? coords.x : coords.y
          });
        }
        if (options.argumentAxis.zoom) {
          var canZoom = chart._argumentAxes.some(function (axis) {
            if (checkCoords(canvasToRect(axis.getCanvas()), coords) || axis.coordsIn(coords.x, coords.y)) {
              return true;
            }
            return false;
          });
          axesZoomed |= canZoom && zoomAxes(e, chart._argumentAxes, getRange, e.delta > 0, {
            coord: rotated ? coords.y : coords.x
          }, chart.getArgumentAxis());
        }
        if (axesZoomed) {
          chart._requestChange(['VISUAL_RANGE']);
          if (targetAxes && isAxisAvailablePanning(targetAxes) || !targetAxes && zoomAndPan.panningVisualRangeEnabled()) {
            preventDefaults(e); // T249548
          }
        }
      },

      cleanup: function cleanup() {
        renderer.root.off(EVENTS_NS);
        zoomAndPan.actionData && zoomAndPan.actionData.rect && zoomAndPan.actionData.rect.dispose();
        zoomAndPan.actionData = null;
        renderer.root.css({
          'touch-action': '',
          '-ms-touch-action': ''
        });
      },
      setup: function setup(options) {
        zoomAndPan.cleanup();
        if (!options.argumentAxis.pan) {
          renderer.root.on(SCROLL_BAR_START_EVENT_NAME, cancelEvent);
        }
        if (options.argumentAxis.none && options.valueAxis.none) {
          return;
        }
        zoomAndPan.options = options;
        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowMouseWheel) {
          renderer.root.on(_wheel.name + EVENTS_NS, zoomAndPan.mouseWheelHandler);
        }
        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowTouchGestures) {
          renderer.root.on(PINCH_START_EVENT_NAME, {
            passive: false
          }, zoomAndPan.pinchStartHandler).on(PINCH_EVENT_NAME, {
            passive: false
          }, zoomAndPan.pinchHandler).on(PINCH_END_EVENT_NAME, zoomAndPan.pinchEndHandler);
        }
        renderer.root.on(DRAG_START_EVENT_NAME, {
          immediate: true,
          passive: false
        }, zoomAndPan.dragStartHandler).on(DRAG_EVENT_NAME, {
          immediate: true,
          passive: false
        }, zoomAndPan.dragHandler).on(DRAG_END_EVENT_NAME, zoomAndPan.dragEndHandler);
        renderer.root.on(SCROLL_BAR_START_EVENT_NAME, function (e) {
          zoomAndPan.actionData = {
            valueAxes: [],
            offset: {
              x: 0,
              y: 0
            },
            center: {
              x: 0,
              y: 0
            }
          };
          preventDefaults(e);
          startAxesViewportChanging(zoomAndPan, 'pan', e);
        }).on(SCROLL_BAR_MOVE_EVENT_NAME, function (e) {
          preventDefaults(e);
          axesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag, function (e) {
            return e.offset;
          });
        }).on(SCROLL_BAR_END_EVENT_NAME, function (e) {
          preventDefaults(e);
          finishAxesViewportChanging(zoomAndPan, 'pan', e, calcOffsetForDrag);
          zoomAndPan.actionData = null;
        });
      },
      panningVisualRangeEnabled: function panningVisualRangeEnabled() {
        return isAxisAvailablePanning(chart._valueAxes) || isAxisAvailablePanning(chart._argumentAxes);
      }
    };
    this._zoomAndPan = zoomAndPan;
  },
  members: {
    _setupZoomAndPan: function _setupZoomAndPan() {
      this._zoomAndPan.setup(this._themeManager.getOptions('zoomAndPan'));
    }
  },
  dispose: function dispose() {
    this._zoomAndPan.cleanup();
  },
  customize: function customize(constructor) {
    constructor.addChange({
      code: 'ZOOM_AND_PAN',
      handler: function handler() {
        this._setupZoomAndPan();
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'zoomAndPan'
    });
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 39847:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _circular_gauge = _interopRequireDefault(__webpack_require__(31500));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _circular_gauge.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99327:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ThemeManager = void 0;
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _base_theme_manager = __webpack_require__(43637);
var _utils = __webpack_require__(19157);
var ThemeManager = _base_theme_manager.BaseThemeManager.inherit(function () {
  var ctor = function ctor(params) {
    var that = this;
    that.callBase.apply(that, arguments);
    var options = params.options || {};
    that._userOptions = options;
    that._mergeAxisTitleOptions = [];
    that._multiPieColors = {};

    // This is required because chart calls "_getOption" during "_init" stage
    // TODO: Remove it when chart stops doing that
    that._callback = _common.noop;
  };
  var dispose = function dispose() {
    var that = this;
    that.palette && that.palette.dispose();
    that.palette = that._userOptions = that._mergedSettings = that._multiPieColors = null;
    return that.callBase.apply(that, arguments);
  };
  var resetPalette = function resetPalette() {
    this.palette.reset();
    this._multiPieColors = {};
  };
  var processTitleOptions = function processTitleOptions(options) {
    return (0, _type.isString)(options) ? {
      text: options
    } : options;
  };
  var processAxisOptions = function processAxisOptions(axisOptions) {
    if (!axisOptions) {
      return {};
    }
    axisOptions = (0, _extend.extend)(true, {}, axisOptions);
    axisOptions.title = processTitleOptions(axisOptions.title);
    if (axisOptions.type === 'logarithmic' && axisOptions.logarithmBase <= 0 || axisOptions.logarithmBase && !(0, _type.isNumeric)(axisOptions.logarithmBase)) {
      axisOptions.logarithmBase = undefined;
      axisOptions.logarithmBaseError = true;
    }
    if (axisOptions.label) {
      if (axisOptions.label.alignment) {
        axisOptions.label['userAlignment'] = true;
      }
    }
    return axisOptions;
  };
  var applyParticularAxisOptions = function applyParticularAxisOptions(name, userOptions, rotated) {
    var theme = this._theme;
    var position = !(rotated ^ name === 'valueAxis') ? 'horizontalAxis' : 'verticalAxis';
    var processedUserOptions = processAxisOptions(userOptions);
    var commonAxisSettings = processAxisOptions(this._userOptions['commonAxisSettings']);
    var mergeOptions = (0, _extend.extend)(true, {}, theme.commonAxisSettings, theme[position], theme[name], commonAxisSettings, processedUserOptions);
    mergeOptions.workWeek = processedUserOptions.workWeek || theme[name].workWeek;
    mergeOptions.forceUserTickInterval |= (0, _type.isDefined)(processedUserOptions.tickInterval) && !(0, _type.isDefined)(processedUserOptions.axisDivisionFactor);
    return mergeOptions;
  };
  var mergeOptions = function mergeOptions(name, userOptions) {
    userOptions = userOptions || this._userOptions[name];
    var theme = this._theme[name];
    var result = this._mergedSettings[name];
    if (result) {
      return result;
    }
    if ((0, _type.isPlainObject)(theme) && (0, _type.isPlainObject)(userOptions)) {
      result = (0, _extend.extend)(true, {}, theme, userOptions);
    } else {
      result = (0, _type.isDefined)(userOptions) ? userOptions : theme;
    }
    this._mergedSettings[name] = result;
    return result;
  };
  var applyParticularTheme = {
    base: mergeOptions,
    argumentAxis: applyParticularAxisOptions,
    valueAxisRangeSelector: function valueAxisRangeSelector() {
      return mergeOptions.call(this, 'valueAxis');
    },
    valueAxis: applyParticularAxisOptions,
    series: function series(name, userOptions, seriesCount) {
      var that = this;
      var theme = that._theme;
      var userCommonSettings = that._userOptions.commonSeriesSettings || {};
      var themeCommonSettings = theme.commonSeriesSettings;
      var widgetType = that._themeSection.split('.').slice(-1)[0];
      var type = (0, _utils.normalizeEnum)(userOptions.type || userCommonSettings.type || themeCommonSettings.type || widgetType === 'pie' && theme.type); // userCommonSettings.type && themeCommonSettings.type deprecated in 15.2 in pie
      var palette = that.palette;
      var isBar = ~type.indexOf('bar');
      var isLine = ~type.indexOf('line');
      var isArea = ~type.indexOf('area');
      var isBubble = type === 'bubble';
      var mainSeriesColor;
      var resolveLabelsOverlapping = that.getOptions('resolveLabelsOverlapping');
      var containerBackgroundColor = that.getOptions('containerBackgroundColor');
      var seriesTemplate = applyParticularTheme.seriesTemplate.call(this);
      var seriesVisibility;
      if (isBar || isBubble) {
        userOptions = (0, _extend.extend)(true, {}, userCommonSettings, userCommonSettings[type], userOptions);
        seriesVisibility = userOptions.visible;
        userCommonSettings = {
          type: {}
        };
        (0, _extend.extend)(true, userOptions, userOptions.point);
        userOptions.visible = seriesVisibility;
      }
      var settings = (0, _extend.extend)(true, {
        aggregation: {}
      }, themeCommonSettings, themeCommonSettings[type], userCommonSettings, userCommonSettings[type], userOptions);
      settings.aggregation.enabled = widgetType === 'chart' && !!settings.aggregation.enabled;
      settings.type = type;
      settings.widgetType = widgetType;
      settings.containerBackgroundColor = containerBackgroundColor;
      if (widgetType !== 'pie') {
        mainSeriesColor = (0, _utils.extractColor)(settings.color, true) || palette.getNextColor(seriesCount);
      } else {
        mainSeriesColor = function mainSeriesColor(argument, index, count) {
          var cat = "".concat(argument, "-").concat(index);
          if (!that._multiPieColors[cat]) {
            that._multiPieColors[cat] = palette.getNextColor(count);
          }
          return that._multiPieColors[cat];
        };
      }
      settings.mainSeriesColor = mainSeriesColor;
      settings.resolveLabelsOverlapping = resolveLabelsOverlapping;
      if (settings.label && (isLine || isArea && type !== 'rangearea' || type === 'scatter')) {
        settings.label.position = 'outside';
      }
      if (seriesTemplate) {
        settings.nameField = seriesTemplate.nameField;
      }
      return settings;
    },
    animation: function animation(name) {
      var userOptions = this._userOptions[name];
      userOptions = (0, _type.isPlainObject)(userOptions) ? userOptions : (0, _type.isDefined)(userOptions) ? {
        enabled: !!userOptions
      } : {};
      return mergeOptions.call(this, name, userOptions);
    },
    seriesTemplate() {
      var value = mergeOptions.call(this, 'seriesTemplate');
      if (value) {
        value.nameField = value.nameField || 'series';
      }
      return value;
    },
    zoomAndPan() {
      function parseOption(option) {
        option = (0, _utils.normalizeEnum)(option);
        var pan = option === 'pan' || option === 'both';
        var zoom = option === 'zoom' || option === 'both';
        return {
          pan: pan,
          zoom: zoom,
          none: !pan && !zoom
        };
      }
      var options = mergeOptions.call(this, 'zoomAndPan');
      return {
        valueAxis: parseOption(options.valueAxis),
        argumentAxis: parseOption(options.argumentAxis),
        dragToZoom: !!options.dragToZoom,
        dragBoxStyle: {
          class: 'dxc-shutter',
          fill: options.dragBoxStyle.color,
          opacity: options.dragBoxStyle.opacity
        },
        panKey: options.panKey,
        allowMouseWheel: !!options.allowMouseWheel,
        allowTouchGestures: !!options.allowTouchGestures
      };
    }
  };
  return {
    _themeSection: 'chart',
    ctor: ctor,
    dispose: dispose,
    resetPalette: resetPalette,
    getOptions: function getOptions(name) {
      return (applyParticularTheme[name] || applyParticularTheme.base).apply(this, arguments);
    },
    refresh: function refresh() {
      this._mergedSettings = {};
      return this.callBase.apply(this, arguments);
    },
    _initializeTheme: function _initializeTheme() {
      var that = this;
      that.callBase.apply(that, arguments);
      that.updatePalette();
    },
    resetOptions: function resetOptions(name) {
      this._mergedSettings[name] = null;
    },
    update: function update(options) {
      this._userOptions = options;
    },
    updatePalette: function updatePalette() {
      var that = this;
      that.palette = that.createPalette(that.getOptions('palette'), {
        useHighlight: true,
        extensionMode: that.getOptions('paletteExtensionMode')
      });
    }
  };
}());
exports.ThemeManager = ThemeManager;

/***/ }),

/***/ 32410:
/***/ (function(module, exports) {



exports["default"] = void 0;
var _default = {
  events: {
    'mouseover': 'mouseover',
    'mouseout': 'mouseout',
    'mousemove': 'mousemove',
    'touchstart': 'touchstart',
    'touchmove': 'touchmove',
    'touchend': 'touchend',
    'mousedown': 'mousedown',
    'mouseup': 'mouseup',
    click: 'click',
    selectSeries: 'selectseries',
    deselectSeries: 'deselectseries',
    selectPoint: 'selectpoint',
    deselectPoint: 'deselectpoint',
    showPointTooltip: 'showpointtooltip',
    hidePointTooltip: 'hidepointtooltip'
  },
  states: {
    hover: 'hover',
    normal: 'normal',
    selection: 'selection',
    normalMark: 0,
    hoverMark: 1,
    selectedMark: 2,
    applyHover: 'applyHover',
    applySelected: 'applySelected',
    resetItem: 'resetItem'
  },
  radialLabelIndent: 30,
  pieLabelSpacing: 10,
  pieSeriesSpacing: 4
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 45865:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.validateData = validateData;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _parse_utils = __webpack_require__(8587);
var STRING = 'string';
var NUMERIC = 'numeric';
var DATETIME = 'datetime';
var DISCRETE = 'discrete';
var SEMIDISCRETE = 'semidiscrete';
var CONTINUOUS = 'continuous';
var LOGARITHMIC = 'logarithmic';
var VALUE_TYPE = 'valueType';
var ARGUMENT_TYPE = 'argumentType';
var axisTypeParser = (0, _utils.enumParser)([STRING, NUMERIC, DATETIME]);
var _isArray = Array.isArray;
function groupingValues(data, others, valueField, index) {
  if (index >= 0) {
    data.slice(index).forEach(function (cell) {
      if ((0, _type.isDefined)(cell[valueField])) {
        others[valueField] += cell[valueField];
        cell[valueField] = undefined;
      }
    });
  }
}
function processGroups(groups) {
  groups.forEach(function (group) {
    group.valueType = group.valueAxisType = null;
    group.series.forEach(function (series) {
      series.updateDataType({});
    });
    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);
  });
}
function sortValues(data, asc, selector) {
  var func = asc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  };
  data.sort(function (a, b) {
    var valA = selector(a);
    var valB = selector(b);
    var aa = (0, _type.isDefined)(valA) ? 1 : 0;
    var bb = (0, _type.isDefined)(valB) ? 1 : 0;
    return aa && bb ? func(valA, valB) : func(aa, bb);
  });
  return data;
}
function resetArgumentAxes(axes) {
  axes && axes.forEach(function (axis) {
    axis.resetTypes(ARGUMENT_TYPE);
  });
}
function parseCategories(categories, parser) {
  var newArray = [];
  categories.forEach(function (category) {
    var parsedCategory = parser(category);
    parsedCategory !== undefined && newArray.push(parsedCategory);
  });
  return newArray;
}
function parseAxisCategories(groupsData, parsers) {
  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;
  groupsData.groups.forEach(function (valueGroup, i) {
    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;
    if (categories) {
      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);
    }
  });
  if (argumentCategories) {
    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);
  }
}
function eigen(x) {
  return x;
}
function getType(unit, type) {
  var result = type;
  if (type === STRING || (0, _type.isString)(unit)) {
    result = STRING;
  } else if (type === DATETIME || (0, _type.isDate)(unit)) {
    result = DATETIME;
  } else if ((0, _type.isNumeric)(unit)) {
    result = NUMERIC;
  }
  return result;
}
function correctAxisType(type, axisType, hasCategories, incidentOccurred) {
  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {
    incidentOccurred('E2002');
  }
  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;
}

// Do we really need this one if all it is only for logarithmic case?
function validUnit(unit, field, incidentOccurred) {
  if (unit) {
    incidentOccurred(!(0, _type.isNumeric)(unit) && !(0, _type.isDate)(unit) && !(0, _type.isString)(unit) ? 'E2003' : 'E2004', [field]);
  }
}
function createParserUnit(type, axisType, incidentOccurred) {
  var parser = type ? (0, _parse_utils.getParser)(type) : eigen;
  var filterInfinity = axisType !== DISCRETE ? function (x) {
    return isFinite(x) || x === undefined ? x : null;
  } : eigen;
  return function (unit, field) {
    var parseUnit = filterInfinity(parser(unit));
    if (parseUnit === undefined) {
      validUnit(unit, field, incidentOccurred);
    }
    return parseUnit;
  };
}
function prepareParsers(groupsData, incidentOccurred) {
  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);
  var sizeParser;
  var valueParser;
  var categoryParsers = [argumentParser];
  var cache = {};
  var list = [];
  groupsData.groups.forEach(function (group, groupIndex) {
    group.series.forEach(function (series) {
      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);
      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);
      cache[series.getArgumentField()] = argumentParser;
      series.getValueFields().forEach(function (field) {
        categoryParsers[groupIndex + 1] = valueParser;
        cache[field] = valueParser;
      });
      if (series.getSizeField()) {
        cache[series.getSizeField()] = sizeParser;
      }
    });
  });
  for (var field in cache) {
    list.push([field, cache[field]]);
  }
  list.length && parseAxisCategories(groupsData, categoryParsers);
  return list;
}
function getParsedCell(cell, parsers) {
  var i;
  var ii = parsers.length;
  var obj = (0, _extend.extend)({}, cell);
  var field;
  var value;
  for (i = 0; i < ii; ++i) {
    field = parsers[i][0];
    value = cell[field];
    obj[field] = parsers[i][1](value, field);
  }
  return obj;
}
function parse(data, parsers) {
  var parsedData = [];
  var i;
  var ii = data.length;
  parsedData.length = ii;
  for (i = 0; i < ii; ++i) {
    parsedData[i] = getParsedCell(data[i], parsers);
  }
  return parsedData;
}
function findIndexByThreshold(data, valueField, threshold) {
  var i;
  var ii = data.length;
  var value;
  for (i = 0; i < ii; ++i) {
    value = data[i][valueField];
    if ((0, _type.isDefined)(value) && threshold > value) {
      break;
    }
  }
  return i;
}
function groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {
  smallValuesGrouping = smallValuesGrouping || {};
  var mode = smallValuesGrouping.mode;
  var others = {};
  if (!mode || mode === 'none') {
    return;
  }
  others[argumentField] = String(smallValuesGrouping.groupName || 'others');
  others[valueField] = 0;
  var data = sortValues(originalData.slice(), false, function (a) {
    return a[valueField];
  });
  groupingValues(data, others, valueField, mode === 'smallValueThreshold' ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);
  others[valueField] && originalData.push(others);
}
function groupPieData(data, groupsData) {
  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];
  var isPie = firstSeries && (firstSeries.type === 'pie' || firstSeries.type === 'doughnut' || firstSeries.type === 'donut');
  if (!isPie) {
    return;
  }
  groupsData.groups.forEach(function (group) {
    group.series.forEach(function (series) {
      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);
    });
  });
}
function addUniqueItemToCollection(item, collection, itemsHash) {
  if (!itemsHash[item]) {
    collection.push(item);
    itemsHash[item] = true;
  }
}
function getUniqueArgumentFields(groupsData) {
  var uniqueArgumentFields = [];
  var hash = {};
  groupsData.groups.forEach(function (group) {
    group.series.forEach(function (series) {
      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);
    });
  });
  return uniqueArgumentFields;
}
function sort(a, b) {
  var result = a - b;
  if (isNaN(result)) {
    if (!(0, _type.isDefined)(a)) {
      return 1;
    }
    if (!(0, _type.isDefined)(b)) {
      return -1;
    }
    return 0;
  }
  return result;
}
function sortByArgument(data, argumentField) {
  return data.slice().sort(function (a, b) {
    return sort(a[argumentField], b[argumentField]);
  });
}
function sortByCallback(data, callback) {
  return data.slice().sort(callback);
}
function checkValueTypeOfGroup(group, cell) {
  group.series.forEach(function (series) {
    series.getValueFields().forEach(function (field) {
      group.valueType = getType(cell[field], group.valueType);
    });
  });
  return group.valueType;
}
function getSortByCategories(categories) {
  var hash = {};
  categories.forEach(function (value, i) {
    hash[value] = i;
  });
  return function (data, argumentField) {
    return sortValues(data.slice(), true, function (a) {
      return hash[a[argumentField]];
    });
  };
}
function sortData(data, groupsData, options, uniqueArgumentFields) {
  var dataByArguments = {};
  var isDiscrete = groupsData.argumentAxisType === DISCRETE;
  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;
  var sortFunction = function sortFunction(data) {
    return data;
  };
  var sortingMethodOption = options.sortingMethod;
  var reSortCategories;
  if (!userCategories && (0, _type.isFunction)(sortingMethodOption)) {
    data = sortByCallback(data, sortingMethodOption);
  }
  if (isDiscrete) {
    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);
  }
  if (userCategories || !(0, _type.isFunction)(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {
    sortFunction = getSortByCategories(groupsData.categories);
  } else if (sortingMethodOption === true && groupsData.argumentType !== STRING) {
    sortFunction = sortByArgument;
    reSortCategories = isDiscrete;
  }
  uniqueArgumentFields.forEach(function (field) {
    dataByArguments[field] = sortFunction(data, field);
  });
  if (reSortCategories) {
    groupsData.categories = groupsData.categories.sort(sort);
  }
  return dataByArguments;
}
function checkItemExistence(collection, item) {
  return collection.map(function (collectionItem) {
    return collectionItem.valueOf();
  }).indexOf(item.valueOf()) === -1;
}
function getCategories(data, uniqueArgumentFields, userCategories) {
  var categories = userCategories ? userCategories.slice() : [];
  uniqueArgumentFields.forEach(function (field) {
    data.forEach(function (item) {
      var dataItem = item[field];
      (0, _type.isDefined)(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);
    });
  });
  return categories;
}
function checkArgumentTypeOfGroup(series, cell, groupsData) {
  series.forEach(function (currentSeries) {
    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);
  });
  return groupsData.argumentType;
}
function checkType(data, groupsData, checkTypeForAllData) {
  var groupsWithUndefinedValueType = [];
  var groupsWithUndefinedArgumentType = [];
  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);
  var groupsIndexes;
  groupsData.groups.forEach(function (group) {
    if (!group.series.length) {
      return;
    }
    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);
    group.valueType = valueTypeGroup;
    groupsData.argumentType = argumentTypeGroup;
    !valueTypeGroup && groupsWithUndefinedValueType.push(group);
    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);
  });
  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {
    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {
      return index;
    });
    data.some(function (cell) {
      var defineArg;
      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {
        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {
          groupsIndexes.splice(groupIndex, 1);
        }
      });
      if (!defineArg) {
        groupsWithUndefinedArgumentType.forEach(function (group) {
          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);
        });
      }
      if (!checkTypeForAllData && defineArg && groupsIndexes.length === 0) {
        return true;
      }
    });
  }
}
function checkAxisType(groupsData, incidentOccurred) {
  var argumentOptions = groupsData.argumentOptions || {};
  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];
  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);
  groupsData.groups.forEach(function (group) {
    var valueOptions = group.valueOptions || {};
    var valueCategories = valueOptions.categories || [];
    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);
    group.series.forEach(function (series) {
      var optionsSeries = {};
      optionsSeries.argumentAxisType = argumentAxisType;
      optionsSeries.valueAxisType = valueAxisType;
      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;
      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;
      optionsSeries.argumentType = groupsData.argumentType;
      optionsSeries.valueType = group.valueType;
      optionsSeries.showZero = valueOptions.showZero;
      series.updateDataType(optionsSeries);
    });
    group.valueAxisType = group.valueAxisType || valueAxisType;
    if (group.valueAxis) {
      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);
      group.valueAxis.validate();
    }
  });
  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;
  if (groupsData.argumentAxes) {
    groupsData.argumentAxes.forEach(function (axis) {
      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);
      axis.validate();
    });
  }
}
function verifyData(source, incidentOccurred) {
  var data = [];
  var sourceIsDefined = (0, _type.isDefined)(source);
  var hasError = sourceIsDefined && !_isArray(source);
  var i;
  var ii;
  var k;
  var item;
  if (sourceIsDefined && !hasError) {
    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {
      item = source[i];
      if ((0, _type.isObject)(item)) {
        data[k++] = item;
      } else if (item) {
        // TODO: And what about `null`, `undefined` and `0`?
        hasError = true;
      }
    }
  }
  if (hasError) {
    incidentOccurred('E2001');
  }
  return data;
}
function validateData(data, groupsData, incidentOccurred, options) {
  data = verifyData(data, incidentOccurred);
  groupsData.argumentType = groupsData.argumentAxisType = null;
  processGroups(groupsData.groups);
  resetArgumentAxes(groupsData.argumentAxes);
  checkType(data, groupsData, options.checkTypeForAllData);
  checkAxisType(groupsData, incidentOccurred);
  if (options.convertToAxisDataType) {
    data = parse(data, prepareParsers(groupsData, incidentOccurred));
  }
  groupPieData(data, groupsData);
  var dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));
  return dataByArgumentFields;
}

/***/ }),

/***/ 16342:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.Legend = void 0;
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _layout_element = __webpack_require__(73711);
var _type = __webpack_require__(35922);
var _title = __webpack_require__(17384);
var _object = __webpack_require__(48013);
var _common = __webpack_require__(20576);
var _renderer = __webpack_require__(56453);
var _deferred = __webpack_require__(62754);
var _Number = Number;
var _math = Math;
var _round = _math.round;
var _max = _math.max;
var _min = _math.min;
var _ceil = _math.ceil;
var _isDefined = _type.isDefined;
var _isFunction = _type.isFunction;
var _enumParser = _utils.enumParser;
var _normalizeEnum = _utils.normalizeEnum;
var _extend = _extend2.extend;
var DEFAULT_MARGIN = 10;
var DEFAULT_MARKER_HATCHING_WIDTH = 2;
var DEFAULT_MARKER_HATCHING_STEP = 5;
var CENTER = 'center';
var RIGHT = 'right';
var LEFT = 'left';
var TOP = 'top';
var BOTTOM = 'bottom';
var HORIZONTAL = 'horizontal';
var VERTICAL = 'vertical';
var INSIDE = 'inside';
var OUTSIDE = 'outside';
var NONE = 'none';
var HEIGHT = 'height';
var WIDTH = 'width';
var parseHorizontalAlignment = _enumParser([LEFT, CENTER, RIGHT]);
var parseVerticalAlignment = _enumParser([TOP, BOTTOM]);
var parseOrientation = _enumParser([VERTICAL, HORIZONTAL]);
var parseItemTextPosition = _enumParser([LEFT, RIGHT, TOP, BOTTOM]);
var parsePosition = _enumParser([OUTSIDE, INSIDE]);
var parseItemsAlignment = _enumParser([LEFT, CENTER, RIGHT]);
function getState(state, color, stateName) {
  if (!state) {
    return;
  }
  var colorFromAction = state.fill;
  return (0, _extend2.extend)({}, {
    state: stateName,
    fill: colorFromAction === NONE ? color : colorFromAction,
    opacity: state.opacity,
    filter: state.filter,
    hatching: _extend({}, state.hatching, {
      step: DEFAULT_MARKER_HATCHING_STEP,
      width: DEFAULT_MARKER_HATCHING_WIDTH
    })
  });
}
function getAttributes(item, state, size) {
  var attrs = (0, _renderer.processHatchingAttrs)(item, state);
  if (attrs.fill && attrs.fill.indexOf('DevExpress') === 0) {
    attrs.fill = (0, _renderer.getFuncIri)(attrs.fill);
  }
  attrs.opacity = attrs.opacity >= 0 ? attrs.opacity : 1;
  return (0, _extend2.extend)({}, attrs, {
    size
  });
}
function parseMargins(options) {
  var margin = options.margin;
  if (margin >= 0) {
    margin = _Number(options.margin);
    margin = {
      top: margin,
      bottom: margin,
      left: margin,
      right: margin
    };
  } else {
    margin = {
      top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,
      bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,
      left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,
      right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN
    };
  }
  options.margin = margin;
}
function getSizeItem(options, markerBBox, labelBBox) {
  var defaultXMargin = 7;
  var defaultTopMargin = 4;
  var width;
  var height;
  switch (options.itemTextPosition) {
    case LEFT:
    case RIGHT:
      width = markerBBox.width + defaultXMargin + labelBBox.width;
      height = _max(markerBBox.height, labelBBox.height);
      break;
    case TOP:
    case BOTTOM:
      width = _max(markerBBox.width, labelBBox.width);
      height = markerBBox.height + defaultTopMargin + labelBBox.height;
      break;
  }
  return {
    width: width,
    height: height
  };
}
function calculateBBoxLabelAndMarker(markerBBox, labelBBox) {
  var bBox = {};
  bBox.left = _min(markerBBox.x, labelBBox.x);
  bBox.top = _min(markerBBox.y, labelBBox.y);
  bBox.right = _max(markerBBox.x + markerBBox.width, labelBBox.x + labelBBox.width);
  bBox.bottom = _max(markerBBox.y + markerBBox.height, labelBBox.y + labelBBox.height);
  return bBox;
}
function applyMarkerState(id, idToIndexMap, items, stateName) {
  var item = idToIndexMap && items[idToIndexMap[id]];
  if (item) {
    item.renderMarker(item.states[stateName]);
  }
}
function parseOptions(options, textField, allowInsidePosition) {
  if (!options) return null;
  parseMargins(options);
  options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, RIGHT);
  options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, options.horizontalAlignment === CENTER ? BOTTOM : TOP);
  options.orientation = parseOrientation(options.orientation, options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);
  options.itemTextPosition = parseItemTextPosition(options.itemTextPosition, options.orientation === HORIZONTAL ? BOTTOM : RIGHT);
  options.position = allowInsidePosition ? parsePosition(options.position, OUTSIDE) : OUTSIDE;
  options.itemsAlignment = parseItemsAlignment(options.itemsAlignment, null);
  options.hoverMode = _normalizeEnum(options.hoverMode);
  options.customizeText = _isFunction(options.customizeText) ? options.customizeText : function () {
    return this[textField];
  };
  options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : _common.noop;
  options._incidentOccurred = options._incidentOccurred || _common.noop;
  return options;
}
function createSquareMarker(renderer, size) {
  return renderer.rect(0, 0, size, size);
}
function createCircleMarker(renderer, size) {
  return renderer.circle(size / 2, size / 2, size / 2);
}
function isCircle(type) {
  return _normalizeEnum(type) === 'circle';
}
function inRect(rect, x, y) {
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}
function checkLinesSize(lines, layoutOptions, countItems, margins) {
  var position = {
    x: 0,
    y: 0
  };
  var maxMeasureLength = 0;
  var maxAltMeasureLength = 0;
  var margin = 0;
  if (layoutOptions.direction === 'y') {
    margin = margins.top + margins.bottom;
  } else {
    margin = margins.left + margins.right;
  }
  lines.forEach(function (line, i) {
    var firstItem = line[0];
    var lineLength = line.length;
    line.forEach(function (item, index) {
      var offset = item.offset || layoutOptions.spacing;
      position[layoutOptions.direction] += item[layoutOptions.measure] + (index !== lineLength - 1 ? offset : 0);
      maxMeasureLength = _max(maxMeasureLength, position[layoutOptions.direction]);
    });
    position[layoutOptions.direction] = 0;
    position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + firstItem.altOffset || layoutOptions.altSpacing;
    maxAltMeasureLength = _max(maxAltMeasureLength, position[layoutOptions.altDirection]);
  });
  if (maxMeasureLength + margin > layoutOptions.length) {
    layoutOptions.countItem = decreaseItemCount(layoutOptions, countItems);
    return true;
  }
}
function decreaseItemCount(layoutOptions, countItems) {
  layoutOptions.altCountItem++;
  return _ceil(countItems / layoutOptions.altCountItem);
}
function getLineLength(line, layoutOptions) {
  return line.reduce(function (lineLength, item) {
    var offset = item.offset || layoutOptions.spacing;
    return lineLength + item[layoutOptions.measure] + offset;
  }, 0);
}
function getMaxLineLength(lines, layoutOptions) {
  return lines.reduce(function (maxLineLength, line) {
    return _max(maxLineLength, getLineLength(line, layoutOptions));
  }, 0);
}
function getInitPositionForDirection(line, layoutOptions, maxLineLength) {
  var lineLength = getLineLength(line, layoutOptions);
  var initPosition;
  switch (layoutOptions.itemsAlignment) {
    case RIGHT:
      initPosition = maxLineLength - lineLength;
      break;
    case CENTER:
      initPosition = (maxLineLength - lineLength) / 2;
      break;
    default:
      initPosition = 0;
  }
  return initPosition;
}
function getPos(layoutOptions) {
  switch (layoutOptions.itemTextPosition) {
    case BOTTOM:
      return {
        horizontal: CENTER,
        vertical: TOP
      };
    case TOP:
      return {
        horizontal: CENTER,
        vertical: BOTTOM
      };
    case LEFT:
      return {
        horizontal: RIGHT,
        vertical: CENTER
      };
    case RIGHT:
      return {
        horizontal: LEFT,
        vertical: CENTER
      };
  }
}
function getLines(lines, layoutOptions, itemIndex) {
  var tableLine = {};
  if (itemIndex % layoutOptions.countItem === 0) {
    if (layoutOptions.markerOffset) {
      lines.push([], []);
    } else {
      lines.push([]);
    }
  }
  if (layoutOptions.markerOffset) {
    tableLine.firstLine = lines[lines.length - 1];
    tableLine.secondLine = lines[lines.length - 2];
  } else {
    tableLine.firstLine = tableLine.secondLine = lines[lines.length - 1];
  }
  return tableLine;
}
function setMaxInLine(line, measure) {
  var maxLineSize = line.reduce(function (maxLineSize, item) {
    var itemMeasure = item ? item[measure] : maxLineSize;
    return _max(maxLineSize, itemMeasure);
  }, 0);
  line.forEach(function (item) {
    if (item) {
      item[measure] = maxLineSize;
    }
  });
}
function transpose(array) {
  var width = array.length;
  var height = array[0].length;
  var i;
  var j;
  var transposeArray = [];
  for (i = 0; i < height; i++) {
    transposeArray[i] = [];
    for (j = 0; j < width; j++) {
      transposeArray[i][j] = array[j][i];
    }
  }
  return transposeArray;
}
function getAlign(position) {
  switch (position) {
    case TOP:
    case BOTTOM:
      return CENTER;
    case LEFT:
      return RIGHT;
    case RIGHT:
      return LEFT;
  }
}
var getMarkerCreator = function getMarkerCreator(type) {
  return isCircle(type) ? createCircleMarker : createSquareMarker;
};
function getTitleHorizontalAlignment(options) {
  if (options.horizontalAlignment === CENTER) {
    return CENTER;
  } else {
    if (options.itemTextPosition === RIGHT) {
      return LEFT;
    } else if (options.itemTextPosition === LEFT) {
      return RIGHT;
    } else {
      return CENTER;
    }
  }
}
var Legend = function Legend(settings) {
  var that = this;
  that._renderer = settings.renderer;
  that._legendGroup = settings.group;
  that._backgroundClass = settings.backgroundClass;
  that._itemGroupClass = settings.itemGroupClass;
  that._textField = settings.textField;
  that._getCustomizeObject = settings.getFormatObject;
  that._titleGroupClass = settings.titleGroupClass;
  that._allowInsidePosition = settings.allowInsidePosition;
  that._widget = settings.widget;
  that._updated = false;
};
exports.Legend = Legend;
var _Legend = Legend;
var legendPrototype = _Legend.prototype = (0, _object.clone)(_layout_element.LayoutElement.prototype);
(0, _extend2.extend)(legendPrototype, {
  constructor: _Legend,
  getOptions: function getOptions() {
    return this._options;
  },
  update: function update() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 ? arguments[1] : undefined;
    var themeManagerTitleOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var that = this;
    options = that._options = parseOptions(options, that._textField, that._allowInsidePosition) || {};
    var initMarkerSize = options.markerSize;
    this._updated = true;
    this._data = data.map(function (dataItem) {
      dataItem.size = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize);
      dataItem.marker = getAttributes(dataItem, dataItem.states.normal);
      Object.defineProperty(dataItem.marker, 'size', {
        get() {
          return dataItem.size;
        },
        set(value) {
          dataItem.size = value;
        }
      });
      Object.defineProperty(dataItem.marker, 'opacity', {
        get() {
          return dataItem.states.normal.opacity;
        },
        set(value) {
          dataItem.states.normal.opacity = dataItem.states.hover.opacity = dataItem.states.selection.opacity = value;
        }
      });
      return dataItem;
    });
    if (options.customizeItems) {
      that._data = options.customizeItems(data.slice()) || data;
    }
    that._boundingRect = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    if (that.isVisible() && !that._title) {
      that._title = new _title.Title({
        renderer: that._renderer,
        cssClass: that._titleGroupClass,
        root: that._legendGroup
      });
    }
    if (that._title) {
      var titleOptions = options.title;
      themeManagerTitleOptions.horizontalAlignment = getTitleHorizontalAlignment(options);
      that._title.update(themeManagerTitleOptions, titleOptions);
    }
    this.erase();
    return that;
  },
  isVisible: function isVisible() {
    return this._options && this._options.visible;
  },
  draw: function draw(width, height) {
    // TODO check multiple groups creation
    var that = this;
    var items = that._getItemData();
    that.erase();
    if (!(that.isVisible() && items && items.length)) {
      return that;
    }
    that._insideLegendGroup = that._renderer.g().enableLinks().append(that._legendGroup);
    that._title.changeLink(that._insideLegendGroup);
    that._createBackground();
    if (that._title.hasText()) {
      var horizontalPadding = that._background ? 2 * that._options.paddingLeftRight : 0;
      that._title.draw(width - horizontalPadding, height);
    }

    // TODO review pass or process states in legend
    that._markersGroup = that._renderer.g().attr({
      class: that._itemGroupClass
    }).append(that._insideLegendGroup);
    that._createItems(items);
    that._updateElementsPosition(width, height);
    return that;
  },
  _measureElements: function _measureElements() {
    var options = this._options;
    var maxBBoxHeight = 0;
    this._items.forEach(function (item) {
      var labelBBox = item.label.getBBox();
      var markerBBox = item.marker.getBBox();
      item.markerBBox = markerBBox;
      item.markerSize = Math.max(markerBBox.width, markerBBox.height);
      var bBox = getSizeItem(options, markerBBox, labelBBox);
      item.labelBBox = labelBBox;
      item.bBox = bBox;
      maxBBoxHeight = _max(maxBBoxHeight, bBox.height);
    });
    if (options.equalRowHeight) {
      this._items.forEach(function (item) {
        return item.bBox.height = maxBBoxHeight;
      });
    }
  },
  _updateElementsPosition: function _updateElementsPosition(width, height) {
    var that = this;
    var options = that._options;
    this._size = {
      width: width,
      height: height
    };
    that._measureElements();
    that._locateElements(options);
    that._finalUpdate(options);
    var size = that.getLayoutOptions();
    if (size.width > width || size.height > height) {
      that.freeSpace();
    }
  },
  _createItems: function _createItems(items) {
    var that = this;
    var options = that._options;
    var renderer = that._renderer;
    var createMarker = getMarkerCreator(options.markerShape);
    that._markersId = {};
    var templateFunction = !options.markerTemplate ? function (dataItem, group) {
      var attrs = dataItem.marker;
      createMarker(renderer, attrs.size).attr({
        fill: attrs.fill,
        opacity: attrs.opacity,
        filter: attrs.filter
      }).append({
        element: group
      });
    } : options.markerTemplate;
    var template = that._widget._getTemplate(templateFunction);
    var markersGroup = that._markersGroup;
    markersGroup.css((0, _utils.patchFontOptions)(options.font));
    that._deferredItems = [];
    that._templatesGroups = [];
    that._items = (items || []).map(function (dataItem, i) {
      var stateOfDataItem = dataItem.states;
      var normalState = stateOfDataItem.normal;
      var normalStateFill = normalState.fill;
      dataItem.size = dataItem.marker.size;
      var states = {
        normal: (0, _extend2.extend)(normalState, {
          fill: normalStateFill || options.markerColor || options.defaultColor,
          state: 'normal'
        }),
        hover: getState(stateOfDataItem.hover, normalStateFill, 'hovered'),
        selection: getState(stateOfDataItem.selection, normalStateFill, 'selected')
      };
      dataItem.states = states;
      var itemGroup = renderer.g().append(markersGroup);
      var markerGroup = renderer.g().attr({
        class: 'dxl-marker'
      }).append(itemGroup);
      that._deferredItems[i] = new _deferred.Deferred();
      that._templatesGroups.push(markerGroup);
      var item = {
        label: that._createLabel(dataItem, itemGroup),
        marker: markerGroup,
        renderer,
        group: itemGroup,
        tracker: {
          id: dataItem.id,
          argument: dataItem.argument,
          argumentIndex: dataItem.argumentIndex
        },
        states: states,
        itemTextPosition: options.itemTextPosition,
        markerOffset: 0,
        bBoxes: [],
        renderMarker(state) {
          dataItem.marker = getAttributes(item, state, dataItem.size);
          markerGroup.clear();
          template.render({
            model: dataItem,
            container: markerGroup.element,
            onRendered: that._deferredItems[i].resolve
          });
        }
      };
      item.renderMarker(states.normal);
      that._createHint(dataItem, itemGroup);
      if (dataItem.id !== undefined) {
        that._markersId[dataItem.id] = i;
      }
      return item;
    });
  },
  getTemplatesGroups: function getTemplatesGroups() {
    return this._templatesGroups || [];
  },
  getTemplatesDef: function getTemplatesDef() {
    return this._deferredItems || [];
  },
  _getItemData: function _getItemData() {
    var items = this._data || [];
    var options = this._options || {};
    // For maps in dashboards
    if (options.inverted) {
      items = items.slice().reverse();
    }
    return items.filter(function (i) {
      return i.visible;
    });
  },
  _finalUpdate: function _finalUpdate(options) {
    this._adjustBackgroundSettings(options);
    this._setBoundingRect(options.margin);
  },
  // The name is chosen to be opposite for `draw`
  erase: function erase() {
    var that = this;
    var insideLegendGroup = that._insideLegendGroup;
    insideLegendGroup && insideLegendGroup.dispose();
    that._insideLegendGroup = that._markersGroup = that._x1 = that._x2 = that._y2 = that._y2 = null;
    return that;
  },
  _locateElements: function _locateElements(locationOptions) {
    this._moveInInitialValues();
    this._locateRowsColumns(locationOptions);
  },
  _moveInInitialValues: function _moveInInitialValues() {
    var that = this;
    that._title.hasText() && that._title.move([0, 0]);
    that._legendGroup && that._legendGroup.move(0, 0);
    that._background && that._background.attr({
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  },
  applySelected: function applySelected(id) {
    applyMarkerState(id, this._markersId, this._items, 'selection');
    return this;
  },
  applyHover: function applyHover(id) {
    applyMarkerState(id, this._markersId, this._items, 'hover');
    return this;
  },
  resetItem: function resetItem(id) {
    applyMarkerState(id, this._markersId, this._items, 'normal');
    return this;
  },
  _createLabel: function _createLabel(data, group) {
    var labelFormatObject = this._getCustomizeObject(data);
    var options = this._options;
    var align = getAlign(options.itemTextPosition);
    var text = options.customizeText.call(labelFormatObject, labelFormatObject);
    var fontStyle = _isDefined(data.textOpacity) ? {
      color: options.font.color,
      opacity: data.textOpacity
    } : {};
    return this._renderer.text(text, 0, 0).css((0, _utils.patchFontOptions)(fontStyle)).attr({
      align: align,
      class: options.cssClass
    }).append(group);
  },
  _createHint: function _createHint(data, group) {
    var labelFormatObject = this._getCustomizeObject(data);
    var text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);
    if (_isDefined(text) && text !== '') {
      group.setTitle(text);
    }
  },
  _createBackground: function _createBackground() {
    var that = this;
    var isInside = that._options.position === INSIDE;
    var color = that._options.backgroundColor;
    var fill = color || (isInside ? that._options.containerBackgroundColor : NONE);
    if (that._options.border.visible || (isInside || color) && color !== NONE) {
      that._background = that._renderer.rect(0, 0, 0, 0).attr({
        fill: fill,
        class: that._backgroundClass
      }).append(that._insideLegendGroup);
    }
  },
  _locateRowsColumns: function _locateRowsColumns(options) {
    var that = this;
    var iteration = 0;
    var layoutOptions = that._getItemsLayoutOptions();
    var countItems = that._items.length;
    var lines;
    do {
      lines = [];
      that._createLines(lines, layoutOptions);
      that._alignLines(lines, layoutOptions);
      iteration++;
    } while (checkLinesSize(lines, layoutOptions, countItems, options.margin) && iteration < countItems);
    that._applyItemPosition(lines, layoutOptions);
  },
  _createLines: function _createLines(lines, layoutOptions) {
    this._items.forEach(function (item, i) {
      var tableLine = getLines(lines, layoutOptions, i);
      var labelBox = {
        width: item.labelBBox.width,
        height: item.labelBBox.height,
        element: item.label,
        bBox: item.labelBBox,
        pos: getPos(layoutOptions),
        itemIndex: i
      };
      var markerBox = {
        width: item.markerBBox.width,
        height: item.markerBBox.height,
        element: item.marker,
        pos: {
          horizontal: CENTER,
          vertical: CENTER
        },
        bBox: {
          width: item.markerBBox.width,
          height: item.markerBBox.height,
          x: item.markerBBox.x,
          y: item.markerBBox.y
        },
        itemIndex: i
      };
      var firstItem;
      var secondItem;
      var offsetDirection = layoutOptions.markerOffset ? 'altOffset' : 'offset';
      if (layoutOptions.inverseLabelPosition) {
        firstItem = labelBox;
        secondItem = markerBox;
      } else {
        firstItem = markerBox;
        secondItem = labelBox;
      }
      firstItem[offsetDirection] = layoutOptions.labelOffset;
      tableLine.secondLine.push(firstItem);
      tableLine.firstLine.push(secondItem);
    });
  },
  _alignLines: function _alignLines(lines, layoutOptions) {
    var i;
    var measure = layoutOptions.altMeasure;
    lines.forEach(function (line) {
      return setMaxInLine(line, measure);
    });
    measure = layoutOptions.measure;
    if (layoutOptions.itemsAlignment) {
      if (layoutOptions.markerOffset) {
        for (i = 0; i < lines.length;) {
          transpose([lines[i++], lines[i++]]).forEach(processLine);
        }
      }
    } else {
      transpose(lines).forEach(processLine);
    }
    function processLine(line) {
      setMaxInLine(line, measure);
    }
  },
  _applyItemPosition: function _applyItemPosition(lines, layoutOptions) {
    var that = this;
    var position = {
      x: 0,
      y: 0
    };
    var maxLineLength = getMaxLineLength(lines, layoutOptions);
    lines.forEach(function (line) {
      var firstItem = line[0];
      var altOffset = firstItem.altOffset || layoutOptions.altSpacing;
      position[layoutOptions.direction] = getInitPositionForDirection(line, layoutOptions, maxLineLength);
      line.forEach(function (item) {
        var offset = item.offset || layoutOptions.spacing;
        var wrap = new _layout_element.WrapperLayoutElement(item.element, item.bBox);
        var itemBBoxOptions = {
          x: position.x,
          y: position.y,
          width: item.width,
          height: item.height
        };
        var itemBBox = new _layout_element.WrapperLayoutElement(null, itemBBoxOptions);
        var itemLegend = that._items[item.itemIndex];
        wrap.position({
          of: itemBBox,
          my: item.pos,
          at: item.pos
        });
        itemLegend.bBoxes.push(itemBBox);
        position[layoutOptions.direction] += item[layoutOptions.measure] + offset;
      });
      position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + altOffset;
    });
    this._items.forEach(function (item) {
      var itemBBox = calculateBBoxLabelAndMarker(item.bBoxes[0].getLayoutOptions(), item.bBoxes[1].getLayoutOptions());
      var horizontal = that._options.columnItemSpacing / 2;
      var vertical = that._options.rowItemSpacing / 2;
      item.tracker.left = itemBBox.left - horizontal;
      item.tracker.right = itemBBox.right + horizontal;
      item.tracker.top = itemBBox.top - vertical;
      item.tracker.bottom = itemBBox.bottom + vertical;
    });
  },
  _getItemsLayoutOptions: function _getItemsLayoutOptions() {
    var that = this;
    var options = that._options;
    var orientation = options.orientation;
    var layoutOptions = {
      itemsAlignment: options.itemsAlignment,
      orientation: options.orientation
    };
    var width = that._size.width - (that._background ? 2 * options.paddingLeftRight : 0);
    var height = that._size.height - (that._background ? 2 * options.paddingTopBottom : 0);
    if (orientation === HORIZONTAL) {
      layoutOptions.length = width;
      layoutOptions.spacing = options.columnItemSpacing;
      layoutOptions.direction = 'x';
      layoutOptions.measure = WIDTH;
      layoutOptions.altMeasure = HEIGHT;
      layoutOptions.altDirection = 'y';
      layoutOptions.altSpacing = options.rowItemSpacing;
      layoutOptions.countItem = options.columnCount;
      layoutOptions.altCountItem = options.rowCount;
      layoutOptions.marginTextLabel = 4;
      layoutOptions.labelOffset = 7;
      if (options.itemTextPosition === BOTTOM || options.itemTextPosition === TOP) {
        layoutOptions.labelOffset = 4;
        layoutOptions.markerOffset = true;
      }
    } else {
      layoutOptions.length = height;
      layoutOptions.spacing = options.rowItemSpacing;
      layoutOptions.direction = 'y';
      layoutOptions.measure = HEIGHT;
      layoutOptions.altMeasure = WIDTH;
      layoutOptions.altDirection = 'x';
      layoutOptions.altSpacing = options.columnItemSpacing;
      layoutOptions.countItem = options.rowCount;
      layoutOptions.altCountItem = options.columnCount;
      layoutOptions.marginTextLabel = 7;
      layoutOptions.labelOffset = 4;
      if (options.itemTextPosition === RIGHT || options.itemTextPosition === LEFT) {
        layoutOptions.labelOffset = 7;
        layoutOptions.markerOffset = true;
      }
    }
    if (!layoutOptions.countItem) {
      if (layoutOptions.altCountItem) {
        layoutOptions.countItem = _ceil(that._items.length / layoutOptions.altCountItem);
      } else {
        layoutOptions.countItem = that._items.length;
      }
    }
    if (options.itemTextPosition === TOP || options.itemTextPosition === LEFT) {
      layoutOptions.inverseLabelPosition = true;
    }
    layoutOptions.itemTextPosition = options.itemTextPosition;
    layoutOptions.altCountItem = layoutOptions.altCountItem || _ceil(that._items.length / layoutOptions.countItem);
    return layoutOptions;
  },
  _adjustBackgroundSettings: function _adjustBackgroundSettings(locationOptions) {
    if (!this._background) return;
    var border = locationOptions.border;
    var legendBox = this._calculateTotalBox();
    var backgroundSettings = {
      x: _round(legendBox.x - locationOptions.paddingLeftRight),
      y: _round(legendBox.y - locationOptions.paddingTopBottom),
      width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,
      height: _round(legendBox.height),
      opacity: locationOptions.backgroundOpacity
    };
    if (border.visible && border.width && border.color && border.color !== NONE) {
      backgroundSettings['stroke-width'] = border.width;
      backgroundSettings.stroke = border.color;
      backgroundSettings['stroke-opacity'] = border.opacity;
      backgroundSettings.dashStyle = border.dashStyle;
      backgroundSettings.rx = border.cornerRadius || 0;
      backgroundSettings.ry = border.cornerRadius || 0;
    }
    this._background.attr(backgroundSettings);
  },
  _setBoundingRect: function _setBoundingRect(margin) {
    if (!this._insideLegendGroup) {
      return;
    }
    var box = this._calculateTotalBox();
    box.height += margin.top + margin.bottom;
    box.widthWithoutMargins = box.width;
    box.width += margin.left + margin.right;
    box.x -= margin.left;
    box.y -= margin.top;
    this._boundingRect = box;
  },
  _calculateTotalBox: function _calculateTotalBox() {
    var markerBox = this._markersGroup.getBBox();
    var titleBox = this._title.getCorrectedLayoutOptions();
    var box = this._insideLegendGroup.getBBox();
    var verticalPadding = this._background ? 2 * this._options.paddingTopBottom : 0;
    box.height = markerBox.height + titleBox.height + verticalPadding;
    titleBox.width > box.width && (box.width = titleBox.width);
    return box;
  },
  getActionCallback: function getActionCallback(point) {
    var that = this;
    if (that._options.visible) {
      return function (act) {
        that[act](point.index);
      };
    } else {
      return _common.noop;
    }
  },
  getLayoutOptions: function getLayoutOptions() {
    var options = this._options;
    var boundingRect = this._insideLegendGroup ? this._boundingRect : {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    if (options) {
      boundingRect.verticalAlignment = options.verticalAlignment;
      boundingRect.horizontalAlignment = options.horizontalAlignment;
      if (options.orientation === HORIZONTAL) {
        boundingRect.cutLayoutSide = options.verticalAlignment;
        boundingRect.cutSide = 'vertical';
      } else {
        if (options.horizontalAlignment === CENTER) {
          boundingRect.cutLayoutSide = options.verticalAlignment;
          boundingRect.cutSide = 'vertical';
        } else {
          boundingRect.cutLayoutSide = options.horizontalAlignment;
          boundingRect.cutSide = 'horizontal';
        }
      }
      boundingRect.position = {
        horizontal: options.horizontalAlignment,
        vertical: options.verticalAlignment
      };
      return boundingRect;
    }
    return null;
  },
  shift: function shift(x, y) {
    var that = this;
    var box = {};
    if (that._insideLegendGroup) {
      that._insideLegendGroup.attr({
        translateX: x - that._boundingRect.x,
        translateY: y - that._boundingRect.y
      });
    }
    that._title && that._shiftTitle(that._boundingRect.widthWithoutMargins);
    that._markersGroup && that._shiftMarkers();
    if (that._insideLegendGroup) box = that._legendGroup.getBBox();
    that._x1 = box.x;
    that._y1 = box.y;
    that._x2 = box.x + box.width;
    that._y2 = box.y + box.height;
    return that;
  },
  _shiftTitle: function _shiftTitle(boxWidth) {
    var that = this;
    var title = that._title;
    var titleBox = title.getCorrectedLayoutOptions();
    if (!titleBox || !title.hasText()) {
      return;
    }
    var width = boxWidth - (that._background ? 2 * that._options.paddingLeftRight : 0);
    var titleOptions = title.getOptions();
    var titleY = titleBox.y + titleOptions.margin.top;
    var titleX = 0;
    if (titleOptions.verticalAlignment === BOTTOM && that._markersGroup) {
      titleY += that._markersGroup.getBBox().height;
    }
    if (titleOptions.horizontalAlignment === RIGHT) {
      titleX = width - titleBox.width;
    } else if (titleOptions.horizontalAlignment === CENTER) {
      titleX = (width - titleBox.width) / 2;
    }
    title.shift(titleX, titleY);
  },
  _shiftMarkers: function _shiftMarkers() {
    var titleBox = this._title.getLayoutOptions();
    var markerBox = this._markersGroup.getBBox();
    var titleOptions = this._title.getOptions() || {};
    var center = 0;
    var y = 0;
    if (titleBox.width > markerBox.width && this._options.horizontalAlignment === CENTER) {
      center = titleBox.width / 2 - markerBox.width / 2;
    }
    if (titleOptions.verticalAlignment === TOP) {
      y = titleBox.height;
    }
    if (center !== 0 || y !== 0) {
      this._markersGroup.attr({
        translateX: center,
        translateY: y
      });
      this._items.forEach(function (item) {
        item.tracker.left += center;
        item.tracker.right += center;
        item.tracker.top += y;
        item.tracker.bottom += y;
      });
    }
  },
  getPosition: function getPosition() {
    return this._options.position;
  },
  coordsIn: function coordsIn(x, y) {
    return x >= this._x1 && x <= this._x2 && y >= this._y1 && y <= this._y2;
  },
  getItemByCoord: function getItemByCoord(x, y) {
    var items = this._items;
    var legendGroup = this._insideLegendGroup;
    x = x - legendGroup.attr('translateX');
    y = y - legendGroup.attr('translateY');
    for (var i = 0; i < items.length; i++) {
      if (inRect(items[i].tracker, x, y)) {
        return items[i].tracker;
      }
    }
    return null;
  },
  dispose: function dispose() {
    var that = this;
    that._title && that._title.dispose();
    that._legendGroup = that._insideLegendGroup = that._title = that._renderer = that._options = that._data = that._items = null;
    return that;
  },
  // BaseWidget_layout_implementation
  layoutOptions: function layoutOptions() {
    if (!this.isVisible()) {
      return null;
    }
    var pos = this.getLayoutOptions();
    return {
      horizontalAlignment: this._options.horizontalAlignment,
      verticalAlignment: this._options.verticalAlignment,
      side: pos.cutSide,
      priority: 1,
      position: this.getPosition()
    };
  },
  measure: function measure(size) {
    if (this._updated || !this._insideLegendGroup) {
      this.draw(size[0], size[1]);
      this._updated = false;
    } else {
      this._items.forEach(function (item) {
        item.bBoxes = [];
      });
      this._updateElementsPosition(size[0], size[1]);
    }
    var rect = this.getLayoutOptions();
    return [rect.width, rect.height];
  },
  move: function move(rect) {
    this.shift(rect[0], rect[1]);
  },
  freeSpace: function freeSpace() {
    this._options._incidentOccurred('W2104');
    this.erase();
  }
  // BaseWidget_layout_implementation
});

var plugin = {
  name: 'legend',
  init: function init() {
    var that = this;
    var group = this._renderer.g().attr({
      class: this._rootClassPrefix + '-legend'
    }).enableLinks().append(that._renderer.root);
    that._legend = new Legend({
      renderer: that._renderer,
      group: group,
      widget: this,
      itemGroupClass: this._rootClassPrefix + '-item',
      titleGroupClass: this._rootClassPrefix + '-title',
      textField: 'text',
      getFormatObject: function getFormatObject(data) {
        return {
          item: data.item,
          text: data.text
        };
      }
    });
    that._layout.add(that._legend);
  },
  extenders: {
    _applyTilesAppearance: function _applyTilesAppearance() {
      var that = this;
      this._items.forEach(function (item) {
        that._applyLegendItemStyle(item.id, item.getState());
      });
    },
    _buildNodes: function _buildNodes() {
      this._createLegendItems();
    }
  },
  members: {
    _applyLegendItemStyle: function _applyLegendItemStyle(id, state) {
      var legend = this._legend;
      switch (state) {
        case 'hover':
          legend.applyHover(id);
          break;
        case 'selection':
          legend.applySelected(id);
          break;
        default:
          legend.resetItem(id);
          break;
      }
    },
    _createLegendItems: function _createLegendItems() {
      if (this._legend.update(this._getLegendData(), this._getOption('legend'), this._themeManager.theme('legend').title)) {
        this._requestChange(['LAYOUT']);
      }
    }
  },
  dispose: function dispose() {
    this._legend.dispose();
  },
  customize: function customize(constructor) {
    constructor.prototype._proxyData.push(function (x, y) {
      if (this._legend.coordsIn(x, y)) {
        var item = this._legend.getItemByCoord(x, y);
        if (item) {
          return {
            id: item.id,
            type: 'legend'
          };
        }
      }
    });
    constructor.addChange({
      code: 'LEGEND',
      handler: function handler() {
        this._createLegendItems();
      },
      isThemeDependent: true,
      option: 'legend',
      isOptionChange: true
    });
  }
};
exports.plugin = plugin;

/***/ }),

/***/ 8587:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.correctValueType = correctValueType;
exports.getParser = void 0;
var _common = __webpack_require__(20576);
var _date_serialization = _interopRequireDefault(__webpack_require__(69434));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var parsers = {
  string: function string(val) {
    return (0, _type.isDefined)(val) ? '' + val : val;
  },
  numeric: function numeric(val) {
    if (!(0, _type.isDefined)(val)) {
      return val;
    }
    var parsedVal = Number(val);
    if (isNaN(parsedVal)) {
      parsedVal = undefined;
    }
    return parsedVal;
  },
  datetime: function datetime(val) {
    if (!(0, _type.isDefined)(val)) {
      return val;
    }
    var parsedVal;
    var numVal = Number(val);
    if (!isNaN(numVal)) {
      parsedVal = new Date(numVal);
    } else {
      parsedVal = _date_serialization.default.deserializeDate(val);
    }
    if (isNaN(Number(parsedVal))) {
      parsedVal = undefined;
    }
    return parsedVal;
  }
};
function correctValueType(type) {
  return type === 'numeric' || type === 'datetime' || type === 'string' ? type : '';
}
var getParser = function getParser(valueType) {
  return parsers[correctValueType(valueType)] || _common.noop;
};
exports.getParser = getParser;

/***/ }),

/***/ 88997:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Tracker = Tracker;
var _index = __webpack_require__(39611);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _click = __webpack_require__(95429);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var downPointerEventName = _pointer.default.down;
var movePointerEventName = _pointer.default.move;
function Tracker(parameters) {
  this._initHandlers(parameters);
}
Tracker.prototype = {
  constructor: Tracker,
  _initHandlers: function _initHandlers(parameters) {
    var document = _dom_adapter.default.getDocument();
    parameters.getCoords = function (e) {
      // TODO: Looks like "eventData" just returns e.pageX, e.pageY. Investigate and use just e.pageX, e.pageY is possible. Don't forget about touch.
      var data = (0, _index.eventData)(e);
      var offset = parameters.widget._renderer.getRootOffset();
      return [data.x - offset.left, data.y - offset.top];
    };
    parameters.root.on(_click.name, clickHandler);
    parameters.root.on(downPointerEventName, downHandler);
    _events_engine.default.on(document, downPointerEventName, downHandler);
    _events_engine.default.on(document, movePointerEventName, moveHandler);
    this._disposeHandlers = function () {
      parameters.root.off(_click.name, clickHandler);
      parameters.root.off(downPointerEventName, downHandler);
      _events_engine.default.off(document, downPointerEventName, downHandler);
      _events_engine.default.off(document, movePointerEventName, moveHandler);
    };
    function clickHandler(e) {
      processClick(e, parameters);
    }

    // Previously "stopPropagation" was called from the "downHandler" - so event triggered on "root" is not then triggered on "document".
    // Unfortunately it occurred (during T396917) that on touch devices calling "stopPropagation" prevents the following "dxclick" event.
    // Generally I think it would be better to use only (dxpointerdown, dxpointermove, dxpointerup) events (of course click is then implemented manually).
    // But for now removing "stopPropagation" will suffice - it can be implemented faster and with less changes, there are no known drawbacks in it.
    // We use "stopPropagation" to prevent unexpected scrolling or zooming when widget has some own scrolling behavior and is located inside another widget
    // (like dxScrollable) with its own scrolling behavior - dxTreeMap does not have own scrolling behavior.
    var isRootDown = false;
    function downHandler(e) {
      if (isRootDown) {
        isRootDown = false;
      } else {
        if (parameters.getData(e) !== undefined) {
          isRootDown = true;
        }
        moveHandler(e);
      }
    }
    function moveHandler(e) {
      processHover(e, parameters);
      parameters.widget._getOption('tooltip').enabled && processTooltip(e, parameters);
    }
  },
  dispose: function dispose() {
    this._disposeHandlers();
  }
};
function processClick(e, params) {
  var id = params.getData(e);
  if (id >= 0) {
    params.click({
      node: params.getNode(id),
      coords: params.getCoords(e),
      event: e
    });
  }
}
function processHover(e, params) {
  var id = params.getData(e);
  if (id >= 0) {
    params.getNode(id).setHover();
  } else {
    params.widget.clearHover();
  }
}
function processTooltip(e, params) {
  var id = params.getData(e, true);
  var coords;
  if (id >= 0) {
    coords = (0, _index.eventData)(e);
    params.getNode(id).showTooltip([coords.x, coords.y]);
  } else {
    params.widget.hideTooltip();
  }
}

/***/ }),

/***/ 77129:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugins = exports.createAnnotations = void 0;
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
var _tooltip = __webpack_require__(14371);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _plaque = __webpack_require__(64509);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _drag = __webpack_require__(23174);
var _index = __webpack_require__(39611);
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var getDocument = _dom_adapter.default.getDocument;
var EVENT_NS = 'annotations';
var DOT_EVENT_NS = '.' + EVENT_NS;
var POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
var POINTER_UP_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.up, EVENT_NS);
var DRAG_START_EVENT_NAME = _drag.start + DOT_EVENT_NS;
var DRAG_EVENT_NAME = _drag.move + DOT_EVENT_NS;
var DRAG_END_EVENT_NAME = _drag.end + DOT_EVENT_NS;
function coreAnnotation(options, contentTemplate) {
  return {
    draw: function draw(widget, group) {
      var _this = this;
      var annotationGroup = widget._renderer.g().append(group).css((0, _utils.patchFontOptions)(options.font));
      if (this.plaque) {
        this.plaque.clear();
      }
      this.plaque = new _plaque.Plaque((0, _extend.extend)(true, {}, options, {
        cornerRadius: (options.border || {}).cornerRadius
      }), widget, annotationGroup, contentTemplate, widget._isAnnotationBounded(options));
      this.plaque.draw(widget._getAnnotationCoords(this));
      if (options.allowDragging) {
        annotationGroup.on(DRAG_START_EVENT_NAME, {
          immediate: true
        }, function (e) {
          _this._dragOffsetX = _this.plaque.x - e.pageX;
          _this._dragOffsetY = _this.plaque.y - e.pageY;
        }).on(DRAG_EVENT_NAME, function (e) {
          _this.plaque.move(e.pageX + _this._dragOffsetX, e.pageY + _this._dragOffsetY);
        }).on(DRAG_END_EVENT_NAME, function (e) {
          _this.offsetX = (_this.offsetX || 0) + e.offset.x;
          _this.offsetY = (_this.offsetY || 0) + e.offset.y;
        });
      }
    },
    hitTest(x, y) {
      return this.plaque.hitTest(x, y);
    },
    showTooltip(tooltip, _ref) {
      var x = _ref.x,
        y = _ref.y;
      var that = this;
      var options = that.options;
      if (tooltip.annotation !== that) {
        tooltip.setTemplate(options.tooltipTemplate);
        var callback = function callback(result) {
          result && (tooltip.annotation = that);
        };
        callback(tooltip.show(options, {
          x,
          y
        }, {
          target: options
        }, options.customizeTooltip, callback));
      } else {
        if (!tooltip.isCursorOnTooltip(x, y)) {
          tooltip.move(x, y);
        }
      }
    }
  };
}
function getTemplateFunction(options, widget) {
  var template;
  if (options.type === 'text') {
    template = function template(item, groupElement) {
      var text = widget._renderer.text(item.text).attr({
        'class': item.cssClass
      }).append({
        element: groupElement
      });
      if (item.width > 0 || item.height > 0) {
        text.setMaxSize(item.width, item.height, {
          wordWrap: item.wordWrap,
          textOverflow: item.textOverflow
        });
      }
    };
  } else if (options.type === 'image') {
    template = function template(item, groupElement) {
      var _ref2 = item.image || {},
        width = _ref2.width,
        height = _ref2.height,
        url = _ref2.url,
        location = _ref2.location;
      var outerWidth = item.width,
        outerHeight = item.height;
      var imageWidth = outerWidth > 0 ? Math.min(width, outerWidth) : width;
      var imageHeight = outerHeight > 0 ? Math.min(height, outerHeight) : height;
      widget._renderer.image(0, 0, imageWidth, imageHeight, url, location || 'center').append({
        element: groupElement
      });
    };
  } else if (options.type === 'custom') {
    template = options.template;
  }
  return template;
}
function getImageObject(image) {
  return typeof image === 'string' ? {
    url: image
  } : image;
}
var createAnnotations = function createAnnotations(widget, items) {
  var commonAnnotationSettings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var customizeAnnotation = arguments.length > 3 ? arguments[3] : undefined;
  var pullOptions = arguments.length > 4 ? arguments[4] : undefined;
  var commonImageOptions = getImageObject(commonAnnotationSettings.image);
  return items.reduce(function (arr, item) {
    var currentImageOptions = getImageObject(item.image);
    var customizedItem = (0, _type.isFunction)(customizeAnnotation) ? customizeAnnotation(item) : {};
    if (customizedItem) {
      customizedItem.image = getImageObject(customizedItem.image); // T881143
    }

    var options = (0, _extend.extend)(true, {}, commonAnnotationSettings, item, {
      image: commonImageOptions
    }, {
      image: currentImageOptions
    }, customizedItem);
    var templateFunction = getTemplateFunction(options, widget);
    var annotation = templateFunction && (0, _extend.extend)(true, pullOptions(options), coreAnnotation(options, widget._getTemplate(templateFunction)));
    annotation && arr.push(annotation);
    return arr;
  }, []);
};
exports.createAnnotations = createAnnotations;
var chartPlugin = {
  name: 'annotations_chart',
  init() {},
  dispose() {},
  members: {
    _getAnnotationCoords(annotation) {
      var _axis, _axis2;
      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY
      };
      var argCoordName = this._options.silent('rotated') ? 'y' : 'x';
      var valCoordName = this._options.silent('rotated') ? 'x' : 'y';
      var argAxis = this.getArgumentAxis();
      var argument = argAxis.validateUnit(annotation.argument);
      var axis = this.getValueAxis(annotation.axis);
      var series;
      var pane = (_axis = axis) === null || _axis === void 0 ? void 0 : _axis.pane;
      if (annotation.series) {
        var _series;
        series = this.series.filter(function (s) {
          return s.name === annotation.series;
        })[0];
        axis = (_series = series) === null || _series === void 0 ? void 0 : _series.getValueAxis();
        (0, _type.isDefined)(axis) && (pane = axis.pane);
      }
      if ((0, _type.isDefined)(argument)) {
        if (series) {
          var center = series.getPointCenterByArg(argument);
          center && (coords[argCoordName] = center[argCoordName]);
        } else {
          coords[argCoordName] = argAxis.getTranslator().translate(argument);
        }
        !(0, _type.isDefined)(pane) && (pane = argAxis.pane);
      }
      var value = (_axis2 = axis) === null || _axis2 === void 0 ? void 0 : _axis2.validateUnit(annotation.value);
      if ((0, _type.isDefined)(value)) {
        var _axis3;
        coords[valCoordName] = (_axis3 = axis) === null || _axis3 === void 0 ? void 0 : _axis3.getTranslator().translate(value);
        !(0, _type.isDefined)(pane) && (0, _type.isDefined)(axis) && (pane = axis.pane);
      }
      coords.canvas = this._getCanvasForPane(pane);
      if ((0, _type.isDefined)(coords[argCoordName]) && !(0, _type.isDefined)(value)) {
        var _series2;
        if (!(0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[valCoordName] = argAxis.getAxisPosition();
        } else if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[valCoordName] = this._argumentAxes.filter(function (a) {
            return a.pane === axis.pane;
          })[0].getAxisPosition();
        } else if ((_series2 = series) !== null && _series2 !== void 0 && _series2.checkSeriesViewportCoord(argAxis, coords[argCoordName])) {
          coords[valCoordName] = series.getSeriesPairCoord(coords[argCoordName], true);
        }
      }
      if (!(0, _type.isDefined)(argument) && (0, _type.isDefined)(coords[valCoordName])) {
        if ((0, _type.isDefined)(axis) && !(0, _type.isDefined)(series)) {
          coords[argCoordName] = axis.getAxisPosition();
        } else if ((0, _type.isDefined)(series)) {
          if (series.checkSeriesViewportCoord(axis, coords[valCoordName])) {
            coords[argCoordName] = series.getSeriesPairCoord(coords[valCoordName], false);
          }
        }
      }
      return coords;
    },
    _annotationsPointerEventHandler(event) {
      if (this._disposed) {
        return;
      }
      var originalEvent = event.originalEvent || {};
      var touch = originalEvent.touches && originalEvent.touches[0] || {};
      var rootOffset = this._renderer.getRootOffset();
      var coords = {
        x: touch.pageX || originalEvent.pageX || event.pageX,
        y: touch.pageY || originalEvent.pageY || event.pageY
      };
      var annotation = this._annotations.items.filter(function (a) {
        return a.hitTest(coords.x - rootOffset.left, coords.y - rootOffset.top);
      })[0];
      if (!annotation || !annotation.options.tooltipEnabled) {
        this._annotations.hideTooltip();
        return;
      }
      this._clear();
      if (annotation.options.allowDragging && event.type === _pointer.default.down) {
        this._annotations._hideToolTipForDrag = true;
      }
      if (!this._annotations._hideToolTipForDrag) {
        annotation.showTooltip(this._annotations.tooltip, coords);
        event.stopPropagation();
      }
    },
    _isAnnotationBounded(options) {
      return (0, _type.isDefined)(options.value) || (0, _type.isDefined)(options.argument);
    },
    _pullOptions(options) {
      return {
        type: options.type,
        name: options.name,
        x: options.x,
        y: options.y,
        value: options.value,
        argument: options.argument,
        axis: options.axis,
        series: options.series,
        options: options,
        offsetX: options.offsetX,
        offsetY: options.offsetY
      };
    },
    _forceAnnotationRender() {
      this._change(['FORCE_RENDER']);
    },
    _clear() {
      this.hideTooltip();
      this.clearHover();
    }
  }
};
var polarChartPlugin = {
  name: 'annotations_polar_chart',
  init() {},
  dispose() {},
  members: {
    _getAnnotationCoords(annotation) {
      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY,
        canvas: this._calcCanvas()
      };
      var argAxis = this.getArgumentAxis();
      var argument = argAxis.validateUnit(annotation.argument);
      var value = this.getValueAxis().validateUnit(annotation.value);
      var radius = annotation.radius;
      var angle = annotation.angle;
      var pointCoords;
      var series;
      if (annotation.series) {
        series = this.series.filter(function (s) {
          return s.name === annotation.series;
        })[0];
      }
      (0, _extend.extend)(true, coords, this.getXYFromPolar(angle, radius, argument, value));
      if ((0, _type.isDefined)(series)) {
        if ((0, _type.isDefined)(coords.angle) && !(0, _type.isDefined)(value) && !(0, _type.isDefined)(radius)) {
          if (!(0, _type.isDefined)(argument)) {
            argument = argAxis.getTranslator().from(isFinite(angle) ? this.getActualAngle(angle) : coords.angle);
          }
          pointCoords = series.getSeriesPairCoord({
            argument,
            angle: -coords.angle
          }, true);
        } else if ((0, _type.isDefined)(coords.radius) && !(0, _type.isDefined)(argument) && !(0, _type.isDefined)(angle)) {
          pointCoords = series.getSeriesPairCoord({
            radius: coords.radius
          }, false);
        }
        if ((0, _type.isDefined)(pointCoords)) {
          coords.x = pointCoords.x;
          coords.y = pointCoords.y;
        }
      }
      if (annotation.series && !(0, _type.isDefined)(pointCoords)) {
        coords.x = coords.y = undefined;
      }
      return coords;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _isAnnotationBounded: chartPlugin.members._isAnnotationBounded,
    _pullOptions(options) {
      var polarOptions = (0, _extend.extend)({}, {
        radius: options.radius,
        angle: options.angle
      }, chartPlugin.members._pullOptions(options));
      delete polarOptions.axis;
      return polarOptions;
    },
    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender,
    _clear: chartPlugin.members._clear
  }
};
var vectorMapPlugin = {
  name: 'annotations_vector_map',
  init() {},
  dispose() {
    this._annotations._offTracker();
    this._annotations._offTracker = null;
  },
  members: {
    _getAnnotationCoords(annotation) {
      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY
      };
      coords.canvas = this._projection.getCanvas();
      if (annotation.coordinates) {
        var data = this._projection.toScreenPoint(annotation.coordinates);
        coords.x = data[0];
        coords.y = data[1];
      }
      return coords;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _isAnnotationBounded(options) {
      return (0, _type.isDefined)(options.coordinates);
    },
    _pullOptions(options) {
      var vectorMapOptions = (0, _extend.extend)({}, {
        coordinates: options.coordinates
      }, chartPlugin.members._pullOptions(options));
      delete vectorMapOptions.axis;
      delete vectorMapOptions.series;
      delete vectorMapOptions.argument;
      delete vectorMapOptions.value;
      return vectorMapOptions;
    },
    _forceAnnotationRender() {
      this._change(['EXTRA_ELEMENTS']);
    },
    _getAnnotationStyles() {
      return {
        'text-anchor': 'start'
      };
    },
    _clear() {}
  },
  extenders: {
    _prepareExtraElements() {
      var that = this;
      var renderElements = function renderElements() {
        that._renderExtraElements();
      };
      that._annotations._offTracker = that._tracker.on({
        'move': renderElements,
        'zoom': renderElements,
        'end': renderElements
      });
    }
  }
};
var pieChartPlugin = {
  name: 'annotations_pie_chart',
  init() {},
  dispose() {},
  members: {
    _getAnnotationCoords(annotation) {
      var series;
      var coords = {
        offsetX: annotation.offsetX,
        offsetY: annotation.offsetY,
        canvas: this._canvas
      };
      if (annotation.argument) {
        if (annotation.series) {
          series = this.getSeriesByName(annotation.series);
        } else {
          series = this.series[0];
        }
        var argument = series.getPointsByArg(annotation.argument)[0];
        var _argument$getAnnotati = argument.getAnnotationCoords(annotation.location),
          x = _argument$getAnnotati.x,
          y = _argument$getAnnotati.y;
        coords.x = x;
        coords.y = y;
      }
      return coords;
    },
    _isAnnotationBounded(options) {
      return options.argument;
    },
    _annotationsPointerEventHandler: chartPlugin.members._annotationsPointerEventHandler,
    _pullOptions(options) {
      var pieChartOptions = (0, _extend.extend)({}, {
        location: options.location
      }, chartPlugin.members._pullOptions(options));
      delete pieChartOptions.axis;
      return pieChartOptions;
    },
    _clear: chartPlugin.members._clear,
    _forceAnnotationRender: chartPlugin.members._forceAnnotationRender
  }
};
var corePlugin = {
  name: 'annotations_core',
  init() {
    this._annotations = {
      items: [],
      _hideToolTipForDrag: false,
      tooltip: new _tooltip.Tooltip({
        cssClass: "".concat(this._rootClassPrefix, "-annotation-tooltip"),
        eventTrigger: this._eventTrigger,
        widgetRoot: this.element(),
        widget: this
      }),
      hideTooltip() {
        this.tooltip.annotation = null;
        this.tooltip.hide();
      },
      clearItems() {
        this.items.forEach(function (i) {
          return i.plaque.clear();
        });
        this.items = [];
      }
    };
    this._annotations.tooltip.setRendererOptions(this._getRendererOptions());
  },
  dispose() {
    this._annotationsGroup.linkRemove().linkOff();
    _events_engine.default.off(getDocument(), DOT_EVENT_NS);
    this._annotationsGroup.off(DOT_EVENT_NS);
    this._annotations.tooltip && this._annotations.tooltip.dispose();
  },
  extenders: {
    _createHtmlStructure() {
      var _this2 = this;
      this._annotationsGroup = this._renderer.g().attr({
        'class': "".concat(this._rootClassPrefix, "-annotations")
      }).css(this._getAnnotationStyles()).linkOn(this._renderer.root, 'annotations').linkAppend();
      _events_engine.default.on(getDocument(), POINTER_ACTION, function (e) {
        if (_this2._disposed) {
          return;
        }
        if (!_this2._annotations.tooltip.isCursorOnTooltip(e.pageX, e.pageY)) {
          _this2._annotations.hideTooltip();
        }
      });
      _events_engine.default.on(getDocument(), POINTER_UP_EVENT_NAME, function (event) {
        _this2._annotations._hideToolTipForDrag = false;
        _this2._annotationsPointerEventHandler(event);
      });
      this._annotationsGroup.on(POINTER_ACTION, this._annotationsPointerEventHandler.bind(this));
    },
    _renderExtraElements() {
      var _this3 = this;
      this._annotationsGroup.clear();
      this._annotations.items.forEach(function (item) {
        return item.draw(_this3, _this3._annotationsGroup);
      });
    },
    _stopCurrentHandling() {
      this._annotations.hideTooltip();
    }
  },
  members: {
    _buildAnnotations() {
      this._annotations.clearItems();
      var items = this._getOption('annotations', true);
      if (!(items !== null && items !== void 0 && items.length)) {
        return;
      }
      this._annotations.items = createAnnotations(this, items, this._getOption('commonAnnotationSettings'), this._getOption('customizeAnnotation', true), this._pullOptions);
    },
    _setAnnotationTooltipOptions() {
      var tooltipOptions = (0, _extend.extend)({}, this._getOption('tooltip'));
      tooltipOptions.contentTemplate = tooltipOptions.customizeTooltip = undefined;
      this._annotations.tooltip.update(tooltipOptions);
    },
    _getAnnotationCoords() {
      return {};
    },
    _pullOptions() {
      return {};
    },
    _getAnnotationStyles() {
      return {};
    }
  },
  customize(constructor) {
    constructor.addChange({
      code: 'ANNOTATIONITEMS',
      handler() {
        this._requestChange(['ANNOTATIONS']);
      },
      isOptionChange: true,
      option: 'annotations'
    });
    constructor.addChange({
      code: 'ANNOTATIONSSETTINGS',
      handler() {
        this._requestChange(['ANNOTATIONS']);
      },
      isOptionChange: true,
      option: 'commonAnnotationSettings'
    });
    constructor.addChange({
      code: 'ANNOTATIONS',
      handler() {
        this._buildAnnotations();
        this._setAnnotationTooltipOptions();
        this._forceAnnotationRender();
      },
      isThemeDependent: true,
      isOptionChange: true
    });
  },
  fontFields: ['commonAnnotationSettings.font']
};
var plugins = {
  core: corePlugin,
  chart: chartPlugin,
  polarChart: polarChartPlugin,
  vectorMap: vectorMapPlugin,
  pieChart: pieChartPlugin
};
exports.plugins = plugins;

/***/ }),

/***/ 43637:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.BaseThemeManager = void 0;
var _class = _interopRequireDefault(__webpack_require__(38377));
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _iterator = __webpack_require__(95479);
var _palette = __webpack_require__(23696);
var _utils = __webpack_require__(19157);
var _themes = __webpack_require__(86231);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _getTheme = _themes.getTheme;
var _addCacheItem = _themes.addCacheItem;
var _removeCacheItem = _themes.removeCacheItem;
var _extend = _extend2.extend;
var _each = _iterator.each;
function getThemePart(theme, path) {
  var _theme = theme;
  path && _each(path.split('.'), function (_, pathItem) {
    return _theme = _theme[pathItem];
  });
  return _theme;
}
var BaseThemeManager = _class.default.inherit({
  // TODO: test hack
  ctor: function ctor(options) {
    this._themeSection = options.themeSection;
    this._fontFields = options.fontFields || [];
    _addCacheItem(this);
  },
  dispose: function dispose() {
    var that = this;
    _removeCacheItem(that);
    that._callback = that._theme = that._font = null;
    return that;
  },
  // TODO: Move it to constructor when charts theme managers's constructor is removed
  setCallback: function setCallback(callback) {
    this._callback = callback;
    return this;
  },
  setTheme: function setTheme(theme, rtl) {
    this._current = theme;
    this._rtl = rtl;
    return this.refresh();
  },
  // Officially we do not support objects as "theme" option value - we should stop doing it in code
  refresh: function refresh() {
    var that = this;
    var current = that._current || {};
    var theme = _getTheme(current.name || current);
    that._themeName = theme.name;
    that._defaultPalette = theme.defaultPalette;
    that._font = _extend({}, theme.font, current.font);
    that._themeSection && _each(that._themeSection.split('.'), function (_, path) {
      theme = _extend(true, {}, theme[path]);
    });
    that._theme = _extend(true, {}, theme, (0, _type.isString)(current) ? {} : current);
    that._initializeTheme();
    if ((0, _utils.parseScalar)(that._rtl, that._theme.rtlEnabled)) {
      _extend(true, that._theme, that._theme._rtl);
    }
    that._callback();
    return that;
  },
  theme: function theme(path) {
    return getThemePart(this._theme, path);
  },
  themeName: function themeName() {
    return this._themeName;
  },
  // TODO: May be we need some single method for all palettes?

  createPalette: function createPalette(palette, options) {
    return (0, _palette.createPalette)(palette, options, this._defaultPalette);
  },
  createDiscretePalette: function createDiscretePalette(palette, count) {
    return (0, _palette.getDiscretePalette)(palette, count, this._defaultPalette);
  },
  createGradientPalette: function createGradientPalette(palette) {
    return (0, _palette.getGradientPalette)(palette, this._defaultPalette);
  },
  getAccentColor: function getAccentColor(palette) {
    return (0, _palette.getAccentColor)(palette, this._defaultPalette);
  },
  _initializeTheme: function _initializeTheme() {
    var that = this;
    _each(that._fontFields || [], function (_, path) {
      that._initializeFont(getThemePart(that._theme, path));
    });
  },
  _initializeFont: function _initializeFont(font) {
    _extend(font, this._font, _extend({}, font));
  }
});
exports.BaseThemeManager = BaseThemeManager;

/***/ }),

/***/ 98469:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createEventTrigger = createEventTrigger;
exports.createIncidentOccurred = void 0;
exports.createResizeHandler = createResizeHandler;
var _version = __webpack_require__(36739);
var _string = __webpack_require__(68752);
var _errors_warnings = _interopRequireDefault(__webpack_require__(80726));
var _iterator = __webpack_require__(95479);
var _resize_callbacks = _interopRequireDefault(__webpack_require__(55814));
var _resize_observer = _interopRequireDefault(__webpack_require__(91784));
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var ERROR_MESSAGES = _errors_warnings.default.ERROR_MESSAGES;
function createEventTrigger(eventsMap, callbackGetter) {
  var triggers = {};
  (0, _iterator.each)(eventsMap, function (name, info) {
    if (info.name) {
      createEvent(name);
    }
  });
  var changes;
  triggerEvent.change = function (name) {
    var eventInfo = eventsMap[name];
    if (eventInfo) {
      (changes = changes || {})[name] = eventInfo;
    }
    return !!eventInfo;
  };
  triggerEvent.applyChanges = function () {
    if (changes) {
      (0, _iterator.each)(changes, function (name, eventInfo) {
        createEvent(eventInfo.newName || name);
      });
      changes = null;
    }
  };
  triggerEvent.dispose = function () {
    eventsMap = callbackGetter = triggers = null;
  };
  return triggerEvent;
  function createEvent(name) {
    var eventInfo = eventsMap[name];
    triggers[eventInfo.name] = callbackGetter(name, eventInfo.actionSettings);
  }
  function triggerEvent(name, arg, complete) {
    triggers[name](arg);
    complete && complete();
  }
}
var createIncidentOccurred = function createIncidentOccurred(widgetName, eventTrigger) {
  return function incidentOccurred(id, args) {
    eventTrigger('incidentOccurred', {
      target: {
        id: id,
        type: id[0] === 'E' ? 'error' : 'warning',
        args: args,
        text: _string.format.apply(null, [ERROR_MESSAGES[id]].concat(args || [])),
        widget: widgetName,
        version: _version.version
      }
    });
  };
};
exports.createIncidentOccurred = createIncidentOccurred;
function getResizeManager(resizeCallback) {
  return function (observe, unsubscribe) {
    var _createDeferredHandle = createDeferredHandler(resizeCallback, unsubscribe),
      handler = _createDeferredHandle.handler,
      dispose = _createDeferredHandle.dispose;
    observe(handler);
    return dispose;
  };
}
function createDeferredHandler(callback, unsubscribe) {
  var timeout;
  var handler = function handler() {
    clearTimeout(timeout);
    timeout = setTimeout(callback, 100);
  };
  return {
    handler,
    dispose() {
      clearTimeout(timeout);
      unsubscribe(handler);
    }
  };
}
function createResizeHandler(contentElement, redrawOnResize, resize) {
  var disposeHandler;
  var resizeManager = getResizeManager(resize);
  if ((0, _utils.normalizeEnum)(redrawOnResize) === 'windowonly') {
    disposeHandler = resizeManager(function (handler) {
      return _resize_callbacks.default.add(handler);
    }, function (handler) {
      return _resize_callbacks.default.remove(handler);
    });
  } else if (redrawOnResize === true) {
    disposeHandler = resizeManager(function (handler) {
      return _resize_observer.default.observe(contentElement, handler);
    }, function () {
      return _resize_observer.default.unobserve(contentElement);
    });
  }
  return disposeHandler;
}

/***/ }),

/***/ 56672:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugins = void 0;
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
var pieChartPlugin = {
  name: 'center_template_pie_chart',
  init: _common.noop,
  dispose: function dispose() {
    this._centerTemplateGroup.linkOff().dispose();
  },
  extenders: {
    _createHtmlStructure() {
      var patchedFontOptions = (0, _utils.patchFontOptions)(this._themeManager._font);
      this._centerTemplateGroup = this._renderer.g().attr({
        class: 'dxc-hole-template'
      }).linkOn(this._renderer.root, 'center-template').css(patchedFontOptions).linkAppend();
    },
    _renderExtraElements() {
      this._requestChange(['CENTER_TEMPLATE']);
    }
  },
  members: {
    _renderCenterTemplate() {
      var template = this.option('centerTemplate');
      var centerTemplateGroup = this._centerTemplateGroup.clear();
      if (!template) {
        return;
      }
      centerTemplateGroup.attr({
        visibility: 'hidden'
      });
      var center = this._getCenter();
      this._getTemplate(template).render({
        model: this,
        container: centerTemplateGroup.element,
        onRendered: function onRendered() {
          var group = centerTemplateGroup;
          var bBox = group.getBBox();
          var bBoxCenterX = bBox.x + bBox.width / 2;
          var bBoxCenterY = bBox.y + bBox.height / 2;
          group.move(center.x - bBoxCenterX, center.y - bBoxCenterY);
          group.attr({
            visibility: 'visible'
          });
        }
      });
    }
  },
  customize(constructor) {
    constructor.addChange({
      code: 'CENTER_TEMPLATE',
      handler: function handler() {
        this._renderCenterTemplate();
      },
      option: 'centerTemplate'
    });
  }
};
var gaugePlugin = {
  name: 'center_template_gauge',
  init: _common.noop,
  dispose: pieChartPlugin.dispose,
  extenders: {
    _initCore() {
      this._createCenterTemplateGroup();
    },
    _renderContent() {
      var patchedFontOptions = (0, _utils.patchFontOptions)(this._themeManager._font);
      this._centerTemplateGroup.css(patchedFontOptions);
      this._requestChange(['CENTER_TEMPLATE']);
    },
    _updateExtraElements() {
      this._requestChange(['CENTER_TEMPLATE']);
    }
  },
  members: {
    _renderCenterTemplate: pieChartPlugin.members._renderCenterTemplate,
    _createCenterTemplateGroup() {
      this._centerTemplateGroup = this._renderer.g().attr({
        class: 'dxg-hole-template'
      }).linkOn(this._renderer.root, 'center-template').linkAppend();
    }
  },
  customize: pieChartPlugin.customize
};
var plugins = {
  pieChart: pieChartPlugin,
  gauge: gaugePlugin
};
exports.plugins = plugins;

/***/ }),

/***/ 1539:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _common = __webpack_require__(20576);
var _data_helper = _interopRequireDefault(__webpack_require__(53305));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var postCtor = _data_helper.default.postCtor;
var name;
var members = {
  _dataSourceLoadErrorHandler: function _dataSourceLoadErrorHandler() {
    this._dataSourceChangedHandler();
  },
  _dataSourceOptions: function _dataSourceOptions() {
    return {
      paginate: false
    };
  },
  _updateDataSource: function _updateDataSource() {
    this._refreshDataSource();
    if (!this.option('dataSource')) {
      this._dataSourceChangedHandler();
    }
  },
  _dataIsLoaded: function _dataIsLoaded() {
    return !this._dataSource || this._dataSource.isLoaded();
  },
  _dataSourceItems: function _dataSourceItems() {
    return this._dataSource && this._dataSource.items();
  }
};
for (name in _data_helper.default) {
  if (name === 'postCtor') {
    continue;
  }
  members[name] = _data_helper.default[name];
}
var plugin = {
  name: 'data_source',
  init: function init() {
    postCtor.call(this);
  },
  dispose: _common.noop,
  members: members
};
exports.plugin = plugin;

/***/ }),

/***/ 80726:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _error = _interopRequireDefault(__webpack_require__(95640));
var _errors = _interopRequireDefault(__webpack_require__(17381));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = (0, _error.default)(_errors.default.ERROR_MESSAGES, {
  /**
  * @name ErrorsUIWidgets.E2001
  */
  E2001: 'Invalid data source',
  /**
  * @name ErrorsUIWidgets.E2002
  */
  E2002: 'Axis type and data type are incompatible',
  /**
  * @name ErrorsUIWidgets.E2003
  */
  E2003: 'The "{0}" data source field contains data of unsupported type',
  /**
  * @name ErrorsUIWidgets.E2004
  */
  E2004: 'The "{0}" data source field is inconsistent',
  /**
  * @name ErrorsUIWidgets.E2005
  */
  E2005: 'The value field "{0}" is absent in the data source or all its values are negative',
  /**
  * @name ErrorsUIWidgets.E2006
  */
  E2006: 'A cycle is detected in provided data',
  /**
  * @name ErrorsUIWidgets.E2007
  */
  E2007: 'The value field "{0}" is absent in the data source',
  /**
  * @name ErrorsUIWidgets.E2008
  */
  E2008: 'The value field "{0}" must be a string',
  /**
  * @name ErrorsUIWidgets.E2009
  */
  E2009: 'The value field "{0}" must be a positive numeric value',
  /**
  * @name ErrorsUIWidgets.E2101
  */
  E2101: 'Unknown series type: {0}',
  /**
  * @name ErrorsUIWidgets.E2102
  */
  E2102: 'Ambiguity occurred between two value axes with the same name',
  /**
  * @name ErrorsUIWidgets.E2103
  */
  E2103: 'The "{0}" option is given an invalid value. Assign a function instead',
  /**
  * @name ErrorsUIWidgets.E2104
  */
  E2104: 'Invalid logarithm base',
  /**
  * @name ErrorsUIWidgets.E2105
  */
  E2105: 'Invalid value of a "{0}"',
  /**
  * @name ErrorsUIWidgets.E2202
  */
  E2202: 'Invalid {0} scale value',
  /**
  * @name ErrorsUIWidgets.E2203
  */
  E2203: 'The range you are trying to set is invalid',
  /**
  * @name ErrorsUIWidgets.W2002
  */
  W2002: 'The {0} series cannot be drawn because the {1} data field is missing',
  /**
  * @name ErrorsUIWidgets.W2003
  */
  W2003: 'Tick interval is too small',
  /**
  * @name ErrorsUIWidgets.W2101
  */
  W2101: 'The "{0}" pane does not exist; the last pane is used by default',
  /**
  * @name ErrorsUIWidgets.W2102
  */
  W2102: 'A value axis with the "{0}" name was created automatically',
  /**
  * @name ErrorsUIWidgets.W2103
  */
  W2103: 'The chart title was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2104
  */
  W2104: 'The legend was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2105
  */
  W2105: 'The title of the "{0}" axis was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2106
  */
  W2106: 'The labels of the "{0}" axis were hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2107
  */
  W2107: 'The export menu was hidden due to the container size',
  /**
  * @name ErrorsUIWidgets.W2108
  */
  W2108: 'The browser does not support exporting images to {0} format.',
  /**
  * @name ErrorsUIWidgets.W2301
  */
  W2301: 'Invalid value range'
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82454:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.getMarkup = exports.exportWidgets = exports.exportFromMarkup = exports.combineMarkups = exports.ExportMenu = void 0;
var _extend = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _utils = __webpack_require__(19157);
var _svg = __webpack_require__(19155);
var _exporter = __webpack_require__(78292);
var _message = _interopRequireDefault(__webpack_require__(28109));
var _type = __webpack_require__(35922);
var _themes = __webpack_require__(86231);
var _hover = __webpack_require__(24028);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _console = __webpack_require__(30869);
var _size = __webpack_require__(58664);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var pointerActions = [_pointer.default.down, _pointer.default.move].join(' ');
var BUTTON_SIZE = 35;
var ICON_COORDS = [[9, 12, 26, 12, 26, 14, 9, 14], [9, 17, 26, 17, 26, 19, 9, 19], [9, 22, 26, 22, 26, 24, 9, 24]];
var LIST_PADDING_TOP = 4;
var LIST_WIDTH = 120;
var VERTICAL_TEXT_MARGIN = 8;
var HORIZONTAL_TEXT_MARGIN = 15;
var MENU_ITEM_HEIGHT = 30;
var LIST_STROKE_WIDTH = 1;
var MARGIN = 10;
var SHADOW_OFFSET = 2;
var SHADOW_BLUR = 3;
var DEFAULT_EXPORT_FORMAT = 'PNG';
var ALLOWED_IMAGE_FORMATS = [DEFAULT_EXPORT_FORMAT, 'JPEG', 'GIF'];
var ALLOWED_EXTRA_FORMATS = ['PDF', 'SVG'];
var EXPORT_CSS_CLASS = 'dx-export-menu';
var A4WidthCm = '21cm';
var EXPORT_DATA_KEY = 'export-element-type';
var FORMAT_DATA_KEY = 'export-element-format';
var GET_COLOR_REGEX = /data-backgroundcolor="([^"]*)"/;
function getValidFormats() {
  var imageFormats = _exporter.image.testFormats(ALLOWED_IMAGE_FORMATS);
  return {
    unsupported: imageFormats.unsupported,
    supported: imageFormats.supported.concat(ALLOWED_EXTRA_FORMATS)
  };
}
function validateFormat(format, incidentOccurred, validFormats) {
  validFormats = validFormats || getValidFormats();
  format = String(format).toUpperCase();
  if (validFormats.supported.indexOf(format) !== -1) {
    return format;
  }
  if (validFormats.unsupported.indexOf(format) !== -1) {
    incidentOccurred && incidentOccurred('W2108', [format]);
  }
}
function getCreatorFunc(format) {
  if (format === 'SVG') {
    return _exporter.svg.getData;
  } else if (format === 'PDF') {
    return _exporter.pdf.getData;
  } else {
    return _exporter.image.getData;
  }
}
function print(imageSrc, options) {
  var document = (0, _window.getWindow)().document;
  var iFrame = document.createElement('iframe');
  iFrame.onload = setPrint(imageSrc, options);
  iFrame.style.position = 'fixed';
  iFrame.style.width = '0';
  iFrame.style.height = '0';
  iFrame.style.right = '0';
  iFrame.style.bottom = '0';
  document.body.appendChild(iFrame);
}
function calculatePrintPageWidth(iFrameBody) {
  iFrameBody.style.width = A4WidthCm;
  var width = (0, _size.getWidth)(iFrameBody);
  iFrameBody.style.width = '';
  return width;
}
function setPrint(imageSrc, options) {
  return function () {
    var _this = this;
    var window = this.contentWindow;
    var img = window.document.createElement('img');
    window.document.body.appendChild(img);
    var widthRatio = calculatePrintPageWidth(window.document.body) / options.width;
    if (widthRatio < 1) {
      window.document.body.style.transform = "scale(".concat(widthRatio, ")");
      window.document.body.style['transform-origin'] = '0 0';
    }
    var removeFrame = function removeFrame() {
      _this.parentElement.removeChild(_this);
    };
    img.addEventListener('load', function () {
      window.focus();
      window.print();
    });
    img.addEventListener('error', removeFrame);
    window.addEventListener('afterprint', function () {
      // T933486
      setTimeout(removeFrame, 0); // timeout needed for FF
    });

    img.src = imageSrc;
  };
}
function getItemAttributes(options, type, itemIndex) {
  var x = BUTTON_SIZE - LIST_WIDTH;
  var y = BUTTON_SIZE + LIST_PADDING_TOP + LIST_STROKE_WIDTH + itemIndex * MENU_ITEM_HEIGHT;
  var attr = {
    rect: {
      width: LIST_WIDTH - LIST_STROKE_WIDTH * 2,
      height: MENU_ITEM_HEIGHT,
      x: x + LIST_STROKE_WIDTH,
      y: y
    },
    text: {
      x: x + (options.rtl ? LIST_WIDTH - HORIZONTAL_TEXT_MARGIN : HORIZONTAL_TEXT_MARGIN),
      y: y + MENU_ITEM_HEIGHT - VERTICAL_TEXT_MARGIN
    }
  };
  if (type === 'printing') {
    attr.separator = {
      stroke: options.button.default.borderColor,
      'stroke-width': LIST_STROKE_WIDTH,
      cursor: 'pointer',
      sharp: 'v',
      d: 'M ' + x + ' ' + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH) + ' ' + 'L ' + (x + LIST_WIDTH) + ' ' + (y + MENU_ITEM_HEIGHT - LIST_STROKE_WIDTH)
    };
  }
  return attr;
}
function createMenuItem(renderer, options, settings) {
  var itemData = {};
  var type = settings.type;
  var format = settings.format;
  var attr = getItemAttributes(options, type, settings.itemIndex);
  var fontStyle = (0, _utils.patchFontOptions)(options.font);
  fontStyle['pointer-events'] = 'none';
  var menuItem = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-list-item'
  });
  itemData[EXPORT_DATA_KEY] = type;
  if (format) {
    itemData[FORMAT_DATA_KEY] = format;
  }
  var rect = renderer.rect();
  rect.attr(attr.rect).css({
    cursor: 'pointer',
    'pointer-events': 'all'
  }).data(itemData);
  rect.on(_hover.start + '.export', function () {
    return rect.attr({
      fill: options.button.hover.backgroundColor
    });
  }).on(_hover.end + '.export', function () {
    return rect.attr({
      fill: null
    });
  });
  rect.append(menuItem);
  var text = renderer.text(settings.text).css(fontStyle).attr(attr.text).append(menuItem);
  if (type === 'printing') {
    renderer.path(null, 'line').attr(attr.separator).append(menuItem);
  }
  return {
    g: menuItem,
    rect: rect,
    resetState: function resetState() {
      return rect.attr({
        fill: null
      });
    },
    fixPosition: function fixPosition() {
      var textBBox = text.getBBox();
      text.move(attr.text.x - textBBox.x - (options.rtl ? textBBox.width : 0));
    }
  };
}
function createMenuItems(renderer, options) {
  var items = [];
  if (options.printingEnabled) {
    items.push(createMenuItem(renderer, options, {
      type: 'printing',
      text: _message.default.format('vizExport-printingButtonText'),
      itemIndex: items.length
    }));
  }
  items = options.formats.reduce(function (r, format) {
    r.push(createMenuItem(renderer, options, {
      type: 'exporting',
      text: _message.default.getFormatter('vizExport-exportButtonText')(format),
      format: format,
      itemIndex: r.length
    }));
    return r;
  }, items);
  return items;
}
function getBackgroundColorFromMarkup(markup) {
  var parsedMarkup = GET_COLOR_REGEX.exec(markup);
  return parsedMarkup === null || parsedMarkup === void 0 ? void 0 : parsedMarkup[1];
}
var exportFromMarkup = function exportFromMarkup(markup, options) {
  options.format = validateFormat(options.format) || DEFAULT_EXPORT_FORMAT;
  options.fileName = options.fileName || 'file';
  options.exportingAction = options.onExporting;
  options.exportedAction = options.onExported;
  options.fileSavingAction = options.onFileSaving;
  options.margin = (0, _type.isDefined)(options.margin) ? options.margin : MARGIN;
  options.backgroundColor = (0, _type.isDefined)(options.backgroundColor) ? options.backgroundColor : getBackgroundColorFromMarkup(markup) || (0, _themes.getTheme)().backgroundColor;
  (0, _exporter.export)(markup, options, getCreatorFunc(options.format));
};
exports.exportFromMarkup = exportFromMarkup;
var getMarkup = function getMarkup(widgets) {
  return combineMarkups(widgets).markup;
};
exports.getMarkup = getMarkup;
var exportWidgets = function exportWidgets(widgets, options) {
  options = options || {};
  var markupInfo = combineMarkups(widgets, {
    gridLayout: options.gridLayout,
    verticalAlignment: options.verticalAlignment,
    horizontalAlignment: options.horizontalAlignment
  });
  options.width = markupInfo.width;
  options.height = markupInfo.height;
  exportFromMarkup(markupInfo.markup, options);
};
exports.exportWidgets = exportWidgets;
var combineMarkups = function combineMarkups(widgets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!Array.isArray(widgets)) {
    widgets = [[widgets]];
  } else if (!Array.isArray(widgets[0])) {
    widgets = widgets.map(function (item) {
      return [item];
    });
  }
  var compactView = !options.gridLayout;
  var exportItems = widgets.reduce(function (r, row, rowIndex) {
    var rowInfo = row.reduce(function (r, item, colIndex) {
      var size = item.getSize();
      var backgroundColor = item.option('backgroundColor') || (0, _themes.getTheme)(item.option('theme')).backgroundColor;
      backgroundColor && r.backgroundColors.indexOf(backgroundColor) === -1 && r.backgroundColors.push(backgroundColor);
      r.hOffset = r.width;
      r.width += size.width;
      r.height = Math.max(r.height, size.height);
      r.itemWidth = Math.max(r.itemWidth, size.width);
      r.items.push({
        markup: item.svg(),
        width: size.width,
        height: size.height,
        c: colIndex,
        r: rowIndex,
        hOffset: r.hOffset
      });
      return r;
    }, {
      items: [],
      height: 0,
      itemWidth: 0,
      hOffset: 0,
      width: 0,
      backgroundColors: r.backgroundColors
    });
    r.rowOffsets.push(r.totalHeight);
    r.rowHeights.push(rowInfo.height);
    r.totalHeight += rowInfo.height;
    r.items = r.items.concat(rowInfo.items);
    r.itemWidth = Math.max(r.itemWidth, rowInfo.itemWidth);
    r.maxItemLen = Math.max(r.maxItemLen, rowInfo.items.length);
    r.totalWidth = compactView ? Math.max(r.totalWidth, rowInfo.width) : r.maxItemLen * r.itemWidth;
    return r;
  }, {
    items: [],
    rowOffsets: [],
    rowHeights: [],
    itemWidth: 0,
    totalHeight: 0,
    maxItemLen: 0,
    totalWidth: 0,
    backgroundColors: []
  });
  var backgroundColor = "data-backgroundcolor=\"".concat(exportItems.backgroundColors.length === 1 ? exportItems.backgroundColors[0] : '', "\" ");
  var getVOffset = function getVOffset(item) {
    var align = options.verticalAlignment;
    var dy = exportItems.rowHeights[item.r] - item.height;
    return exportItems.rowOffsets[item.r] + (align === 'bottom' ? dy : align === 'center' ? dy / 2 : 0);
  };
  var getHOffset = function getHOffset(item) {
    if (compactView) {
      return item.hOffset;
    }
    var align = options.horizontalAlignment;
    var colWidth = exportItems.itemWidth;
    var dx = colWidth - item.width;
    return item.c * colWidth + (align === 'right' ? dx : align === 'center' ? dx / 2 : 0);
  };
  var totalHeight = exportItems.totalHeight;
  var totalWidth = exportItems.totalWidth;
  return {
    markup: '<svg ' + backgroundColor + 'height="' + totalHeight + '" width="' + totalWidth + '" version="1.1" xmlns="http://www.w3.org/2000/svg">' + exportItems.items.map(function (item) {
      return "<g transform=\"translate(".concat(getHOffset(item), ",").concat(getVOffset(item), ")\">").concat(item.markup, "</g>");
    }).join('') + '</svg>',
    width: totalWidth,
    height: totalHeight
  };
};
exports.combineMarkups = combineMarkups;
var ExportMenu = function ExportMenu(params) {
  var renderer = this._renderer = params.renderer;
  this._incidentOccurred = params.incidentOccurred;
  this._exportTo = params.exportTo;
  this._print = params.print;
  this._shadow = renderer.shadowFilter('-50%', '-50%', '200%', '200%', SHADOW_OFFSET, 6, SHADOW_BLUR);
  this._shadow.attr({
    opacity: 0.8
  });
  this._group = renderer.g().attr({
    'class': EXPORT_CSS_CLASS,
    [_svg.HIDDEN_FOR_EXPORT]: true
  }).linkOn(renderer.root, {
    name: 'export-menu',
    after: 'peripheral'
  });
  this._buttonGroup = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-button'
  }).append(this._group);
  this._listGroup = renderer.g().attr({
    'class': EXPORT_CSS_CLASS + '-list'
  }).append(this._group);
  this._overlay = renderer.rect(-LIST_WIDTH + BUTTON_SIZE, BUTTON_SIZE + LIST_PADDING_TOP, LIST_WIDTH, 0);
  this._overlay.attr({
    'stroke-width': LIST_STROKE_WIDTH,
    cursor: 'pointer',
    rx: 4,
    ry: 4,
    filter: this._shadow.id
  });
  this._overlay.data({
    'export-element-type': 'list'
  });
  this.validFormats = getValidFormats();
  this._subscribeEvents();
};
exports.ExportMenu = ExportMenu;
(0, _extend.extend)(ExportMenu.prototype, {
  getLayoutOptions() {
    if (this._hiddenDueToLayout) {
      return {
        width: 0,
        height: 0,
        cutSide: 'vertical',
        cutLayoutSide: 'top'
      };
    }
    var bBox = this._buttonGroup.getBBox();
    bBox.cutSide = 'vertical';
    bBox.cutLayoutSide = 'top';
    bBox.height += MARGIN;
    bBox.position = {
      vertical: 'top',
      horizontal: 'right'
    };
    bBox.verticalAlignment = 'top';
    bBox.horizontalAlignment = 'right';
    return bBox;
  },
  shift(_, y) {
    this._group.attr({
      translateY: this._group.attr('translateY') + y
    });
  },
  draw(width, height, canvas) {
    this._group.move(width - BUTTON_SIZE - SHADOW_OFFSET - SHADOW_BLUR + canvas.left, Math.floor(height / 2 - BUTTON_SIZE / 2));
    var layoutOptions = this.getLayoutOptions();
    if (layoutOptions.width > width || layoutOptions.height > height) {
      this.freeSpace();
    }
    return this;
  },
  show() {
    this._group.linkAppend();
  },
  hide() {
    this._group.linkRemove();
  },
  setOptions(options) {
    var _this2 = this;
    this._options = options;
    if (options.formats) {
      options.formats = options.formats.reduce(function (r, format) {
        format = validateFormat(format, _this2._incidentOccurred, _this2.validFormats);
        format && r.push(format);
        return r;
      }, []);
    } else {
      options.formats = this.validFormats.supported.slice();
    }
    options.printingEnabled = options.printingEnabled === undefined ? true : options.printingEnabled;
    if (options.enabled && (options.formats.length || options.printingEnabled)) {
      this.show();
      this._updateButton();
      this._updateList();
      this._hideList();
    } else {
      this.hide();
    }
  },
  dispose() {
    this._unsubscribeEvents();
    this._group.linkRemove().linkOff();
    this._group.dispose();
    this._shadow.dispose();
  },
  // BaseWidget_layout_implementation
  layoutOptions() {
    return this._options.enabled && {
      horizontalAlignment: 'right',
      verticalAlignment: 'top',
      weak: true
    };
  },
  measure() {
    this._fillSpace();
    var margin = this._options.button.margin;
    return [BUTTON_SIZE + margin.left + margin.right, BUTTON_SIZE + margin.top + margin.bottom];
  },
  move(rect) {
    var margin = this._options.button.margin;
    this._group.attr({
      translateX: Math.round(rect[0]) + margin.left,
      translateY: Math.round(rect[1]) + margin.top
    });
  },
  _fillSpace() {
    this._hiddenDueToLayout = false;
    this.show();
  },
  freeSpace() {
    this._incidentOccurred('W2107');
    this._hiddenDueToLayout = true;
    this.hide();
  },
  // BaseWidget_layout_implementation

  _hideList() {
    this._listGroup.remove();
    this._listShown = false;
    this._setButtonState('default');
    this._menuItems.forEach(function (item) {
      return item.resetState();
    });
  },
  _showList() {
    this._listGroup.append(this._group);
    this._listShown = true;
    this._menuItems.forEach(function (item) {
      return item.fixPosition();
    });
  },
  _setButtonState(state) {
    var style = this._options.button[state];
    this._button.attr({
      stroke: style.borderColor,
      fill: style.backgroundColor
    });
    this._icon.attr({
      fill: style.color
    });
  },
  _subscribeEvents() {
    var _this3 = this;
    this._renderer.root.on(_pointer.default.up + '.export', function (e) {
      var elementType = e.target[EXPORT_DATA_KEY];
      if (!elementType) {
        if (_this3._button) {
          _this3._hideList();
        }
        return;
      }
      if (elementType === 'button') {
        if (_this3._listShown) {
          _this3._setButtonState('default');
          _this3._hideList();
        } else {
          _this3._setButtonState('focus');
          _this3._showList();
        }
      } else if (elementType === 'printing') {
        _this3._print();
        _this3._hideList();
      } else if (elementType === 'exporting') {
        _this3._exportTo(e.target[FORMAT_DATA_KEY]);
        _this3._hideList();
      }
    });
    this._listGroup.on(pointerActions, function (e) {
      return e.stopPropagation();
    });
    this._buttonGroup.on(_pointer.default.enter, function () {
      return _this3._setButtonState('hover');
    });
    this._buttonGroup.on(_pointer.default.leave, function () {
      return _this3._setButtonState(_this3._listShown ? 'focus' : 'default');
    });
    this._buttonGroup.on(_pointer.default.down + '.export', function () {
      return _this3._setButtonState('active');
    });
  },
  _unsubscribeEvents() {
    this._renderer.root.off('.export');
    this._listGroup.off();
    this._buttonGroup.off();
  },
  _updateButton() {
    var renderer = this._renderer;
    var options = this._options;
    var exportData = {
      'export-element-type': 'button'
    };
    if (!this._button) {
      this._button = renderer.rect(0, 0, BUTTON_SIZE, BUTTON_SIZE).append(this._buttonGroup);
      this._button.attr({
        rx: 4,
        ry: 4,
        fill: options.button.default.backgroundColor,
        stroke: options.button.default.borderColor,
        'stroke-width': 1,
        cursor: 'pointer'
      });
      this._button.data(exportData);
      this._icon = renderer.path(ICON_COORDS).append(this._buttonGroup);
      this._icon.attr({
        fill: options.button.default.color,
        cursor: 'pointer'
      });
      this._icon.data(exportData);
      this._buttonGroup.setTitle(_message.default.format('vizExport-titleMenuText'));
    }
  },
  _updateList() {
    var options = this._options;
    var buttonDefault = options.button.default;
    var listGroup = this._listGroup;
    var items = createMenuItems(this._renderer, options);
    this._shadow.attr({
      color: options.shadowColor
    });
    this._overlay.attr({
      height: items.length * MENU_ITEM_HEIGHT + LIST_STROKE_WIDTH * 2,
      fill: buttonDefault.backgroundColor,
      stroke: buttonDefault.borderColor
    });
    listGroup.clear();
    this._overlay.append(listGroup);
    items.forEach(function (item) {
      return item.g.append(listGroup);
    });
    this._menuItems = items;
  }
});

// BaseWidget.js
function getExportOptions(widget, exportOptions, fileName, format) {
  if (format || exportOptions.format) {
    format = validateFormat(format || exportOptions.format, widget._incidentOccurred);
  }
  var _widget$getSize = widget.getSize(),
    width = _widget$getSize.width,
    height = _widget$getSize.height;
  return {
    format: format || DEFAULT_EXPORT_FORMAT,
    fileName: fileName || exportOptions.fileName || 'file',
    backgroundColor: exportOptions.backgroundColor,
    width,
    height,
    margin: exportOptions.margin,
    svgToCanvas: exportOptions.svgToCanvas,
    exportingAction: widget._createActionByOption('onExporting', {
      excludeValidators: ['disabled']
    }),
    exportedAction: widget._createActionByOption('onExported', {
      excludeValidators: ['disabled']
    }),
    fileSavingAction: widget._createActionByOption('onFileSaving', {
      excludeValidators: ['disabled']
    })
  };
}
var plugin = {
  name: 'export',
  init() {
    var _this4 = this;
    this._exportMenu = new ExportMenu({
      renderer: this._renderer,
      incidentOccurred: this._incidentOccurred,
      print: function print() {
        return _this4.print();
      },
      exportTo: function exportTo(format) {
        return _this4.exportTo(undefined, format);
      }
    });
    this._layout.add(this._exportMenu);
  },
  dispose() {
    this._exportMenu.dispose();
  },
  members: {
    _getExportMenuOptions() {
      return (0, _extend.extend)({}, this._getOption('export'), {
        rtl: this._getOption('rtlEnabled', true)
      });
    },
    _disablePointerEvents() {
      var pointerEventsValue = this._renderer.root.attr('pointer-events');
      this._renderer.root.attr({
        'pointer-events': 'none'
      });
      return pointerEventsValue;
    },
    exportTo(fileName, format) {
      var _this5 = this;
      var menu = this._exportMenu;
      var options = getExportOptions(this, this._getOption('export') || {}, fileName, format);
      menu && menu.hide();
      var pointerEventsValue = this._disablePointerEvents();
      var promise = (0, _exporter.export)(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(function () {
        _this5._renderer.root.attr({
          'pointer-events': pointerEventsValue
        });
      });
      menu && menu.show();
      return promise;
    },
    print() {
      var _this6 = this;
      var menu = this._exportMenu;
      var options = getExportOptions(this, this._getOption('export') || {});
      options.exportingAction = null;
      options.exportedAction = null;
      options.margin = 0;
      options.format = 'PNG';
      options.useBase64 = true;
      options.fileSavingAction = function (eventArgs) {
        print("data:image/png;base64,".concat(eventArgs.data), {
          width: options.width,
          __test: options.__test
        });
        eventArgs.cancel = true;
      };
      var pointerEventsValue = this._disablePointerEvents();
      menu && menu.hide();
      var promise = (0, _exporter.export)(this._renderer.root.element, options, getCreatorFunc(options.format)).fail(_console.logger.error).always(function () {
        _this6._renderer.root.attr({
          'pointer-events': pointerEventsValue
        });
      });
      menu && menu.show();
      return promise;
    }
  },
  customize(constructor) {
    var proto = constructor.prototype;
    constructor.addChange({
      code: 'EXPORT',
      handler() {
        this._exportMenu.setOptions(this._getExportMenuOptions());
        this._change(['LAYOUT']);
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'export'
    });

    // TODO: Event options change processing either should be done by the eventTrigger or shouldn't be done at all
    proto._optionChangesMap.onExporting = 'EXPORT';
    proto._optionChangesMap.onExported = 'EXPORT';
    proto._optionChangesMap.onFileSaving = 'EXPORT';
  },
  fontFields: ['export.font']
};
exports.plugin = plugin;

/***/ }),

/***/ 3603:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.changes = changes;
exports.expand = expand;
exports.replaceInherit = void 0;
var _extend2 = __webpack_require__(13306);
var _window = __webpack_require__(58201);
var _common = __webpack_require__(20576);
var isServerSide = !(0, _window.hasWindow)();
function Flags() {
  this.reset();
}
Flags.prototype = {
  constructor: Flags,
  add: function add(codes) {
    var i;
    var ii = codes.length;
    var flags = this._flags;
    for (i = 0; i < ii; ++i) {
      flags[codes[i]] = 1;
    }
  },
  has: function has(code) {
    return this._flags[code] > 0;
  },
  count: function count() {
    return Object.keys(this._flags).length;
  },
  reset: function reset() {
    this._flags = {};
  }
};
function combineMaps(baseMap, thisMap) {
  return baseMap !== thisMap ? (0, _extend2.extend)({}, baseMap, thisMap) : (0, _extend2.extend)({}, baseMap);
}
function combineLists(baseList, thisList) {
  return baseList !== thisList ? baseList.concat(thisList) : baseList.slice();
}
function buildTotalChanges(proto) {
  proto._totalChangesOrder = proto._optionChangesOrder.concat(proto._layoutChangesOrder, proto._customChangesOrder);
}
function addChange(settings) {
  var proto = this.prototype;
  var code = settings.code;
  proto['_change_' + code] = settings.handler;
  if (settings.isThemeDependent) {
    proto._themeDependentChanges.push(code);
  }
  if (settings.option) {
    proto._optionChangesMap[settings.option] = code;
  }
  (settings.isOptionChange ? proto._optionChangesOrder : proto._customChangesOrder).push(code);
  buildTotalChanges(proto);
}
function createChainExecutor() {
  var executeChain = function executeChain() {
    var i;
    var ii = executeChain._chain.length;
    var result;
    for (i = 0; i < ii; ++i) {
      result = executeChain._chain[i].apply(this, arguments);
    }
    return result;
  };
  executeChain._chain = [];
  executeChain.add = function (item) {
    executeChain._chain.push(item);
  };
  executeChain.copy = function (executor) {
    executeChain._chain = executor._chain.slice();
  };
  return executeChain;
}
function expand(target, name, expander) {
  var current = target[name];
  if (!current) {
    current = expander;
  } else {
    if (!current.add) {
      current = createChainExecutor();
      current.add(target[name]);
      current.add(expander);
    } else {
      if (Object.prototype.hasOwnProperty.call(target, name) === false) {
        current = createChainExecutor();
        current.copy(target[name]);
      }
      current.add(expander);
    }
  }
  target[name] = current;
}
function addPlugin(plugin) {
  var proto = this.prototype;
  proto._plugins.push(plugin);
  plugin.fontFields && proto._fontFields.push.apply(proto._fontFields, plugin.fontFields);
  if (plugin.members) {
    (0, _extend2.extend)(this.prototype, plugin.members);
  }
  if (plugin.customize) {
    plugin.customize(this);
  }
  if (plugin.extenders) {
    Object.keys(plugin.extenders).forEach(function (key) {
      var func = plugin.extenders[key];
      expand(proto, key, func);
    }, this);
  }
}
var replaceInherit = isServerSide ? function (widget) {
  var _inherit = widget.inherit;
  widget.inherit = function () {
    var result = _inherit.apply(this, arguments);
    var proto = result.prototype;
    ['_plugins', '_eventsMap', '_initialChanges', '_themeDependentChanges', '_optionChangesMap', '_optionChangesOrder', '_layoutChangesOrder', '_customChangesOrder', '_totalChangesOrder'].forEach(function (key) {
      proto[key] = {};
    });
    result.addPlugin = _common.noop;
    return result;
  };
  widget.addChange = _common.noop;
  widget.addPlugin = _common.noop;
} : function (widget) {
  var _inherit = widget.inherit;
  widget.inherit = function () {
    var proto = this.prototype;
    var plugins = proto._plugins;
    var fontFields = proto._fontFields;
    var eventsMap = proto._eventsMap;
    var initialChanges = proto._initialChanges;
    var themeDependentChanges = proto._themeDependentChanges;
    var optionChangesMap = proto._optionChangesMap;
    var partialOptionChangesMap = proto._partialOptionChangesMap;
    var partialOptionChangesPath = proto._partialOptionChangesPath;
    var optionChangesOrder = proto._optionChangesOrder;
    var layoutChangesOrder = proto._layoutChangesOrder;
    var customChangesOrder = proto._customChangesOrder;
    var result = _inherit.apply(this, arguments);
    proto = result.prototype;
    proto._plugins = combineLists(plugins, proto._plugins);
    proto._fontFields = combineLists(fontFields, proto._fontFields);
    proto._eventsMap = combineMaps(eventsMap, proto._eventsMap);
    proto._initialChanges = combineLists(initialChanges, proto._initialChanges);
    proto._themeDependentChanges = combineLists(themeDependentChanges, proto._themeDependentChanges);
    proto._optionChangesMap = combineMaps(optionChangesMap, proto._optionChangesMap);
    proto._partialOptionChangesMap = combineMaps(partialOptionChangesMap, proto._partialOptionChangesMap);
    proto._partialOptionChangesPath = combineMaps(partialOptionChangesPath, proto._partialOptionChangesPath);
    proto._optionChangesOrder = combineLists(optionChangesOrder, proto._optionChangesOrder);
    proto._layoutChangesOrder = combineLists(layoutChangesOrder, proto._layoutChangesOrder);
    proto._customChangesOrder = combineLists(customChangesOrder, proto._customChangesOrder);
    buildTotalChanges(proto);
    result.addPlugin = addPlugin;
    return result;
  };
  widget.prototype._plugins = [];
  widget.prototype._fontFields = [];
  widget.addChange = addChange;
  widget.addPlugin = addPlugin;
};
exports.replaceInherit = replaceInherit;
function changes() {
  return new Flags();
}

/***/ }),

/***/ 94551:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _min = Math.min;
var _max = Math.max;
var _round = Math.round;
var ALIGN_START = 0;
var ALIGN_MIDDLE = 1;
var ALIGN_END = 2;
var horizontalAlignmentMap = {
  left: ALIGN_START,
  center: ALIGN_MIDDLE,
  right: ALIGN_END
};
var verticalAlignmentMap = {
  top: ALIGN_START,
  center: ALIGN_MIDDLE,
  bottom: ALIGN_END
};
var sideMap = {
  horizontal: 0,
  vertical: 1
};
var slicersMap = {};
var BBOX_CEIL_CORRECTION = 2;
slicersMap[ALIGN_START] = function (a, b, size) {
  return [a, _min(b, a + size)];
};
slicersMap[ALIGN_MIDDLE] = function (a, b, size) {
  return [_max(a, (a + b - size) / 2), _min(b, (a + b + size) / 2)];
};
slicersMap[ALIGN_END] = function (a, b, size) {
  return [_max(a, b - size), b];
};
function pickValue(value, map, defaultValue) {
  var val = (0, _utils.normalizeEnum)(value);
  return val in map ? map[val] : defaultValue;
}
function normalizeLayoutOptions(options) {
  var side = pickValue(options.side, sideMap, 1);
  var alignment = [pickValue(options.horizontalAlignment, horizontalAlignmentMap, ALIGN_MIDDLE), pickValue(options.verticalAlignment, verticalAlignmentMap, ALIGN_START)];
  return {
    side: side,
    primary: bringToEdge(alignment[side]),
    secondary: alignment[1 - side],
    weak: options.weak,
    priority: options.priority || 0,
    header: options.header,
    position: options.position
  };
}
function bringToEdge(primary) {
  return primary < 2 ? 0 : 2;
}
function getConjugateSide(side) {
  return 1 - side;
}
function getSlice(alignment, a, b, size) {
  return slicersMap[alignment](a, b, size);
}
function getShrink(alignment, size) {
  return (alignment > 0 ? -1 : +1) * size;
}
function processForward(item, rect, minSize) {
  var side = item.side;
  var size = item.element.measure([rect[2] - rect[0], rect[3] - rect[1]]);
  var minSide = item.position === 'indside' ? 0 : minSize[side];
  var isValid = size[side] < rect[2 + side] - rect[side] - minSide;
  if (isValid) {
    if (item.position !== 'inside') {
      rect[item.primary + side] += getShrink(item.primary, size[side]);
    }
    item.size = size;
  }
  return isValid;
}
function processRectBackward(item, rect, alignmentRect) {
  var primarySide = item.side;
  var secondarySide = getConjugateSide(primarySide);
  var itemRect = [];
  var secondary = getSlice(item.secondary, alignmentRect[secondarySide], alignmentRect[2 + secondarySide], item.size[secondarySide]);
  itemRect[primarySide] = _round(itemRect[2 + primarySide] = rect[item.primary + primarySide] + (item.position === 'inside' ? getShrink(item.primary, item.size[primarySide]) : 0));
  itemRect[item.primary + primarySide] = _round(rect[item.primary + primarySide] - getShrink(item.primary, item.size[primarySide]));
  if (item.position !== 'inside') {
    rect[item.primary + primarySide] = itemRect[item.primary + primarySide];
  }
  itemRect[secondarySide] = _round(secondary[0]);
  itemRect[2 + secondarySide] = _round(secondary[1]);
  return itemRect;
}
function processBackward(item, rect, alignmentRect, fitRect, size, targetRect) {
  var itemRect = processRectBackward(item, rect, alignmentRect);
  var itemFitRect = processRectBackward(item, fitRect, fitRect);
  if (size[item.side] > 0) {
    size[item.side] -= item.size[item.side];
    targetRect[item.primary + item.side] = itemRect[item.primary + item.side];
    item.element.freeSpace();
  } else {
    item.element.move(itemRect, itemFitRect);
  }
}
function Layout() {
  this._targets = [];
}
Layout.prototype = {
  constructor: Layout,
  dispose: function dispose() {
    this._targets = null;
  },
  add: function add(target) {
    this._targets.push(target);
  },
  // Note on possible improvement.
  // "createTargets" part depends on options of a target while the following cycle depends on container size - those areas do not intersect.
  // When any of options are changed targets have to be recreated and cycle has to be executed. But when container size is changed there is no
  // need to recreate targets - only cycle has to be executed.
  forward: function forward(targetRect, minSize) {
    var rect = targetRect.slice();
    var targets = createTargets(this._targets);
    var i;
    var ii = targets.length;
    var cache = [];
    for (i = 0; i < ii; ++i) {
      if (processForward(targets[i], rect, minSize)) {
        cache.push(targets[i]);
      } else {
        targets[i].element.freeSpace();
      }
    }
    this._cache = cache.reverse();
    return rect;
  },
  backward: function backward(targetRect, alignmentRect) {
    var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];
    var backwardRect = targetRect.slice();
    var fitRect = targetRect.slice();
    var targets = this._cache;
    var targetSide = 0;
    var target;
    var i;
    var ii = targets.length;
    for (i = 0; i < ii; ++i) {
      target = targets[i];
      if (target.side !== targetSide) {
        backwardRect = targetRect.slice();
      }
      processBackward(target, backwardRect, alignmentRect, fitRect, size, targetRect);
      targetSide = target.side;
    }
    return size;
  }
};
function createTargets(targets) {
  var i;
  var ii = targets.length;
  var collection = [];
  var layout;
  for (i = 0; i < ii; ++i) {
    layout = targets[i].layoutOptions();
    if (layout) {
      layout = normalizeLayoutOptions(layout);
      layout.element = targets[i];
      collection.push(layout);
    }
  }
  collection.sort(function (a, b) {
    return b.side - a.side || a.priority - b.priority;
  });
  collection = processWeakItems(collection);
  return collection;
}
function processWeakItems(collection) {
  var weakItem = collection.filter(function (item) {
    return item.weak === true;
  })[0];
  var headerItem;
  if (weakItem) {
    headerItem = collection.filter(function (item) {
      return weakItem.primary === item.primary && item.side === weakItem.side && item !== weakItem;
    })[0];
  }
  if (weakItem && headerItem) {
    return [makeHeader(headerItem, weakItem)].concat(collection.filter(function (item) {
      return !(item === headerItem || item === weakItem);
    }));
  }
  return collection;
}
function processBackwardHeaderRect(element, rect) {
  var rectCopy = rect.slice();
  var itemRect = processRectBackward(element, rectCopy, rectCopy);
  itemRect[element.side] = rect[element.side];
  itemRect[2 + element.side] = rect[2 + element.side];
  return itemRect;
}
function makeHeader(header, weakElement) {
  var side = header.side;
  var primary = header.primary;
  var secondary = header.secondary;
  return {
    side: side,
    primary: primary,
    secondary: secondary,
    priority: 0,
    element: {
      measure: function measure(targetSize) {
        var result = targetSize.slice();
        var weakSize = weakElement.element.measure(targetSize.slice());
        targetSize[primary] -= weakSize[primary];
        var headerSize = header.element.measure(targetSize.slice());
        result[side] = weakSize[side] = headerSize[side] = Math.max(headerSize[side], weakSize[side]);
        weakElement.size = weakSize;
        header.size = headerSize;
        return result;
      },
      move: function move(rect, fitRect) {
        if (fitRect[2] - fitRect[0] < header.size[0] + weakElement.size[0] - BBOX_CEIL_CORRECTION) {
          this.freeSpace();
          return;
        }
        var weakRect = processBackwardHeaderRect(weakElement, fitRect);
        fitRect[2 + weakElement.primary] = weakRect[weakElement.primary];
        var headerFitReact = processBackwardHeaderRect(header, fitRect);
        if (fitRect[2 + weakElement.primary] < rect[2 + weakElement.primary] && header.size[header.primary] > rect[2 + header.primary] - rect[header.primary]) {
          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];
        }
        var headerRect = processBackwardHeaderRect(header, rect);
        if (headerRect[2 + weakElement.primary] > fitRect[2 + weakElement.primary]) {
          rect[2 + weakElement.primary] = fitRect[2 + weakElement.primary];
          headerRect = processBackwardHeaderRect(header, rect);
        }
        weakElement.element.move(weakRect);
        header.element.move(headerRect, headerFitReact);
      },
      freeSpace: function freeSpace() {
        header.element.freeSpace();
        weakElement.element.freeSpace();
      }
    }
  };
}
var _default = Layout;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 73711:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LayoutElement = LayoutElement;
exports.WrapperLayoutElement = WrapperLayoutElement;
var _common = __webpack_require__(20576);
var _object = __webpack_require__(48013);
var _round = Math.round;
var defaultOffset = {
  horizontal: 0,
  vertical: 0
};
var alignFactors = {
  center: 0.5,
  right: 1,
  bottom: 1,
  left: 0,
  top: 0
};
function LayoutElement(options) {
  this._options = options;
}
LayoutElement.prototype = {
  constructor: LayoutElement,
  position: function position(options) {
    var that = this;
    var ofBBox = options.of.getLayoutOptions();
    var myBBox = that.getLayoutOptions();
    var at = options.at;
    var my = options.my;
    var offset = options.offset || defaultOffset;
    var shiftX = -alignFactors[my.horizontal] * myBBox.width + ofBBox.x + alignFactors[at.horizontal] * ofBBox.width + parseInt(offset.horizontal);
    var shiftY = -alignFactors[my.vertical] * myBBox.height + ofBBox.y + alignFactors[at.vertical] * ofBBox.height + parseInt(offset.vertical);
    that.shift(_round(shiftX), _round(shiftY));
  },
  getLayoutOptions: _common.noop
};
function WrapperLayoutElement(renderElement, bBox) {
  this._renderElement = renderElement;
  this._cacheBBox = bBox;
}
var wrapperLayoutElementPrototype = WrapperLayoutElement.prototype = (0, _object.clone)(LayoutElement.prototype);
wrapperLayoutElementPrototype.constructor = WrapperLayoutElement;
wrapperLayoutElementPrototype.getLayoutOptions = function () {
  return this._cacheBBox || this._renderElement.getBBox();
};
wrapperLayoutElementPrototype.shift = function (shiftX, shiftY) {
  var bBox = this.getLayoutOptions();
  this._renderElement.move(_round(shiftX - bBox.x), _round(shiftY - bBox.y));
};

/***/ }),

/***/ 64758:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.LoadingIndicator = void 0;
var _utils = __webpack_require__(19157);
var STATE_HIDDEN = 0;
var STATE_SHOWN = 1;
var ANIMATION_EASING = 'linear';
var ANIMATION_DURATION = 400;
var LOADING_INDICATOR_READY = 'loadingIndicatorReady';
var LoadingIndicator = function LoadingIndicator(parameters) {
  var that = this;
  var renderer = parameters.renderer;
  that._group = renderer.g().attr({
    'class': 'dx-loading-indicator'
  }).linkOn(renderer.root, {
    name: 'loading-indicator',
    after: 'peripheral'
  });
  that._rect = renderer.rect().attr({
    opacity: 0
  }).append(that._group);
  that._text = renderer.text().attr({
    align: 'center'
  }).append(that._group);
  that._createStates(parameters.eventTrigger, that._group, renderer.root, parameters.notify);
};
exports.LoadingIndicator = LoadingIndicator;
LoadingIndicator.prototype = {
  constructor: LoadingIndicator,
  _createStates: function _createStates(eventTrigger, group, root, notify) {
    var that = this;
    that._states = [{
      opacity: 0,
      start: function start() {
        notify(false);
      },
      complete: function complete() {
        group.linkRemove();
        root.css({
          'pointer-events': ''
        });
        eventTrigger(LOADING_INDICATOR_READY);
      }
    }, {
      opacity: 0.85,
      start: function start() {
        group.linkAppend();
        root.css({
          'pointer-events': 'none'
        });
        notify(true);
      },
      complete: function complete() {
        eventTrigger(LOADING_INDICATOR_READY);
      }
    }];
    that._state = STATE_HIDDEN;
  },
  setSize: function setSize(size) {
    var width = size.width;
    var height = size.height;
    this._rect.attr({
      width: width,
      height: height
    });
    this._text.attr({
      x: width / 2,
      y: height / 2
    });
  },
  setOptions: function setOptions(options) {
    this._rect.attr({
      fill: options.backgroundColor
    });
    this._text.css((0, _utils.patchFontOptions)(options.font)).attr({
      text: options.text,
      'class': options.cssClass
    });
    this[options.show ? 'show' : 'hide']();
  },
  dispose: function dispose() {
    var that = this;
    that._group.linkRemove().linkOff();
    that._group = that._rect = that._text = that._states = null;
  },
  _transit: function _transit(stateId) {
    var that = this;
    var state;
    if (that._state !== stateId) {
      that._state = stateId;
      that._isHiding = false;
      state = that._states[stateId];
      that._rect.stopAnimation().animate({
        opacity: state.opacity
      }, {
        complete: state.complete,
        easing: ANIMATION_EASING,
        duration: ANIMATION_DURATION,
        unstoppable: true // T261694
      });

      that._noHiding = true;
      state.start();
      that._noHiding = false;
    }
  },
  show: function show() {
    this._transit(STATE_SHOWN);
  },
  hide: function hide() {
    this._transit(STATE_HIDDEN);
  },
  scheduleHiding: function scheduleHiding() {
    if (!this._noHiding) {
      this._isHiding = true;
    }
  },
  fulfillHiding: function fulfillHiding() {
    if (this._isHiding) {
      this.hide();
    }
  }
};
var plugin = {
  name: 'loading_indicator',
  init: function init() {
    var that = this;
    // "exports" is used for testing purposes.
    that._loadingIndicator = new LoadingIndicator({
      eventTrigger: that._eventTrigger,
      renderer: that._renderer,
      notify: notify
    });
    that._scheduleLoadingIndicatorHiding();
    function notify(state) {
      // This flag is used to suppress redundant `_optionChanged` notifications caused by the mechanism that synchronizes the `loadingIndicator.show` option and the loading indicator visibility
      that._skipLoadingIndicatorOptions = true;
      that.option('loadingIndicator', {
        show: state
      });
      that._skipLoadingIndicatorOptions = false;
      if (state) {
        that._stopCurrentHandling();
      }
    }
  },
  dispose: function dispose() {
    this._loadingIndicator.dispose();
    this._loadingIndicator = null;
  },
  members: {
    _scheduleLoadingIndicatorHiding: function _scheduleLoadingIndicatorHiding() {
      this._loadingIndicator.scheduleHiding();
    },
    _fulfillLoadingIndicatorHiding: function _fulfillLoadingIndicatorHiding() {
      this._loadingIndicator.fulfillHiding();
    },
    showLoadingIndicator: function showLoadingIndicator() {
      this._loadingIndicator.show();
    },
    hideLoadingIndicator: function hideLoadingIndicator() {
      this._loadingIndicator.hide();
    },
    _onBeginUpdate: function _onBeginUpdate() {
      if (!this._optionChangedLocker) {
        this._scheduleLoadingIndicatorHiding();
      }
    }
  },
  extenders: {
    _dataSourceLoadingChangedHandler(isLoading) {
      if (isLoading && (this._options.silent('loadingIndicator') || {}).enabled) {
        this._loadingIndicator.show();
      }
    },
    _setContentSize() {
      this._loadingIndicator.setSize(this._canvas);
    },
    endUpdate() {
      if (this._initialized && this._dataIsReady()) {
        this._fulfillLoadingIndicatorHiding();
      }
    }
  },
  customize: function customize(constructor) {
    var proto = constructor.prototype;

    // Of course this looks dirty - but cleaning it is another task. For now it has been just extracted from BaseWidget with minimal changes.
    if (proto._dataSourceChangedHandler) {
      var _dataSourceChangedHandler = proto._dataSourceChangedHandler;
      proto._dataSourceChangedHandler = function () {
        this._scheduleLoadingIndicatorHiding();
        _dataSourceChangedHandler.apply(this, arguments);
      };
    }
    constructor.addChange({
      code: 'LOADING_INDICATOR',
      handler: function handler() {
        if (!this._skipLoadingIndicatorOptions) {
          this._loadingIndicator.setOptions(this._getOption('loadingIndicator'));
        }
        this._scheduleLoadingIndicatorHiding();
      },
      isThemeDependent: true,
      option: 'loadingIndicator',
      isOptionChange: true
    });
    proto._eventsMap.onLoadingIndicatorReady = {
      name: 'loadingIndicatorReady'
    };
    var _drawn = proto._drawn;
    proto._drawn = function () {
      _drawn.apply(this, arguments);
      if (this._dataIsReady()) {
        this._fulfillLoadingIndicatorHiding();
      }
    };
  },
  fontFields: ['loadingIndicator.font']
};
exports.plugin = plugin;

/***/ }),

/***/ 64509:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Plaque = void 0;
var _extend = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _excluded = ["x", "y", "canvas", "offsetX", "offsetY", "offset"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
var math = Math;
var round = math.round;
var max = math.max;
var min = math.min;
var sin = math.sin;
var cos = math.cos;
var asin = math.asin;
var PI = math.PI;
var buildPath = function buildPath() {
  for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
    points[_key] = arguments[_key];
  }
  return points.join('');
};
function getArc(cornerRadius, xDirection, yDirection) {
  return "a ".concat(cornerRadius, " ").concat(cornerRadius, " 0 0 1 ").concat(xDirection * cornerRadius, " ").concat(yDirection * cornerRadius);
}
function getAbsoluteArc(cornerRadius, x, y) {
  return "A ".concat(cornerRadius, " ").concat(cornerRadius, " 0 0 1 ").concat(x, " ").concat(y);
}
function rotateX(x, y, angle, x0, y0) {
  return (x - x0) * round(cos(angle)) + (y - y0) * round(sin(angle)) + x0;
}
function rotateY(x, y, angle, x0, y0) {
  return -(x - x0) * round(sin(angle)) + (y - y0) * round(cos(angle)) + y0;
}
function rotateSize(options, angle) {
  if (angle % 90 === 0 && angle % 180 !== 0) {
    return {
      width: options.height,
      height: options.width
    };
  }
  return options;
}
function getCloudAngle(_ref, x, y, anchorX, anchorY) {
  var width = _ref.width,
    height = _ref.height;
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var xr = Math.ceil(x + halfWidth);
  var xl = Math.floor(x - halfWidth);
  var yt = Math.floor(y - halfHeight);
  var yb = Math.ceil(y + halfHeight);

  // 1 | 2 | 3
  // 8 | 0 | 4
  // 7 | 6 | 5
  if (anchorX < xl && anchorY < yt ||
  // 1
  anchorX >= xl && anchorX <= xr && anchorY < yt // 2
  ) {
    return 270;
  }
  if (anchorX > xr && anchorY > yb ||
  // 5
  anchorX >= xl && anchorX <= xr && anchorY > yb // 6
  ) {
    return 90;
  } else if (anchorX < xl && anchorY > yb ||
  // 7
  anchorX < xl && anchorY >= yt && anchorY <= yb // 8
  ) {
    return 180;
  }
  return 0; // 0, 3, 4
}

function getCloudPoints(_ref2, x, y, anchorX, anchorY, _ref3, bounded) {
  var width = _ref2.width,
    height = _ref2.height;
  var arrowWidth = _ref3.arrowWidth,
    _ref3$cornerRadius = _ref3.cornerRadius,
    cornerRadius = _ref3$cornerRadius === void 0 ? 0 : _ref3$cornerRadius;
  var halfArrowWidth = arrowWidth / 2;
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var xr = Math.ceil(x + halfWidth);
  var xl = Math.floor(x - halfWidth);
  var yt = Math.floor(y - halfHeight);
  var yb = Math.ceil(y + halfHeight);
  var leftTopCorner = [xl, yt];
  var rightTopCorner = [xr, yt];
  var rightBottomCorner = [xr, yb];
  var leftBottomCorner = [xl, yb];
  var arrowX = anchorX <= xl ? xl : xr <= anchorX ? xr : anchorX;
  var arrowY = anchorY <= yt ? yt : yb <= anchorY ? yb : anchorY;
  var arrowBaseBottom = min(arrowY + halfArrowWidth, yb);
  var arrowBaseTop = max(arrowY - halfArrowWidth, yt);
  var arrowBaseLeft = max(arrowX - halfArrowWidth, xl);
  cornerRadius = Math.min(width / 2, height / 2, cornerRadius);
  var points;
  leftTopCorner[1] += cornerRadius;
  rightTopCorner[0] -= cornerRadius;
  rightBottomCorner[1] -= cornerRadius;
  leftBottomCorner[0] += cornerRadius;
  // 1 | 2 | 3
  // 8 | 0 | 4
  // 7 | 6 | 5
  if (!bounded || xl <= anchorX && anchorX <= xr && yt <= anchorY && anchorY <= yb) {
    // 0
    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), 'L', rightTopCorner, getArc(cornerRadius, 1, 1), 'L', rightBottomCorner, getArc(cornerRadius, -1, 1), 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  } else if (anchorX > xr && anchorY < yt) {
    // 3
    var arrowAngle = arrowWidth / cornerRadius || 0;
    var angle = PI / 4 + arrowAngle / 2;
    var endAngle = PI / 4 - arrowAngle / 2;
    var arrowEndPointX = rightTopCorner[0] + cos(endAngle) * cornerRadius;
    var arrowEndPointY = rightTopCorner[1] + (1 - sin(endAngle)) * cornerRadius;
    var arrowArc = buildPath('L', rightTopCorner, getArc(cornerRadius, cos(angle), 1 - sin(angle)), 'L', [anchorX, anchorY, arrowEndPointX, arrowEndPointY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius));
    if (Math.abs(angle) > PI / 2) {
      arrowArc = buildPath('L', [arrowBaseLeft, yt, anchorX, anchorY, xr, arrowBaseBottom]);
    }
    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), arrowArc, 'L', rightBottomCorner, getArc(cornerRadius, -1, 1), 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  } else if (anchorX > xr && anchorY >= yt && anchorY <= yb) {
    // 4
    var _arrowArc;
    if (arrowBaseTop >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', [xr, arrowBaseTop, anchorX, anchorY, xr, arrowBaseBottom], 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightTopCorner[1] + cornerRadius && arrowBaseBottom <= rightBottomCorner[1]) {
      var arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;
      var _angle = arrowWidthRest / cornerRadius;
      var arrowBaseTopX = rightTopCorner[0] + cos(_angle) * cornerRadius;
      var arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle)) * cornerRadius;
      _arrowArc = buildPath(getArc(cornerRadius, cos(_angle), 1 - sin(_angle)), 'L', [arrowBaseTopX, arrowBaseTopY, anchorX, anchorY, xr, arrowBaseBottom], 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop < rightTopCorner[1] + cornerRadius && arrowBaseBottom < rightTopCorner[1] + cornerRadius) {
      var _arrowWidthRest = rightTopCorner[1] + cornerRadius - arrowBaseTop;
      var _arrowAngle = _arrowWidthRest / cornerRadius;
      var _angle2 = _arrowAngle;
      var _arrowBaseTopX = rightTopCorner[0] + cos(_angle2) * cornerRadius;
      var _arrowBaseTopY = rightTopCorner[1] + (1 - sin(_angle2)) * cornerRadius;
      var bottomAngle = Math.sin((rightTopCorner[1] + cornerRadius - arrowBaseBottom) / cornerRadius);
      var arrowBaseBottomX = rightTopCorner[0] + cornerRadius * cos(bottomAngle);
      var arrowBaseBottomY = rightTopCorner[1] + cornerRadius * (1 - sin(bottomAngle));
      _arrowArc = buildPath(getArc(cornerRadius, cos(_angle2), 1 - sin(_angle2)), 'L', [_arrowBaseTopX, _arrowBaseTopY, anchorX, anchorY, arrowBaseBottomX, arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightTopCorner[0] + cornerRadius, rightTopCorner[1] + cornerRadius), 'L', rightBottomCorner, getArc(cornerRadius, -1, 1));
    } else if (arrowBaseTop <= rightTopCorner[1] + cornerRadius && arrowBaseBottom >= rightBottomCorner[1]) {
      var topAngle = asin((rightTopCorner[1] + cornerRadius - arrowBaseTop) / cornerRadius);
      var _arrowBaseTopX2 = rightTopCorner[0] + cornerRadius * cos(topAngle);
      var _arrowBaseTopY2 = rightTopCorner[1] + cornerRadius * (1 - sin(topAngle));
      var _bottomAngle = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
      var _arrowBaseBottomX = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle) - 1);
      var _arrowBaseBottomY = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle);
      _arrowArc = buildPath(getArc(cornerRadius, cos(topAngle), 1 - sin(topAngle)), 'L', [_arrowBaseTopX2, _arrowBaseTopY2, anchorX, anchorY, _arrowBaseBottomX, _arrowBaseBottomY], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseTop <= rightBottomCorner[1] && arrowBaseBottom > rightBottomCorner[1]) {
      var _bottomAngle2 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
      var _arrowBaseBottomX2 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle2) - 1);
      var _arrowBaseBottomY2 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle2);
      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', [xr, arrowBaseTop, anchorX, anchorY, _arrowBaseBottomX2, _arrowBaseBottomY2], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    } else if (arrowBaseTop > rightTopCorner[1] + cornerRadius && arrowBaseBottom > rightBottomCorner[1]) {
      var _bottomAngle3 = asin((arrowBaseBottom - rightBottomCorner[1]) / cornerRadius);
      var _arrowBaseBottomX3 = rightBottomCorner[0] + cornerRadius * (cos(_bottomAngle3) - 1);
      var _arrowBaseBottomY3 = rightBottomCorner[1] + cornerRadius * sin(_bottomAngle3);
      var _topAngle = asin((arrowBaseTop - rightBottomCorner[1]) / cornerRadius);
      var _arrowBaseTopX3 = rightBottomCorner[0] + cornerRadius * (cos(_topAngle) - 1);
      var _arrowBaseTopY3 = rightBottomCorner[1] + cornerRadius * sin(_topAngle);
      _arrowArc = buildPath(getArc(cornerRadius, 1, 1), 'L', rightBottomCorner, getArc(cornerRadius, cos(_topAngle) - 1, sin(_topAngle)), 'L', [_arrowBaseTopX3, _arrowBaseTopY3, anchorX, anchorY, _arrowBaseBottomX3, _arrowBaseBottomY3], getAbsoluteArc(cornerRadius, rightBottomCorner[0] - cornerRadius, rightBottomCorner[1] + cornerRadius));
    }
    points = buildPath(leftTopCorner, getArc(cornerRadius, 1, -1), 'L', rightTopCorner, _arrowArc, 'L', leftBottomCorner, getArc(cornerRadius, -1, -1));
  }
  return buildPath('M', points, 'Z');
}
var Plaque = /*#__PURE__*/function () {
  function Plaque(options, widget, root, contentTemplate) {
    var bounded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    var measureContent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (_, g) {
      return g.getBBox();
    };
    var moveContentGroup = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function (_, g, x, y) {
      return g.move(x, y);
    };
    this.widget = widget;
    this.options = options;
    this.root = root;
    this.contentTemplate = contentTemplate;
    this.bonded = bounded;
    this.measureContent = measureContent;
    this.moveContentGroup = moveContentGroup;
  }
  var _proto = Plaque.prototype;
  _proto.draw = function draw(_ref4) {
    var _this = this;
    var anchorX = _ref4.x,
      anchorY = _ref4.y,
      _ref4$canvas = _ref4.canvas,
      canvas = _ref4$canvas === void 0 ? {} : _ref4$canvas,
      offsetX = _ref4.offsetX,
      offsetY = _ref4.offsetY,
      _ref4$offset = _ref4.offset,
      offset = _ref4$offset === void 0 ? 0 : _ref4$offset,
      restProps = _objectWithoutProperties(_ref4, _excluded);
    var options = this.options;
    var x = options.x,
      y = options.y;
    var bounds = {
      xl: canvas.left,
      xr: canvas.width - canvas.right,
      width: canvas.width - canvas.right - canvas.left,
      yt: canvas.top,
      yb: canvas.height - canvas.bottom,
      height: canvas.height - canvas.bottom - canvas.top
    };
    if (!((0, _type.isDefined)(anchorX) && (0, _type.isDefined)(anchorY)) && !((0, _type.isDefined)(x) && (0, _type.isDefined)(y))) {
      return false;
    }
    if ((0, _type.isDefined)(anchorX) && (anchorX < bounds.xl || bounds.xr < anchorX || anchorY < bounds.yt || bounds.yb < anchorY)) {
      return false;
    }
    if (!this._root) {
      this._draw();
    }
    var shadowSettings = (0, _extend.extend)({
      x: '-50%',
      y: '-50%',
      width: '200%',
      height: '200%'
    }, options.shadow);
    var contentWidth = options.width > 0 ? options.width : null;
    var contentHeight = options.height > 0 ? options.height : null;
    var onRender = function onRender() {
      var _this$_root;
      var bBox = _this._contentBBox = _this.measureContent(_this.widget, _this._contentGroup);
      var size = _this._size = {
        width: max(contentWidth, bBox.width) + options.paddingLeftRight * 2,
        height: max(contentHeight, bBox.height) + options.paddingTopBottom * 2,
        offset
      };
      var xOff = shadowSettings.offsetX;
      var yOff = shadowSettings.offsetY;
      var blur = shadowSettings.blur * 2 + 1;
      var lm = max(blur - xOff, 0); // left margin
      var rm = max(blur + xOff, 0); // right margin
      var tm = max(blur - yOff, 0); // top margin
      var bm = max(blur + yOff, 0); // bottom margin

      _this.margins = {
        lm,
        rm,
        tm,
        bm
      };
      if (!(0, _type.isDefined)(x)) {
        if ((0, _type.isDefined)(offsetX)) {
          x = anchorX + offsetX;
        } else {
          if (bounds.width < size.width) {
            x = round(bounds.xl + bounds.width / 2);
          } else {
            x = min(max(anchorX, Math.ceil(bounds.xl + size.width / 2 + lm)), Math.floor(bounds.xr - size.width / 2 - rm));
          }
        }
      } else {
        x += offsetX || 0;
        if (!(0, _type.isDefined)(anchorX)) {
          anchorX = x;
        }
      }
      if (!(0, _type.isDefined)(y)) {
        if ((0, _type.isDefined)(offsetY)) {
          y = anchorY + offsetY;
        } else {
          var y_top = anchorY - options.arrowLength - size.height / 2 - offset;
          var y_bottom = anchorY + options.arrowLength + size.height / 2 + offset;
          if (bounds.height < size.height + options.arrowLength) {
            y = round(bounds.yt + size.height / 2);
          } else if (y_top - size.height / 2 - tm < bounds.yt) {
            if (y_bottom + size.height / 2 + bm < bounds.yb) {
              y = y_bottom;
              anchorY += offset;
            } else {
              y = round(bounds.yt + size.height / 2);
            }
          } else {
            y = y_top;
            anchorY -= offset;
          }
        }
      } else {
        y += offsetY || 0;
        if (!(0, _type.isDefined)(anchorY)) {
          anchorY = y + size.height / 2;
        }
      }
      _this.anchorX = anchorX;
      _this.anchorY = anchorY;
      _this.move(x, y);
      (_this$_root = _this._root) === null || _this$_root === void 0 ? void 0 : _this$_root.append(_this.root);
    };
    if (this.contentTemplate.render) {
      this.contentTemplate.render({
        model: options,
        container: this._contentGroup.element,
        onRendered: onRender
      });
    } else {
      return this.contentTemplate(_extends({
        group: this._contentGroup,
        onRender
      }, restProps));
    }
    return true;
  };
  _proto._draw = function _draw() {
    var renderer = this.widget._renderer;
    var options = this.options;
    var shadowSettings = (0, _extend.extend)({
      x: '-50%',
      y: '-50%',
      width: '200%',
      height: '200%'
    }, options.shadow);
    var shadow = this._shadow = renderer.shadowFilter().attr(shadowSettings);
    var cloudSettings = {
      opacity: options.opacity,
      'stroke-width': 0,
      fill: options.color
    };
    var borderOptions = options.border || {};
    if (borderOptions.visible) {
      (0, _extend.extend)(cloudSettings, {
        'stroke-width': borderOptions.width,
        stroke: borderOptions.color,
        'stroke-opacity': borderOptions.opacity,
        dashStyle: borderOptions.dashStyle
      });
    }
    var group = this._root = renderer.g().append(this.root);
    if (options.type) {
      group.attr({
        class: "dxc-".concat(options.type, "-annotation")
      });
    }
    var cloudGroup = renderer.g().attr({
      filter: shadow.id
    }).append(group);
    this._cloud = renderer.path([], 'area').attr(cloudSettings).sharp().append(cloudGroup);
    this._contentGroup = renderer.g().append(group);
  };
  _proto.getBBox = function getBBox() {
    var size = this._size || {};
    var margins = this.margins || {};
    var rotationAngle = getCloudAngle(size, this.x, this.y, this.anchorX, this.anchorY);
    return {
      x: Math.floor(this.x - size.width / 2 - margins.lm),
      y: Math.floor(this.y - size.height / 2 - margins.tm - (rotationAngle === 270 ? this.options.arrowLength : 0)),
      width: size.width + margins.lm + margins.rm,
      height: size.height + margins.tm + margins.bm + (rotationAngle === 90 || rotationAngle === 270 ? this.options.arrowLength : 0)
    };
  };
  _proto.clear = function clear() {
    if (this._root) {
      this._root.remove();
      this._shadow.remove();
      this._root = null;
    }
    return this;
  };
  _proto.customizeCloud = function customizeCloud(attr) {
    if (this._cloud) {
      this._cloud.attr(attr);
    }
  };
  _proto.moveRoot = function moveRoot(x, y) {
    if (this._root) {
      this._root.move(x, y);
    }
  };
  _proto.move = function move(x, y) {
    x = round(x);
    y = round(y);
    this.x = x;
    this.y = y;
    var rotationAngle = getCloudAngle(this._size, x, y, this.anchorX, this.anchorY);
    var radRotationAngle = rotationAngle * PI / 180;
    this._cloud.attr({
      d: getCloudPoints(rotateSize(this._size, rotationAngle), x, y, rotateX(this.anchorX, this.anchorY, radRotationAngle, x, y), rotateY(this.anchorX, this.anchorY, radRotationAngle, x, y), this.options, this.bonded)
    }).rotate(rotationAngle, x, y);
    this.moveContentGroup(this.widget, this._contentGroup, x - this._contentBBox.x - this._contentBBox.width / 2, y - this._contentBBox.y - this._contentBBox.height / 2);
  };
  _proto.hitTest = function hitTest(x, y) {
    var _ref5 = this._size || {},
      width = _ref5.width,
      height = _ref5.height;
    return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2;
  };
  return Plaque;
}();
exports.Plaque = Plaque;

/***/ }),

/***/ 91577:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.AnimationController = AnimationController;
exports.easingFunctions = exports.animationSvgStep = void 0;
var _frame = __webpack_require__(90057);
var noop = function noop() {};
var easingFunctions = {
  easeOutCubic: function easeOutCubic(pos, start, end) {
    return pos === 1 ? end : (1 - Math.pow(1 - pos, 3)) * (end - start) + +start;
  },
  linear: function linear(pos, start, end) {
    return pos === 1 ? end : pos * (end - start) + +start;
  }
};
exports.easingFunctions = easingFunctions;
var animationSvgStep = {
  segments: function segments(elem, params, progress, easing, currentParams) {
    var from = params.from;
    var to = params.to;
    var curSeg;
    var seg;
    var i;
    var j;
    var segments = [];
    for (i = 0; i < from.length; i++) {
      curSeg = from[i];
      seg = [curSeg[0]];
      if (curSeg.length > 1) {
        for (j = 1; j < curSeg.length; j++) {
          seg.push(easing(progress, curSeg[j], to[i][j]));
        }
      }
      segments.push(seg);
    }
    currentParams.segments = params.end && progress === 1 ? params.end : segments;
    elem.attr({
      segments: segments
    });
  },
  arc: function arc(elem, params, progress, easing) {
    var from = params.from;
    var to = params.to;
    var current = {};
    for (var i in from) {
      current[i] = easing(progress, from[i], to[i]);
    }
    elem.attr(current);
  },
  transform: function transform(elem, params, progress, easing, currentParams) {
    var from = params.from;
    var to = params.to;
    var current = {};
    for (var i in from) {
      current[i] = currentParams[i] = easing(progress, from[i], to[i]);
    }
    elem.attr(current);
  },
  base: function base(elem, params, progress, easing, currentParams, attributeName) {
    var obj = {};
    obj[attributeName] = currentParams[attributeName] = easing(progress, params.from, params.to);
    elem.attr(obj);
  },
  _: noop,
  complete: function complete(element, currentSettings) {
    element.attr(currentSettings);
  }
};
exports.animationSvgStep = animationSvgStep;
function step(now) {
  var that = this;
  var animateStep = that._animateStep;
  var attrName;
  that._progress = that._calcProgress(now);
  for (attrName in that.params) {
    var anim = animateStep[attrName] || animateStep.base;
    anim(that.element, that.params[attrName], that._progress, that._easing, that._currentParams, attrName);
  }
  that.options.step && that.options.step(that._easing(that._progress, 0, 1), that._progress);
  if (that._progress === 1) return that.stop();
  return true;
}
function delayTick(now) {
  if (now - this._startTime >= this.delay) {
    this.tick = step;
  }
  return true;
}
function start(now) {
  this._startTime = now;
  this.tick = this.delay ? delayTick : step;
  return true;
}
function Animation(element, params, options) {
  var that = this;
  that._progress = 0;
  that.element = element;
  that.params = params;
  that.options = options;
  that.duration = options.partitionDuration ? options.duration * options.partitionDuration : options.duration;
  that.delay = options.delay && options.duration * options.delay || 0;
  that._animateStep = options.animateStep || animationSvgStep;
  that._easing = easingFunctions[options.easing] || easingFunctions['easeOutCubic'];
  that._currentParams = {};
  that.tick = start;
}
Animation.prototype = {
  _calcProgress: function _calcProgress(now) {
    return Math.min(1, (now - this.delay - this._startTime) / this.duration);
  },
  stop: function stop(disableComplete) {
    var that = this;
    var options = that.options;
    var animateStep = that._animateStep;
    that.stop = that.tick = noop;
    animateStep.complete && animateStep.complete(that.element, that._currentParams);
    options.complete && !disableComplete && options.complete();
  }
};
function AnimationController(element) {
  var that = this;
  that._animationCount = 0;
  that._timerId = null;
  that._animations = {};
  that.element = element;
}
AnimationController.prototype = {
  _loop: function _loop() {
    var that = this;
    var animations = that._animations;
    var activeAnimation = 0;
    var now = new Date().getTime();
    var an;
    var endAnimation = that._endAnimation;
    for (an in animations) {
      if (!animations[an].tick(now)) {
        delete animations[an];
      }
      activeAnimation++;
    }
    if (activeAnimation === 0) {
      that.stop();
      that._endAnimationTimer = endAnimation && setTimeout(function () {
        if (that._animationCount === 0) {
          endAnimation();
          that._endAnimation = null;
        }
      });
      return;
    }
    that._timerId = _frame.requestAnimationFrame.call(null, function () {
      that._loop();
    }, that.element);
  },
  addAnimation: function addAnimation(animation) {
    var that = this;
    that._animations[that._animationCount++] = animation;
    clearTimeout(that._endAnimationTimer);
    if (!that._timerId) {
      clearTimeout(that._startDelay);
      that._startDelay = setTimeout(function () {
        that._timerId = 1;
        that._loop();
      }, 0);
    }
  },
  animateElement: function animateElement(elem, params, options) {
    if (elem && params && options) {
      elem.animation && elem.animation.stop();
      this.addAnimation(elem.animation = new Animation(elem, params, options));
    }
  },
  onEndAnimation: function onEndAnimation(endAnimation) {
    this._animationCount ? this._endAnimation = endAnimation : endAnimation();
  },
  dispose: function dispose() {
    this.stop();
    this.element = null;
  },
  stop: function stop() {
    var that = this;
    that._animations = {};
    that._animationCount = 0;
    (0, _frame.cancelAnimationFrame)(that._timerId);
    clearTimeout(that._startDelay);
    clearTimeout(that._endAnimationTimer);
    that._timerId = null;
  },
  lock: function lock() {
    var an;
    var animations = this._animations;
    var unstoppable; // T261694
    var hasUnstoppableInAnimations;
    for (an in animations) {
      unstoppable = animations[an].options.unstoppable;
      hasUnstoppableInAnimations = hasUnstoppableInAnimations || unstoppable;
      if (!unstoppable) {
        animations[an].stop(true);
        delete animations[an];
      }
    }
    !hasUnstoppableInAnimations && this.stop();
  }
};

/***/ }),

/***/ 56453:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.RectSvgElement = exports.PathSvgElement = exports.ArcSvgElement = void 0;
exports.Renderer = Renderer;
exports.TextSvgElement = exports.SvgElement = void 0;
exports.getFuncIri = getFuncIri;
exports.processHatchingAttrs = processHatchingAttrs;
exports.refreshPaths = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _call_once = _interopRequireDefault(__webpack_require__(39618));
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _svg = __webpack_require__(19155);
var _animation = __webpack_require__(91577);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var window = (0, _window.getWindow)();
var max = Math.max,
  round = Math.round;
var SHARPING_CORRECTION = 0.5;
var ARC_COORD_PREC = 5;
var LIGHTENING_HASH = '@filter::lightening';
var pxAddingExceptions = {
  'column-count': true,
  'fill-opacity': true,
  'flex-grow': true,
  'flex-shrink': true,
  'font-weight': true,
  'line-height': true,
  'opacity': true,
  'order': true,
  'orphans': true,
  'widows': true,
  'z-index': true,
  'zoom': true
};
var KEY_TEXT = 'text';
var KEY_STROKE = 'stroke';
var KEY_STROKE_WIDTH = 'stroke-width';
var KEY_STROKE_OPACITY = 'stroke-opacity';
var KEY_FONT_SIZE = 'font-size';
var KEY_FONT_STYLE = 'font-style';
var KEY_FONT_WEIGHT = 'font-weight';
var KEY_TEXT_DECORATION = 'text-decoration';
var KEY_TEXTS_ALIGNMENT = 'textsAlignment';
var NONE = 'none';
var DEFAULT_FONT_SIZE = 12;
var ELLIPSIS = '...';
var objectCreate = function () {
  if (!Object.create) {
    return function (proto) {
      var F = function F() {};
      F.prototype = proto;
      return new F();
    };
  } else {
    return function (proto) {
      return Object.create(proto);
    };
  }
}();
var DEFAULTS = {
  scaleX: 1,
  scaleY: 1,
  'pointer-events': null
};
var getBackup = (0, _call_once.default)(function () {
  var backupContainer = _dom_adapter.default.createElement('div');
  var backupCounter = 0;
  backupContainer.style.left = '-9999px';
  backupContainer.style.position = 'absolute';
  return {
    backupContainer: backupContainer,
    backupCounter: backupCounter
  };
});
function backupRoot(root) {
  if (getBackup().backupCounter === 0) {
    _dom_adapter.default.getBody().appendChild(getBackup().backupContainer);
  }
  ++getBackup().backupCounter;
  root.append({
    element: getBackup().backupContainer
  });
}
function restoreRoot(root, container) {
  root.append({
    element: container
  });
  --getBackup().backupCounter;
  if (getBackup().backupCounter === 0) {
    _dom_adapter.default.getBody().removeChild(getBackup().backupContainer);
  }
}
function isObjectArgument(value) {
  return value && typeof value !== 'string';
}
function createElement(tagName) {
  return _dom_adapter.default.createElementNS('http://www.w3.org/2000/svg', tagName);
}
function getFuncIri(id, pathModified) {
  return id !== null ? 'url(' + (pathModified ? window.location.href.split('#')[0] : '') + '#' + id + ')' : id;
}
function extend(target, source) {
  var key;
  for (key in source) {
    target[key] = source[key];
  }
  return target;
}
var preserveAspectRatioMap = {
  'full': NONE,
  'lefttop': 'xMinYMin',
  'leftcenter': 'xMinYMid',
  'leftbottom': 'xMinYMax',
  'centertop': 'xMidYMin',
  'center': 'xMidYMid',
  'centerbottom': 'xMidYMax',
  'righttop': 'xMaxYMin',
  'rightcenter': 'xMaxYMid',
  'rightbottom': 'xMaxYMax'
};
function processHatchingAttrs(element, attrs) {
  if (attrs.hatching && (0, _utils.normalizeEnum)(attrs.hatching.direction) !== 'none') {
    attrs = extend({}, attrs);
    attrs.fill = element._hatching = element.renderer.lockDefsElements({
      color: attrs.fill,
      hatching: attrs.hatching
    }, element._hatching, 'pattern');
    delete attrs.filter;
  } else if (element._hatching) {
    element.renderer.releaseDefsElements(element._hatching);
    element._hatching = null;
    delete attrs.filter;
  } else if (attrs.filter) {
    attrs = extend({}, attrs);
    attrs.filter = element._filter = element.renderer.lockDefsElements({}, element._filter, 'filter');
  } else if (element._filter) {
    element.renderer.releaseDefsElements(element._filter);
    element._filter = null;
  }
  delete attrs.hatching;
  return attrs;
}

//
// Build path segments
//

var buildArcPath = function buildArcPath(x, y, innerR, outerR, startAngleCos, startAngleSin, endAngleCos, endAngleSin, isCircle, longFlag) {
  return ['M', (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC), 'A', outerR.toFixed(ARC_COORD_PREC), outerR.toFixed(ARC_COORD_PREC), 0, longFlag, 0, (x + outerR * endAngleCos).toFixed(ARC_COORD_PREC), (y - outerR * endAngleSin).toFixed(ARC_COORD_PREC), isCircle ? 'M' : 'L', (x + innerR * endAngleCos).toFixed(5), (y - innerR * endAngleSin).toFixed(ARC_COORD_PREC), 'A', innerR.toFixed(ARC_COORD_PREC), innerR.toFixed(ARC_COORD_PREC), 0, longFlag, 1, (x + innerR * startAngleCos).toFixed(ARC_COORD_PREC), (y - innerR * startAngleSin).toFixed(ARC_COORD_PREC), 'Z'].join(' ');
};
function buildPathSegments(points, type) {
  var list = [['M', 0, 0]];
  switch (type) {
    case 'line':
      list = buildLineSegments(points);
      break;
    case 'area':
      list = buildLineSegments(points, true);
      break;
    case 'bezier':
      list = buildCurveSegments(points);
      break;
    case 'bezierarea':
      list = buildCurveSegments(points, true);
      break;
  }
  return list;
}
function buildLineSegments(points, close) {
  return buildSegments(points, buildSimpleLineSegment, close);
}
function buildCurveSegments(points, close) {
  return buildSegments(points, buildSimpleCurveSegment, close);
}
function buildSegments(points, buildSimpleSegment, close) {
  var _points$;
  var i;
  var ii;
  var list = [];
  if ((_points$ = points[0]) !== null && _points$ !== void 0 && _points$.length) {
    for (i = 0, ii = points.length; i < ii; ++i) {
      buildSimpleSegment(points[i], close, list);
    }
  } else {
    buildSimpleSegment(points, close, list);
  }
  return list;
}
function buildSimpleLineSegment(points, close, list) {
  var i = 0;
  var k0 = list.length;
  var k = k0;
  var ii = (points || []).length;
  if (ii) {
    // backward compatibility
    if (points[0].x !== undefined) {
      for (; i < ii;) {
        list[k++] = ['L', points[i].x, points[i++].y];
      }
    } else {
      for (; i < ii;) {
        list[k++] = ['L', points[i++], points[i++]];
      }
    }
    list[k0][0] = 'M';
  } else {
    list[k] = ['M', 0, 0];
  }
  close && list.push(['Z']);
  return list;
}
function buildSimpleCurveSegment(points, close, list) {
  var i;
  var k = list.length;
  var ii = (points || []).length;
  if (ii) {
    // backward compatibility
    if (points[0].x !== undefined) {
      list[k++] = ['M', points[0].x, points[0].y];
      for (i = 1; i < ii;) {
        list[k++] = ['C', points[i].x, points[i++].y, points[i].x, points[i++].y, points[i].x, points[i++].y];
      }
    } else {
      list[k++] = ['M', points[0], points[1]];
      for (i = 2; i < ii;) {
        list[k++] = ['C', points[i++], points[i++], points[i++], points[i++], points[i++], points[i++]];
      }
    }
  } else {
    list[k] = ['M', 0, 0];
  }
  close && list.push(['Z']);
  return list;
}
function combinePathParam(segments) {
  var d = [];
  var k = 0;
  var i;
  var ii = segments.length;
  var segment;
  var j;
  var jj;
  for (i = 0; i < ii; ++i) {
    segment = segments[i];
    for (j = 0, jj = segment.length; j < jj; ++j) {
      d[k++] = segment[j];
    }
  }
  return d.join(' ');
}
function compensateSegments(oldSegments, newSegments, type) {
  var oldLength = oldSegments.length;
  var newLength = newSegments.length;
  var i;
  var originalNewSegments;
  var makeEqualSegments = type.indexOf('area') !== -1 ? makeEqualAreaSegments : makeEqualLineSegments;
  if (oldLength === 0) {
    for (i = 0; i < newLength; i++) {
      oldSegments.push(newSegments[i].slice(0));
    }
  } else if (oldLength < newLength) {
    makeEqualSegments(oldSegments, newSegments, type);
  } else if (oldLength > newLength) {
    originalNewSegments = newSegments.slice(0);
    makeEqualSegments(newSegments, oldSegments, type);
  }
  return originalNewSegments;
}
function prepareConstSegment(constSeg, type) {
  var x = constSeg[constSeg.length - 2];
  var y = constSeg[constSeg.length - 1];
  switch (type) {
    case 'line':
    case 'area':
      constSeg[0] = 'L';
      break;
    case 'bezier':
    case 'bezierarea':
      constSeg[0] = 'C';
      constSeg[1] = constSeg[3] = constSeg[5] = x;
      constSeg[2] = constSeg[4] = constSeg[6] = y;
      break;
  }
}
function makeEqualLineSegments(short, long, type) {
  var constSeg = short[short.length - 1].slice();
  var i = short.length;
  prepareConstSegment(constSeg, type);
  for (; i < long.length; i++) {
    short[i] = constSeg.slice(0);
  }
}
function makeEqualAreaSegments(short, long, type) {
  var i;
  var head;
  var shortLength = short.length;
  var longLength = long.length;
  var constsSeg1;
  var constsSeg2;
  if ((shortLength - 1) % 2 === 0 && (longLength - 1) % 2 === 0) {
    i = (shortLength - 1) / 2 - 1;
    head = short.slice(0, i + 1);
    constsSeg1 = head[head.length - 1].slice(0);
    constsSeg2 = short.slice(i + 1)[0].slice(0);
    prepareConstSegment(constsSeg1, type);
    prepareConstSegment(constsSeg2, type);
    for (var j = i; j < (longLength - 1) / 2 - 1; j++) {
      short.splice(j + 1, 0, constsSeg1);
      short.splice(j + 3, 0, constsSeg2);
    }
  }
}
function baseCss(that, styles) {
  var elemStyles = that._styles;
  var key;
  var value;
  styles = styles || {};
  for (key in styles) {
    value = styles[key];
    if ((0, _type.isDefined)(value)) {
      value += typeof value === 'number' && !pxAddingExceptions[key] ? 'px' : '';
      elemStyles[key] = value !== '' ? value : null;
    }
  }
  // NOTE: Seems that [].concat is not faster when there are only few entries in the `styles` (and in most cases there are few of them)
  for (key in elemStyles) {
    // The alternative is to *delete* entries in the previous cycle, but it is *delete*!
    value = elemStyles[key];
    if (value) {
      that.element.style[key] = value;
    } else if (value === null) {
      that.element.style[key] = '';
    }
  }
  return that;
}
function fixFuncIri(wrapper, attribute) {
  var element = wrapper.element;
  var id = wrapper.attr(attribute);
  if (id && id.indexOf('DevExpress') !== -1) {
    element.removeAttribute(attribute);
    element.setAttribute(attribute, getFuncIri(id, wrapper.renderer.pathModified));
  }
}
function baseAttr(that, attrs) {
  attrs = attrs || {};
  var settings = that._settings;
  var attributes = {};
  var key;
  var value;
  var elem = that.element;
  var renderer = that.renderer;
  var rtl = renderer.rtl;
  var hasTransformations;
  var recalculateDashStyle;
  var sw;
  var i;
  if (!isObjectArgument(attrs)) {
    if (attrs in settings) {
      return settings[attrs];
    }
    if (attrs in DEFAULTS) {
      return DEFAULTS[attrs];
    }
    return 0;
  }
  extend(attributes, attrs);
  for (key in attributes) {
    value = attributes[key];
    if (value === undefined) {
      continue;
    }
    settings[key] = value;
    if (key === 'align') {
      key = 'text-anchor';
      value = {
        left: rtl ? 'end' : 'start',
        center: 'middle',
        right: rtl ? 'start' : 'end'
      }[value] || null;
    } else if (key === 'dashStyle') {
      recalculateDashStyle = true;
      continue;
    } else if (key === KEY_STROKE_WIDTH) {
      recalculateDashStyle = true;
    } else if (value && (key === 'fill' || key === 'clip-path' || key === 'filter') && value.indexOf('DevExpress') === 0) {
      that._addFixIRICallback();
      value = getFuncIri(value, renderer.pathModified);
    } else if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y)|sharp|sharpDirection)$/i.test(key)) {
      hasTransformations = true;
      continue;
    } else if (/^(x|y|d)$/i.test(key)) {
      // TODO test it
      hasTransformations = true;
    }
    if (value === null) {
      elem.removeAttribute(key);
    } else {
      elem.setAttribute(key, value);
    }
  }
  if (recalculateDashStyle && 'dashStyle' in settings) {
    value = settings.dashStyle;
    sw = ('_originalSW' in that ? that._originalSW : settings[KEY_STROKE_WIDTH]) || 1;
    key = 'stroke-dasharray';
    value = value === null ? '' : (0, _utils.normalizeEnum)(value);
    if (value === '' || value === 'solid' || value === NONE) {
      that.element.removeAttribute(key);
    } else {
      value = value.replace(/longdash/g, '8,3,').replace(/dash/g, '4,3,').replace(/dot/g, '1,3,').replace(/,$/, '').split(',');
      i = value.length;
      while (i--) {
        value[i] = parseInt(value[i]) * sw;
      }
      that.element.setAttribute(key, value.join(','));
    }
  }
  if (hasTransformations) {
    that._applyTransformation();
  }
  return that;
}
function pathAttr(attrs) {
  var that = this;
  var segments;
  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);
    segments = attrs.segments;
    if ('points' in attrs) {
      segments = buildPathSegments(attrs.points, that.type);
      delete attrs.points;
    }
    if (segments) {
      attrs.d = combinePathParam(segments);
      that.segments = segments;
      delete attrs.segments;
    }
  }
  return baseAttr(that, attrs);
}
function arcAttr(attrs) {
  var settings = this._settings;
  var x;
  var y;
  var innerRadius;
  var outerRadius;
  var startAngle;
  var endAngle;
  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);
    if ('x' in attrs || 'y' in attrs || 'innerRadius' in attrs || 'outerRadius' in attrs || 'startAngle' in attrs || 'endAngle' in attrs) {
      settings.x = x = 'x' in attrs ? attrs.x : settings.x;
      delete attrs.x;
      settings.y = y = 'y' in attrs ? attrs.y : settings.y;
      delete attrs.y;
      settings.innerRadius = innerRadius = 'innerRadius' in attrs ? attrs.innerRadius : settings.innerRadius;
      delete attrs.innerRadius;
      settings.outerRadius = outerRadius = 'outerRadius' in attrs ? attrs.outerRadius : settings.outerRadius;
      delete attrs.outerRadius;
      settings.startAngle = startAngle = 'startAngle' in attrs ? attrs.startAngle : settings.startAngle;
      delete attrs.startAngle;
      settings.endAngle = endAngle = 'endAngle' in attrs ? attrs.endAngle : settings.endAngle;
      delete attrs.endAngle;
      attrs.d = buildArcPath.apply(null, (0, _utils.normalizeArcParams)(x, y, innerRadius, outerRadius, startAngle, endAngle));
    }
  }
  return baseAttr(this, attrs);
}
function rectAttr(attrs) {
  var that = this;
  var x;
  var y;
  var width;
  var height;
  var sw;
  var maxSW;
  var newSW;
  if (isObjectArgument(attrs)) {
    attrs = extend({}, attrs);
    if (attrs.x !== undefined || attrs.y !== undefined || attrs.width !== undefined || attrs.height !== undefined || attrs[KEY_STROKE_WIDTH] !== undefined) {
      attrs.x !== undefined ? x = that._originalX = attrs.x : x = that._originalX || 0;
      attrs.y !== undefined ? y = that._originalY = attrs.y : y = that._originalY || 0;
      attrs.width !== undefined ? width = that._originalWidth = attrs.width : width = that._originalWidth || 0;
      attrs.height !== undefined ? height = that._originalHeight = attrs.height : height = that._originalHeight || 0;
      attrs[KEY_STROKE_WIDTH] !== undefined ? sw = that._originalSW = attrs[KEY_STROKE_WIDTH] : sw = that._originalSW;
      maxSW = ~~((width < height ? width : height) / 2);
      newSW = (sw || 0) < maxSW ? sw || 0 : maxSW;
      attrs.x = x + newSW / 2;
      attrs.y = y + newSW / 2;
      attrs.width = width - newSW;
      attrs.height = height - newSW;
      ((sw || 0) !== newSW || !(newSW === 0 && sw === undefined)) && (attrs[KEY_STROKE_WIDTH] = newSW);
    }
    if ('sharp' in attrs) {
      delete attrs.sharp;
    }
  }
  return baseAttr(that, attrs);
}
function textAttr(attrs) {
  var that = this;
  var isResetRequired;
  if (!isObjectArgument(attrs)) {
    return baseAttr(that, attrs);
  }
  attrs = extend({}, attrs);
  var settings = that._settings;
  var wasStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);
  if (attrs[KEY_TEXT] !== undefined) {
    settings[KEY_TEXT] = attrs[KEY_TEXT];
    delete attrs[KEY_TEXT];
    isResetRequired = true;
  }
  if (attrs[KEY_STROKE] !== undefined) {
    settings[KEY_STROKE] = attrs[KEY_STROKE];
    delete attrs[KEY_STROKE];
  }
  if (attrs[KEY_STROKE_WIDTH] !== undefined) {
    settings[KEY_STROKE_WIDTH] = attrs[KEY_STROKE_WIDTH];
    delete attrs[KEY_STROKE_WIDTH];
  }
  if (attrs[KEY_STROKE_OPACITY] !== undefined) {
    settings[KEY_STROKE_OPACITY] = attrs[KEY_STROKE_OPACITY];
    delete attrs[KEY_STROKE_OPACITY];
  }
  if (attrs[KEY_TEXTS_ALIGNMENT] !== undefined) {
    alignTextNodes(that, attrs[KEY_TEXTS_ALIGNMENT]);
    delete attrs[KEY_TEXTS_ALIGNMENT];
  }
  var isStroked = (0, _type.isDefined)(settings[KEY_STROKE]) && (0, _type.isDefined)(settings[KEY_STROKE_WIDTH]);
  baseAttr(that, attrs);
  isResetRequired = isResetRequired || isStroked !== wasStroked && settings[KEY_TEXT];
  if (isResetRequired) {
    createTextNodes(that, settings.text, isStroked);
    that._hasEllipsis = false;
  }
  if (isResetRequired || attrs['x'] !== undefined || attrs['y'] !== undefined) {
    locateTextNodes(that);
  }
  if (isStroked) {
    strokeTextNodes(that);
  }
  return that;
}
function textCss(styles) {
  styles = styles || {};
  baseCss(this, styles);
  if (KEY_FONT_SIZE in styles) {
    locateTextNodes(this);
  }
  return this;
}
function orderHtmlTree(list, line, node, parentStyle, parentClassName) {
  var style;
  var realStyle;
  var i;
  var ii;
  var nodes;
  if (node.wholeText !== undefined) {
    list.push({
      value: node.wholeText,
      style: parentStyle,
      className: parentClassName /* EXPERIMENTAL */,
      line: line,
      height: parentStyle[KEY_FONT_SIZE] || 0
    });
  } else if (node.tagName === 'BR') {
    ++line;
  } else if (_dom_adapter.default.isElementNode(node)) {
    extend(style = {}, parentStyle);
    switch (node.tagName) {
      case 'B':
      case 'STRONG':
        style[KEY_FONT_WEIGHT] = 'bold';
        break;
      case 'I':
      case 'EM':
        style[KEY_FONT_STYLE] = 'italic';
        break;
      case 'U':
        style[KEY_TEXT_DECORATION] = 'underline';
        break;
    }
    realStyle = node.style;
    realStyle.color && (style.fill = realStyle.color);
    realStyle.fontSize && (style[KEY_FONT_SIZE] = realStyle.fontSize);
    realStyle.fontStyle && (style[KEY_FONT_STYLE] = realStyle.fontStyle);
    realStyle.fontWeight && (style[KEY_FONT_WEIGHT] = realStyle.fontWeight);
    realStyle.textDecoration && (style[KEY_TEXT_DECORATION] = realStyle.textDecoration);
    for (i = 0, nodes = node.childNodes, ii = nodes.length; i < ii; ++i) {
      line = orderHtmlTree(list, line, nodes[i], style, node.className || parentClassName);
    }
  }
  return line;
}
function adjustLineHeights(items) {
  var i;
  var ii;
  var currentItem = items[0];
  var item;
  for (i = 1, ii = items.length; i < ii; ++i) {
    item = items[i];
    if (item.line === currentItem.line) {
      // T177039
      currentItem.height = maxLengthFontSize(currentItem.height, item.height);
      currentItem.inherits = currentItem.inherits || parseFloat(item.height) === 0;
      item.height = NaN;
    } else {
      currentItem = item;
    }
  }
}
function removeExtraAttrs(html) {
  var findTagAttrs = /(?:(<[a-z0-9]+\s*))([\s\S]*?)(>|\/>)/gi;
  var findStyleAndClassAttrs = /(style|class)\s*=\s*(["'])(?:(?!\2).)*\2\s?/gi;
  return html.replace(findTagAttrs, function (allTagAttrs, p1, p2, p3) {
    p2 = (p2 && p2.match(findStyleAndClassAttrs) || []).map(function (str) {
      return str;
    }).join(' ');
    return p1 + p2 + p3;
  });
}
function parseHTML(text) {
  var items = [];
  var div = _dom_adapter.default.createElement('div');
  div.innerHTML = text.replace(/\r/g, '').replace(/\n/g, '<br/>').replace(/style=/g, 'data-style=');
  div.querySelectorAll('[data-style]').forEach(function (element) {
    element.style = element.getAttribute('data-style');
    element.removeAttribute('data-style');
  });
  orderHtmlTree(items, 0, div, {}, '');
  adjustLineHeights(items);
  return items;
}
function parseMultiline(text) {
  var texts = text.replace(/\r/g, '').split(/\n/g);
  var i = 0;
  var items = [];
  for (; i < texts.length; i++) {
    items.push({
      value: texts[i].trim(),
      height: 0,
      line: i
    });
  }
  return items;
}
function createTspans(items, element, fieldName) {
  var i;
  var ii;
  var item;
  for (i = 0, ii = items.length; i < ii; ++i) {
    item = items[i];
    item[fieldName] = createElement('tspan');
    item[fieldName].appendChild(_dom_adapter.default.createTextNode(item.value));
    item.style && baseCss({
      element: item[fieldName],
      _styles: {}
    }, item.style);
    item.className && item[fieldName].setAttribute('class', item.className); // EXPERIMENTAL
    element.appendChild(item[fieldName]);
  }
}
function restoreText() {
  if (this._hasEllipsis) {
    this.attr({
      text: this._settings.text
    });
  }
}
function applyEllipsis(maxWidth) {
  var that = this;
  var lines;
  var hasEllipsis = false;
  var i;
  var ii;
  var lineParts;
  var j;
  var jj;
  var text;
  restoreText.call(that);
  var ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
  var ellipsisWidth = ellipsis.getBBox().width;
  if (that._getElementBBox().width > maxWidth) {
    if (maxWidth - ellipsisWidth < 0) {
      maxWidth = 0;
    } else {
      maxWidth -= ellipsisWidth;
    }
    lines = prepareLines(that.element, that._texts, maxWidth);
    for (i = 0, ii = lines.length; i < ii; ++i) {
      lineParts = lines[i].parts;
      if (lines[i].commonLength === 1) {
        continue;
      }
      for (j = 0, jj = lineParts.length; j < jj; ++j) {
        text = lineParts[j];
        if ((0, _type.isDefined)(text.endIndex)) {
          setNewText(text, text.endIndex);
          hasEllipsis = true;
        } else if (text.startBox > maxWidth) {
          removeTextSpan(text);
        }
      }
    }
  }
  ellipsis.remove();
  that._hasEllipsis = hasEllipsis;
  return hasEllipsis;
}
function cloneAndRemoveAttrs(node) {
  var clone;
  if (node) {
    clone = node.cloneNode();
    clone.removeAttribute('y');
    clone.removeAttribute('x');
  }
  return clone || node;
}
function detachTitleElements(element) {
  var titleElements = _dom_adapter.default.querySelectorAll(element, 'title');
  for (var i = 0; i < titleElements.length; i++) {
    element.removeChild(titleElements[i]);
  }
  return titleElements;
}
function detachAndStoreTitleElements(element) {
  var titleElements = detachTitleElements(element);
  return function () {
    for (var i = 0; i < titleElements.length; i++) {
      element.appendChild(titleElements[i]);
    }
  };
}
function setMaxSize(maxWidth, maxHeight) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var that = this;
  var lines = [];
  var textChanged = false;
  var textIsEmpty = false;
  var ellipsisMaxWidth = maxWidth;
  restoreText.call(that);
  var restoreTitleElement = detachAndStoreTitleElements(this.element);
  var ellipsis = that.renderer.text(ELLIPSIS).attr(that._styles).append(that.renderer.root);
  var ellipsisWidth = ellipsis.getBBox().width;
  var _that$_getElementBBox = that._getElementBBox(),
    width = _that$_getElementBBox.width,
    height = _that$_getElementBBox.height;
  if ((width || height) && (width > maxWidth || maxHeight && height > maxHeight)) {
    if (maxWidth - ellipsisWidth < 0) {
      ellipsisMaxWidth = 0;
    } else {
      ellipsisMaxWidth -= ellipsisWidth;
    }
    lines = applyOverflowRules(that.element, that._texts, maxWidth, ellipsisMaxWidth, options);
    lines = setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, parseFloat(this._getLineHeight()));
    this._texts = lines.reduce(function (texts, line) {
      return texts.concat(line.parts);
    }, []).filter(function (t) {
      return t.value !== '';
    }).map(function (t) {
      t.stroke && t.tspan.parentNode.appendChild(t.stroke);
      return t;
    }).map(function (t) {
      t.tspan.parentNode.appendChild(t.tspan);
      return t;
    });
    !this._texts.length && (this._texts = null);
    textChanged = true;
    if (this._texts) {
      locateTextNodes(this);
    } else {
      this.element.textContent = '';
      textIsEmpty = true;
    }
  }
  ellipsis.remove();
  that._hasEllipsis = textChanged;
  restoreTitleElement();
  return {
    rowCount: lines.length,
    textChanged,
    textIsEmpty
  };
}
function getIndexForEllipsis(text, maxWidth, startBox, endBox) {
  var k;
  var kk;
  if (startBox <= maxWidth && endBox > maxWidth) {
    for (k = 1, kk = text.value.length; k <= kk; ++k) {
      if (startBox + text.tspan.getSubStringLength(0, k) > maxWidth) {
        return k - 1;
      }
    }
  }
}
function getTextWidth(text) {
  return text.value.length ? text.tspan.getSubStringLength(0, text.value.length) : 0;
}
function prepareLines(element, texts, maxWidth) {
  var lines = [];
  var i;
  var ii;
  var text;
  var startBox;
  var endBox;
  if (texts) {
    for (i = 0, ii = texts.length; i < ii; ++i) {
      text = texts[i];
      if (!lines[text.line]) {
        text.startBox = startBox = 0;
        lines.push({
          commonLength: text.value.length,
          parts: [text]
        });
      } else {
        text.startBox = startBox;
        lines[text.line].parts.push(text);
        lines[text.line].commonLength += text.value.length;
      }
      endBox = startBox + text.tspan.getSubStringLength(0, text.value.length);
      text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
      startBox = endBox;
    }
  } else {
    text = {
      value: element.textContent,
      tspan: element
    };
    text.startBox = startBox = 0;
    endBox = startBox + getTextWidth(text);
    text.endIndex = getIndexForEllipsis(text, maxWidth, startBox, endBox);
    lines = [{
      commonLength: element.textContent.length,
      parts: [text]
    }];
  }
  return lines;
}
function getSpaceBreakIndex(text, maxWidth) {
  var initialIndices = text.startBox > 0 ? [0] : [];
  var spaceIndices = text.value.split('').reduce(function (indices, char, index) {
    if (char === ' ') {
      indices.push(index);
    }
    return indices;
  }, initialIndices);
  var spaceIndex = 0;
  while (spaceIndices[spaceIndex + 1] !== undefined && text.startBox + text.tspan.getSubStringLength(0, spaceIndices[spaceIndex + 1]) < maxWidth) {
    spaceIndex++;
  }
  return spaceIndices[spaceIndex];
}
function getWordBreakIndex(text, maxWidth) {
  for (var i = 0; i < text.value.length - 1; i++) {
    if (text.startBox + text.tspan.getSubStringLength(0, i + 1) > maxWidth) {
      return i;
    }
  }
}
function getEllipsisString(ellipsisMaxWidth, _ref) {
  var hideOverflowEllipsis = _ref.hideOverflowEllipsis;
  return hideOverflowEllipsis && ellipsisMaxWidth === 0 ? '' : ELLIPSIS;
}
function setEllipsis(text, ellipsisMaxWidth, options) {
  var ellipsis = getEllipsisString(ellipsisMaxWidth, options);
  if (text.value.length && text.tspan.parentNode) {
    for (var i = text.value.length - 1; i >= 1; i--) {
      if (text.startBox + text.tspan.getSubStringLength(0, i) < ellipsisMaxWidth) {
        setNewText(text, i, ellipsis);
        break;
      } else if (i === 1) {
        setNewText(text, 0, ellipsis);
      }
    }
  }
}
function wordWrap(text, maxWidth, ellipsisMaxWidth, options, lastStepBreakIndex) {
  var wholeText = text.value;
  var breakIndex;
  if (options.wordWrap !== 'none') {
    breakIndex = options.wordWrap === 'normal' ? getSpaceBreakIndex(text, maxWidth) : getWordBreakIndex(text, maxWidth);
  }
  var restLines = [];
  var restText;
  if (isFinite(breakIndex) && !(lastStepBreakIndex === 0 && breakIndex === 0)) {
    setNewText(text, breakIndex, '');
    var newTextOffset = wholeText[breakIndex] === ' ' ? 1 : 0;
    var restString = wholeText.slice(breakIndex + newTextOffset);
    if (restString.length) {
      var restTspan = cloneAndRemoveAttrs(text.tspan);
      restTspan.textContent = restString;
      text.tspan.parentNode.appendChild(restTspan);
      restText = extend(extend({}, text), {
        value: restString,
        startBox: 0,
        height: 0,
        tspan: restTspan,
        stroke: cloneAndRemoveAttrs(text.stroke),
        endBox: restTspan.getSubStringLength(0, restString.length)
      });
      restText.stroke && (restText.stroke.textContent = restString);
      if (restText.endBox > maxWidth) {
        restLines = wordWrap(restText, maxWidth, ellipsisMaxWidth, options, breakIndex);
        if (!restLines.length) {
          return [];
        }
      }
    }
  }
  if (text.value.length) {
    if (options.textOverflow === 'ellipsis' && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
      setEllipsis(text, ellipsisMaxWidth, options);
    }
    if (options.textOverflow === 'hide' && text.tspan.getSubStringLength(0, text.value.length) > maxWidth) {
      return [];
    }
  } else {
    text.tspan.parentNode.removeChild(text.tspan);
  }
  var parts = [];
  if (restText) {
    parts.push(restText);
  }
  return [{
    commonLength: wholeText.length,
    parts
  }].concat(restLines);
}
function calculateLineHeight(line, lineHeight) {
  return line.parts.reduce(function (height, text) {
    return max(height, getItemLineHeight(text, lineHeight));
  }, 0);
}
function setMaxHeight(lines, ellipsisMaxWidth, options, maxHeight, lineHeight) {
  var textOverflow = options.textOverflow;
  if (!isFinite(maxHeight) || Number(maxHeight) === 0 || textOverflow === 'none') {
    return lines;
  }
  var result = lines.reduce(function (_ref2, l, index, arr) {
    var _ref3 = _slicedToArray(_ref2, 2),
      lines = _ref3[0],
      commonHeight = _ref3[1];
    var height = calculateLineHeight(l, lineHeight);
    commonHeight += height;
    if (commonHeight < maxHeight) {
      lines.push(l);
    } else {
      l.parts.forEach(function (item) {
        removeTextSpan(item);
      });
      if (textOverflow === 'ellipsis') {
        var prevLine = arr[index - 1];
        if (prevLine) {
          var text = prevLine.parts[prevLine.parts.length - 1];
          if (!text.hasEllipsis) {
            if (ellipsisMaxWidth === 0 || text.endBox < ellipsisMaxWidth) {
              setNewText(text, text.value.length, getEllipsisString(ellipsisMaxWidth, options));
            } else {
              setEllipsis(text, ellipsisMaxWidth, options);
            }
          }
        }
      }
    }
    return [lines, commonHeight];
  }, [[], 0]);
  if (textOverflow === 'hide' && result[1] > maxHeight) {
    result[0].forEach(function (l) {
      l.parts.forEach(function (item) {
        removeTextSpan(item);
      });
    });
    return [];
  }
  return result[0];
}
function applyOverflowRules(element, texts, maxWidth, ellipsisMaxWidth, options) {
  if (!texts) {
    var textValue = element.textContent;
    var text = {
      value: textValue,
      height: 0,
      line: 0
    };
    element.textContent = '';
    createTspans([text], element, 'tspan');
    texts = [text];
  }
  return texts.reduce(function (_ref4, text) {
    var _ref5 = _slicedToArray(_ref4, 5),
      lines = _ref5[0],
      startBox = _ref5[1],
      endBox = _ref5[2],
      stop = _ref5[3],
      lineNumber = _ref5[4];
    var line = lines[lines.length - 1];
    if (stop) {
      return [lines, startBox, endBox, stop];
    }
    if (!line || text.line !== lineNumber) {
      text.startBox = startBox = 0;
      lines.push({
        commonLength: text.value.length,
        parts: [text]
      });
    } else {
      text.startBox = startBox;
      if (startBox > ellipsisMaxWidth && options.wordWrap === 'none' && options.textOverflow === 'ellipsis') {
        removeTextSpan(text);
        return [lines, startBox, endBox, stop, lineNumber];
      }
      line.parts.push(text);
      line.commonLength += text.value.length;
    }
    text.endBox = endBox = startBox + getTextWidth(text);
    startBox = endBox;
    if ((0, _type.isDefined)(maxWidth) && endBox > maxWidth) {
      var wordWrapLines = wordWrap(text, maxWidth, ellipsisMaxWidth, options);
      if (!wordWrapLines.length) {
        lines = [];
        stop = true;
      } else {
        lines = lines.concat(wordWrapLines.filter(function (l) {
          return l.parts.length > 0;
        }));
      }
    }
    return [lines, startBox, endBox, stop, text.line];
  }, [[], 0, 0, false, 0])[0];
}
function setNewText(text, index) {
  var insertString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ELLIPSIS;
  var newText = text.value.substr(0, index) + insertString;
  text.value = text.tspan.textContent = newText;
  text.stroke && (text.stroke.textContent = newText);
  if (insertString === ELLIPSIS) {
    text.hasEllipsis = true;
  }
}
function removeTextSpan(text) {
  text.tspan.parentNode && text.tspan.parentNode.removeChild(text.tspan);
  text.stroke && text.stroke.parentNode && text.stroke.parentNode.removeChild(text.stroke);
}
function createTextNodes(wrapper, text, isStroked) {
  var items;
  var parsedHtml;
  wrapper._texts = null;
  wrapper.clear();
  if (text === null) return;
  text = '' + text;
  if (!wrapper.renderer.encodeHtml && (/<[a-z][\s\S]*>/i.test(text) || text.indexOf('&') !== -1)) {
    parsedHtml = removeExtraAttrs(text);
    items = parseHTML(parsedHtml);
  } else if (/\n/g.test(text)) {
    items = parseMultiline(text);
  } else if (isStroked) {
    items = [{
      value: text.trim(),
      height: 0
    }];
  }
  if (items) {
    if (items.length) {
      // T227388
      wrapper._texts = items;
      if (isStroked) {
        createTspans(items, wrapper.element, KEY_STROKE);
      }
      createTspans(items, wrapper.element, 'tspan');
    }
  } else {
    wrapper.element.appendChild(_dom_adapter.default.createTextNode(text));
  }
}
function setTextNodeAttribute(item, name, value) {
  item.tspan.setAttribute(name, value);
  item.stroke && item.stroke.setAttribute(name, value);
}
function getItemLineHeight(item, defaultValue) {
  return item.inherits ? maxLengthFontSize(item.height, defaultValue) : item.height || defaultValue;
}
function locateTextNodes(wrapper) {
  if (!wrapper._texts) return;
  var items = wrapper._texts;
  var x = wrapper._settings.x;
  var lineHeight = wrapper._getLineHeight();
  var i;
  var ii;
  var item = items[0];
  setTextNodeAttribute(item, 'x', x);
  setTextNodeAttribute(item, 'y', wrapper._settings.y);
  for (i = 1, ii = items.length; i < ii; ++i) {
    item = items[i];
    if (parseFloat(item.height) >= 0) {
      setTextNodeAttribute(item, 'x', x);
      var height = getItemLineHeight(item, lineHeight);
      setTextNodeAttribute(item, 'dy', height); // T177039
    }
  }
}

function alignTextNodes(wrapper, alignment) {
  if (!wrapper._texts || alignment === 'center') {
    return;
  }
  var items = wrapper._texts;
  var direction = alignment === 'left' ? -1 : 1;
  var maxTextWidth = Math.max.apply(Math, items.map(function (t) {
    return getTextWidth(t);
  }));
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var textWidth = getTextWidth(item);
    if (maxTextWidth !== 0 && maxTextWidth !== textWidth) {
      setTextNodeAttribute(item, 'dx', direction * round((maxTextWidth - textWidth) / 2 * 10) / 10);
    }
  }
}
function maxLengthFontSize(fontSize1, fontSize2) {
  var parsedHeight1 = parseFloat(fontSize1);
  var parsedHeight2 = parseFloat(fontSize2);
  var height1 = parsedHeight1 || DEFAULT_FONT_SIZE;
  var height2 = parsedHeight2 || DEFAULT_FONT_SIZE;
  return height1 > height2 ? !isNaN(parsedHeight1) ? fontSize1 : height1 : !isNaN(parsedHeight2) ? fontSize2 : height2;
}
function strokeTextNodes(wrapper) {
  if (!wrapper._texts) return;
  var items = wrapper._texts;
  var stroke = wrapper._settings[KEY_STROKE];
  var strokeWidth = wrapper._settings[KEY_STROKE_WIDTH];
  var strokeOpacity = wrapper._settings[KEY_STROKE_OPACITY] || 1;
  var tspan;
  var i;
  var ii;
  for (i = 0, ii = items.length; i < ii; ++i) {
    tspan = items[i].stroke;
    tspan.setAttribute(KEY_STROKE, stroke);
    tspan.setAttribute(KEY_STROKE_WIDTH, strokeWidth);
    tspan.setAttribute(KEY_STROKE_OPACITY, strokeOpacity);
    tspan.setAttribute('stroke-linejoin', 'round');
  }
}
function baseAnimate(that, params, options, complete) {
  options = options || {};
  var key;
  var value;
  var renderer = that.renderer;
  var settings = that._settings;
  var animationParams = {};
  var defaults = {
    translateX: 0,
    translateY: 0,
    scaleX: 1,
    scaleY: 1,
    rotate: 0,
    rotateX: 0,
    rotateY: 0
  };
  if (complete) {
    options.complete = complete;
  }
  if (renderer.animationEnabled()) {
    for (key in params) {
      value = params[key];
      if (/^(translate(X|Y)|rotate[XY]?|scale(X|Y))$/i.test(key)) {
        animationParams.transform = animationParams.transform || {
          from: {},
          to: {}
        };
        animationParams.transform.from[key] = key in settings ? Number(settings[key].toFixed(3)) : defaults[key]; // T338486
        animationParams.transform.to[key] = value;
      } else if (key === 'arc' || key === 'segments') {
        animationParams[key] = value;
      } else {
        animationParams[key] = {
          from: key in settings ? settings[key] : parseFloat(that.element.getAttribute(key) || 0),
          to: value
        };
      }
    }
    renderer.animateElement(that, animationParams, extend(extend({}, renderer._animation), options));
  } else {
    options.step && options.step.call(that, 1, 1);
    options.complete && options.complete.call(that);
    that.attr(params);
  }
  return that;
}
function pathAnimate(params, options, complete) {
  var that = this;
  var curSegments = that.segments || [];
  var newSegments;
  var endSegments;
  if (that.renderer.animationEnabled() && 'points' in params) {
    newSegments = buildPathSegments(params.points, that.type);
    endSegments = compensateSegments(curSegments, newSegments, that.type);
    params.segments = {
      from: curSegments,
      to: newSegments,
      end: endSegments
    };
    delete params.points;
  }
  return baseAnimate(that, params, options, complete);
}
function arcAnimate(params, options, complete) {
  var that = this;
  var settings = that._settings;
  var arcParams = {
    from: {},
    to: {}
  };
  if (that.renderer.animationEnabled() && ('x' in params || 'y' in params || 'innerRadius' in params || 'outerRadius' in params || 'startAngle' in params || 'endAngle' in params)) {
    arcParams.from.x = settings.x || 0;
    arcParams.from.y = settings.y || 0;
    arcParams.from.innerRadius = settings.innerRadius || 0;
    arcParams.from.outerRadius = settings.outerRadius || 0;
    arcParams.from.startAngle = settings.startAngle || 0;
    arcParams.from.endAngle = settings.endAngle || 0;
    arcParams.to.x = 'x' in params ? params.x : settings.x;
    delete params.x;
    arcParams.to.y = 'y' in params ? params.y : settings.y;
    delete params.y;
    arcParams.to.innerRadius = 'innerRadius' in params ? params.innerRadius : settings.innerRadius;
    delete params.innerRadius;
    arcParams.to.outerRadius = 'outerRadius' in params ? params.outerRadius : settings.outerRadius;
    delete params.outerRadius;
    arcParams.to.startAngle = 'startAngle' in params ? params.startAngle : settings.startAngle;
    delete params.startAngle;
    arcParams.to.endAngle = 'endAngle' in params ? params.endAngle : settings.endAngle;
    delete params.endAngle;
    params.arc = arcParams;
  }
  return baseAnimate(that, params, options, complete);
}
function buildLink(target, parameters) {
  var obj = {
    is: false,
    name: parameters.name || parameters,
    after: parameters.after
  };
  if (target) {
    obj.to = target;
  } else {
    obj.virtual = true;
  }
  return obj;
}

// SvgElement
var SvgElement = function SvgElement(renderer, tagName, type) {
  var that = this;
  that.renderer = renderer;
  that.element = createElement(tagName);
  that._settings = {};
  that._styles = {};
  if (tagName === 'path') {
    that.type = type || 'line';
  }
};
exports.SvgElement = SvgElement;
function removeFuncIriCallback(callback) {
  fixFuncIriCallbacks.remove(callback);
}
SvgElement.prototype = {
  constructor: SvgElement,
  _getJQElement: function _getJQElement() {
    return this._$element || (this._$element = (0, _renderer.default)(this.element));
  },
  _addFixIRICallback: function _addFixIRICallback() {
    var that = this;
    var fn = function fn() {
      fixFuncIri(that, 'fill');
      fixFuncIri(that, 'clip-path');
      fixFuncIri(that, 'filter');
    };
    that.element._fixFuncIri = fn;
    fn.renderer = that.renderer;
    fixFuncIriCallbacks.add(fn);
    that._addFixIRICallback = function () {};
  },
  _clearChildrenFuncIri: function _clearChildrenFuncIri() {
    var clearChildren = function clearChildren(element) {
      var i;
      for (i = 0; i < element.childNodes.length; i++) {
        removeFuncIriCallback(element.childNodes[i]._fixFuncIri);
        clearChildren(element.childNodes[i]);
      }
    };
    clearChildren(this.element);
  },
  dispose: function dispose() {
    removeFuncIriCallback(this.element._fixFuncIri);
    this._clearChildrenFuncIri();
    this._getJQElement().remove();
    return this;
  },
  append: function append(parent) {
    (parent || this.renderer.root).element.appendChild(this.element);
    return this;
  },
  remove: function remove() {
    var element = this.element;
    element.parentNode && element.parentNode.removeChild(element);
    return this;
  },
  // NOTE: Though it is not actually required I think it would be better to explicitly declare usage of link mechanism
  enableLinks: function enableLinks() {
    this._links = [];
    return this;
  },
  virtualLink: function virtualLink(parameters) {
    linkItem({
      _link: buildLink(null, parameters)
    }, this);
    return this;
  },
  linkAfter: function linkAfter(name) {
    this._linkAfter = name;
    return this;
  },
  linkOn: function linkOn(target, parameters) {
    this._link = buildLink(target, parameters);
    linkItem(this, target);
    return this;
  },
  linkOff: function linkOff() {
    unlinkItem(this);
    this._link = null;
    return this;
  },
  // It might be better to traverse list to start (not to end) as widget components more likely will be rendered in the same order as they were created
  linkAppend: function linkAppend() {
    var link = this._link;
    var items = link.to._links;
    var i;
    var next;
    for (i = link.i + 1; (next = items[i]) && !next._link.is; ++i);
    this._insert(link.to, next);
    link.is = true;
    return this;
  },
  // The method exists only for being overridden in vml
  _insert: function _insert(parent, next) {
    parent.element.insertBefore(this.element, next ? next.element : null);
  },
  linkRemove: function linkRemove() {
    this.remove();
    this._link.is = false;
    return this;
  },
  clear: function clear() {
    this._clearChildrenFuncIri(); // T711457
    this._getJQElement().empty();
    return this;
  },
  toBackground: function toBackground() {
    var elem = this.element;
    var parent = elem.parentNode;
    parent && parent.insertBefore(elem, parent.firstChild);
    return this;
  },
  toForeground: function toForeground() {
    var elem = this.element;
    var parent = elem.parentNode;
    parent && parent.appendChild(elem);
    return this;
  },
  attr: function attr(attrs) {
    return baseAttr(this, attrs);
  },
  smartAttr: function smartAttr(attrs) {
    return this.attr(processHatchingAttrs(this, attrs));
  },
  css: function css(styles) {
    return baseCss(this, styles);
  },
  animate: function animate(params, options, complete) {
    return baseAnimate(this, params, options, complete);
  },
  sharp(pos, sharpDirection) {
    return this.attr({
      sharp: pos || true,
      sharpDirection
    });
  },
  _applyTransformation() {
    var tr = this._settings;
    var rotateX;
    var rotateY;
    var transformations = [];
    var sharpMode = tr.sharp;
    var trDirection = tr.sharpDirection || 1;
    var strokeOdd = tr[KEY_STROKE_WIDTH] % 2;
    var correctionX = strokeOdd && (sharpMode === 'h' || sharpMode === true) ? SHARPING_CORRECTION * trDirection : 0;
    var correctionY = strokeOdd && (sharpMode === 'v' || sharpMode === true) ? SHARPING_CORRECTION * trDirection : 0;
    transformations.push('translate(' + ((tr.translateX || 0) + correctionX) + ',' + ((tr.translateY || 0) + correctionY) + ')');
    if (tr.rotate) {
      if ('rotateX' in tr) {
        rotateX = tr.rotateX;
      } else {
        rotateX = tr.x;
      }
      if ('rotateY' in tr) {
        rotateY = tr.rotateY;
      } else {
        rotateY = tr.y;
      }
      transformations.push('rotate(' + tr.rotate + ',' + (rotateX || 0) + ',' + (rotateY || 0) + ')');
    }
    var scaleXDefined = (0, _type.isDefined)(tr.scaleX);
    var scaleYDefined = (0, _type.isDefined)(tr.scaleY);
    if (scaleXDefined || scaleYDefined) {
      transformations.push('scale(' + (scaleXDefined ? tr.scaleX : 1) + ',' + (scaleYDefined ? tr.scaleY : 1) + ')');
    }
    if (transformations.length) {
      this.element.setAttribute('transform', transformations.join(' '));
    }
  },
  move: function move(x, y, animate, animOptions) {
    var obj = {};
    (0, _type.isDefined)(x) && (obj.translateX = x);
    (0, _type.isDefined)(y) && (obj.translateY = y);
    if (!animate) {
      this.attr(obj);
    } else {
      this.animate(obj, animOptions);
    }
    return this;
  },
  rotate: function rotate(angle, x, y, animate, animOptions) {
    var obj = {
      rotate: angle || 0
    };
    (0, _type.isDefined)(x) && (obj.rotateX = x);
    (0, _type.isDefined)(y) && (obj.rotateY = y);
    if (!animate) {
      this.attr(obj);
    } else {
      this.animate(obj, animOptions);
    }
    return this;
  },
  _getElementBBox: function _getElementBBox() {
    var elem = this.element;
    var bBox;
    try {
      bBox = elem.getBBox && elem.getBBox();
    } catch (e) {}
    return bBox || {
      x: 0,
      y: 0,
      width: elem.offsetWidth || 0,
      height: elem.offsetHeight || 0
    };
  },
  // TODO do we need to round results and consider rotation coordinates?
  getBBox: function getBBox() {
    var transformation = this._settings;
    var bBox = this._getElementBBox();
    if (transformation.rotate) {
      bBox = (0, _utils.rotateBBox)(bBox, [('rotateX' in transformation ? transformation.rotateX : transformation.x) || 0, ('rotateY' in transformation ? transformation.rotateY : transformation.y) || 0], -transformation.rotate); // Angle is transformed from svg to right-handed cartesian space
    } else {
      bBox = (0, _utils.normalizeBBox)(bBox);
    }
    return bBox;
  },
  markup: function markup() {
    return (0, _svg.getSvgMarkup)(this.element);
  },
  getOffset: function getOffset() {
    return this._getJQElement().offset();
  },
  stopAnimation: function stopAnimation(disableComplete) {
    var animation = this.animation;
    animation && animation.stop(disableComplete);
    return this;
  },
  setTitle: function setTitle(text) {
    var titleElem = createElement('title');
    titleElem.textContent = text || '';
    this.element.appendChild(titleElem);
  },
  removeTitle() {
    detachTitleElements(this.element);
  },
  data: function data(obj, val) {
    var elem = this.element;
    var key;
    if (val !== undefined) {
      elem[obj] = val;
    } else {
      for (key in obj) {
        elem[key] = obj[key];
      }
    }
    return this;
  },
  on: function on() {
    var args = [this._getJQElement()];
    args.push.apply(args, arguments);
    _events_engine.default.on.apply(_events_engine.default, args);
    return this;
  },
  off: function off() {
    var args = [this._getJQElement()];
    args.push.apply(args, arguments);
    _events_engine.default.off.apply(_events_engine.default, args);
    return this;
  },
  trigger: function trigger() {
    var args = [this._getJQElement()];
    args.push.apply(args, arguments);
    _events_engine.default.trigger.apply(_events_engine.default, args);
    return this;
  }
};
// SvgElement

// PathSvgElement
var PathSvgElement = function PathSvgElement(renderer, type) {
  SvgElement.call(this, renderer, 'path', type);
};
exports.PathSvgElement = PathSvgElement;
PathSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(PathSvgElement.prototype, {
  constructor: PathSvgElement,
  attr: pathAttr,
  animate: pathAnimate
});
// PathSvgElement

// ArcSvgElement
var ArcSvgElement = function ArcSvgElement(renderer) {
  SvgElement.call(this, renderer, 'path', 'arc');
};
exports.ArcSvgElement = ArcSvgElement;
ArcSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(ArcSvgElement.prototype, {
  constructor: ArcSvgElement,
  attr: arcAttr,
  animate: arcAnimate
});
// ArcSvgElement

// RectSvgElement
var RectSvgElement = function RectSvgElement(renderer) {
  SvgElement.call(this, renderer, 'rect');
};
exports.RectSvgElement = RectSvgElement;
RectSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(RectSvgElement.prototype, {
  constructor: RectSvgElement,
  attr: rectAttr
});
// RectSvgElement

// TextSvgElement
var TextSvgElement = function TextSvgElement(renderer) {
  SvgElement.call(this, renderer, 'text');
  this.css({
    'white-space': 'pre'
  });
};
exports.TextSvgElement = TextSvgElement;
TextSvgElement.prototype = objectCreate(SvgElement.prototype);
extend(TextSvgElement.prototype, {
  constructor: TextSvgElement,
  attr: textAttr,
  css: textCss,
  applyEllipsis,
  setMaxSize,
  restoreText,
  _getLineHeight() {
    return !isNaN(parseFloat(this._styles[KEY_FONT_SIZE])) ? this._styles[KEY_FONT_SIZE] : DEFAULT_FONT_SIZE;
  }
});
// TextSvgElement

function updateIndexes(items, k) {
  var i;
  var item;
  for (i = k; item = items[i]; ++i) {
    item._link.i = i;
  }
}
function linkItem(target, container) {
  var items = container._links;
  var key = target._link.after = target._link.after || container._linkAfter;
  var i;
  var item;
  if (key) {
    for (i = 0; (item = items[i]) && item._link.name !== key; ++i);
    if (item) {
      for (++i; (item = items[i]) && item._link.after === key; ++i);
    }
  } else {
    i = items.length;
  }
  items.splice(i, 0, target);
  updateIndexes(items, i);
}
function unlinkItem(target) {
  var i;
  var items = target._link.to._links;
  for (i = 0; items[i] !== target; ++i);
  items.splice(i, 1);
  updateIndexes(items, i);
}
function Renderer(options) {
  var that = this;
  that.root = that._createElement('svg', {
    xmlns: 'http://www.w3.org/2000/svg',
    version: '1.1',
    // Backward compatibility
    fill: NONE,
    stroke: NONE,
    'stroke-width': 0
  }).attr({
    'class': options.cssClass
  }).css({
    'line-height': 'normal',
    // T179515
    '-ms-user-select': NONE,
    '-moz-user-select': NONE,
    '-webkit-user-select': NONE,
    '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)',
    display: 'block',
    overflow: 'hidden'
  });
  that._init();
  that.pathModified = !!options.pathModified;
  that._$container = (0, _renderer.default)(options.container);
  that.root.append({
    element: options.container
  });
  that._locker = 0;
  that._backed = false;
}
Renderer.prototype = {
  constructor: Renderer,
  _init: function _init() {
    var that = this;
    that._defs = that._createElement('defs').append(that.root);
    that._animationController = new _animation.AnimationController(that.root.element);
    that._animation = {
      enabled: true,
      duration: 1000,
      easing: 'easeOutCubic'
    };
  },
  setOptions: function setOptions(options) {
    var that = this;
    that.rtl = !!options.rtl;
    that.encodeHtml = !!options.encodeHtml;
    that.updateAnimationOptions(options.animation || {});
    that.root.attr({
      direction: that.rtl ? 'rtl' : 'ltr'
    });
    return that;
  },
  _createElement: function _createElement(tagName, attr, type) {
    var elem = new SvgElement(this, tagName, type);
    attr && elem.attr(attr);
    return elem;
  },
  lock: function lock() {
    var that = this;
    if (that._locker === 0) {
      that._backed = !that._$container.is(':visible');
      if (that._backed) {
        backupRoot(that.root);
      }
    }
    ++that._locker;
    return that;
  },
  unlock: function unlock() {
    var that = this;
    --that._locker;
    if (that._locker === 0) {
      if (that._backed) {
        restoreRoot(that.root, that._$container[0]);
      }
      that._backed = false;
    }
    return that;
  },
  resize: function resize(width, height) {
    if (width >= 0 && height >= 0) {
      this.root.attr({
        width: width,
        height: height
      });
    }
    return this;
  },
  dispose: function dispose() {
    var that = this;
    var key;
    that.root.dispose();
    that._defs.dispose();
    that._animationController.dispose();
    fixFuncIriCallbacks.removeByRenderer(that);
    for (key in that) {
      that[key] = null;
    }
    return that;
  },
  animationEnabled: function animationEnabled() {
    return !!this._animation.enabled;
  },
  updateAnimationOptions: function updateAnimationOptions(newOptions) {
    extend(this._animation, newOptions);
    return this;
  },
  stopAllAnimations: function stopAllAnimations(lock) {
    this._animationController[lock ? 'lock' : 'stop']();
    return this;
  },
  animateElement: function animateElement(element, params, options) {
    this._animationController.animateElement(element, params, options);
    return this;
  },
  svg: function svg() {
    return this.root.markup();
  },
  getRootOffset: function getRootOffset() {
    return this.root.getOffset();
  },
  onEndAnimation: function onEndAnimation(endAnimation) {
    this._animationController.onEndAnimation(endAnimation);
  },
  rect: function rect(x, y, width, height) {
    var elem = new RectSvgElement(this);
    return elem.attr({
      x: x || 0,
      y: y || 0,
      width: width || 0,
      height: height || 0
    });
  },
  simpleRect: function simpleRect() {
    return this._createElement('rect');
  },
  circle: function circle(x, y, r) {
    return this._createElement('circle', {
      cx: x || 0,
      cy: y || 0,
      r: r || 0
    });
  },
  g: function g() {
    return this._createElement('g');
  },
  image: function image(x, y, w, h, href, location) {
    var image = this._createElement('image', {
      x: x || 0,
      y: y || 0,
      width: w || 0,
      height: h || 0,
      preserveAspectRatio: preserveAspectRatioMap[(0, _utils.normalizeEnum)(location)] || NONE
    });
    image.element.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href || '');
    return image;
  },
  // to combine different d attributes use helper methods
  path: function path(points, type) {
    var elem = new PathSvgElement(this, type);
    return elem.attr({
      points: points || []
    });
  },
  // TODO check B232257
  // TODO animate end angle special case
  arc: function arc(x, y, innerRadius, outerRadius, startAngle, endAngle) {
    var elem = new ArcSvgElement(this);
    return elem.attr({
      x: x || 0,
      y: y || 0,
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || 0,
      startAngle: startAngle || 0,
      endAngle: endAngle || 0
    });
  },
  text: function text(_text, x, y) {
    var elem = new TextSvgElement(this);
    return elem.attr({
      text: _text,
      x: x || 0,
      y: y || 0
    });
  },
  linearGradient: function linearGradient(stops) {
    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _utils.getNextDefsSvgId)();
    var rotationAngle = arguments.length > 2 ? arguments[2] : undefined;
    var gradient = this._createElement('linearGradient', {
      id,
      gradientTransform: "rotate(".concat(rotationAngle || 0, ")")
    }).append(this._defs);
    gradient.id = id;
    this._createGradientStops(stops, gradient);
    return gradient;
  },
  radialGradient: function radialGradient(stops, id) {
    var gradient = this._createElement('radialGradient', {
      id
    }).append(this._defs);
    this._createGradientStops(stops, gradient);
    return gradient;
  },
  _createGradientStops: function _createGradientStops(stops, group) {
    var _this = this;
    stops.forEach(function (stop) {
      var _stop$stopColor;
      _this._createElement('stop', {
        offset: stop.offset,
        'stop-color': (_stop$stopColor = stop['stop-color']) !== null && _stop$stopColor !== void 0 ? _stop$stopColor : stop.color,
        'stop-opacity': stop.opacity
      }).append(group);
    });
  },
  // appended automatically
  pattern: function pattern(color, hatching, _id) {
    hatching = hatching || {};
    var that = this;
    var step = hatching.step || 6;
    var stepTo2 = step / 2;
    var stepBy15 = step * 1.5;
    var id = _id || (0, _utils.getNextDefsSvgId)();
    var d = (0, _utils.normalizeEnum)(hatching.direction) === 'right' ? 'M ' + stepTo2 + ' ' + -stepTo2 + ' L ' + -stepTo2 + ' ' + stepTo2 + ' M 0 ' + step + ' L ' + step + ' 0 M ' + stepBy15 + ' ' + stepTo2 + ' L ' + stepTo2 + ' ' + stepBy15 : 'M 0 0 L ' + step + ' ' + step + ' M ' + -stepTo2 + ' ' + stepTo2 + ' L ' + stepTo2 + ' ' + stepBy15 + ' M ' + stepTo2 + ' ' + -stepTo2 + ' L ' + stepBy15 + ' ' + stepTo2;
    var pattern = that._createElement('pattern', {
      id: id,
      width: step,
      height: step,
      patternUnits: 'userSpaceOnUse'
    }).append(that._defs);
    pattern.id = id;
    var rect = that.rect(0, 0, step, step).attr({
      fill: color,
      opacity: hatching.opacity
    }).append(pattern);
    var path = new PathSvgElement(this).attr({
      d: d,
      'stroke-width': hatching.width || 1,
      stroke: color
    }).append(pattern);
    return pattern;
  },
  customPattern: function customPattern(id, template, width, height) {
    var option = {
      id,
      width,
      height,
      patternContentUnits: 'userSpaceOnUse',
      patternUnits: this._getPatternUnits(width, height)
    };
    var pattern = this._createElement('pattern', option).append(this._defs);
    template.render({
      container: pattern.element
    });
    return pattern;
  },
  _getPatternUnits: function _getPatternUnits(width, height) {
    if (Number(width) && Number(height)) {
      return 'userSpaceOnUse';
    }
  },
  _getPointsWithYOffset: function _getPointsWithYOffset(points, offset) {
    return points.map(function (point, index) {
      if (index % 2 !== 0) {
        return point + offset;
      }
      return point;
    });
  },
  // appended automatically
  clipShape: function clipShape(method, methodArgs) {
    var that = this;
    var id = (0, _utils.getNextDefsSvgId)();
    var clipPath = that._createElement('clipPath', {
      id: id
    }).append(that._defs);
    var shape = method.apply(that, methodArgs).append(clipPath);
    shape.id = id;
    shape.remove = function () {
      throw 'Not implemented';
    };
    shape.dispose = function () {
      clipPath.dispose();
      clipPath = null;
      return this;
    };
    return shape;
  },
  // appended automatically
  clipRect(x, y, width, height) {
    return this.clipShape(this.rect, arguments);
  },
  // appended automatically
  clipCircle(x, y, radius) {
    return this.clipShape(this.circle, arguments);
  },
  // appended automatically
  shadowFilter: function shadowFilter(x, y, width, height, offsetX, offsetY, blur, color, opacity) {
    var that = this;
    var id = (0, _utils.getNextDefsSvgId)();
    var filter = that._createElement('filter', {
      id: id,
      x: x || 0,
      y: y || 0,
      width: width || 0,
      height: height || 0
    }).append(that._defs);
    var gaussianBlur = that._createElement('feGaussianBlur', {
      'in': 'SourceGraphic',
      'result': 'gaussianBlurResult',
      'stdDeviation': blur || 0
    }).append(filter);
    var offset = that._createElement('feOffset', {
      'in': 'gaussianBlurResult',
      'result': 'offsetResult',
      'dx': offsetX || 0,
      'dy': offsetY || 0
    }).append(filter);
    var flood = that._createElement('feFlood', {
      'result': 'floodResult',
      'flood-color': color || '',
      'flood-opacity': opacity
    }).append(filter);
    var composite = that._createElement('feComposite', {
      'in': 'floodResult',
      'in2': 'offsetResult',
      'operator': 'in',
      'result': 'compositeResult'
    }).append(filter);
    var finalComposite = that._createElement('feComposite', {
      'in': 'SourceGraphic',
      'in2': 'compositeResult',
      'operator': 'over'
    }).append(filter);
    filter.id = id;
    filter.gaussianBlur = gaussianBlur;
    filter.offset = offset;
    filter.flood = flood;
    filter.composite = composite;
    filter.finalComposite = finalComposite;
    filter.attr = function (attrs) {
      var that = this;
      var filterAttrs = {};
      var offsetAttrs = {};
      var floodAttrs = {};
      'x' in attrs && (filterAttrs.x = attrs.x);
      'y' in attrs && (filterAttrs.y = attrs.y);
      'width' in attrs && (filterAttrs.width = attrs.width);
      'height' in attrs && (filterAttrs.height = attrs.height);
      baseAttr(that, filterAttrs);
      'blur' in attrs && that.gaussianBlur.attr({
        'stdDeviation': attrs.blur
      });
      'offsetX' in attrs && (offsetAttrs.dx = attrs.offsetX);
      'offsetY' in attrs && (offsetAttrs.dy = attrs.offsetY);
      that.offset.attr(offsetAttrs);
      'color' in attrs && (floodAttrs['flood-color'] = attrs.color);
      'opacity' in attrs && (floodAttrs['flood-opacity'] = attrs.opacity);
      that.flood.attr(floodAttrs);
      return that;
    };
    return filter;
  },
  brightFilter: function brightFilter(type, slope) {
    var that = this;
    var id = (0, _utils.getNextDefsSvgId)();
    var filter = that._createElement('filter', {
      id: id
    }).append(that._defs);
    var componentTransferElement = that._createElement('feComponentTransfer').append(filter);
    var attrs = {
      type: type,
      slope: slope
    };
    filter.id = id;
    that._createElement('feFuncR', attrs).append(componentTransferElement);
    that._createElement('feFuncG', attrs).append(componentTransferElement);
    that._createElement('feFuncB', attrs).append(componentTransferElement);
    return filter;
  },
  getGrayScaleFilter: function getGrayScaleFilter() {
    if (this._grayScaleFilter) {
      return this._grayScaleFilter;
    }
    var that = this;
    var id = (0, _utils.getNextDefsSvgId)();
    var filter = that._createElement('filter', {
      id: id
    }).append(that._defs);
    that._createElement('feColorMatrix').attr({
      type: 'matrix',
      values: '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 0.6 0'
    }).append(filter);
    filter.id = id;
    that._grayScaleFilter = filter;
    return filter;
  },
  lightenFilter: function lightenFilter(id) {
    var coef = 1.3;
    var filter = this._createElement('filter', {
      id
    }).append(this._defs);
    this._createElement('feColorMatrix', {
      type: 'matrix',
      values: "".concat(coef, " 0 0 0 0 0 ").concat(coef, " 0 0 0 0 0 ").concat(coef, " 0 0 0 0 0 1 0")
    }).append(filter);
    filter.id = id;
    return filter;
  },
  initDefsElements: function initDefsElements() {
    var storage = this._defsElementsStorage = this._defsElementsStorage || {
      byHash: {},
      baseId: (0, _utils.getNextDefsSvgId)()
    };
    var byHash = storage.byHash;
    var name;
    for (name in byHash) {
      byHash[name].pattern.dispose();
    }
    storage.byHash = {};
    storage.refToHash = {};
    storage.nextId = 0;
  },
  drawPattern: function drawPattern(_ref6, storageId, nextId) {
    var color = _ref6.color,
      hatching = _ref6.hatching;
    return this.pattern(color, hatching, "".concat(storageId, "-hatching-").concat(nextId++));
  },
  drawFilter: function drawFilter(_, storageId, nextId) {
    return this.lightenFilter("".concat(storageId, "-lightening-").concat(nextId++));
  },
  lockDefsElements: function lockDefsElements(attrs, ref, type) {
    var storage = this._defsElementsStorage;
    var storageItem;
    var hash = type === 'pattern' ? getHatchingHash(attrs) : LIGHTENING_HASH;
    var method = type === 'pattern' ? this.drawPattern : this.drawFilter;
    var pattern;
    if (storage.refToHash[ref] !== hash) {
      if (ref) {
        this.releaseDefsElements(ref);
      }
      storageItem = storage.byHash[hash];
      if (!storageItem) {
        pattern = method.call(this, attrs, storage.baseId, storage.nextId++);
        storageItem = storage.byHash[hash] = {
          pattern: pattern,
          count: 0
        };
        storage.refToHash[pattern.id] = hash;
      }
      ++storageItem.count;
      ref = storageItem.pattern.id;
    }
    return ref;
  },
  releaseDefsElements: function releaseDefsElements(ref) {
    var storage = this._defsElementsStorage;
    var hash = storage.refToHash[ref];
    var storageItem = storage.byHash[hash];
    if (storageItem && --storageItem.count === 0) {
      storageItem.pattern.dispose();
      delete storage.byHash[hash];
      delete storage.refToHash[ref];
    }
  }
};
function getHatchingHash(_ref7) {
  var color = _ref7.color,
    hatching = _ref7.hatching;
  return '@' + color + '::' + hatching.step + ':' + hatching.width + ':' + hatching.opacity + ':' + hatching.direction;
}

// paths modifier
var fixFuncIriCallbacks = function () {
  var callbacks = [];
  return {
    add: function add(fn) {
      callbacks.push(fn);
    },
    remove: function remove(fn) {
      callbacks = callbacks.filter(function (el) {
        return el !== fn;
      });
    },
    removeByRenderer: function removeByRenderer(renderer) {
      callbacks = callbacks.filter(function (el) {
        return el.renderer !== renderer;
      });
    },
    fire: function fire() {
      callbacks.forEach(function (fn) {
        fn();
      });
    }
  };
}();
var refreshPaths = function refreshPaths() {
  fixFuncIriCallbacks.fire();
};
exports.refreshPaths = refreshPaths;

/***/ }),

/***/ 1939:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SeriesFamily = SeriesFamily;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _math = __webpack_require__(60810);
var _common = __webpack_require__(20576);
var _utils = __webpack_require__(19157);
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var round = Math.round,
  abs = Math.abs,
  pow = Math.pow,
  sqrt = Math.sqrt;
var _min = Math.min;
var DEFAULT_BAR_GROUP_PADDING = 0.3;
function validateBarPadding(barPadding) {
  return barPadding < 0 || barPadding > 1 ? undefined : barPadding;
}
function validateBarGroupPadding(barGroupPadding) {
  return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding;
}
function isStackExist(series, arg) {
  return series.some(function (s) {
    return !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function (point) {
      return point.hasValue();
    });
  });
}
function correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {
  series.forEach(function (series) {
    var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);
    var points = series.getPointsByArg(arg, true);
    var barPadding = validateBarPadding(series.getOptions().barPadding);
    var barWidth = series.getOptions().barWidth;
    var offset = getOffset(stackIndex, parameters);
    var width = parameters.width;
    var extraParameters;
    if (stackIndex === -1) {
      return;
    }
    if ((0, _type.isDefined)(barPadding) || (0, _type.isDefined)(barWidth)) {
      extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);
      width = extraParameters.width;
      if (!series.getBarOverlapGroup()) {
        offset = getOffset(stackIndex, extraParameters);
      }
    }
    correctPointCoordinates(points, width, offset);
  });
}
function getStackName(series) {
  return series.getStackName() || series.getBarOverlapGroup();
}
function adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {
  var _series$, _series$2;
  var commonStacks = [];
  var allArguments = [];
  var seriesInStacks = {};
  var barGroupWidth = options.barGroupWidth;
  var argumentAxis = (_series$ = series[0]) === null || _series$ === void 0 ? void 0 : _series$.getArgumentAxis();
  var interval;
  if ((_series$2 = series[0]) !== null && _series$2 !== void 0 && _series$2.useAggregation()) {
    var _series$3;
    var isDateArgAxis = ((_series$3 = series[0]) === null || _series$3 === void 0 ? void 0 : _series$3.argumentType) === 'datetime';
    var tickInterval = argumentAxis.getTickInterval();
    var aggregationInterval = argumentAxis.getAggregationInterval();
    tickInterval = isDateArgAxis ? _date.default.dateToMilliseconds(tickInterval) : tickInterval;
    aggregationInterval = isDateArgAxis ? _date.default.dateToMilliseconds(aggregationInterval) : aggregationInterval;
    interval = aggregationInterval < tickInterval ? aggregationInterval : tickInterval;
  }
  interval = argumentAxis === null || argumentAxis === void 0 ? void 0 : argumentAxis.getTranslator().getInterval(interval);
  var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));
  series.forEach(function (s, i) {
    var stackName = getStackName(s) || i.toString();
    var argument;
    for (argument in s.pointsByArgument) {
      if (allArguments.indexOf(argument.valueOf()) === -1) {
        allArguments.push(argument.valueOf());
      }
    }
    if (commonStacks.indexOf(stackName) === -1) {
      commonStacks.push(stackName);
      seriesInStacks[stackName] = [];
    }
    seriesInStacks[stackName].push(s);
  });
  allArguments.forEach(function (arg) {
    var currentStacks = commonStacks.reduce(function (stacks, stack) {
      if (isStackExist(seriesInStacks[stack], arg)) {
        stacks.push(stack);
      }
      return stacks;
    }, []);
    var parameters = calculateParams(barsArea, currentStacks.length);
    commonStacks.forEach(function (stack) {
      correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback);
    });
  });
}
function calculateParams(barsArea, count, percentWidth, fixedBarWidth) {
  var spacing;
  var width;
  if (fixedBarWidth) {
    width = _min(fixedBarWidth, barsArea / count);
    spacing = count > 1 ? round((barsArea - round(width) * count) / (count - 1)) : 0;
  } else if ((0, _type.isDefined)(percentWidth)) {
    width = barsArea * percentWidth / count;
    spacing = count > 1 ? round((barsArea - barsArea * percentWidth) / (count - 1)) : 0;
  } else {
    spacing = round(barsArea / count * 0.2);
    width = (barsArea - spacing * (count - 1)) / count;
  }
  return {
    width: width > 1 ? round(width) : 1,
    spacing: spacing,
    middleIndex: count / 2,
    rawWidth: width
  };
}
function getOffset(stackIndex, parameters) {
  var width = parameters.rawWidth < 1 ? parameters.rawWidth : parameters.width;
  return (stackIndex - parameters.middleIndex + 0.5) * width - (parameters.middleIndex - stackIndex - 0.5) * parameters.spacing;
}
function correctPointCoordinates(points, width, offset) {
  (0, _iterator.each)(points, function (_, point) {
    point.correctCoordinates({
      width: width,
      offset: offset
    });
  });
}
function getValueType(value) {
  return value >= 0 ? 'positive' : 'negative';
}
function getVisibleSeries(that) {
  return that.series.filter(function (s) {
    return s.isVisible();
  });
}
function getAbsStackSumByArg(stackKeepers, stackName, argument) {
  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
  var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;
  return positiveStackValue + negativeStackValue;
}
function getStackSumByArg(stackKeepers, stackName, argument) {
  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;
  var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;
  return positiveStackValue + negativeStackValue;
}
function getSeriesStackIndexCallback(inverted) {
  if (!inverted) {
    return function (index) {
      return index;
    };
  } else {
    return function (index, stackCount) {
      return stackCount - index - 1;
    };
  }
}
function isInverted(series) {
  return series[0] && series[0].getArgumentAxis().getTranslator().isInverted();
}
function adjustBarSeriesDimensions() {
  var series = getVisibleSeries(this);
  adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)));
}
function getFirstValueSign(series) {
  var points = series.getPoints();
  var value;
  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    value = point.initialValue && point.initialValue.valueOf();
    if (abs(value) > 0) {
      break;
    }
  }
  return (0, _math.sign)(value);
}
function adjustStackedSeriesValues() {
  var that = this;
  var negativesAsZeroes = that._options.negativesAsZeroes;
  var series = getVisibleSeries(that);
  var stackKeepers = {
    positive: {},
    negative: {}
  };
  var holesStack = {
    left: {},
    right: {}
  };
  var lastSeriesInPositiveStack = {};
  var lastSeriesInNegativeStack = {};
  series.forEach(function (singleSeries) {
    var stackName = getStackName(singleSeries);
    var hole = false;
    var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;
    singleSeries._prevSeries = stack[stackName];
    stack[stackName] = singleSeries;
    singleSeries.holes = (0, _extend.extend)(true, {}, holesStack);
    singleSeries.getPoints().forEach(function (point, index, points) {
      var value = point.initialValue && point.initialValue.valueOf();
      var argument = point.argument.valueOf();
      var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;
      var isNotBarSeries = singleSeries.type !== 'bar';
      if (negativesAsZeroes && value < 0) {
        stacks = stackKeepers.positive;
        value = 0;
        point.resetValue();
      }
      stacks[stackName] = stacks[stackName] || {};
      var currentStack = stacks[stackName];
      if (currentStack[argument]) {
        if (isNotBarSeries) point.correctValue(currentStack[argument]);
        currentStack[argument] += value;
      } else {
        currentStack[argument] = value;
        if (isNotBarSeries) point.resetCorrection();
      }
      if (!point.hasValue()) {
        var prevPoint = points[index - 1];
        if (!hole && prevPoint && prevPoint.hasValue()) {
          argument = prevPoint.argument.valueOf();
          prevPoint._skipSetRightHole = true;
          holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0));
        }
        hole = true;
      } else if (hole) {
        hole = false;
        holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));
        point._skipSetLeftHole = true;
      }
    });
  });
  series.forEach(function (singleSeries) {
    var holes = singleSeries.holes;
    singleSeries.getPoints().forEach(function (point) {
      var argument = point.argument.valueOf();
      point.resetHoles();
      !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, 'left');
      !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, 'right');
      point._skipSetLeftHole = null;
      point._skipSetRightHole = null;
    });
  });
  that._stackKeepers = stackKeepers;
  series.forEach(function (singleSeries) {
    singleSeries.getPoints().forEach(function (point) {
      var argument = point.argument.valueOf();
      var stackName = getStackName(singleSeries);
      var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);
      var total = getStackSumByArg(stackKeepers, stackName, argument);
      point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument]);
    });
  });
}
function updateStackedSeriesValues() {
  var that = this;
  var series = getVisibleSeries(that);
  var stack = that._stackKeepers;
  var stackKeepers = {
    positive: {},
    negative: {}
  };
  (0, _iterator.each)(series, function (_, singleSeries) {
    var minBarSize = singleSeries.getOptions().minBarSize;
    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
    var stackName = singleSeries.getStackName();
    (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
      if (!point.hasValue()) {
        return;
      }
      var value = point.initialValue && point.initialValue.valueOf();
      var argument = point.argument.valueOf();
      if (that.fullStacked) {
        value = value / getAbsStackSumByArg(stack, stackName, argument) || 0;
      }
      var updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);
      var valueType = getValueType(updateValue);
      var currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};
      if (currentStack[argument]) {
        point.minValue = currentStack[argument];
        currentStack[argument] += updateValue;
      } else {
        currentStack[argument] = updateValue;
      }
      point.value = currentStack[argument];
    });
  });
  if (that.fullStacked) {
    updateFullStackedSeriesValues(series, stackKeepers);
  }
}
function updateFullStackedSeriesValues(series, stackKeepers) {
  (0, _iterator.each)(series, function (_, singleSeries) {
    var stackName = singleSeries.getStackName ? singleSeries.getStackName() : 'default';
    (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
      var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());
      if (stackSum !== 0) {
        point.value = point.value / stackSum;
        if ((0, _type.isNumeric)(point.minValue)) {
          point.minValue = point.minValue / stackSum;
        }
      }
    });
  });
}
function updateRangeSeriesValues() {
  var that = this;
  var series = getVisibleSeries(that);
  (0, _iterator.each)(series, function (_, singleSeries) {
    var minBarSize = singleSeries.getOptions().minBarSize;
    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
    if (minShownBusinessValue) {
      (0, _iterator.each)(singleSeries.getPoints(), function (_, point) {
        if (!point.hasValue()) {
          return;
        }
        if (point.value.valueOf() - point.minValue.valueOf() < minShownBusinessValue) {
          point.value = point.value.valueOf() + minShownBusinessValue / 2;
          point.minValue = point.minValue.valueOf() - minShownBusinessValue / 2;
        }
      });
    }
  });
}
function updateBarSeriesValues() {
  (0, _iterator.each)(this.series, function (_, singleSeries) {
    var minBarSize = singleSeries.getOptions().minBarSize;
    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();
    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);
    if (minShownBusinessValue) {
      (0, _iterator.each)(singleSeries.getPoints(), function (index, point) {
        if (point.hasValue()) {
          point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue);
        }
      });
    }
  });
}
function adjustCandlestickSeriesDimensions() {
  var series = getVisibleSeries(this);
  adjustBarSeriesDimensionsCore(series, {
    barGroupPadding: 0.3
  }, getSeriesStackIndexCallback(isInverted(series)));
}
function adjustBubbleSeriesDimensions() {
  var series = getVisibleSeries(this);
  if (!series.length) {
    return;
  }
  var options = this._options;
  var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();
  var visibleAreaY = series[0].getValueAxis().getVisibleArea();
  var min = _min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);
  var minBubbleArea = pow(options.minBubbleSize, 2);
  var maxBubbleArea = pow(min * options.maxBubbleSize, 2);
  var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;
  var minPointSize = Infinity;
  var maxPointSize = -Infinity;
  var pointSize;
  var bubbleArea;
  var sizeProportion;
  (0, _iterator.each)(series, function (_, seriesItem) {
    (0, _iterator.each)(seriesItem.getPoints(), function (_, point) {
      maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;
      minPointSize = minPointSize < point.size ? minPointSize : point.size;
    });
  });
  var sizeDispersion = maxPointSize - minPointSize;
  var areaDispersion = abs(maxBubbleArea - minBubbleArea);
  (0, _iterator.each)(series, function (_, seriesItem) {
    (0, _iterator.each)(seriesItem.getPoints(), function (_, point) {
      if (maxPointSize === minPointSize) {
        pointSize = round(equalBubbleSize);
      } else {
        sizeProportion = abs(point.size - minPointSize) / sizeDispersion;
        bubbleArea = areaDispersion * sizeProportion + minBubbleArea;
        pointSize = round(sqrt(bubbleArea));
      }
      point.correctCoordinates(pointSize);
    });
  });
}
function SeriesFamily(options) {
  var that = this;
  that.type = (0, _utils.normalizeEnum)(options.type);
  that.pane = options.pane;
  that.series = [];
  that.updateOptions(options);
  switch (that.type) {
    case 'bar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.updateSeriesValues = updateBarSeriesValues;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;
    case 'rangebar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.updateSeriesValues = updateRangeSeriesValues;
      break;
    case 'fullstackedbar':
      that.fullStacked = true;
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      that.updateSeriesValues = updateStackedSeriesValues;
      break;
    case 'stackedbar':
      that.adjustSeriesDimensions = adjustBarSeriesDimensions;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      that.updateSeriesValues = updateStackedSeriesValues;
      break;
    case 'fullstackedarea':
    case 'fullstackedline':
    case 'fullstackedspline':
    case 'fullstackedsplinearea':
      that.fullStacked = true;
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;
    case 'stackedarea':
    case 'stackedsplinearea':
    case 'stackedline':
    case 'stackedspline':
      that.adjustSeriesValues = adjustStackedSeriesValues;
      break;
    case 'candlestick':
    case 'stock':
      that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;
      break;
    case 'bubble':
      that.adjustSeriesDimensions = adjustBubbleSeriesDimensions;
      break;
  }
}
SeriesFamily.prototype = {
  constructor: SeriesFamily,
  adjustSeriesDimensions: _common.noop,
  adjustSeriesValues: _common.noop,
  updateSeriesValues: _common.noop,
  updateOptions: function updateOptions(options) {
    this._options = options;
  },
  dispose: function dispose() {
    this.series = null;
  },
  add: function add(series) {
    var type = this.type;
    this.series = (0, _utils.map)(series, function (singleSeries) {
      return singleSeries.type === type ? singleSeries : null;
    });
  }
};

/***/ }),

/***/ 39726:
/***/ (function(module, exports) {



exports["default"] = void 0;
var ACCENT_COLOR = '#f05b41';
var BACKGROUND_COLOR = '#fff';
var TITLE_COLOR = '#333';
var SUBTITLE_COLOR = '#8899a8';
var TEXT_COLOR = '#707070';
var BORDER_COLOR = '#dee1e3';
var _default = [{
  theme: {
    name: 'generic.carmine',
    defaultPalette: 'Carmine',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    'export': {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        'default': {
          color: TITLE_COLOR,
          borderColor: '#b1b7bd',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#b1b7bd',
          backgroundColor: '#faf2f0'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#6d7781',
          backgroundColor: '#faf2f0'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#6d7781',
          backgroundColor: '#f5e7e4'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: BACKGROUND_COLOR,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      font: {
        color: TITLE_COLOR
      },
      border: {
        color: BORDER_COLOR
      },
      color: BACKGROUND_COLOR
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#c1c5c7'
        }
      }
    },
    rangeSelector: {
      scale: {
        breakStyle: {
          color: '#c1c5c7'
        },
        tick: {
          opacity: 0.12
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#f74d61'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        'rangebar': {
          color: ACCENT_COLOR
        },
        'textcloud': {
          color: ACCENT_COLOR
        }
      }
    }
  },
  baseThemeName: 'generic.light'
}, {
  theme: {
    name: 'generic.carmine.compact'
  },
  baseThemeName: 'generic.carmine'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 14870:
/***/ (function(module, exports) {



exports["default"] = void 0;
var WHITE = '#ffffff';
var BLACK = '#000000';
var CONTRAST_ACTIVE = '#cf00da';
var MARKER_COLOR = '#f8ca00';
var AREA_LAYER_COLOR = '#686868';
var _default = [{
  theme: {
    name: 'generic.contrast',
    defaultPalette: 'Bright',
    // CONTRAST_ACTIVE
    font: {
      color: WHITE
    },
    backgroundColor: BLACK,
    primaryTitleColor: WHITE,
    secondaryTitleColor: WHITE,
    gridColor: WHITE,
    axisColor: WHITE,
    'export': {
      backgroundColor: BLACK,
      font: {
        color: WHITE
      },
      button: {
        'default': {
          color: WHITE,
          borderColor: WHITE,
          backgroundColor: BLACK
        },
        hover: {
          color: WHITE,
          borderColor: WHITE,
          backgroundColor: '#cf00d7'
        },
        focus: {
          color: WHITE,
          borderColor: '#cf00d7',
          backgroundColor: BLACK
        },
        active: {
          color: BLACK,
          borderColor: WHITE,
          backgroundColor: WHITE
        }
      },
      borderColor: WHITE,
      menuButtonColor: BLACK,
      activeBackgroundColor: WHITE,
      activeColor: BLACK,
      selectedBorderColor: CONTRAST_ACTIVE,
      selectedColor: CONTRAST_ACTIVE,
      shadowColor: 'none'
    },
    tooltip: {
      border: {
        color: WHITE
      },
      font: {
        color: WHITE
      },
      color: BLACK
    },
    'chart:common': {
      commonSeriesSettings: {
        valueErrorBar: {
          color: WHITE
        },
        hoverStyle: {
          hatching: {
            opacity: 0.5
          }
        },
        selectionStyle: {
          hatching: {
            opacity: 0.35
          }
        },
        label: {
          font: {
            color: WHITE
          },
          border: {
            color: WHITE
          }
        }
      }
    },
    'chart:common:axis': {
      constantLineStyle: {
        color: WHITE
      }
    },
    'chart:common:annotation': {
      font: {
        color: WHITE
      },
      border: {
        color: WHITE
      },
      color: BLACK
    },
    chart: {
      commonSeriesSettings: {},
      crosshair: {
        color: '#cf00d7'
      },
      commonPaneSettings: {
        backgroundColor: BLACK,
        border: {
          color: WHITE
        }
      },
      scrollBar: {
        color: WHITE
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#cf00d7'
        }
      },
      zoomAndPan: {
        dragBoxStyle: {
          color: WHITE,
          opacity: 0.7
        }
      }
    },
    pie: {
      commonSeriesSettings: {
        pie: {
          hoverStyle: {
            hatching: {
              opacity: 0.5
            }
          },
          selectionStyle: {
            hatching: {
              opacity: 0.35
            }
          }
        },
        doughnut: {
          hoverStyle: {
            hatching: {
              opacity: 0.5
            }
          },
          selectionStyle: {
            hatching: {
              opacity: 0.35
            }
          }
        },
        donut: {
          hoverStyle: {
            hatching: {
              opacity: 0.5
            }
          },
          selectionStyle: {
            hatching: {
              opacity: 0.35
            }
          }
        }
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: WHITE
      },
      valueIndicators: {
        _default: {
          color: WHITE
        },
        'rangebar': {
          color: WHITE,
          backgroundColor: BLACK
        },
        'twocolorneedle': {
          secondColor: WHITE
        },
        'trianglemarker': {
          color: WHITE
        },
        'textcloud': {
          color: WHITE,
          text: {
            font: {
              color: BLACK
            }
          }
        }
      }
    },
    barGauge: {
      backgroundColor: '#3c3c3c'
    },
    rangeSelector: {
      scale: {
        tick: {
          color: WHITE,
          opacity: 0.4
        },
        minorTick: {
          color: WHITE,
          opacity: 0.12
        },
        breakStyle: {
          color: '#cf00d7'
        }
      },
      selectedRangeColor: CONTRAST_ACTIVE,
      sliderMarker: {
        color: CONTRAST_ACTIVE
      },
      sliderHandle: {
        color: CONTRAST_ACTIVE,
        opacity: 1
      },
      shutter: {
        opacity: 0.75
      },
      background: {
        color: BLACK
      }
    },
    map: {
      background: {
        borderColor: WHITE
      },
      layer: {
        label: {
          stroke: BLACK,
          font: {
            color: WHITE
          }
        }
      },
      'layer:area': {
        borderColor: BLACK,
        color: AREA_LAYER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE,
        label: {
          font: {
            opacity: 1
          }
        }
      },
      'layer:line': {
        color: '#267cff',
        hoveredColor: '#f613ff',
        selectedColor: WHITE
      },
      'layer:marker:dot': {
        borderColor: BLACK,
        color: MARKER_COLOR,
        backColor: BLACK,
        backOpacity: 0.32
      },
      'layer:marker:bubble': {
        color: MARKER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:marker:pie': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      controlBar: {
        borderColor: WHITE,
        color: BLACK,
        opacity: 0.3
      }
    },
    treeMap: {
      tile: {
        color: '#70c92f'
      },
      group: {
        color: '#797979',
        label: {
          font: {
            color: WHITE
          }
        }
      }
    },
    sparkline: {
      pointColor: BLACK
    },
    bullet: {},
    polar: {
      commonSeriesSettings: {}
    },
    funnel: {
      label: {
        connector: {
          opacity: 1
        }
      }
    },
    sankey: {
      label: {
        font: {
          color: WHITE
        },
        shadow: {
          opacity: 0
        }
      },
      node: {
        border: {
          visible: true,
          width: 1,
          color: WHITE
        }
      },
      link: {
        opacity: 0.5,
        border: {
          visible: true,
          width: 1,
          color: WHITE
        },
        hoverStyle: {
          opacity: 0.9
        }
      }
    }
  },
  baseThemeName: 'generic.light'
}, {
  theme: {
    name: 'generic.contrast.compact'
  },
  baseThemeName: 'generic.contrast'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 17374:
/***/ (function(module, exports) {



exports["default"] = void 0;
var WHITE = '#ffffff';
var BLACK = '#000000';
var SOME_GREY = '#2b2b2b';
var RANGE_COLOR = '#b5b5b5';
var GREY_GREEN = '#303030';
var AREA_LAYER_COLOR = '#686868';
var LINE_COLOR = '#c7c7c7';
var TARGET_COLOR = '#8e8e8e';
var POSITIVE_COLOR = '#b8b8b8';
var BORDER_COLOR = '#494949';
var _default = [{
  theme: {
    name: 'generic.dark',
    font: {
      color: '#808080'
    },
    backgroundColor: '#2a2a2a',
    primaryTitleColor: '#dedede',
    secondaryTitleColor: '#a3a3a3',
    gridColor: '#555555',
    axisColor: '#a3a3a3',
    'export': {
      backgroundColor: '#2a2a2a',
      font: {
        color: '#dbdbdb'
      },
      button: {
        'default': {
          color: '#dedede',
          borderColor: '#4d4d4d',
          backgroundColor: '#2e2e2e'
        },
        hover: {
          color: '#dedede',
          borderColor: '#6c6c6c',
          backgroundColor: '#444'
        },
        focus: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#444444'
        },
        active: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#555555'
        }
      },
      shadowColor: '#292929'
    },
    tooltip: {
      color: SOME_GREY,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: '#929292'
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        },
        valueErrorBar: {
          color: WHITE
        }
      }
    },
    'chart:common:axis': {
      constantLineStyle: {
        color: WHITE
      }
    },
    'chart:common:annotation': {
      font: {
        color: '#929292'
      },
      border: {
        color: BORDER_COLOR
      },
      color: SOME_GREY,
      shadow: {
        opacity: 0.008,
        offsetY: 4,
        blur: 8
      }
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#818181'
        }
      },
      zoomAndPan: {
        dragBoxStyle: {
          color: WHITE
        }
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: RANGE_COLOR
      },
      valueIndicators: {
        _default: {
          color: RANGE_COLOR
        },
        'rangebar': {
          color: '#84788b'
        },
        'twocolorneedle': {
          secondColor: '#ba544d'
        },
        'trianglemarker': {
          color: '#b7918f'
        },
        'textcloud': {
          color: '#ba544d'
        }
      }
    },
    barGauge: {
      backgroundColor: '#3c3c3c'
    },
    rangeSelector: {
      scale: {
        tick: {
          color: WHITE,
          opacity: 0.32
        },
        minorTick: {
          color: WHITE,
          opacity: 0.1
        },
        breakStyle: {
          color: '#818181'
        }
      },
      selectedRangeColor: RANGE_COLOR,
      sliderMarker: {
        color: RANGE_COLOR,
        font: {
          color: GREY_GREEN
        }
      },
      sliderHandle: {
        color: WHITE,
        opacity: 0.2
      },
      shutter: {
        color: SOME_GREY,
        opacity: 0.9
      }
    },
    map: {
      background: {
        borderColor: '#3f3f3f'
      },
      layer: {
        label: {
          stroke: BLACK,
          font: {
            color: WHITE
          }
        }
      },
      'layer:area': {
        borderColor: GREY_GREEN,
        color: AREA_LAYER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:line': {
        color: '#c77244',
        hoveredColor: '#ff5d04',
        selectedColor: '#ff784f'
      },
      'layer:marker:bubble': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:marker:pie': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      legend: {
        border: {
          color: '#3f3f3f'
        },
        font: {
          color: WHITE
        }
      },
      controlBar: {
        borderColor: LINE_COLOR,
        color: GREY_GREEN
      }
    },
    treeMap: {
      group: {
        color: '#4c4c4c',
        label: {
          font: {
            color: '#a3a3a3'
          }
        }
      }
    },
    sparkline: {
      lineColor: LINE_COLOR,
      firstLastColor: LINE_COLOR,
      barPositiveColor: POSITIVE_COLOR,
      barNegativeColor: TARGET_COLOR,
      winColor: POSITIVE_COLOR,
      lossColor: TARGET_COLOR,
      pointColor: GREY_GREEN
    },
    bullet: {
      targetColor: TARGET_COLOR
    },
    funnel: {
      item: {
        border: {
          color: '#2a2a2a'
        }
      }
    },
    sankey: {
      label: {
        font: {
          color: WHITE
        },
        shadow: {
          opacity: 0
        }
      },
      node: {
        border: {
          color: '#2a2a2a'
        }
      },
      link: {
        color: '#888888',
        border: {
          color: '#2a2a2a'
        },
        hoverStyle: {
          color: '#bbbbbb'
        }
      }
    }
  },
  baseThemeName: 'generic.light'
}, {
  theme: {
    name: 'generic.dark.compact'
  },
  baseThemeName: 'generic.dark'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 83313:
/***/ (function(module, exports) {



exports["default"] = void 0;
var ACCENT_COLOR = '#3debd3';
var BACKGROUND_COLOR = '#465672';
var TITLE_COLOR = '#fff';
var SUBTITLE_COLOR = '#919bac';
var TEXT_COLOR = '#c7ccd4';
var BORDER_COLOR = '#596980';
var _default = [{
  theme: {
    name: 'generic.darkmoon',
    defaultPalette: 'Dark Moon',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    'export': {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        'default': {
          color: TITLE_COLOR,
          borderColor: '#7a889e',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#9da8b8',
          backgroundColor: '#596e92'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#c4cad4',
          backgroundColor: '#596e92'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#c4cad4',
          backgroundColor: '#6b80a4'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: '#62789e',
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      font: {
        color: TITLE_COLOR
      },
      border: {
        color: BORDER_COLOR
      },
      color: '#62789e'
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#73869e'
        }
      }
    },
    gauge: {
      valueIndicators: {
        'rangebar': {
          color: ACCENT_COLOR
        },
        'textcloud': {
          color: ACCENT_COLOR,
          text: {
            font: {
              color: BACKGROUND_COLOR
            }
          }
        }
      }
    },
    barGauge: {
      backgroundColor: '#526280'
    },
    funnel: {
      item: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#f9517e'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: TITLE_COLOR
          }
        }
      }
    },
    map: {
      background: {
        borderColor: BORDER_COLOR
      },
      'layer:area': {
        color: '#97a3b6',
        borderColor: BACKGROUND_COLOR
      }
    },
    rangeSelector: {
      shutter: {
        color: BACKGROUND_COLOR
      },
      scale: {
        breakStyle: {
          color: '#73869e'
        },
        tick: {
          opacity: 0.2
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR,
        font: {
          color: '#000'
        }
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    sankey: {
      link: {
        border: {
          color: BACKGROUND_COLOR
        }
      },
      node: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    }
  },
  baseThemeName: 'generic.dark'
}, {
  theme: {
    name: 'generic.darkmoon.compact'
  },
  baseThemeName: 'generic.darkmoon'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 25257:
/***/ (function(module, exports) {



exports["default"] = void 0;
var ACCENT_COLOR = '#9c63ff';
var BACKGROUND_COLOR = '#17171f';
var TITLE_COLOR = '#f5f6f7';
var SUBTITLE_COLOR = '#fff';
var TEXT_COLOR = '#b2b2b6';
var BORDER_COLOR = '#343840';
var _default = [{
  theme: {
    name: 'generic.darkviolet',
    defaultPalette: 'Dark Violet',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    'export': {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        'default': {
          color: TITLE_COLOR,
          borderColor: '#414152',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#5c5c74',
          backgroundColor: '#2d2d3c'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#7c7c97',
          backgroundColor: '#2d2d3c'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#7c7c97',
          backgroundColor: '#3c3c51'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: BACKGROUND_COLOR,
      border: {
        color: '#414152'
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      font: {
        color: TITLE_COLOR
      },
      border: {
        color: '#414152'
      },
      color: BACKGROUND_COLOR
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#575e6b'
        }
      }
    },
    funnel: {
      item: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#d9534f'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    rangeSelector: {
      shutter: {
        color: BACKGROUND_COLOR
      },
      scale: {
        breakStyle: {
          color: '#575e6b'
        },
        tick: {
          opacity: 0.2
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR,
        font: {
          color: '#fff'
        }
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        'rangebar': {
          color: ACCENT_COLOR
        },
        'textcloud': {
          color: ACCENT_COLOR
        }
      }
    },
    sankey: {
      link: {
        border: {
          color: BACKGROUND_COLOR
        }
      },
      node: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    }
  },
  baseThemeName: 'generic.dark'
}, {
  theme: {
    name: 'generic.darkviolet.compact'
  },
  baseThemeName: 'generic.darkviolet'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 84253:
/***/ (function(module, exports) {



exports["default"] = void 0;
var ACCENT_COLOR = '#3cbab2';
var BACKGROUND_COLOR = '#f5f5f5';
var TITLE_COLOR = '#28484f';
var SUBTITLE_COLOR = '#7eb2be';
var TEXT_COLOR = '#657c80';
var BORDER_COLOR = '#dedede';
var _default = [{
  theme: {
    name: 'generic.greenmist',
    defaultPalette: 'Green Mist',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    'export': {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        'default': {
          color: TITLE_COLOR,
          borderColor: '#a2b4b8',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#7f989e',
          backgroundColor: 'rgba(222, 222, 222, 0.4)'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#5f777c',
          backgroundColor: 'rgba(222, 222, 222, 0.4)'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#5f777c',
          backgroundColor: 'rgba(222, 222, 222, 0.8)'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: '#fff',
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      color: '#fff',
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#c1c1c1'
        }
      }
    },
    funnel: {
      item: {
        border: {
          color: BACKGROUND_COLOR
        }
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#ffc852',
      maxColor: '#f74a5e'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    rangeSelector: {
      shutter: {
        color: BACKGROUND_COLOR
      },
      scale: {
        breakStyle: {
          color: '#c1c1c1'
        },
        tick: {
          opacity: 0.12
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        'rangebar': {
          color: ACCENT_COLOR
        },
        'textcloud': {
          color: ACCENT_COLOR
        }
      }
    }
  },
  baseThemeName: 'generic.light'
}, {
  theme: {
    name: 'generic.greenmist.compact'
  },
  baseThemeName: 'generic.greenmist'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 8839:
/***/ (function(module, exports) {



exports["default"] = void 0;
var WHITE = '#ffffff';
var BLACK = '#000000';
var LIGHT_GREY = '#d3d3d3';
var GREY_GREEN = '#303030';
var SOME_GREY = '#2b2b2b';
var RED = '#ff0000';
var PRIMARY_TITLE_COLOR = '#232323';
var SECONDARY_TITLE_COLOR = '#767676';
var NONE = 'none';
var SOLID = 'solid';
var TOP = 'top';
var RIGHT = 'right';
var BOTTOM = 'bottom';
var LEFT = 'left';
var CENTER = 'center';
var INSIDE = 'inside';
var OUTSIDE = 'outside';
var _default = [{
  theme: {
    name: 'generic.light',
    isDefault: true,
    font: {
      color: SECONDARY_TITLE_COLOR,
      family: '\'Segoe UI\', \'Helvetica Neue\', \'Trebuchet MS\', Verdana, sans-serif',
      weight: 400,
      size: 12,
      cursor: 'default'
    },
    redrawOnResize: true,
    backgroundColor: WHITE,
    primaryTitleColor: PRIMARY_TITLE_COLOR,
    secondaryTitleColor: SECONDARY_TITLE_COLOR,
    gridColor: LIGHT_GREY,
    axisColor: SECONDARY_TITLE_COLOR,
    title: {
      backgroundColor: WHITE,
      font: {
        size: 28,
        family: '\'Segoe UI Light\', \'Helvetica Neue Light\', \'Segoe UI\', \'Helvetica Neue\', \'Trebuchet MS\', Verdana, sans-serif',
        weight: 200
      },
      subtitle: {
        font: {
          size: 16
        },
        offset: 0,
        wordWrap: 'normal',
        textOverflow: 'ellipsis'
      },
      wordWrap: 'normal',
      textOverflow: 'ellipsis'
    },
    loadingIndicator: {
      text: 'Loading...'
    },
    'export': {
      backgroundColor: WHITE,
      margin: 10,
      font: {
        size: 14,
        color: PRIMARY_TITLE_COLOR,
        weight: 400
      },
      button: {
        margin: {
          top: 8,
          left: 10,
          right: 10,
          bottom: 8
        },
        'default': {
          color: '#333',
          borderColor: '#ddd',
          backgroundColor: WHITE
        },
        hover: {
          color: '#333',
          borderColor: '#bebebe',
          backgroundColor: '#e6e6e6'
        },
        focus: {
          color: BLACK,
          borderColor: '#9d9d9d',
          backgroundColor: '#e6e6e6'
        },
        active: {
          color: '#333',
          borderColor: '#9d9d9d',
          backgroundColor: '#d4d4d4'
        }
      },
      shadowColor: LIGHT_GREY
    },
    tooltip: {
      enabled: false,
      border: {
        width: 1,
        color: LIGHT_GREY,
        dashStyle: SOLID,
        visible: true
      },
      font: {
        color: PRIMARY_TITLE_COLOR
      },
      color: WHITE,
      arrowLength: 10,
      paddingLeftRight: 18,
      paddingTopBottom: 15,
      textAlignment: 'center',
      shared: false,
      location: CENTER,
      shadow: {
        opacity: 0.4,
        offsetX: 0,
        offsetY: 4,
        blur: 2,
        color: BLACK
      },
      interactive: false
    },
    legend: {
      hoverMode: 'includePoints',
      verticalAlignment: TOP,
      horizontalAlignment: RIGHT,
      position: OUTSIDE,
      visible: true,
      margin: 10,
      markerSize: 12,
      border: {
        visible: false,
        width: 1,
        cornerRadius: 0,
        dashStyle: SOLID
      },
      paddingLeftRight: 20,
      paddingTopBottom: 15,
      columnCount: 0,
      rowCount: 0,
      columnItemSpacing: 20,
      rowItemSpacing: 8,
      title: {
        backgroundColor: WHITE,
        margin: {
          left: 0,
          bottom: 9,
          right: 0,
          top: 0
        },
        font: {
          size: 18,
          weight: 200
        },
        subtitle: {
          offset: 0,
          font: {
            size: 14
          },
          wordWrap: 'none',
          textOverflow: 'ellipsis'
        },
        wordWrap: 'none',
        textOverflow: 'ellipsis'
      }
    },
    'chart:common': {
      animation: {
        enabled: true,
        duration: 1000,
        easing: 'easeOutCubic',
        maxPointCountSupported: 300
      },
      commonSeriesSettings: {
        border: {
          visible: false,
          width: 2
        },
        showInLegend: true,
        visible: true,
        hoverMode: 'nearestPoint',
        selectionMode: 'includePoints',
        hoverStyle: {
          hatching: {
            direction: RIGHT,
            width: 2,
            step: 6,
            opacity: 0.75
          },
          highlight: true,
          border: {
            visible: false,
            width: 3
          }
        },
        selectionStyle: {
          hatching: {
            direction: RIGHT,
            width: 2,
            step: 6,
            opacity: 0.5
          },
          highlight: true,
          border: {
            visible: false,
            width: 3
          }
        },
        valueErrorBar: {
          displayMode: 'auto',
          value: 1,
          color: BLACK,
          lineWidth: 2,
          edgeLength: 8
        },
        label: {
          visible: false,
          alignment: CENTER,
          rotationAngle: 0,
          horizontalOffset: 0,
          verticalOffset: 0,
          radialOffset: 0,
          showForZeroValues: true,
          customizeText: undefined,
          maxLabelCount: undefined,
          position: OUTSIDE,
          font: {
            color: WHITE
          },
          border: {
            visible: false,
            width: 1,
            color: LIGHT_GREY,
            dashStyle: SOLID
          },
          connector: {
            visible: false,
            width: 1
          }
        }
      },
      seriesSelectionMode: 'single',
      pointSelectionMode: 'single',
      equalRowHeight: true,
      dataPrepareSettings: {
        checkTypeForAllData: false,
        convertToAxisDataType: true,
        sortingMethod: true
      },
      title: {
        margin: 10
      },
      adaptiveLayout: {
        width: 80,
        height: 80,
        keepLabels: true
      },
      _rtl: {
        legend: {
          itemTextPosition: LEFT
        }
      },
      resolveLabelOverlapping: NONE
    },
    'chart:common:axis': {
      visible: true,
      valueMarginsEnabled: true,
      placeholderSize: null,
      logarithmBase: 10,
      discreteAxisDivisionMode: 'betweenLabels',
      aggregatedPointsPosition: 'betweenTicks',
      width: 1,
      label: {
        visible: true
      },
      grid: {
        visible: false,
        width: 1
      },
      minorGrid: {
        visible: false,
        width: 1,
        opacity: 0.3
      },
      tick: {
        visible: true,
        width: 1,
        length: 7,
        shift: 3
      },
      minorTick: {
        visible: false,
        width: 1,
        opacity: 0.3,
        length: 7,
        shift: 3
      },
      stripStyle: {
        paddingLeftRight: 10,
        paddingTopBottom: 5
      },
      constantLineStyle: {
        width: 1,
        color: BLACK,
        dashStyle: SOLID,
        label: {
          visible: true,
          position: INSIDE
        }
      },
      marker: {
        label: {}
      }
    },
    'chart:common:annotation': {
      font: {
        color: '#333333'
      },
      tooltipEnabled: true,
      border: {
        width: 1,
        color: '#dddddd',
        dashStyle: SOLID,
        visible: true
      },
      color: WHITE,
      opacity: 0.9,
      arrowLength: 14,
      arrowWidth: 14,
      paddingLeftRight: 10,
      paddingTopBottom: 10,
      shadow: {
        opacity: 0.15,
        offsetX: 0,
        offsetY: 1,
        blur: 4,
        color: BLACK
      },
      image: {
        width: 30,
        height: 30
      },
      wordWrap: 'normal',
      textOverflow: 'ellipsis',
      allowDragging: false
    },
    chart: {
      commonSeriesSettings: {
        type: 'line',
        stack: 'default',
        aggregation: {
          enabled: undefined
        },
        'point': {
          visible: true,
          symbol: 'circle',
          size: 12,
          border: {
            visible: false,
            width: 1
          },
          hoverMode: 'onlyPoint',
          selectionMode: 'onlyPoint',
          hoverStyle: {
            border: {
              visible: true,
              width: 4
            }
          },
          selectionStyle: {
            border: {
              visible: true,
              width: 4
            }
          }
        },
        'scatter': {},
        'line': {
          width: 2,
          dashStyle: SOLID,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3
          }
        },
        'stackedline': {
          width: 2,
          dashStyle: SOLID,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3
          }
        },
        'stackedspline': {
          width: 2,
          dashStyle: SOLID,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3
          }
        },
        'fullstackedline': {
          width: 2,
          dashStyle: SOLID,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3
          }
        },
        'fullstackedspline': {
          width: 2,
          dashStyle: SOLID,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3
          }
        },
        'stepline': {
          width: 2,
          dashStyle: SOLID,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3
          }
        },
        'area': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'stackedarea': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'fullstackedarea': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'fullstackedsplinearea': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'steparea': {
          border: {
            visible: true,
            width: 2
          },
          point: {
            visible: false
          },
          hoverStyle: {
            border: {
              visible: true,
              width: 3
            }
          },
          selectionStyle: {
            border: {
              visible: true,
              width: 3
            }
          },
          opacity: 0.5
        },
        'spline': {
          width: 2,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3
          }
        },
        'splinearea': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'stackedsplinearea': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'bar': {
          cornerRadius: 0,
          point: {
            hoverStyle: {
              border: {
                visible: false
              }
            },
            selectionStyle: {
              border: {
                visible: false
              }
            }
          }
        },
        'stackedbar': {
          cornerRadius: 0,
          point: {
            hoverStyle: {
              border: {
                visible: false
              }
            },
            selectionStyle: {
              border: {
                visible: false
              }
            }
          },
          label: {
            position: INSIDE
          }
        },
        'fullstackedbar': {
          cornerRadius: 0,
          point: {
            hoverStyle: {
              border: {
                visible: false
              }
            },
            selectionStyle: {
              border: {
                visible: false
              }
            }
          },
          label: {
            position: INSIDE
          }
        },
        'rangebar': {
          cornerRadius: 0,
          point: {
            hoverStyle: {
              border: {
                visible: false
              }
            },
            selectionStyle: {
              border: {
                visible: false
              }
            }
          }
        },
        'rangearea': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'rangesplinearea': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'bubble': {
          opacity: 0.5,
          point: {
            hoverStyle: {
              border: {
                visible: false
              }
            },
            selectionStyle: {
              border: {
                visible: false
              }
            }
          }
        },
        'candlestick': {
          width: 1,
          reduction: {
            color: RED
          },
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3,
            highlight: false
          },
          point: {
            border: {
              visible: true
            }
          }
        },
        'stock': {
          width: 1,
          reduction: {
            color: RED
          },
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            },
            highlight: false
          },
          selectionStyle: {
            width: 3,
            highlight: false
          },
          point: {
            border: {
              visible: true
            }
          }
        }
      },
      crosshair: {
        enabled: false,
        color: '#f05b41',
        width: 1,
        dashStyle: SOLID,
        label: {
          visible: false,
          font: {
            color: WHITE,
            size: 12
          }
        },
        verticalLine: {
          visible: true
        },
        horizontalLine: {
          visible: true
        }
      },
      commonAxisSettings: {
        multipleAxesSpacing: 5,
        forceUserTickInterval: false,
        breakStyle: {
          width: 5,
          color: '#ababab',
          line: 'waved'
        },
        label: {
          displayMode: 'standard',
          overlappingBehavior: 'hide',
          indentFromAxis: 10,
          wordWrap: 'normal',
          textOverflow: 'none'
        },
        title: {
          font: {
            size: 16
          },
          margin: 6,
          alignment: CENTER
        },
        constantLineStyle: {
          paddingLeftRight: 10,
          paddingTopBottom: 10
        }
      },
      horizontalAxis: {
        position: BOTTOM,
        axisDivisionFactor: 70,
        label: {
          rotationAngle: 90,
          staggeringSpacing: 5,
          alignment: CENTER
        },
        stripStyle: {
          label: {
            horizontalAlignment: CENTER,
            verticalAlignment: TOP
          }
        },
        constantLineStyle: {
          label: {
            horizontalAlignment: RIGHT,
            verticalAlignment: TOP
          }
        },
        constantLines: []
      },
      verticalAxis: {
        position: LEFT,
        axisDivisionFactor: 40,
        label: {
          alignment: RIGHT
        },
        stripStyle: {
          label: {
            horizontalAlignment: LEFT,
            verticalAlignment: CENTER
          }
        },
        constantLineStyle: {
          label: {
            horizontalAlignment: LEFT,
            verticalAlignment: TOP
          }
        },
        constantLines: []
      },
      argumentAxis: {
        endOnTick: false,
        aggregateByCategory: true,
        workWeek: [1, 2, 3, 4, 5]
      },
      valueAxis: {
        grid: {
          visible: true
        },
        autoBreaksEnabled: false,
        maxAutoBreakCount: 4
      },
      commonPaneSettings: {
        backgroundColor: NONE,
        border: {
          color: LIGHT_GREY,
          width: 1,
          visible: false,
          top: true,
          bottom: true,
          left: true,
          right: true,
          dashStyle: SOLID
        }
      },
      scrollBar: {
        visible: false,
        offset: 5,
        color: 'gray',
        width: 10
      },
      adjustOnZoom: true,
      autoHidePointMarkers: true,
      rotated: false,
      synchronizeMultiAxes: true,
      stickyHovering: true,
      barGroupPadding: 0.3,
      minBubbleSize: 12,
      maxBubbleSize: 0.2,
      zoomAndPan: {
        dragBoxStyle: {
          color: '#2a2a2a',
          opacity: 0.2
        },
        panKey: 'shift',
        allowMouseWheel: true,
        allowTouchGestures: true
      }
    },
    pie: {
      innerRadius: 0.5,
      minDiameter: 0.5,
      type: 'pie',
      dataPrepareSettings: {
        _skipArgumentSorting: true
      },
      commonSeriesSettings: {
        pie: {
          border: {
            visible: false,
            width: 2,
            color: WHITE
          },
          hoverStyle: {
            hatching: {
              direction: RIGHT,
              width: 4,
              step: 10,
              opacity: 0.75
            },
            highlight: true,
            border: {
              visible: false,
              width: 2
            }
          },
          selectionStyle: {
            hatching: {
              direction: RIGHT,
              width: 4,
              step: 10,
              opacity: 0.5
            },
            highlight: true,
            border: {
              visible: false,
              width: 2
            }
          }
        },
        doughnut: {
          border: {
            visible: false,
            width: 2,
            color: WHITE
          },
          hoverStyle: {
            hatching: {
              direction: RIGHT,
              width: 4,
              step: 10,
              opacity: 0.75
            },
            highlight: true,
            border: {
              visible: false,
              width: 2
            }
          },
          selectionStyle: {
            hatching: {
              direction: RIGHT,
              width: 4,
              step: 10,
              opacity: 0.5
            },
            highlight: true,
            border: {
              visible: false,
              width: 2
            }
          }
        },
        donut: {
          border: {
            visible: false,
            width: 2,
            color: WHITE
          },
          hoverStyle: {
            hatching: {
              direction: RIGHT,
              width: 4,
              step: 10,
              opacity: 0.75
            },
            highlight: true,
            border: {
              visible: false,
              width: 2
            }
          },
          selectionStyle: {
            hatching: {
              direction: RIGHT,
              width: 4,
              step: 10,
              opacity: 0.5
            },
            highlight: true,
            border: {
              visible: false,
              width: 2
            }
          }
        },
        label: {
          textOverflow: 'ellipsis',
          wordWrap: 'normal'
        }
      },
      legend: {
        hoverMode: 'allArgumentPoints',
        backgroundColor: NONE
      },
      adaptiveLayout: {
        keepLabels: false
      }
    },
    gauge: {
      scale: {
        tick: {
          visible: true,
          length: 5,
          width: 2,
          opacity: 1
        },
        minorTick: {
          visible: false,
          length: 3,
          width: 1,
          opacity: 1
        },
        label: {
          visible: true,
          alignment: CENTER,
          hideFirstOrLast: 'last',
          overlappingBehavior: 'hide'
        },
        position: TOP,
        endOnTick: false
      },
      rangeContainer: {
        offset: 0,
        width: 5,
        backgroundColor: '#808080'
      },
      valueIndicators: {
        _default: {
          color: '#c2c2c2'
        },
        'rangebar': {
          space: 2,
          size: 10,
          color: '#cbc5cf',
          backgroundColor: NONE,
          text: {
            indent: 0,
            font: {
              size: 14,
              color: null
            }
          }
        },
        'twocolorneedle': {
          secondColor: '#e18e92'
        },
        'trianglemarker': {
          space: 2,
          length: 14,
          width: 13,
          color: '#8798a5'
        },
        'textcloud': {
          arrowLength: 5,
          horizontalOffset: 6,
          verticalOffset: 3,
          color: '#679ec5',
          text: {
            font: {
              color: WHITE,
              size: 18
            }
          }
        }
      },
      indicator: {
        hasPositiveMeaning: true,
        layout: {
          horizontalAlignment: CENTER,
          verticalAlignment: BOTTOM
        },
        text: {
          font: {
            size: 18
          }
        }
      },
      _circular: {
        scale: {
          scaleDivisionFactor: 17,
          orientation: OUTSIDE,
          label: {
            indentFromTick: 10
          }
        },
        rangeContainer: {
          orientation: OUTSIDE
        },
        valueIndicatorType: 'rectangleneedle',
        subvalueIndicatorType: 'trianglemarker',
        valueIndicators: {
          _type: 'rectangleneedle',
          _default: {
            offset: 20,
            indentFromCenter: 0,
            width: 2,
            spindleSize: 14,
            spindleGapSize: 10,
            beginAdaptingAtRadius: 50
          },
          'triangleneedle': {
            width: 4
          },
          'twocolorneedle': {
            space: 2,
            secondFraction: 0.4
          },
          'rangebar': {
            offset: 30
          },
          'trianglemarker': {
            offset: 6
          },
          'textcloud': {
            offset: -6
          }
        }
      },
      _linear: {
        scale: {
          scaleDivisionFactor: 25,
          horizontalOrientation: RIGHT,
          verticalOrientation: BOTTOM,
          label: {
            indentFromTick: -10
          }
        },
        rangeContainer: {
          horizontalOrientation: RIGHT,
          verticalOrientation: BOTTOM
        },
        valueIndicatorType: 'rangebar',
        subvalueIndicatorType: 'trianglemarker',
        valueIndicators: {
          _type: 'rectangle',
          _default: {
            offset: 2.5,
            length: 15,
            width: 15
          },
          'rectangle': {
            width: 10
          },
          'rangebar': {
            offset: 10,
            horizontalOrientation: RIGHT,
            verticalOrientation: BOTTOM
          },
          'trianglemarker': {
            offset: 10,
            horizontalOrientation: LEFT,
            verticalOrientation: TOP
          },
          'textcloud': {
            offset: -1,
            horizontalOrientation: LEFT,
            verticalOrientation: TOP
          }
        }
      }
    },
    barGauge: {
      backgroundColor: '#e0e0e0',
      relativeInnerRadius: 0.3,
      barSpacing: 4,
      resolveLabelOverlapping: 'hide',
      label: {
        indent: 20,
        connectorWidth: 2,
        font: {
          size: 16
        }
      },
      legend: {
        visible: false
      },
      indicator: {
        hasPositiveMeaning: true,
        layout: {
          horizontalAlignment: CENTER,
          verticalAlignment: BOTTOM
        },
        text: {
          font: {
            size: 18
          }
        }
      }
    },
    rangeSelector: {
      scale: {
        valueMarginsEnabled: true,
        width: 1,
        color: BLACK,
        opacity: 0.1,
        showCustomBoundaryTicks: true,
        aggregateByCategory: true,
        label: {
          overlappingBehavior: 'hide',
          alignment: CENTER,
          visible: true,
          topIndent: 7,
          font: {
            size: 11
          }
        },
        tick: {
          width: 1,
          color: BLACK,
          opacity: 0.17,
          visible: true,
          length: 12
        },
        minorTick: {
          width: 1,
          color: BLACK,
          opacity: 0.05,
          visible: true,
          length: 12
        },
        marker: {
          width: 1,
          color: '#000000',
          opacity: 0.1,
          visible: true,
          separatorHeight: 33,
          topIndent: 10,
          textLeftIndent: 7,
          textTopIndent: 11,
          label: {}
        },
        logarithmBase: 10,
        workWeek: [1, 2, 3, 4, 5],
        breakStyle: {
          width: 5,
          color: '#ababab',
          line: 'waved'
        },
        endOnTick: false
      },
      selectedRangeColor: '#606060',
      sliderMarker: {
        visible: true,
        paddingTopBottom: 2,
        paddingLeftRight: 4,
        color: '#606060',
        invalidRangeColor: RED,
        font: {
          color: WHITE,
          size: 11
        }
      },
      sliderHandle: {
        width: 1,
        color: BLACK,
        opacity: 0.2
      },
      shutter: {
        opacity: 0.75
      },
      background: {
        color: '#c0bae1',
        visible: true,
        image: {
          location: 'full'
        }
      },
      behavior: {
        snapToTicks: true,
        animationEnabled: true,
        moveSelectedRangeByClick: true,
        manualRangeSelectionEnabled: true,
        allowSlidersSwap: true,
        valueChangeMode: 'onHandleRelease'
      },
      redrawOnResize: true,
      chart: {
        barGroupPadding: 0.3,
        minBubbleSize: 12,
        maxBubbleSize: 0.2,
        topIndent: 0.1,
        bottomIndent: 0,
        valueAxis: {
          inverted: false,
          logarithmBase: 10
        },
        commonSeriesSettings: {
          type: 'area',
          aggregation: {
            enabled: undefined
          },
          point: {
            visible: false
          },
          scatter: {
            point: {
              visible: true
            }
          }
        }
      }
    },
    map: {
      title: {
        margin: 10
      },
      background: {
        borderWidth: 1,
        borderColor: '#cacaca'
      },
      layer: {
        label: {
          enabled: false,
          stroke: WHITE,
          'stroke-width': 1,
          'stroke-opacity': 0.7,
          font: {
            color: SOME_GREY,
            size: 12
          }
        }
      },
      'layer:area': {
        borderWidth: 1,
        borderColor: WHITE,
        color: '#d2d2d2',
        hoveredBorderColor: GREY_GREEN,
        selectedBorderWidth: 2,
        selectedBorderColor: GREY_GREEN,
        label: {
          'stroke-width': 2,
          font: {
            size: 16
          }
        }
      },
      'layer:line': {
        borderWidth: 2,
        color: '#ba8365',
        hoveredColor: '#a94813',
        selectedBorderWidth: 3,
        selectedColor: '#e55100',
        label: {
          'stroke-width': 2,
          font: {
            size: 16
          }
        }
      },
      'layer:marker': {
        label: {
          enabled: true,
          'stroke-width': 1,
          font: {
            size: 12
          }
        }
      },
      'layer:marker:dot': {
        borderWidth: 2,
        borderColor: WHITE,
        size: 8,
        selectedStep: 2,
        backStep: 18,
        backColor: WHITE,
        backOpacity: 0.32,
        shadow: true
      },
      'layer:marker:bubble': {
        minSize: 20,
        maxSize: 50,
        hoveredBorderWidth: 1,
        hoveredBorderColor: GREY_GREEN,
        selectedBorderWidth: 2,
        selectedBorderColor: GREY_GREEN
      },
      'layer:marker:pie': {
        size: 50,
        hoveredBorderWidth: 1,
        hoveredBorderColor: GREY_GREEN,
        selectedBorderWidth: 2,
        selectedBorderColor: GREY_GREEN
      },
      'layer:marker:image': {
        size: 20
      },
      legend: {
        verticalAlignment: BOTTOM,
        horizontalAlignment: RIGHT,
        position: INSIDE,
        backgroundOpacity: 0.65,
        border: {
          visible: true
        },
        paddingLeftRight: 16,
        paddingTopBottom: 12
      },
      controlBar: {
        borderColor: '#5d5d5d',
        borderWidth: 3,
        color: WHITE,
        margin: 20,
        opacity: 0.3
      },
      _rtl: {
        legend: {
          itemTextPosition: LEFT
        }
      }
    },
    treeMap: {
      tile: {
        border: {
          width: 1,
          opacity: 0.2,
          color: '#000000'
        },
        color: '#5f8b95',
        hoverStyle: {
          hatching: {
            opacity: 0.75,
            step: 6,
            width: 2,
            direction: 'right'
          },
          border: {}
        },
        selectionStyle: {
          hatching: {
            opacity: 0.5,
            step: 6,
            width: 2,
            direction: 'right'
          },
          border: {
            opacity: 1
          }
        },
        label: {
          visible: true,
          paddingLeftRight: 5,
          paddingTopBottom: 4,
          font: {
            color: '#ffffff',
            weight: 600
          },
          shadow: {
            opacity: 0.6,
            offsetX: 0,
            offsetY: 1,
            blur: 2,
            color: '#000000'
          },
          wordWrap: 'normal',
          textOverflow: 'ellipsis'
        }
      },
      group: {
        padding: 4,
        border: {
          width: 1
        },
        color: '#eeeeee',
        hoverStyle: {
          hatching: {
            opacity: 0,
            step: 6,
            width: 2,
            direction: 'right'
          },
          border: {}
        },
        selectionStyle: {
          hatching: {
            opacity: 0,
            step: 6,
            width: 2,
            direction: 'right'
          },
          border: {}
        },
        label: {
          visible: true,
          paddingLeftRight: 5,
          paddingTopBottom: 4,
          font: {
            color: SECONDARY_TITLE_COLOR,
            weight: 600
          },
          textOverflow: 'ellipsis'
        }
      },
      title: {
        subtitle: {}
      },
      tooltip: {},
      loadingIndicator: {}
    },
    sparkline: {
      lineColor: '#666666',
      lineWidth: 2,
      areaOpacity: 0.2,
      minColor: '#e8c267',
      maxColor: '#e55253',
      barPositiveColor: '#a9a9a9',
      barNegativeColor: '#d7d7d7',
      winColor: '#a9a9a9',
      lossColor: '#d7d7d7',
      firstLastColor: '#666666',
      pointSymbol: 'circle',
      pointColor: WHITE,
      pointSize: 4,
      type: 'line',
      argumentField: 'arg',
      valueField: 'val',
      winlossThreshold: 0,
      showFirstLast: true,
      showMinMax: false,
      tooltip: {
        enabled: true
      }
    },
    bullet: {
      color: '#e8c267',
      targetColor: '#666666',
      targetWidth: 4,
      showTarget: true,
      showZeroLevel: true,
      tooltip: {
        enabled: true
      }
    },
    polar: {
      commonSeriesSettings: {
        type: 'scatter',
        closed: true,
        'point': {
          visible: true,
          symbol: 'circle',
          size: 12,
          border: {
            visible: false,
            width: 1
          },
          hoverMode: 'onlyPoint',
          selectionMode: 'onlyPoint',
          hoverStyle: {
            border: {
              visible: true,
              width: 4
            },
            size: 12
          },
          selectionStyle: {
            border: {
              visible: true,
              width: 4
            },
            size: 12
          }
        },
        'scatter': {},
        'line': {
          width: 2,
          dashStyle: SOLID,
          hoverStyle: {
            width: 3,
            hatching: {
              direction: NONE
            }
          },
          selectionStyle: {
            width: 3
          }
        },
        'area': {
          point: {
            visible: false
          },
          opacity: 0.5
        },
        'stackedline': {
          width: 2
        },
        'bar': {
          opacity: 0.8
        },
        'stackedbar': {
          opacity: 0.8
        }
      },
      adaptiveLayout: {
        width: 80,
        height: 80,
        keepLabels: true
      },
      barGroupPadding: 0.3,
      commonAxisSettings: {
        visible: true,
        forceUserTickInterval: false,
        label: {
          overlappingBehavior: 'hide',
          indentFromAxis: 5
        },
        grid: {
          visible: true
        },
        minorGrid: {
          visible: true
        },
        tick: {
          visible: true
        },
        title: {
          font: {
            size: 16
          },
          margin: 10
        }
      },
      argumentAxis: {
        startAngle: 0,
        firstPointOnStartAngle: false,
        period: undefined
      },
      valueAxis: {
        endOnTick: false,
        tick: {
          visible: false
        }
      },
      horizontalAxis: {
        position: TOP,
        axisDivisionFactor: 50,
        label: {
          alignment: CENTER
        }
      },
      verticalAxis: {
        position: TOP,
        axisDivisionFactor: 30,
        label: {
          alignment: RIGHT
        }
      }
    },
    funnel: {
      sortData: true,
      valueField: 'val',
      colorField: 'color',
      argumentField: 'arg',
      hoverEnabled: true,
      selectionMode: 'single',
      item: {
        border: {
          visible: false,
          width: 2,
          color: WHITE
        },
        hoverStyle: {
          hatching: {
            opacity: 0.75,
            step: 6,
            width: 2,
            direction: RIGHT
          },
          border: {}
        },
        selectionStyle: {
          hatching: {
            opacity: 0.5,
            step: 6,
            width: 2,
            direction: RIGHT
          },
          border: {}
        }
      },
      title: {
        margin: 10
      },
      adaptiveLayout: {
        width: 80,
        height: 80,
        keepLabels: true
      },
      legend: {
        visible: false
      },
      _rtl: {
        legend: {
          itemTextPosition: LEFT
        }
      },
      tooltip: {
        customizeTooltip: function customizeTooltip(info) {
          return {
            text: info.item.argument + ' ' + info.valueText
          };
        }
      },
      inverted: false,
      algorithm: 'dynamicSlope',
      neckWidth: 0,
      neckHeight: 0,
      resolveLabelOverlapping: 'shift',
      label: {
        textOverflow: 'ellipsis',
        wordWrap: 'normal',
        visible: true,
        horizontalAlignment: RIGHT,
        horizontalOffset: 0,
        verticalOffset: 0,
        showForZeroValues: false,
        customizeText: function customizeText(info) {
          return info.item.argument + ' ' + info.valueText;
        },
        position: 'columns',
        font: {
          color: WHITE
        },
        border: {
          visible: false,
          width: 1,
          color: LIGHT_GREY,
          dashStyle: SOLID
        },
        connector: {
          visible: true,
          width: 1,
          opacity: 0.5
        }
      }
    },
    sankey: {
      sourceField: 'source',
      targetField: 'target',
      weightField: 'weight',
      hoverEnabled: true,
      alignment: CENTER,
      adaptiveLayout: {
        width: 80,
        height: 80,
        keepLabels: true
      },
      label: {
        visible: true,
        horizontalOffset: 8,
        verticalOffset: 0,
        overlappingBehavior: 'ellipsis',
        useNodeColors: false,
        font: {
          color: BLACK,
          weight: 500
        },
        border: {
          visible: false,
          width: 2,
          color: WHITE
        },
        customizeText: function customizeText(info) {
          return info.title;
        },
        shadow: {
          opacity: 0.2,
          offsetX: 0,
          offsetY: 1,
          blur: 1,
          color: WHITE
        }
      },
      title: {
        margin: 10,
        font: {
          size: 28,
          weight: 200
        },
        subtitle: {
          font: {
            size: 16
          }
        }
      },
      tooltip: {
        enabled: true
      },
      node: {
        padding: 30,
        width: 8,
        opacity: 1,
        border: {
          color: WHITE,
          width: 1,
          visible: false
        },
        hoverStyle: {
          hatching: {
            opacity: 0.75,
            step: 6,
            width: 2,
            direction: RIGHT
          },
          border: {}
        }
      },
      link: {
        color: '#888888',
        colorMode: 'none',
        opacity: 0.3,
        border: {
          color: WHITE,
          width: 1,
          visible: false
        },
        hoverStyle: {
          opacity: 0.5,
          hatching: {
            opacity: 0.75,
            step: 6,
            width: 2,
            direction: RIGHT
          },
          border: {}
        }
      }
    }
  },
  baseThemeName: undefined
}, {
  theme: {
    name: 'generic.light.compact'
  },
  baseThemeName: 'generic.light'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 60350:
/***/ (function(module, exports) {



exports["default"] = void 0;
var ACCENT_COLOR = '#7ab8eb';
var BACKGROUND_COLOR = '#fff';
var TITLE_COLOR = '#333';
var SUBTITLE_COLOR = '#99a1a8';
var TEXT_COLOR = '#707070';
var BORDER_COLOR = '#e8eaeb';
var _default = [{
  theme: {
    name: 'generic.softblue',
    defaultPalette: 'Soft Blue',
    backgroundColor: BACKGROUND_COLOR,
    primaryTitleColor: TITLE_COLOR,
    secondaryTitleColor: SUBTITLE_COLOR,
    gridColor: BORDER_COLOR,
    axisColor: TEXT_COLOR,
    'export': {
      backgroundColor: BACKGROUND_COLOR,
      font: {
        color: TITLE_COLOR
      },
      button: {
        'default': {
          color: TITLE_COLOR,
          borderColor: '#c9d0d4',
          backgroundColor: BACKGROUND_COLOR
        },
        hover: {
          color: TITLE_COLOR,
          borderColor: '#a7b2b9',
          backgroundColor: '#e6e6e6'
        },
        focus: {
          color: TITLE_COLOR,
          borderColor: '#82929b',
          backgroundColor: '#e6e6e6'
        },
        active: {
          color: TITLE_COLOR,
          borderColor: '#82929b',
          backgroundColor: '#d4d4d4'
        }
      }
    },
    legend: {
      font: {
        color: TEXT_COLOR
      }
    },
    tooltip: {
      color: BACKGROUND_COLOR,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: BORDER_COLOR
          }
        }
      }
    },
    'chart:common:annotation': {
      color: BACKGROUND_COLOR,
      border: {
        color: BORDER_COLOR
      },
      font: {
        color: TITLE_COLOR
      }
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: '#cfd2d3'
        }
      }
    },
    rangeSelector: {
      scale: {
        breakStyle: {
          color: '#cfd2d3'
        },
        tick: {
          opacity: 0.12
        }
      },
      selectedRangeColor: ACCENT_COLOR,
      sliderMarker: {
        color: ACCENT_COLOR
      },
      sliderHandle: {
        color: ACCENT_COLOR,
        opacity: 0.5
      }
    },
    sparkline: {
      pointColor: BACKGROUND_COLOR,
      minColor: '#f0ad4e',
      maxColor: '#d9534f'
    },
    treeMap: {
      group: {
        color: BORDER_COLOR,
        label: {
          font: {
            color: SUBTITLE_COLOR
          }
        }
      }
    },
    bullet: {
      color: ACCENT_COLOR
    },
    gauge: {
      valueIndicators: {
        'rangebar': {
          color: ACCENT_COLOR
        },
        'textcloud': {
          color: ACCENT_COLOR
        }
      }
    }
  },
  baseThemeName: 'generic.light'
}, {
  theme: {
    name: 'generic.softblue.compact'
  },
  baseThemeName: 'generic.softblue'
}];
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 11239:
/***/ (function(module, exports) {



exports["default"] = void 0;
var FONT_FAMILY = '\'Roboto\', \'RobotoFallback\', \'Helvetica\', \'Arial\', sans-serif';
var LIGHT_TITLE_COLOR = 'rgba(0,0,0,0.87)';
var LIGHT_LABEL_COLOR = 'rgba(0,0,0,0.54)';
var DARK_TITLE_COLOR = 'rgba(255,255,255,0.87)';
var DARK_LABEL_COLOR = 'rgba(255,255,255,0.54)';
var DARK_BACKGROUND_COLOR = '#363640';
var WHITE = '#ffffff';
var BLACK = '#000000';
var RANGE_COLOR = '#b5b5b5';
var AREA_LAYER_COLOR = '#686868';
var LINE_COLOR = '#c7c7c7';
var TARGET_COLOR = '#8e8e8e';
var POSITIVE_COLOR = '#b8b8b8';
var LABEL_BORDER_COLOR = '#494949';
var BREAK_STYLE_COLOR = '#818181';
var themes = [{
  theme: {
    name: 'material',
    defaultPalette: 'Material',
    font: {
      family: FONT_FAMILY
    },
    title: {
      margin: {
        top: 20,
        bottom: 20,
        left: 0,
        right: 0
      },
      font: {
        size: 20,
        family: FONT_FAMILY,
        weight: 500
      },
      horizontalAlignment: 'left',
      subtitle: {
        font: {
          size: 14
        },
        horizontalAlignment: 'left'
      }
    },
    tooltip: {
      shadow: {
        opacity: 0
      },
      border: {
        visible: false
      },
      paddingLeftRight: 8,
      paddingTopBottom: 6,
      arrowLength: 0,
      location: 'edge',
      color: '#616161',
      font: {
        color: WHITE
      },
      cornerRadius: 4
    },
    chart: {
      commonAxisSettings: {
        minorTick: {
          opacity: 0.5
        },
        label: {
          font: {
            size: 11
          }
        }
      },
      commonAnnotationSettings: {
        font: {
          color: WHITE
        },
        border: {
          color: '#616161'
        },
        color: '#616161',
        arrowLength: 14,
        arrowWidth: 0,
        shadow: {
          opacity: 0.08,
          offsetY: 4,
          blur: 8
        },
        cornerRadius: 4
      }
    },
    pie: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    polar: {
      commonAxisSettings: {
        minorTick: {
          opacity: 0.5
        }
      },
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    funnel: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    gauge: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    barGauge: {
      title: {
        horizontalAlignment: 'center',
        subtitle: {
          horizontalAlignment: 'center'
        }
      }
    },
    rangeSelector: {
      sliderHandle: {
        opacity: 0.5
      }
    },
    treeMap: {
      group: {
        label: {
          font: {
            weight: 500
          }
        }
      }
    }
  },
  baseThemeName: 'generic.light'
}, {
  theme: {
    name: 'material.light',
    gridColor: '#e0e0e0',
    axisColor: LIGHT_LABEL_COLOR,
    primaryTitleColor: LIGHT_TITLE_COLOR,
    legend: {
      font: {
        color: LIGHT_LABEL_COLOR
      }
    },
    chart: {
      scrollBar: {
        color: '#bfbfbf',
        opacity: 0.7
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: 'rgba(0,0,0,0.2)'
      }
    },
    barGauge: {
      backgroundColor: '#efefef'
    }
  },
  baseThemeName: 'material'
}, {
  theme: {
    name: 'material.dark',
    gridColor: '#515159',
    backgroundColor: DARK_BACKGROUND_COLOR,
    axisColor: DARK_LABEL_COLOR,
    font: {
      color: DARK_LABEL_COLOR
    },
    primaryTitleColor: DARK_TITLE_COLOR,
    secondaryTitleColor: DARK_TITLE_COLOR,
    tooltip: {
      color: '#000'
    },
    'export': {
      backgroundColor: DARK_BACKGROUND_COLOR,
      font: {
        color: '#dbdbdb'
      },
      button: {
        'default': {
          color: '#dedede',
          borderColor: '#4d4d4d',
          backgroundColor: DARK_BACKGROUND_COLOR
        },
        hover: {
          color: '#dedede',
          borderColor: '#6c6c6c',
          backgroundColor: '#3f3f4b'
        },
        focus: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#494956'
        },
        active: {
          color: '#dedede',
          borderColor: '#8d8d8d',
          backgroundColor: '#494956'
        }
      },
      shadowColor: '#292929'
    },
    'chart:common': {
      commonSeriesSettings: {
        label: {
          border: {
            color: LABEL_BORDER_COLOR
          }
        },
        valueErrorBar: {
          color: WHITE
        }
      }
    },
    'chart:common:axis': {
      constantLineStyle: {
        color: WHITE
      }
    },
    'chart:common:annotation': {
      border: {
        color: '#000'
      },
      color: '#000'
    },
    chart: {
      commonPaneSettings: {
        border: {
          color: LABEL_BORDER_COLOR
        }
      },
      commonAxisSettings: {
        breakStyle: {
          color: BREAK_STYLE_COLOR
        }
      },
      zoomAndPan: {
        dragBoxStyle: {
          color: WHITE
        }
      }
    },
    gauge: {
      rangeContainer: {
        backgroundColor: RANGE_COLOR
      },
      valueIndicators: {
        _default: {
          color: RANGE_COLOR
        },
        'rangebar': {
          color: '#84788b'
        },
        'twocolorneedle': {
          secondColor: '#ba544d'
        },
        'trianglemarker': {
          color: '#b7918f'
        },
        'textcloud': {
          color: '#ba544d'
        }
      }
    },
    barGauge: {
      backgroundColor: '#3c3c3c'
    },
    rangeSelector: {
      scale: {
        tick: {
          color: WHITE,
          opacity: 0.32
        },
        minorTick: {
          color: WHITE,
          opacity: 0.1
        },
        breakStyle: {
          color: BREAK_STYLE_COLOR
        }
      },
      selectedRangeColor: RANGE_COLOR,
      sliderMarker: {
        color: RANGE_COLOR,
        font: {
          color: DARK_BACKGROUND_COLOR
        }
      },
      sliderHandle: {
        color: WHITE,
        opacity: 0.2
      },
      shutter: {
        color: WHITE,
        opacity: 0.1
      }
    },
    map: {
      background: {
        borderColor: '#3f3f3f'
      },
      layer: {
        label: {
          stroke: BLACK,
          font: {
            color: WHITE
          }
        }
      },
      'layer:area': {
        borderColor: DARK_BACKGROUND_COLOR,
        color: AREA_LAYER_COLOR,
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:line': {
        color: '#c77244',
        hoveredColor: '#ff5d04',
        selectedColor: '#ff784f'
      },
      'layer:marker:bubble': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      'layer:marker:pie': {
        hoveredBorderColor: WHITE,
        selectedBorderColor: WHITE
      },
      legend: {
        border: {
          color: '#3f3f3f'
        },
        font: {
          color: WHITE
        }
      },
      controlBar: {
        borderColor: LINE_COLOR,
        color: DARK_BACKGROUND_COLOR
      }
    },
    treeMap: {
      group: {
        color: '#4c4c4c',
        label: {
          font: {
            color: '#a3a3a3'
          }
        }
      }
    },
    sparkline: {
      lineColor: LINE_COLOR,
      firstLastColor: LINE_COLOR,
      barPositiveColor: POSITIVE_COLOR,
      barNegativeColor: TARGET_COLOR,
      winColor: POSITIVE_COLOR,
      lossColor: TARGET_COLOR,
      pointColor: DARK_BACKGROUND_COLOR
    },
    bullet: {
      targetColor: TARGET_COLOR
    },
    funnel: {
      item: {
        border: {
          color: DARK_BACKGROUND_COLOR
        }
      }
    },
    sankey: {
      label: {
        font: {
          color: WHITE
        }
      }
    }
  },
  baseThemeName: 'material'
}];
function getMaterialColorScheme(accentName, themeName, accentColor) {
  return {
    theme: {
      name: 'material.' + accentName + '.' + themeName,
      rangeSelector: {
        selectedRangeColor: accentColor,
        sliderMarker: {
          color: accentColor
        },
        sliderHandle: {
          color: accentColor
        }
      },
      map: {
        'layer:marker:dot': {
          color: accentColor
        },
        'layer:marker:bubble': {
          color: accentColor
        },
        legend: {
          markerColor: accentColor
        }
      },
      bullet: {
        color: accentColor
      },
      gauge: {
        valueIndicators: {
          'rangebar': {
            color: accentColor
          },
          'textcloud': {
            color: accentColor
          }
        }
      }
    },
    baseThemeName: 'material.' + themeName
  };
}
var materialAccents = {
  'blue': '#03a9f4',
  'lime': '#cddc39',
  'orange': '#ff5722',
  'purple': '#9c27b0',
  'teal': '#009688'
};
for (var accent in materialAccents) {
  if (Object.prototype.hasOwnProperty.call(materialAccents, accent)) {
    var color = materialAccents[accent];
    themes.push(getMaterialColorScheme(accent, 'light', color), getMaterialColorScheme(accent, 'dark', color), {
      theme: {
        name: "material.".concat(accent, ".light.compact")
      },
      baseThemeName: "material.".concat(accent, ".light")
    }, {
      theme: {
        name: "material.".concat(accent, ".dark.compact")
      },
      baseThemeName: "material.".concat(accent, ".dark")
    });
  }
}
var _default = themes;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 17384:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.Title = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _layout_element = __webpack_require__(73711);
var _Number = Number;
var parseHorizontalAlignment = (0, _utils.enumParser)(['left', 'center', 'right']);
var parseVerticalAlignment = (0, _utils.enumParser)(['top', 'bottom']);
var DEFAULT_MARGIN = 10;
function hasText(text) {
  return !!(text && String(text).length > 0);
}
function processTitleLength(elem, text, width, options, placeholderSize) {
  if (elem.attr({
    text
  }).setMaxSize(width, placeholderSize, options).textChanged) {
    elem.setTitle(text);
  }
}
function pickMarginValue(value) {
  return value >= 0 ? _Number(value) : DEFAULT_MARGIN;
}
function validateMargin(margin) {
  var result;
  if (margin >= 0) {
    result = {
      left: _Number(margin),
      top: _Number(margin),
      right: _Number(margin),
      bottom: _Number(margin)
    };
  } else {
    margin = margin || {};
    result = {
      left: pickMarginValue(margin.left),
      top: pickMarginValue(margin.top),
      right: pickMarginValue(margin.right),
      bottom: pickMarginValue(margin.bottom)
    };
  }
  return result;
}
function checkRect(rect, boundingRect) {
  return rect[2] - rect[0] < boundingRect.width || rect[3] - rect[1] < boundingRect.height;
}
var Title = function Title(params) {
  this._params = params;
  this._group = params.renderer.g().attr({
    'class': params.cssClass
  }).linkOn(params.root || params.renderer.root, 'title');
  this._hasText = false;
};

// There is no normal inheritance from LayoutElement because it is actually a container of methods rather than a class.
exports.Title = Title;
(0, _extend.extend)(Title.prototype, _layout_element.LayoutElement.prototype, {
  dispose: function dispose() {
    var that = this;
    that._group.linkRemove();
    that._group.linkOff();
    if (that._titleElement) {
      that._clipRect.dispose();
      that._titleElement = that._subtitleElement = that._clipRect = null;
    }
    that._params = that._group = that._options = null;
  },
  _updateOptions: function _updateOptions(options) {
    this._options = options;
    this._options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, 'center');
    this._options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, 'top');
    this._options.margin = validateMargin(options.margin);
  },
  _updateStructure: function _updateStructure() {
    var that = this;
    var renderer = that._params.renderer;
    var group = that._group;
    var options = that._options;
    var align = options.horizontalAlignment;

    // Looks like the following "laziness" is only to avoid unnecessary DOM content creation -
    // for example when widget is created without "title" option.
    if (!that._titleElement) {
      that._titleElement = renderer.text().append(group);
      that._subtitleElement = renderer.text();
      that._clipRect = renderer.clipRect();
      group.attr({
        'clip-path': that._clipRect.id
      });
    }
    that._titleElement.attr({
      align,
      'class': options.cssClass
    });
    that._subtitleElement.attr({
      align,
      'class': options.subtitle.cssClass
    });
    group.linkAppend();
    hasText(options.subtitle.text) ? that._subtitleElement.append(group) : that._subtitleElement.remove();
  },
  _updateTexts: function _updateTexts() {
    var that = this;
    var options = that._options;
    var subtitleOptions = options.subtitle;
    var titleElement = that._titleElement;
    var subtitleElement = that._subtitleElement;
    var testText = 'A';
    var titleBox;
    titleElement.attr({
      text: testText,
      y: 0
    }).css((0, _utils.patchFontOptions)(options.font));
    titleBox = titleElement.getBBox(); // for multiline text
    that._baseLineCorrection = titleBox.height + titleBox.y;
    titleElement.attr({
      text: options.text
    });
    titleBox = titleElement.getBBox();
    var y = -titleBox.y;
    titleElement.attr({
      y: y
    });
    if (hasText(subtitleOptions.text)) {
      subtitleElement.attr({
        text: subtitleOptions.text,
        y: 0
      }).css((0, _utils.patchFontOptions)(subtitleOptions.font));
    }
  },
  _shiftSubtitle() {
    var that = this;
    var titleBox = that._titleElement.getBBox();
    var element = that._subtitleElement;
    var offset = that._options.subtitle.offset;
    element.move(0, titleBox.y + titleBox.height - element.getBBox().y - offset);
  },
  _updateBoundingRectAlignment: function _updateBoundingRectAlignment() {
    var boundingRect = this._boundingRect;
    var options = this._options;
    boundingRect.verticalAlignment = options.verticalAlignment;
    boundingRect.horizontalAlignment = options.horizontalAlignment;
    boundingRect.cutLayoutSide = options.verticalAlignment;
    boundingRect.cutSide = 'vertical';
    boundingRect.position = {
      horizontal: options.horizontalAlignment,
      vertical: options.verticalAlignment
    };
  },
  hasText: function hasText() {
    return this._hasText;
  },
  update: function update(themeOptions, userOptions) {
    var that = this;
    var options = (0, _extend.extend)(true, {}, themeOptions, processTitleOptions(userOptions));
    var _hasText = hasText(options.text);
    var isLayoutChanged = _hasText || _hasText !== that._hasText;
    that._baseLineCorrection = 0;
    that._updateOptions(options);
    that._boundingRect = {};
    if (_hasText) {
      that._updateStructure();
      that._updateTexts();
    } else {
      that._group.linkRemove();
    }
    that._updateBoundingRect();
    that._updateBoundingRectAlignment();
    that._hasText = _hasText;
    return isLayoutChanged;
  },
  draw: function draw(width, height) {
    var that = this;
    if (that._hasText) {
      that._group.linkAppend();
      that._correctTitleLength(width);
      if (that._group.getBBox().height > height) {
        this.freeSpace();
      }
    }
    return that;
  },
  _correctTitleLength: function _correctTitleLength(width) {
    var that = this;
    var options = that._options;
    var margin = options.margin;
    var maxWidth = width - margin.left - margin.right;
    var placeholderSize = options.placeholderSize;
    processTitleLength(that._titleElement, options.text, maxWidth, options, placeholderSize);
    if (that._subtitleElement) {
      if (_Number(placeholderSize) > 0) {
        placeholderSize -= that._titleElement.getBBox().height;
      }
      processTitleLength(that._subtitleElement, options.subtitle.text, maxWidth, options.subtitle, placeholderSize);
      that._shiftSubtitle();
    }
    that._updateBoundingRect();
    var _this$getCorrectedLay = this.getCorrectedLayoutOptions(),
      x = _this$getCorrectedLay.x,
      y = _this$getCorrectedLay.y,
      height = _this$getCorrectedLay.height;
    this._clipRect.attr({
      x,
      y,
      width,
      height
    });
  },
  getLayoutOptions: function getLayoutOptions() {
    return this._boundingRect || null;
  },
  shift: function shift(x, y) {
    var that = this;
    var box = that.getLayoutOptions();
    that._group.move(x - box.x, y - box.y);
    return that;
  },
  _updateBoundingRect: function _updateBoundingRect() {
    var that = this;
    var options = that._options;
    var margin = options.margin;
    var boundingRect = that._boundingRect;
    var box = that._hasText ? that._group.getBBox() : {
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      isEmpty: true
    };
    if (!box.isEmpty) {
      box.height += margin.top + margin.bottom - that._baseLineCorrection;
      box.width += margin.left + margin.right;
      box.x -= margin.left;
      box.y += that._baseLineCorrection - margin.top;
    }
    if (options.placeholderSize > 0) {
      box.height = options.placeholderSize;
    }
    boundingRect.height = box.height;
    boundingRect.width = box.width;
    boundingRect.x = box.x;
    boundingRect.y = box.y;
  },
  getCorrectedLayoutOptions() {
    var srcBox = this.getLayoutOptions();
    var correction = this._baseLineCorrection;
    return (0, _extend.extend)({}, srcBox, {
      y: srcBox.y - correction,
      height: srcBox.height + correction
    });
  },
  // BaseWidget_layout_implementation
  layoutOptions: function layoutOptions() {
    if (!this._hasText) {
      return null;
    }
    return {
      horizontalAlignment: this._boundingRect.horizontalAlignment,
      verticalAlignment: this._boundingRect.verticalAlignment,
      priority: 0
    };
  },
  measure: function measure(size) {
    this.draw(size[0], size[1]);
    return [this._boundingRect.width, this._boundingRect.height];
  },
  move: function move(rect, fitRect) {
    var boundingRect = this._boundingRect;
    if (checkRect(rect, boundingRect)) {
      this.shift(fitRect[0], fitRect[1]);
    } else {
      this.shift(Math.round(rect[0]), Math.round(rect[1]));
    }
  },
  freeSpace: function freeSpace() {
    var that = this;
    that._params.incidentOccurred('W2103');
    that._group.linkRemove();
    that._boundingRect.width = that._boundingRect.height = 0;
  },
  getOptions: function getOptions() {
    return this._options;
  },
  changeLink: function changeLink(root) {
    this._group.linkRemove();
    this._group.linkOn(root, 'title');
  }
  // BaseWidget_layout_implementation
});

function processTitleOptions(options) {
  var newOptions = (0, _type.isString)(options) ? {
    text: options
  } : options || {};
  newOptions.subtitle = (0, _type.isString)(newOptions.subtitle) ? {
    text: newOptions.subtitle
  } : newOptions.subtitle || {};
  return newOptions;
}
var plugin = {
  name: 'title',
  init: function init() {
    var that = this;
    // "exports" is used for testing purposes.
    that._title = new Title({
      renderer: that._renderer,
      cssClass: that._rootClassPrefix + '-title',
      incidentOccurred: that._incidentOccurred
    });
    that._layout.add(that._title);
  },
  dispose: function dispose() {
    this._title.dispose();
    this._title = null;
  },
  customize: function customize(constructor) {
    constructor.addChange({
      code: 'TITLE',
      handler: function handler() {
        if (this._title.update(this._themeManager.theme('title'), this.option('title'))) {
          this._change(['LAYOUT']);
        }
      },
      isThemeDependent: true,
      option: 'title',
      isOptionChange: true
    });
  },
  fontFields: ['title.font', 'title.subtitle.font']
};
exports.plugin = plugin;

/***/ }),

/***/ 14371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = exports.Tooltip = void 0;
var _size = __webpack_require__(58664);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _window = __webpack_require__(58201);
var _dom = __webpack_require__(3532);
var _inflector = __webpack_require__(78008);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _renderer2 = __webpack_require__(56453);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _plaque = __webpack_require__(64509);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var format = _format_helper.default.format;
var mathCeil = Math.ceil;
var mathMax = Math.max;
var mathMin = Math.min;
var window = (0, _window.getWindow)();
var DEFAULT_HTML_GROUP_WIDTH = 3000;
function hideElement($element) {
  $element.css({
    left: '-9999px'
  }).detach();
}
function getSpecialFormatOptions(options, specialFormat) {
  var result = options;
  switch (specialFormat) {
    case 'argument':
      result = {
        format: options.argumentFormat
      };
      break;
    case 'percent':
      result = {
        format: {
          type: 'percent',
          precision: options.format && options.format.percentPrecision
        }
      };
      break;
  }
  return result;
}
function createTextHtml() {
  return (0, _renderer.default)('<div>').css({
    position: 'relative',
    display: 'inline-block',
    padding: 0,
    margin: 0,
    border: '0px solid transparent'
  });
}
function removeElements(elements) {
  elements.forEach(function (el) {
    return el.remove();
  });
}
var Tooltip = function Tooltip(params) {
  var that = this;
  that._eventTrigger = params.eventTrigger;
  that._widgetRoot = params.widgetRoot;
  that._widget = params.widget;
  that._textHtmlContainers = []; // T1015148

  that._wrapper = (0, _renderer.default)('<div>').css({
    position: 'absolute',
    overflow: 'hidden',
    'pointerEvents': 'none'
  }) // T265557, T447623
  .addClass(params.cssClass);
  var renderer = that._renderer = new _renderer2.Renderer({
    pathModified: params.pathModified,
    container: that._wrapper[0]
  });
  var root = renderer.root;
  root.attr({
    'pointer-events': 'none'
  });

  // svg text
  that._text = renderer.text(undefined, 0, 0);

  // html text
  that._textGroupHtml = (0, _renderer.default)('<div>').css({
    position: 'absolute',
    padding: 0,
    margin: 0,
    border: '0px solid transparent'
  }).appendTo(that._wrapper);
  that._textHtml = createTextHtml().appendTo(that._textGroupHtml);
};
exports.Tooltip = Tooltip;
Tooltip.prototype = {
  constructor: Tooltip,
  dispose: function dispose() {
    this._wrapper.remove();
    this._renderer.dispose();
    this._options = this._widgetRoot = null;
  },
  _getContainer: function _getContainer() {
    var options = this._options;
    var container = (0, _renderer.default)(this._widgetRoot).closest(options.container);
    if (container.length === 0) {
      container = (0, _renderer.default)(options.container);
    }
    return (container.length ? container : (0, _renderer.default)('body')).get(0);
  },
  setTemplate(contentTemplate) {
    var that = this;
    that._template = contentTemplate ? that._widget._getTemplate(contentTemplate) : null;
  },
  setOptions: function setOptions(options) {
    var _this = this;
    options = options || {};
    var that = this;
    that._options = options;
    that._textFontStyles = (0, _utils.patchFontOptions)(options.font);
    that._textFontStyles.color = that._textFontStyles.fill;
    that._wrapper.css({
      'zIndex': options.zIndex
    });
    that._customizeTooltip = options.customizeTooltip;
    var textGroupHtml = that._textGroupHtml;
    if (this.plaque) {
      this.plaque.clear();
    }
    this.setTemplate(options.contentTemplate);
    var pointerEvents = options.interactive ? 'auto' : 'none';
    if (options.interactive) {
      this._renderer.root.css({
        '-ms-user-select': 'auto',
        '-moz-user-select': 'auto',
        '-webkit-user-select': 'auto'
      });
    }
    var drawTooltip = function drawTooltip(_ref) {
      var group = _ref.group,
        onRender = _ref.onRender,
        eventData = _ref.eventData,
        isMoving = _ref.isMoving,
        _ref$templateCallback = _ref.templateCallback,
        templateCallback = _ref$templateCallback === void 0 ? function () {} : _ref$templateCallback;
      var state = that._state;
      if (!isMoving) {
        var template = that._template;
        var useTemplate = template && !state.formatObject.skipTemplate;
        if (state.html || useTemplate) {
          textGroupHtml.css({
            color: state.textColor,
            width: DEFAULT_HTML_GROUP_WIDTH,
            'pointerEvents': pointerEvents
          });
          if (useTemplate) {
            var htmlContainers = that._textHtmlContainers;
            var containerToTemplateRender = createTextHtml().appendTo(that._textGroupHtml);
            htmlContainers.push(containerToTemplateRender);
            template.render({
              model: state.formatObject,
              container: containerToTemplateRender,
              onRendered: function onRendered() {
                removeElements(htmlContainers.splice(0, htmlContainers.length - 1));
                that._textHtml = (0, _dom.replaceWith)(that._textHtml, containerToTemplateRender);
                state.html = that._textHtml.html();
                if ((0, _size.getWidth)(that._textHtml) === 0 && (0, _size.getHeight)(that._textHtml) === 0) {
                  _this.plaque.clear();
                  templateCallback(false);
                  return;
                }
                onRender();
                that._riseEvents(eventData);
                that._moveWrapper();
                that.plaque.customizeCloud({
                  fill: state.color,
                  stroke: state.borderColor,
                  'pointer-events': pointerEvents
                });
                templateCallback(true);
                that._textHtmlContainers = [];
              }
            });
            return;
          } else {
            that._text.attr({
              text: ''
            });
            that._textHtml.html(state.html);
          }
        } else {
          that._text.css({
            fill: state.textColor
          }).attr({
            text: state.text,
            class: options.cssClass,
            'pointer-events': pointerEvents
          }).append(group.attr({
            align: options.textAlignment
          }));
        }
        that._riseEvents(eventData);
        that.plaque.customizeCloud({
          fill: state.color,
          stroke: state.borderColor,
          'pointer-events': pointerEvents
        });
      }
      onRender();
      that._moveWrapper();
      return true;
    };
    this.plaque = new _plaque.Plaque({
      opacity: that._options.opacity,
      color: that._options.color,
      border: that._options.border,
      paddingLeftRight: that._options.paddingLeftRight,
      paddingTopBottom: that._options.paddingTopBottom,
      arrowLength: that._options.arrowLength,
      arrowWidth: 20,
      shadow: that._options.shadow,
      cornerRadius: that._options.cornerRadius
    }, that, that._renderer.root, drawTooltip, true, function (tooltip, g) {
      var state = tooltip._state;
      if (state.html) {
        var bBox = window.getComputedStyle(that._textHtml.get(0));
        bBox = {
          x: 0,
          y: 0,
          width: mathCeil(parseFloat(bBox.width)),
          height: mathCeil(parseFloat(bBox.height))
        };
        return bBox;
      }
      return g.getBBox();
    }, function (tooltip, g, x, y) {
      var state = tooltip._state;
      if (state.html) {
        that._textGroupHtml.css({
          left: x,
          top: y
        });
      } else {
        g.move(x, y);
      }
    });
    return that;
  },
  _riseEvents: function _riseEvents(eventData) {
    // trigger event
    // The *onTooltipHidden* is triggered outside the *hide* method because of the cases when *show* is called to determine if tooltip will be visible or not (when target is changed) -
    // *hide* can neither be called before that *show* - because if tooltip is determined to hide it requires some timeout before actually hiding
    // nor after that *show* - because it is either too early to hide (because of timeout) or wrong (because tooltip has already been shown for new target)
    // It is only inside the *show* where it is known weather *onTooltipHidden* is required or not
    // This functionality can be simplified when we get rid of timeouts for tooltip
    var that = this;
    that._eventData && that._eventTrigger('tooltipHidden', that._eventData);
    that._eventData = eventData;
    that._eventTrigger('tooltipShown', that._eventData);
  },
  setRendererOptions: function setRendererOptions(options) {
    this._renderer.setOptions(options);
    this._textGroupHtml.css({
      direction: options.rtl ? 'rtl' : 'ltr'
    });
    return this;
  },
  update: function update(options) {
    var that = this;
    that.setOptions(options);

    // The following is because after update (on widget refresh) tooltip must be hidden
    hideElement(that._wrapper);

    // text area
    var normalizedCSS = {};
    for (var name in that._textFontStyles) {
      normalizedCSS[(0, _inflector.camelize)(name)] = that._textFontStyles[name];
    }
    that._textGroupHtml.css(normalizedCSS);
    that._text.css(that._textFontStyles);
    that._eventData = null;
    return that;
  },
  _prepare: function _prepare(formatObject, state) {
    var customizeTooltip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._customizeTooltip;
    var options = this._options;
    var customize = {};
    if ((0, _type.isFunction)(customizeTooltip)) {
      customize = customizeTooltip.call(formatObject, formatObject);
      customize = (0, _type.isPlainObject)(customize) ? customize : {};
      if ('text' in customize) {
        state.text = (0, _type.isDefined)(customize.text) ? String(customize.text) : '';
      }
      if ('html' in customize) {
        state.html = (0, _type.isDefined)(customize.html) ? String(customize.html) : '';
      }
    }
    if (!('text' in state) && !('html' in state)) {
      state.text = formatObject.valueText || formatObject.description || '';
    }
    state.color = customize.color || options.color;
    state.borderColor = customize.borderColor || (options.border || {}).color;
    state.textColor = customize.fontColor || (this._textFontStyles || {}).color;
    return !!state.text || !!state.html || !!this._template;
  },
  show: function show(formatObject, params, eventData, customizeTooltip, templateCallback) {
    var that = this;
    if (that._options.forceEvents) {
      // for Blazor charts
      eventData.x = params.x;
      eventData.y = params.y - params.offset;
      that._riseEvents(eventData);
      return true;
    }
    var state = {
      formatObject,
      eventData,
      templateCallback
    };
    if (!that._prepare(formatObject, state, customizeTooltip)) {
      return false;
    }
    that._state = state;
    that._wrapper.appendTo(that._getContainer());
    that._clear();
    var parameters = (0, _extend.extend)({}, that._options, {
      canvas: that._getCanvas()
    }, state, {
      x: params.x,
      y: params.y,
      offset: params.offset
    });
    return this.plaque.clear().draw(parameters);
  },
  isCursorOnTooltip: function isCursorOnTooltip(x, y) {
    if (this._options.interactive) {
      var box = this.plaque.getBBox();
      return x > box.x && x < box.x + box.width && y > box.y && y < box.y + box.height;
    }
    return false;
  },
  hide: function hide(isPointerOut) {
    var that = this;
    hideElement(that._wrapper);
    // trigger event
    if (that._eventData) {
      that._eventTrigger('tooltipHidden', that._options.forceEvents ? (0, _extend.extend)({
        isPointerOut
      }, that._eventData) : that._eventData);
      that._clear();
      that._eventData = null;
    }
  },
  _clear() {
    this._textHtml.empty();
  },
  move: function move(x, y, offset) {
    this.plaque.draw({
      x,
      y,
      offset,
      canvas: this._getCanvas(),
      isMoving: true
    });
  },
  _moveWrapper: function _moveWrapper() {
    var that = this;
    var plaqueBBox = this.plaque.getBBox();
    that._renderer.resize(plaqueBBox.width, plaqueBBox.height);

    // move wrapper
    var offset = that._wrapper.css({
      left: 0,
      top: 0
    }).offset();
    var left = plaqueBBox.x;
    var top = plaqueBBox.y;
    that._wrapper.css({
      left: left - offset.left,
      top: top - offset.top
    });
    this.plaque.moveRoot(-left, -top);
    if (this._state.html) {
      that._textHtml.css({
        left: -left,
        top: -top
      });
      that._textGroupHtml.css({
        width: mathCeil((0, _size.getWidth)(that._textHtml))
      });
    }
  },
  formatValue: function formatValue(value, _specialFormat) {
    var options = _specialFormat ? getSpecialFormatOptions(this._options, _specialFormat) : this._options;
    return format(value, options.format);
  },
  getOptions() {
    return this._options;
  },
  getLocation: function getLocation() {
    return (0, _utils.normalizeEnum)(this._options.location);
  },
  isEnabled: function isEnabled() {
    return !!this._options.enabled || !!this._options.forceEvents; // for Blazor charts
  },

  isShared: function isShared() {
    return !!this._options.shared;
  },
  _getCanvas: function _getCanvas() {
    var container = this._getContainer();
    var containerBox = container.getBoundingClientRect();
    var html = _dom_adapter.default.getDocumentElement();
    var document = _dom_adapter.default.getDocument();
    var left = window.pageXOffset || html.scrollLeft || 0;
    var top = window.pageYOffset || html.scrollTop || 0;
    var box = {
      left: left,
      top: top,
      width: mathMax(html.clientWidth, document.body.clientWidth) + left,
      height: mathMax(document.body.scrollHeight, html.scrollHeight, document.body.offsetHeight, html.offsetHeight, document.body.clientHeight, html.clientHeight),
      right: 0,
      bottom: 0
    };
    if (container !== _dom_adapter.default.getBody()) {
      left = mathMax(box.left, box.left + containerBox.left);
      top = mathMax(box.top, box.top + containerBox.top);
      box.width = mathMin(containerBox.width, box.width) + left + box.left;
      box.height = mathMin(containerBox.height, box.height) + top + box.top;
      box.left = left;
      box.top = top;
    }
    return box;
  }
};
var plugin = {
  name: 'tooltip',
  init: function init() {
    this._initTooltip();
  },
  dispose: function dispose() {
    this._disposeTooltip();
  },
  members: {
    // The method exists only to be overridden in sparklines.
    _initTooltip: function _initTooltip() {
      // "exports" is used for testing purposes.
      this._tooltip = new Tooltip({
        cssClass: this._rootClassPrefix + '-tooltip',
        eventTrigger: this._eventTrigger,
        pathModified: this.option('pathModified'),
        widgetRoot: this.element(),
        widget: this
      });
    },
    // The method exists only to be overridden in sparklines.
    _disposeTooltip: function _disposeTooltip() {
      this._tooltip.dispose();
      this._tooltip = null;
    },
    // The method exists only to be overridden in sparklines.
    _setTooltipRendererOptions: function _setTooltipRendererOptions() {
      this._tooltip.setRendererOptions(this._getRendererOptions());
    },
    // The method exists only to be overridden in sparklines and gauges.
    _setTooltipOptions: function _setTooltipOptions() {
      this._tooltip.update(this._getOption('tooltip'));
    }
  },
  extenders: {
    _stopCurrentHandling() {
      this._tooltip && this._tooltip.hide();
    }
  },
  customize: function customize(constructor) {
    var proto = constructor.prototype;
    proto._eventsMap.onTooltipShown = {
      name: 'tooltipShown'
    };
    proto._eventsMap.onTooltipHidden = {
      name: 'tooltipHidden'
    };
    constructor.addChange({
      code: 'TOOLTIP_RENDERER',
      handler: function handler() {
        this._setTooltipRendererOptions();
      },
      isThemeDependent: true,
      isOptionChange: true
    });
    constructor.addChange({
      code: 'TOOLTIP',
      handler: function handler() {
        this._setTooltipOptions();
      },
      isThemeDependent: true,
      isOptionChange: true,
      option: 'tooltip'
    });
  },
  fontFields: ['tooltip.font']
};
exports.plugin = plugin;

/***/ }),

/***/ 19157:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.PANE_PADDING = void 0;
exports.adjustVisualRange = adjustVisualRange;
exports.convertAngleToRendererSpace = void 0;
exports.convertPolarToXY = convertPolarToXY;
exports.convertVisualRangeObject = convertVisualRangeObject;
exports.enumParser = exports.degreesToRadians = exports.decreaseGaps = exports.convertXYToPolar = void 0;
exports.extractColor = extractColor;
exports.getAddFunction = getAddFunction;
exports.getLog = exports.getDistance = exports.getDecimalOrder = exports.getCosAndSin = exports.getCategoriesInfo = exports.getAppropriateFormat = exports.getAdjustedLog10 = void 0;
exports.getLogExt = getLogExt;
exports.getVerticallyShiftedAngularCoords = exports.getPower = exports.getNextDefsSvgId = void 0;
exports.getVizRangeObject = getVizRangeObject;
exports.isRelativeHeightPane = isRelativeHeightPane;
exports.map = map;
exports.mergeMarginOptions = mergeMarginOptions;
exports.normalizeAngle = void 0;
exports.normalizeArcParams = normalizeArcParams;
exports.normalizeBBox = normalizeBBox;
exports.normalizeEnum = normalizeEnum;
exports.normalizePanesHeight = normalizePanesHeight;
exports.patchFontOptions = exports.parseScalar = void 0;
exports.pointInCanvas = pointInCanvas;
exports.raiseTo = exports.processSeriesTemplate = void 0;
exports.raiseToExt = raiseToExt;
exports.rangesAreEqual = rangesAreEqual;
exports.rotateBBox = rotateBBox;
exports.roundValue = void 0;
exports.setCanvasValues = setCanvasValues;
exports.unique = void 0;
exports.updatePanesCanvases = updatePanesCanvases;
exports.valueOf = valueOf;
var _common = __webpack_require__(20576);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _math = __webpack_require__(60810);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _color = _interopRequireDefault(__webpack_require__(52752));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var PI = Math.PI,
  LN10 = Math.LN10,
  abs = Math.abs,
  log = Math.log,
  floor = Math.floor,
  ceil = Math.ceil,
  pow = Math.pow,
  sqrt = Math.sqrt,
  atan2 = Math.atan2;
var _min = Math.min;
var _max = Math.max;
var _cos = Math.cos;
var _sin = Math.sin;
var _round = Math.round;
var dateToMilliseconds = _date.default.dateToMilliseconds;
var MAX_PIXEL_COUNT = 1E10;
var PI_DIV_180 = PI / 180;
var _isNaN = isNaN;
var _Number = Number;
var _NaN = NaN;
var numDefsSvgElements = 1;
var PANE_PADDING = 10;
exports.PANE_PADDING = PANE_PADDING;
var getLog = function getLog(value, base) {
  if (!value) {
    return _NaN;
  }
  return log(value) / log(base);
};
exports.getLog = getLog;
var getAdjustedLog10 = function getAdjustedLog10(value) {
  return (0, _math.adjust)(getLog(value, 10));
};
exports.getAdjustedLog10 = getAdjustedLog10;
var raiseTo = function raiseTo(power, base) {
  return pow(base, power);
};

//  Translates angle to [0, 360)
//  Expects number, no validation
exports.raiseTo = raiseTo;
var normalizeAngle = function normalizeAngle(angle) {
  return (angle % 360 + 360) % 360;
};

//  Maps angle in trigonometric space to angle in 'renderer' space
//  Expects numbers, no validation
exports.normalizeAngle = normalizeAngle;
var convertAngleToRendererSpace = function convertAngleToRendererSpace(angle) {
  return 90 - angle;
};

//  Maps angle in degrees to angle in radians
//  Expects number, no validation
exports.convertAngleToRendererSpace = convertAngleToRendererSpace;
var degreesToRadians = function degreesToRadians(value) {
  return PI * value / 180;
};

//  Calculates sin and cos for <angle> in degrees
//  Expects number, no validation
exports.degreesToRadians = degreesToRadians;
var getCosAndSin = function getCosAndSin(angle) {
  var angleInRadians = degreesToRadians(angle);
  return {
    cos: _cos(angleInRadians),
    sin: _sin(angleInRadians)
  };
};

//  Because Math.log(1000) / Math.LN10 < 3 though it is exactly 3
//  Same happens for 1E6, 1E9, 1E12, 1E13, 1E15, ...
exports.getCosAndSin = getCosAndSin;
var DECIMAL_ORDER_THRESHOLD = 1E-14;
//    ____________________
//   /       2          2
// \/ (y2-y1)  + (x2-x1)
var getDistance = function getDistance(x1, y1, x2, y2) {
  var diffX = x2 - x1;
  var diffY = y2 - y1;
  return sqrt(diffY * diffY + diffX * diffX);
};
exports.getDistance = getDistance;
var getDecimalOrder = function getDecimalOrder(number) {
  var n = abs(number);
  var cn;
  if (!_isNaN(n)) {
    if (n > 0) {
      n = log(n) / LN10;
      cn = ceil(n);
      return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n);
    }
    return 0;
  }
  return _NaN;
};
exports.getDecimalOrder = getDecimalOrder;
var getAppropriateFormat = function getAppropriateFormat(start, end, count) {
  var order = _max(getDecimalOrder(start), getDecimalOrder(end));
  var precision = -getDecimalOrder(abs(end - start) / count);
  var format;
  if (!_isNaN(order) && !_isNaN(precision)) {
    if (abs(order) <= 4) {
      format = 'fixedPoint';
      precision < 0 && (precision = 0);
      precision > 4 && (precision = 4);
    } else {
      format = 'exponential';
      precision += order - 1;
      precision > 3 && (precision = 3);
    }
    return {
      type: format,
      precision: precision
    };
  }
  return null;
};
exports.getAppropriateFormat = getAppropriateFormat;
var roundValue = function roundValue(value, precision) {
  if (precision > 20) {
    precision = 20;
  }
  if ((0, _type.isNumeric)(value)) {
    if ((0, _type.isExponential)(value)) {
      return _Number(value.toExponential(precision));
    } else {
      return _Number(value.toFixed(precision));
    }
  }
};
exports.roundValue = roundValue;
var getPower = function getPower(value) {
  return value.toExponential().split('e')[1];
};
exports.getPower = getPower;
function map(array, callback) {
  var i = 0;
  var len = array.length;
  var result = [];
  var value;
  while (i < len) {
    value = callback(array[i], i);
    if (value !== null) {
      result.push(value);
    }
    i++;
  }
  return result;
}
function selectByKeys(object, keys) {
  return map(keys, function (key) {
    return object[key] ? object[key] : null;
  });
}
function decreaseFields(object, keys, eachDecrease, decrease) {
  var dec = decrease;
  (0, _iterator.each)(keys, function (_, key) {
    if (object[key]) {
      object[key] -= eachDecrease;
      dec -= eachDecrease;
    }
  });
  return dec;
}
function normalizeEnum(value) {
  return String(value).toLowerCase();
}
function setCanvasValues(canvas) {
  if (canvas) {
    canvas.originalTop = canvas.top;
    canvas.originalBottom = canvas.bottom;
    canvas.originalLeft = canvas.left;
    canvas.originalRight = canvas.right;
  }
  return canvas;
}
function normalizeBBoxField(value) {
  return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0;
}
function normalizeBBox(bBox) {
  var xl = normalizeBBoxField(floor(bBox.x));
  var yt = normalizeBBoxField(floor(bBox.y));
  var xr = normalizeBBoxField(ceil(bBox.width + bBox.x));
  var yb = normalizeBBoxField(ceil(bBox.height + bBox.y));
  var result = {
    x: xl,
    y: yt,
    width: xr - xl,
    height: yb - yt
  };
  result.isEmpty = !result.x && !result.y && !result.width && !result.height;
  return result;
}

// Angle is expected to be from right-handed cartesian (not svg) space - positive is counterclockwise
function rotateBBox(bBox, center, angle) {
  var cos = _Number(_cos(angle * PI_DIV_180).toFixed(3));
  var sin = _Number(_sin(angle * PI_DIV_180).toFixed(3));
  var w2 = bBox.width / 2;
  var h2 = bBox.height / 2;
  var centerX = bBox.x + w2;
  var centerY = bBox.y + h2;
  var w2_ = abs(w2 * cos) + abs(h2 * sin);
  var h2_ = abs(w2 * sin) + abs(h2 * cos);
  // Note that the following slightly differs from theoretical formula:
  // x' = x * cos - y * sin, y' = x * sin + y * cos
  // That is because in svg y goes down (not up) - so sign of sin is reverted
  // x' = x * cos + y * sin, y' = -x * sin + y * cos
  var centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin;
  var centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;
  return normalizeBBox({
    x: centerX_ - w2_,
    y: centerY_ - h2_,
    width: 2 * w2_,
    height: 2 * h2_
  });
}
var decreaseGaps = function decreaseGaps(object, keys, decrease) {
  var arrayGaps;
  do {
    arrayGaps = selectByKeys(object, keys);
    arrayGaps.push(ceil(decrease / arrayGaps.length));
    decrease = decreaseFields(object, keys, _min.apply(null, arrayGaps), decrease);
  } while (decrease > 0 && arrayGaps.length > 1);
  return decrease;
};
exports.decreaseGaps = decreaseGaps;
var parseScalar = function parseScalar(value, defaultValue) {
  return value !== undefined ? value : defaultValue;
};
exports.parseScalar = parseScalar;
var enumParser = function enumParser(values) {
  var stored = {};
  var i;
  var ii;
  for (i = 0, ii = values.length; i < ii; ++i) {
    stored[normalizeEnum(values[i])] = 1;
  }
  return function (value, defaultValue) {
    var _value = normalizeEnum(value);
    return stored[_value] ? _value : defaultValue;
  };
};
exports.enumParser = enumParser;
var patchFontOptions = function patchFontOptions(options) {
  var fontOptions = {};
  (0, _iterator.each)(options || {}, function (key, value) {
    if (/^(cursor)$/i.test(key)) {
      // TODO check other properties, add tests
    } else if (key === 'opacity') {
      value = null;
    } else if (key === 'color') {
      key = 'fill';
      if ('opacity' in options) {
        var color = new _color.default(value);
        value = "rgba(".concat(color.r, ",").concat(color.g, ",").concat(color.b, ",").concat(options.opacity, ")");
      }
    } else {
      key = 'font-' + key;
    }
    fontOptions[key] = value;
  });
  return fontOptions;
};
exports.patchFontOptions = patchFontOptions;
function convertPolarToXY(centerCoords, startAngle, angle, radius) {
  var shiftAngle = 90;
  var normalizedRadius = radius > 0 ? radius : 0;
  angle = (0, _type.isDefined)(angle) ? angle + startAngle - shiftAngle : 0;
  var cosSin = getCosAndSin(angle);
  return {
    x: _round(centerCoords.x + normalizedRadius * cosSin.cos),
    y: _round(centerCoords.y + normalizedRadius * cosSin.sin)
  };
}
var convertXYToPolar = function convertXYToPolar(centerCoords, x, y) {
  var radius = getDistance(centerCoords.x, centerCoords.y, x, y);
  var angle = atan2(y - centerCoords.y, x - centerCoords.x);
  return {
    phi: _round(normalizeAngle(angle * 180 / PI)),
    r: _round(radius)
  };
};
exports.convertXYToPolar = convertXYToPolar;
var processSeriesTemplate = function processSeriesTemplate(seriesTemplate, items) {
  var customizeSeries = (0, _type.isFunction)(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : _common.noop;
  var nameField = seriesTemplate.nameField;
  var generatedSeries = {};
  var seriesOrder = [];
  var series;
  var i = 0;
  var length;
  var data;
  items = items || [];
  for (length = items.length; i < length; i++) {
    data = items[i];
    if (nameField in data) {
      series = generatedSeries[data[nameField]];
      if (!series) {
        series = generatedSeries[data[nameField]] = {
          name: data[nameField],
          nameFieldValue: data[nameField]
        };
        seriesOrder.push(series.name);
      }
    }
  }
  return map(seriesOrder, function (orderedName) {
    var group = generatedSeries[orderedName];
    return (0, _extend.extend)(group, customizeSeries.call(null, group.name));
  });
};
exports.processSeriesTemplate = processSeriesTemplate;
var getCategoriesInfo = function getCategoriesInfo(categories, startValue, endValue) {
  if (categories.length === 0) {
    return {
      categories: []
    };
  }
  startValue = (0, _type.isDefined)(startValue) ? startValue : categories[0];
  endValue = (0, _type.isDefined)(endValue) ? endValue : categories[categories.length - 1];
  var categoriesValue = map(categories, function (category) {
    return category === null || category === void 0 ? void 0 : category.valueOf();
  });
  var indexStartValue = categoriesValue.indexOf(startValue.valueOf());
  var indexEndValue = categoriesValue.indexOf(endValue.valueOf());
  var swapBuf;
  var inverted = false;
  indexStartValue < 0 && (indexStartValue = 0);
  indexEndValue < 0 && (indexEndValue = categories.length - 1);
  if (indexEndValue < indexStartValue) {
    swapBuf = indexEndValue;
    indexEndValue = indexStartValue;
    indexStartValue = swapBuf;
    inverted = true;
  }
  var visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);
  var lastIdx = visibleCategories.length - 1;
  return {
    categories: visibleCategories,
    start: visibleCategories[inverted ? lastIdx : 0],
    end: visibleCategories[inverted ? 0 : lastIdx],
    inverted: inverted
  };
};
exports.getCategoriesInfo = getCategoriesInfo;
function isRelativeHeightPane(pane) {
  return !(pane.unit % 2);
}
function normalizePanesHeight(panes) {
  panes.forEach(function (pane) {
    var height = pane.height;
    var unit = 0;
    var parsedHeight = parseFloat(height) || undefined;
    if ((0, _type.isString)(height) && height.indexOf('px') > -1 || (0, _type.isNumeric)(height) && height > 1) {
      parsedHeight = _round(parsedHeight);
      unit = 1;
    }
    if (!unit && parsedHeight) {
      if ((0, _type.isString)(height) && height.indexOf('%') > -1) {
        parsedHeight = parsedHeight / 100;
        unit = 2;
      } else if (parsedHeight < 0) {
        parsedHeight = parsedHeight < -1 ? 1 : abs(parsedHeight);
      }
    }
    pane.height = parsedHeight;
    pane.unit = unit;
  });
  var relativeHeightPanes = panes.filter(isRelativeHeightPane);
  var weightSum = relativeHeightPanes.reduce(function (prev, next) {
    return prev + (next.height || 0);
  }, 0);
  var weightHeightCount = relativeHeightPanes.length;
  var emptyHeightPanes = relativeHeightPanes.filter(function (pane) {
    return !pane.height;
  });
  var emptyHeightCount = emptyHeightPanes.length;
  if (weightSum < 1 && emptyHeightCount) {
    emptyHeightPanes.forEach(function (pane) {
      return pane.height = (1 - weightSum) / emptyHeightCount;
    });
  } else if (weightSum > 1 || weightSum < 1 && !emptyHeightCount || weightSum === 1 && emptyHeightCount) {
    if (emptyHeightCount) {
      var weightForEmpty = weightSum / weightHeightCount;
      var emptyWeightSum = emptyHeightCount * weightForEmpty;
      relativeHeightPanes.filter(function (pane) {
        return pane.height;
      }).forEach(function (pane) {
        return pane.height *= (weightSum - emptyWeightSum) / weightSum;
      });
      emptyHeightPanes.forEach(function (pane) {
        return pane.height = weightForEmpty;
      });
    }
    relativeHeightPanes.forEach(function (pane) {
      return pane.height *= 1 / weightSum;
    });
  }
}
function updatePanesCanvases(panes, canvas, rotated) {
  var distributedSpace = 0;
  var padding = PANE_PADDING;
  var paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom;
  var totalCustomSpace = panes.reduce(function (prev, cur) {
    return prev + (!isRelativeHeightPane(cur) ? cur.height : 0);
  }, 0);
  var usefulSpace = paneSpace - padding * (panes.length - 1) - totalCustomSpace;
  var startName = rotated ? 'left' : 'top';
  var endName = rotated ? 'right' : 'bottom';
  panes.forEach(function (pane) {
    var calcLength = !isRelativeHeightPane(pane) ? pane.height : _round(pane.height * usefulSpace);
    pane.canvas = pane.canvas || {};
    (0, _extend.extend)(pane.canvas, canvas);
    pane.canvas[startName] = canvas[startName] + distributedSpace;
    pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);
    distributedSpace = distributedSpace + calcLength + padding;
    setCanvasValues(pane.canvas);
  });
}
var unique = function unique(array) {
  var values = {};
  return map(array, function (item) {
    var result = !values[item] ? item : null;
    values[item] = true;
    return result;
  });
};
exports.unique = unique;
var getVerticallyShiftedAngularCoords = function getVerticallyShiftedAngularCoords(bBox, dy, center) {
  // TODO: Use center instead of left top corner - that is more correct and allows to get rid of "isPositive"
  //   horizontalOffset1 = bBox.x + bBox.width / 2 - center.x
  //   horizontalOffset2 = bBox.y + bBox.height / 2 - center.y
  //   verticalOffset2 = newCoord.y + bBox.height / 2 - center.y
  var isPositive = bBox.x + bBox.width / 2 >= center.x;
  var horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x;
  var verticalOffset1 = bBox.y - center.y;
  var verticalOffset2 = verticalOffset1 + dy;
  var horizontalOffset2 = _round(sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2));
  var dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;
  return {
    x: center.x + (isPositive ? dx : dx - bBox.width),
    y: bBox.y + dy
  };
};
exports.getVerticallyShiftedAngularCoords = getVerticallyShiftedAngularCoords;
function mergeMarginOptions(opt1, opt2) {
  return {
    checkInterval: opt1.checkInterval || opt2.checkInterval,
    size: _max(opt1.size || 0, opt2.size || 0),
    percentStick: opt1.percentStick || opt2.percentStick,
    sizePointNormalState: _max(opt1.sizePointNormalState || 0, opt2.sizePointNormalState || 0)
  };
}
function getVizRangeObject(value) {
  if (Array.isArray(value)) {
    return {
      startValue: value[0],
      endValue: value[1]
    };
  } else {
    return value || {};
  }
}
function normalizeArcParams(x, y, innerRadius, outerRadius, startAngle, endAngle) {
  var isCircle;
  var noArc = true;
  var angleDiff = roundValue(endAngle, 3) - roundValue(startAngle, 3);
  if (angleDiff) {
    if (abs(angleDiff) % 360 === 0) {
      startAngle = 0;
      endAngle = 360;
      isCircle = true;
      endAngle -= 0.01;
    }
    if (startAngle > 360) {
      startAngle = startAngle % 360;
    }
    if (endAngle > 360) {
      endAngle = endAngle % 360;
    }
    if (startAngle > endAngle) {
      startAngle -= 360;
    }
    noArc = false;
  }
  startAngle *= PI_DIV_180;
  endAngle *= PI_DIV_180;
  return [x, y, Math.min(outerRadius, innerRadius), Math.max(outerRadius, innerRadius), Math.cos(startAngle), Math.sin(startAngle), Math.cos(endAngle), Math.sin(endAngle), isCircle, floor(abs(endAngle - startAngle) / PI) % 2 ? '1' : '0', noArc];
}
function convertVisualRangeObject(visualRange, convertToVisualRange) {
  if (convertToVisualRange) {
    return visualRange;
  }
  return [visualRange.startValue, visualRange.endValue];
}
function getAddFunction(range, correctZeroLevel) {
  // T170398
  if (range.dataType === 'datetime') {
    return function (rangeValue, marginValue) {
      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      return new Date(rangeValue.getTime() + sign * marginValue);
    };
  }
  if (range.axisType === 'logarithmic') {
    return function (rangeValue, marginValue) {
      var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var log = getLogExt(rangeValue, range.base) + sign * marginValue;
      return raiseToExt(log, range.base);
    };
  }
  return function (rangeValue, marginValue) {
    var sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var newValue = rangeValue + sign * marginValue;
    return correctZeroLevel && newValue * rangeValue <= 0 ? 0 : newValue;
  };
}
function adjustVisualRange(options, visualRange, wholeRange, dataRange) {
  var minDefined = (0, _type.isDefined)(visualRange.startValue);
  var maxDefined = (0, _type.isDefined)(visualRange.endValue);
  var nonDiscrete = options.axisType !== 'discrete';
  dataRange = dataRange || wholeRange;
  var add = getAddFunction(options, false);
  var min = minDefined ? visualRange.startValue : dataRange.min;
  var max = maxDefined ? visualRange.endValue : dataRange.max;
  var rangeLength = visualRange.length;
  var categories = dataRange.categories;
  if (nonDiscrete && !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {
    return {
      startValue: min,
      endValue: max
    };
  }
  if ((0, _type.isDefined)(rangeLength)) {
    if (nonDiscrete) {
      if (options.dataType === 'datetime' && !(0, _type.isNumeric)(rangeLength)) {
        rangeLength = dateToMilliseconds(rangeLength);
      }
      if (maxDefined && !minDefined || !maxDefined && !minDefined) {
        (0, _type.isDefined)(wholeRange.max) && (max = max > wholeRange.max ? wholeRange.max : max);
        min = add(max, rangeLength, -1);
      } else if (minDefined && !maxDefined) {
        (0, _type.isDefined)(wholeRange.min) && (min = min < wholeRange.min ? wholeRange.min : min);
        max = add(min, rangeLength);
      }
    } else {
      rangeLength = parseInt(rangeLength);
      if (!isNaN(rangeLength) && isFinite(rangeLength)) {
        rangeLength--;
        if (!maxDefined && !minDefined) {
          max = categories[categories.length - 1];
          min = categories[categories.length - 1 - rangeLength];
        } else if (minDefined && !maxDefined) {
          var categoriesInfo = getCategoriesInfo(categories, min, undefined);
          max = categoriesInfo.categories[rangeLength];
        } else if (!minDefined && maxDefined) {
          var _categoriesInfo = getCategoriesInfo(categories, undefined, max);
          min = _categoriesInfo.categories[_categoriesInfo.categories.length - 1 - rangeLength];
        }
      }
    }
  }
  if (nonDiscrete) {
    if ((0, _type.isDefined)(wholeRange.max) && max > wholeRange.max) {
      max = wholeRange.max;
    }
    if ((0, _type.isDefined)(wholeRange.min) && min < wholeRange.min) {
      min = wholeRange.min;
    }
  }
  return {
    startValue: min,
    endValue: max
  };
}
function getLogExt(value, base) {
  var allowNegatives = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var linearThreshold = arguments.length > 3 ? arguments[3] : undefined;
  if (!allowNegatives) {
    return getLog(value, base);
  }
  if (value === 0) {
    return 0;
  }
  var transformValue = getLog(abs(value), base) - (linearThreshold - 1);
  if (transformValue < 0) {
    return 0;
  }
  return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold - 1).toFixed(abs(linearThreshold))));
}
function raiseToExt(value, base) {
  var allowNegatives = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var linearThreshold = arguments.length > 3 ? arguments[3] : undefined;
  if (!allowNegatives) {
    return raiseTo(value, base);
  }
  if (value === 0) {
    return 0;
  }
  var transformValue = raiseTo(abs(value) + (linearThreshold - 1), base);
  if (transformValue < 0) {
    return 0;
  }
  return (0, _math.adjust)((0, _math.sign)(value) * transformValue, Number(pow(base, linearThreshold).toFixed(abs(linearThreshold))));
}
function rangesAreEqual(range, rangeFromOptions) {
  if (Array.isArray(rangeFromOptions)) {
    return range.length === rangeFromOptions.length && range.every(function (item, i) {
      return valueOf(item) === valueOf(rangeFromOptions[i]);
    });
  } else {
    return valueOf(range.startValue) === valueOf(rangeFromOptions.startValue) && valueOf(range.endValue) === valueOf(rangeFromOptions.endValue);
  }
}
function valueOf(value) {
  return value && value.valueOf();
}
function pointInCanvas(canvas, x, y) {
  return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom;
}
var getNextDefsSvgId = function getNextDefsSvgId() {
  return "DevExpress_".concat(numDefsSvgElements++);
};
exports.getNextDefsSvgId = getNextDefsSvgId;
function extractColor(color, isBase) {
  if ((0, _type.isString)(color) || !color) {
    return color;
  } else if (isBase) {
    return color.base;
  } else {
    return color.fillId || color.base;
  }
}

/***/ }),

/***/ 5259:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var _export = __webpack_require__(82454);
Object.keys(_export).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _export[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _export[key];
    }
  });
});

/***/ }),

/***/ 30187:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _funnel = _interopRequireDefault(__webpack_require__(44697));
var _label = __webpack_require__(47250);
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _legend = __webpack_require__(16342);
var _tracker = __webpack_require__(76686);
var _tooltip = __webpack_require__(32037);
var _loading_indicator = __webpack_require__(64758);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
_funnel.default.addPlugin(_label.plugin);
_funnel.default.addPlugin(_export.plugin);
_funnel.default.addPlugin(_title.plugin);
_funnel.default.addPlugin(_legend.plugin);
_funnel.default.addPlugin(_tracker.plugin);
_funnel.default.addPlugin(_tooltip.plugin);
_funnel.default.addPlugin(_loading_indicator.plugin);
var _default = _funnel.default;
/**
 * @name dxFunnelItem
 * @publicName Item
 */
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 44697:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tiling = __webpack_require__(68074);
var _tiling2 = _interopRequireDefault(__webpack_require__(89482));
var _tiling3 = _interopRequireDefault(__webpack_require__(2356));
var _common = __webpack_require__(20576);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _item = _interopRequireDefault(__webpack_require__(65700));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var NODES_CREATE_CHANGE = 'NODES_CREATE';
(0, _tiling.addAlgorithm)('dynamicslope', _tiling2.default, true);
(0, _tiling.addAlgorithm)('dynamicheight', _tiling3.default);
function invertFigure(figure) {
  return figure.map(function (coord, index) {
    return index % 2 ? 1 - coord : coord;
  });
}
function getLegendItemState(itemState) {
  return {
    fill: itemState.fill,
    hatching: itemState.hatching
  };
}
var dxFunnel = _m_base_widget.default.inherit({
  _rootClass: 'dxf-funnel',
  _rootClassPrefix: 'dxf',
  _proxyData: [],
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    neckWidth: NODES_CREATE_CHANGE,
    neckHeight: NODES_CREATE_CHANGE,
    inverted: NODES_CREATE_CHANGE,
    algorithm: NODES_CREATE_CHANGE,
    item: NODES_CREATE_CHANGE,
    valueField: NODES_CREATE_CHANGE,
    argumentField: NODES_CREATE_CHANGE,
    colorField: NODES_CREATE_CHANGE,
    palette: NODES_CREATE_CHANGE,
    paletteExtensionMode: NODES_CREATE_CHANGE,
    sortData: NODES_CREATE_CHANGE
  },
  _themeDependentChanges: [NODES_CREATE_CHANGE],
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'funnel',
  _fontFields: ['legend.title.font', 'legend.title.subtitle.font', 'legend.font'],
  _optionChangesOrder: ['DATA_SOURCE'],
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function _initCore() {
    this._group = this._renderer.g().append(this._renderer.root);
    this._items = [];
  },
  _eventsMap: {
    onHoverChanged: {
      name: 'hoverChanged'
    },
    onSelectionChanged: {
      name: 'selectionChanged'
    }
  },
  _disposeCore: _common.noop,
  _applySize: function _applySize(rect) {
    this._rect = rect.slice();
    this._change(['TILING']);
    return this._rect;
  },
  _getAlignmentRect: function _getAlignmentRect() {
    return this._rect;
  },
  _change_TILING: function _change_TILING() {
    var that = this;
    var items = that._items;
    var rect = that._rect;
    var convertCoord = function convertCoord(coord, index) {
      var offset = index % 2;
      return rect[0 + offset] + (rect[2 + offset] - rect[0 + offset]) * coord;
    };
    this._group.clear();
    items.forEach(function (item, index) {
      var coords = item.figure.map(convertCoord);
      var element = that._renderer.path([], 'area').attr({
        points: coords
      }).append(that._group);
      item.coords = coords;
      item.element = element;
    });
    this._requestChange(['TILES']);
  },
  _customChangesOrder: [NODES_CREATE_CHANGE, 'LAYOUT', 'TILING', 'TILES', 'DRAWN'],
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._requestChange([NODES_CREATE_CHANGE]);
  },
  _change_DRAWN: function _change_DRAWN() {
    this._drawn();
  },
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._change(['DRAWN']);
    this._updateDataSource();
  },
  _change_NODES_CREATE: function _change_NODES_CREATE() {
    this._buildNodes();
  },
  _change_TILES: function _change_TILES() {
    this._applyTilesAppearance();
  },
  _suspend: function _suspend() {
    if (!this._applyingChanges) {
      this._suspendChanges();
    }
  },
  _resume: function _resume() {
    if (!this._applyingChanges) {
      this._resumeChanges();
    }
  },
  _applyTilesAppearance: function _applyTilesAppearance() {
    this._items.forEach(function (item) {
      var state = item.getState();
      item.element.smartAttr(item.states[state]);
    });
  },
  _hitTestTargets: function _hitTestTargets(x, y) {
    var that = this;
    var data;
    this._proxyData.some(function (callback) {
      data = callback.call(that, x, y);
      if (data) {
        return true;
      }
    });
    return data;
  },
  clearHover: function clearHover() {
    this._suspend();
    this._items.forEach(function (item) {
      item.isHovered() && item.hover(false);
    });
    this._resume();
  },
  clearSelection: function clearSelection() {
    this._suspend();
    this._items.forEach(function (item) {
      item.isSelected() && item.select(false);
    });
    this._resume();
  },
  _getData: function _getData() {
    var that = this;
    var data = that._dataSourceItems() || [];
    var valueField = that._getOption('valueField', true);
    var argumentField = that._getOption('argumentField', true);
    var colorField = that._getOption('colorField', true);
    var processedData = data.reduce(function (d, item) {
      var value = Number(item[valueField]);
      if (value >= 0) {
        d[0].push({
          value: value,
          color: item[colorField],
          argument: item[argumentField],
          dataItem: item
        });
        d[1] += value;
      }
      return d;
    }, [[], 0]);
    var items = processedData[0];
    if (data.length > 0 && items.length === 0) {
      that._incidentOccurred('E2005', valueField);
    }
    if (!processedData[1]) {
      return [];
    }
    if (that._getOption('sortData', true)) {
      items.sort(function (a, b) {
        return b.value - a.value;
      });
    }
    return items;
  },
  _buildNodes: function _buildNodes() {
    var that = this;
    var data = that._getData();
    var algorithm = (0, _tiling.getAlgorithm)(that._getOption('algorithm', true));
    var percents = algorithm.normalizeValues(data);
    var itemOptions = that._getOption('item');
    var figures = algorithm.getFigures(percents, that._getOption('neckWidth', true), that._getOption('neckHeight', true));
    var palette = that._themeManager.createPalette(that._getOption('palette', true), {
      useHighlight: true,
      extensionMode: that._getOption('paletteExtensionMode', true),
      count: figures.length
    });
    that._items = figures.map(function (figure, index) {
      var curData = data[index];
      var node = new _item.default(that, {
        figure: figure,
        data: curData,
        percent: percents[index],
        id: index,
        color: curData.color || palette.getNextColor(),
        itemOptions: itemOptions
      });
      return node;
    });
    if (that._getOption('inverted', true)) {
      that._items.forEach(function (item) {
        item.figure = invertFigure(item.figure);
      });
    }
    that._renderer.initDefsElements();
    that._change(['TILING', 'DRAWN']);
  },
  _showTooltip: _common.noop,
  hideTooltip: _common.noop,
  getAllItems: function getAllItems() {
    return this._items.slice();
  },
  _getLegendData() {
    return this._items.map(function (item) {
      var states = item.states;
      return {
        id: item.id,
        visible: true,
        text: item.argument,
        item: item,
        states: {
          normal: getLegendItemState(states.normal),
          hover: getLegendItemState(states.hover),
          selection: getLegendItemState(states.selection)
        }
      };
    });
  },
  _getMinSize: function _getMinSize() {
    var adaptiveLayout = this._getOption('adaptiveLayout');
    return [adaptiveLayout.width, adaptiveLayout.height];
  }
});
(0, _component_registrator.default)('dxFunnel', dxFunnel);
var _default = dxFunnel; // PLUGINS_SECTION
exports["default"] = _default;
dxFunnel.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 65700:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var states = ['normal', 'hover', 'selection', 'selection'];
function parseStyles(color, style, baseStyle) {
  var border = style.border;
  var baseBorder = baseStyle.border;
  var borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  var borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  return {
    fill: color,
    hatching: style.hatching,
    stroke: border.color || baseBorder.color,
    'stroke-width': borderVisible ? borderWidth : 0
  };
}
function Item(widget, options) {
  var that = this;
  var data = options.data;
  that.code = 0;
  that.widget = widget;
  that.figure = options.figure;
  that.argument = data.argument;
  that.value = data.value;
  that.data = data.dataItem;
  that.percent = options.percent;
  that.id = options.id;
  that.color = options.color;
  that.states = {
    normal: parseStyles(options.color, options.itemOptions, options.itemOptions),
    hover: parseStyles(options.color, options.itemOptions.hoverStyle, options.itemOptions),
    selection: parseStyles(options.color, options.itemOptions.selectionStyle, options.itemOptions)
  };
}
Item.prototype = {
  getState: function getState() {
    return states[this.code];
  },
  getNormalStyle: function getNormalStyle() {
    return this.states.normal;
  },
  setHover: function setHover() {
    this.hover(true);
  },
  hover: function hover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }
    this.widget._suspend();
    state && this.widget.clearHover();
    this.setState(1, state);
    this.widget._eventTrigger('hoverChanged', {
      item: this
    });
    this.widget._resume();
  },
  setState: function setState(code, state) {
    if (state) {
      this.code |= code;
    } else {
      this.code &= ~code;
    }
    this.widget._applyTilesAppearance();
  },
  select: function select(state) {
    var mode = this.widget._getOption('selectionMode', true);
    if (mode === 'none' || state === this.isSelected()) {
      return;
    }
    this.widget._suspend();
    if (state && mode !== 'multiple') {
      this.widget.clearSelection();
    }
    this.setState(2, state);
    this.widget._eventTrigger('selectionChanged', {
      item: this
    });
    this.widget._resume();
  },
  showTooltip: function showTooltip(coords) {
    this.widget._showTooltip(this.id, coords);
  },
  getColor: function getColor() {
    return this.color;
  },
  isHovered: function isHovered() {
    return !!(this.code & 1);
  },
  isSelected: function isSelected() {
    return !!(this.code & 2);
  }
};
var _default = Item;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 47250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _label = __webpack_require__(28318);
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
var _common = __webpack_require__(20576);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var OUTSIDE_POSITION = 'outside';
var INSIDE_POSITION = 'inside';
var OUTSIDE_LABEL_INDENT = 5;
var COLUMNS_LABEL_INDENT = 20;
var CONNECTOR_INDENT = 4;
var PREVENT_EMPTY_PIXEL_OFFSET = 1;
function getLabelIndent(pos) {
  pos = (0, _utils.normalizeEnum)(pos);
  if (pos === OUTSIDE_POSITION) {
    return OUTSIDE_LABEL_INDENT;
  } else if (pos === INSIDE_POSITION) {
    return 0;
  }
  return COLUMNS_LABEL_INDENT;
}
function isOutsidePosition(pos) {
  pos = (0, _utils.normalizeEnum)(pos);
  return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION;
}
function correctYForInverted(y, bBox, inverted) {
  return inverted ? y - bBox.height : y;
}
function getOutsideRightLabelPosition(coords, bBox, options, inverted) {
  return {
    x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,
    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
  };
}
function getOutsideLeftLabelPosition(coords, bBox, options, inverted) {
  return {
    x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,
    y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)
  };
}
function getInsideLabelPosition(coords, bBox, options) {
  var width = coords[2] - coords[0];
  var height = coords[7] - coords[1];
  return {
    x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,
    y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2
  };
}
function getColumnLabelRightPosition(labelRect, rect, textAlignment) {
  return function (coords, bBox, options, inverted) {
    return {
      x: textAlignment === 'left' ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,
      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
    };
  };
}
function getColumnLabelLeftPosition(labelRect, rect, textAlignment) {
  return function (coords, bBox, options, inverted) {
    return {
      x: textAlignment === 'left' ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,
      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)
    };
  };
}
function getConnectorStrategy(options, inverted) {
  var isLeftPos = options.horizontalAlignment === 'left';
  var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;
  var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;
  function getFigureCenter(figure) {
    return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection];
  }
  return {
    isLabelInside: function isLabelInside() {
      return !isOutsidePosition(options.position);
    },
    getFigureCenter: getFigureCenter,
    prepareLabelPoints: function prepareLabelPoints(bBox) {
      var x = bBox.x + connectorIndent;
      var y = bBox.y;
      var x1 = x + bBox.width;
      return _toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {
        return [x, y + i];
      }).concat(_toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {
        return [x1, y + i];
      }));
    },
    isHorizontal: function isHorizontal() {
      return true;
    },
    findFigurePoint: function findFigurePoint(figure) {
      return getFigureCenter(figure);
    },
    adjustPoints: function adjustPoints(points) {
      return points.map(Math.round);
    }
  };
}
function getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {
  var opt = labelOptions || {};
  var labelFont = (0, _extend.extend)({}, opt.font) || {};
  var labelBorder = opt.border || {};
  var labelConnector = opt.connector || {};
  var backgroundAttr = {
    fill: opt.backgroundColor || defaultColor,
    'stroke-width': labelBorder.visible ? labelBorder.width || 0 : 0,
    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : 'none',
    dashStyle: labelBorder.dashStyle
  };
  var connectorAttr = {
    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : 'none',
    'stroke-width': labelConnector.visible ? labelConnector.width || 0 : 0,
    opacity: labelConnector.opacity
  };
  labelFont.color = opt.backgroundColor === 'none' && (0, _utils.normalizeEnum)(labelFont.color) === '#ffffff' && opt.position !== 'inside' ? defaultColor : labelFont.color;
  return {
    format: opt.format,
    textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : 'center'),
    customizeText: opt.customizeText,
    attributes: {
      font: labelFont
    },
    visible: labelFont.size !== 0 ? opt.visible : false,
    showForZeroValues: opt.showForZeroValues,
    horizontalOffset: opt.horizontalOffset,
    verticalOffset: opt.verticalOffset,
    background: backgroundAttr,
    connector: connectorAttr,
    wordWrap: labelOptions.wordWrap,
    textOverflow: labelOptions.textOverflow
  };
}
function correctLabelPosition(pos, bBox, rect) {
  if (pos.x < rect[0]) {
    pos.x = rect[0];
  }
  if (pos.x + bBox.width > rect[2]) {
    pos.x = rect[2] - bBox.width;
  }
  if (pos.y < rect[1]) {
    pos.y = rect[1];
  }
  if (pos.y + bBox.height > rect[3]) {
    pos.y = rect[3] - bBox.height;
  }
  return pos;
}
function removeEmptySpace(labels, requiredSpace, startPoint) {
  labels.reduce(function (requiredSpace, label, index, labels) {
    var prevLabel = labels[index + 1];
    if (requiredSpace > 0) {
      var bBox = label.getBoundingRect();
      var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;
      var emptySpace = bBox.y - point;
      var shift = Math.min(emptySpace, requiredSpace);
      labels.slice(0, index + 1).forEach(function (label) {
        var bBox = label.getBoundingRect();
        label.shift(bBox.x, bBox.y - shift);
      });
      requiredSpace -= shift;
    }
    return requiredSpace;
  }, requiredSpace);
}
var plugin = {
  name: 'lables',
  init: _common.noop,
  dispose: _common.noop,
  extenders: {
    _initCore: function _initCore() {
      this._labelsGroup = this._renderer.g().attr({
        class: this._rootClassPrefix + '-labels'
      }).append(this._renderer.root);
      this._labels = [];
    },
    _applySize: function _applySize() {
      var options = this._getOption('label');
      var adaptiveLayout = this._getOption('adaptiveLayout');
      var rect = this._rect;
      var labelWidth = 0;
      var width = rect[2] - rect[0];
      this._labelRect = rect.slice();
      if (!this._labels.length || !isOutsidePosition(options.position)) {
        if ((0, _utils.normalizeEnum)(this._getOption('resolveLabelOverlapping', true) !== 'none')) {
          this._labels.forEach(function (l) {
            return !l.isVisible() && l.draw(true);
          });
        }
        return;
      }
      var groupWidth = this._labels.map(function (label) {
        label.resetEllipsis();
        return label.getBoundingRect().width;
      }).reduce(function (max, width) {
        return Math.max(max, width);
      }, 0);
      labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);
      if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {
        this._labels.forEach(function (label) {
          label.draw(false);
        });
        return;
      } else {
        if (width - labelWidth < adaptiveLayout.width) {
          labelWidth = width - adaptiveLayout.width;
          labelWidth = labelWidth > 0 ? labelWidth : 0;
        }
        this._labels.forEach(function (label) {
          label.draw(true);
        });
      }
      if (options.horizontalAlignment === 'left') {
        rect[0] += labelWidth;
      } else {
        rect[2] -= labelWidth;
      }
    },
    _buildNodes: function _buildNodes() {
      this._createLabels();
    },
    _change_TILING: function _change_TILING() {
      var that = this;
      var options = that._getOption('label');
      var getCoords = getInsideLabelPosition;
      var inverted = that._getOption('inverted', true);
      var textAlignment;
      if (isOutsidePosition(options.position)) {
        if ((0, _utils.normalizeEnum)(options.position) === OUTSIDE_POSITION) {
          getCoords = options.horizontalAlignment === 'left' ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition;
        } else {
          textAlignment = this._defaultLabelTextAlignment();
          getCoords = options.horizontalAlignment === 'left' ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment);
        }
      }
      that._labels.forEach(function (label, index) {
        var item = that._items[index];
        var borderWidth = item.getNormalStyle()['stroke-width'];
        var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;
        var coords = halfBorderWidth ? item.coords.map(function (coord, index) {
          if (index === 1 || index === 3) {
            return coord - halfBorderWidth;
          } else if (index === 2) {
            return coord - borderWidth;
          } else if (index === 0) {
            return coord + borderWidth;
          }
          return coord;
        }) : item.coords;
        if (!options.showForZeroValues && item.value === 0) {
          label.draw(false);
          return;
        }
        if (isOutsidePosition(options.position)) {
          that._correctLabelWidth(label, item.coords, options);
        }
        var bBox = label.getBoundingRect();
        var pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);
        label.setFigureToDrawConnector(coords);
        label.shift(pos.x, pos.y);
      });
      that._resolveLabelOverlapping();
    }
  },
  members: {
    _resolveLabelOverlapping() {
      var that = this;
      var resolveLabelOverlapping = (0, _utils.normalizeEnum)(that._getOption('resolveLabelOverlapping', true));
      var labels = this._getOption('inverted', true) ? that._labels.slice().reverse() : that._labels;
      if (resolveLabelOverlapping === 'hide') {
        labels.reduce(function (height, label) {
          if (label.getBoundingRect().y < height) {
            label.hide();
          } else {
            height = label.getBoundingRect().y + label.getBoundingRect().height;
          }
          return height;
        }, 0);
      } else if (resolveLabelOverlapping === 'shift') {
        var maxHeight = this._labelRect[3];
        labels.filter(function (label) {
          return label.isVisible();
        }).reduce(function (_ref, label, index, labels) {
          var _ref2 = _slicedToArray(_ref, 2),
            height = _ref2[0],
            emptySpace = _ref2[1];
          var bBox = label.getBoundingRect();
          var y = bBox.y;
          if (bBox.y < height) {
            label.shift(bBox.x, height);
            y = height;
          }
          if (y - height > 0) {
            emptySpace += y - height;
          }
          if (y + bBox.height > maxHeight) {
            if (emptySpace && emptySpace > y + bBox.height - maxHeight) {
              removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);
              emptySpace -= y + bBox.height - maxHeight;
              label.shift(bBox.x, y - (y + bBox.height - maxHeight));
              height = y - (y + bBox.height - maxHeight) + bBox.height;
            } else {
              label.hide();
            }
          } else {
            height = y + bBox.height;
          }
          return [height, emptySpace];
        }, [this._labelRect[1], 0]);
      }
    },
    _defaultLabelTextAlignment: function _defaultLabelTextAlignment() {
      return this._getOption('rtlEnabled', true) ? 'right' : 'left';
    },
    _correctLabelWidth: function _correctLabelWidth(label, item, options) {
      var isLeftPos = options.horizontalAlignment === 'left';
      var minX = isLeftPos ? this._labelRect[0] : item[2];
      var maxX = isLeftPos ? item[0] : this._labelRect[2];
      var maxWidth = maxX - minX;
      if (label.getBoundingRect().width > maxWidth) {
        label.fit(maxWidth);
      }
    },
    _createLabels: function _createLabels() {
      var that = this;
      var labelOptions = that._getOption('label');
      var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption('inverted', true));
      this._labelsGroup.clear();
      if (!labelOptions.visible) {
        return;
      }
      this._labels = that._items.map(function (item) {
        var label = new _label.Label({
          renderer: that._renderer,
          labelsGroup: that._labelsGroup,
          strategy: connectorStrategy
        });
        label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));
        label.setData({
          item: item,
          value: item.value,
          percent: item.percent
        });
        label.draw(true);
        return label;
      });
      if (this._labels.length && isOutsidePosition(labelOptions.position)) {
        this._requestChange(['LAYOUT']);
      }
    }
  },
  customize: function customize(constructor) {
    constructor.prototype._proxyData.push(function (x, y) {
      var that = this;
      var data;
      that._labels.forEach(function (label, index) {
        var rect = label.getBoundingRect();
        if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
          var pos = isOutsidePosition(that._getOption('label').position) ? 'outside' : 'inside';
          data = {
            id: index,
            type: pos + '-label'
          };
          return true;
        }
      });
      return data;
    });
    ['label', 'resolveLabelOverlapping'].forEach(function (optionName) {
      constructor.addChange({
        code: optionName.toUpperCase(),
        handler: function handler() {
          this._createLabels();
          this._requestChange(['LAYOUT']);
        },
        isThemeDependent: true,
        isOptionChange: true,
        option: optionName
      });
    });
  },
  fontFields: ['label.font']
};
exports.plugin = plugin;

/***/ }),

/***/ 89482:
/***/ (function(module, exports) {



exports["default"] = void 0;
var CENTER = 0.5;
var _default = {
  getFigures: function getFigures(data) {
    var height = 1 / data.length;
    return data.map(function (value, index, array) {
      var nextValue = array[index + 1] ? array[index + 1] : array[index];
      return [CENTER - value / 2, height * index, CENTER + value / 2, height * index, CENTER + nextValue / 2, height * (index + 1), CENTER - nextValue / 2, height * (index + 1)];
    });
  },
  normalizeValues: function normalizeValues(items) {
    var max = items.reduce(function (max, item) {
      return Math.max(item.value, max);
    }, items[0] && items[0].value || 0);
    return items.map(function (item) {
      return item.value / max;
    });
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 68074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addAlgorithm = addAlgorithm;
exports.getAlgorithm = getAlgorithm;
var _utils = __webpack_require__(19157);
var algorithms = {};
var defaultAlgorithm;
function getAlgorithm(name) {
  return algorithms[(0, _utils.normalizeEnum)(name)] || defaultAlgorithm;
}
function addAlgorithm(name, callback, setDefault) {
  algorithms[name] = callback;
  if (setDefault) {
    defaultAlgorithm = algorithms[name];
  }
}

/***/ }),

/***/ 2356:
/***/ (function(module, exports) {



exports["default"] = void 0;
var CENTER = 0.5;
var LEFTCORNER = 0;
var RIGHTCORNER = 1;
var _default = {
  getFigures: function getFigures(data, neckWidth, neckHeight) {
    var height = 0;
    var y = 0;
    var x = 0;
    var offsetX = 0;
    var halfNeckWidth = neckWidth / 2;
    var offsetFromCorner = CENTER - halfNeckWidth;
    var funnelHeight = 1 - neckHeight;
    var neckLeftCorner = CENTER - halfNeckWidth;
    var neckRightCorner = CENTER + halfNeckWidth;
    return data.map(function (value) {
      x = offsetX;
      y = height;
      height += value;
      offsetX = offsetFromCorner * height / funnelHeight;
      if (y <= funnelHeight && height <= funnelHeight) {
        return [x, y, RIGHTCORNER - x, y, RIGHTCORNER - offsetX, height, LEFTCORNER + offsetX, height];
      } else if (y <= funnelHeight && height > funnelHeight) {
        return [x, y, RIGHTCORNER - x, y, neckRightCorner, funnelHeight, neckRightCorner, height, neckLeftCorner, height, neckLeftCorner, funnelHeight];
      } else {
        return [neckLeftCorner, y, neckRightCorner, y, neckRightCorner, height, neckLeftCorner, height];
      }
    });
  },
  normalizeValues: function normalizeValues(items) {
    var sum = items.reduce(function (sum, item) {
      return sum + item.value;
    }, 0);
    return items.map(function (item) {
      return item.value / sum;
    });
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 32037:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _common = __webpack_require__(20576);
var _tooltip = __webpack_require__(14371);
function getCoords(coords, figureCoords, renderer) {
  var offset = renderer.getRootOffset();
  return coords || figureCoords && [(figureCoords[0] + figureCoords[2]) / 2 + offset.left, (figureCoords[1] + figureCoords[5]) / 2 + offset.top] || [-1000, -1000];
}
var plugin = {
  name: 'funnel-tooltip',
  init: _common.noop,
  dispose: _common.noop,
  extenders: {
    _buildNodes: function _buildNodes() {
      this.hideTooltip();
    },
    _change_TILING: function _change_TILING() {
      if (this._tooltipIndex >= 0) {
        this._moveTooltip(this._items[this._tooltipIndex]);
      }
    }
  },
  members: {
    hideTooltip: function hideTooltip() {
      if (this._tooltipIndex >= 0) {
        this._tooltipIndex = -1;
        this._tooltip.hide();
      }
    },
    _moveTooltip: function _moveTooltip(item, coords) {
      var xy = getCoords(coords, item.coords, this._renderer);
      this._tooltip.move(xy[0], xy[1], 0);
    },
    _showTooltip: function _showTooltip(index, coords) {
      var that = this;
      var tooltip = that._tooltip;
      var item = that._items[index];
      if (that._tooltipIndex === index) {
        that._moveTooltip(item, coords);
        return;
      }
      var callback = function callback(result) {
        if (result === undefined) {
          return;
        }
        if (!result) {
          tooltip.hide();
        }
        that._tooltipIndex = result ? index : -1;
      };
      var xy = getCoords(coords, item.coords, this._renderer);
      callback(tooltip.show({
        value: item.value,
        valueText: tooltip.formatValue(item.value),
        percentText: tooltip.formatValue(item.percent, 'percent'),
        percent: item.percent,
        item: item
      }, {
        x: xy[0],
        y: xy[1],
        offset: 0
      }, {
        item: item
      }, undefined, callback));
    }
  },
  customize: function customize(constructor) {
    constructor.addPlugin(_tooltip.plugin);
  }
};
exports.plugin = plugin;

/***/ }),

/***/ 76686:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _funnel = _interopRequireDefault(__webpack_require__(44697));
var _tracker = __webpack_require__(88997);
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DATA_KEY_BASE = '__funnel_data_';
var dataKeyModifier = 0;
var proto = _funnel.default.prototype;
proto._eventsMap.onItemClick = {
  name: 'itemClick'
};
proto._eventsMap.onLegendClick = {
  name: 'legendClick'
};
var getDataKey = function getDataKey() {
  return DATA_KEY_BASE + dataKeyModifier++;
};
var plugin = {
  name: 'tracker',
  init: function init() {
    var that = this;
    var dataKey = getDataKey();
    var getProxyData = function getProxyData(e) {
      var rootOffset = that._renderer.getRootOffset();
      var x = Math.floor(e.pageX - rootOffset.left);
      var y = Math.floor(e.pageY - rootOffset.top);
      return that._hitTestTargets(x, y);
    };
    that._tracker = new _tracker.Tracker({
      widget: that,
      root: that._renderer.root,
      getData: function getData(e, tooltipData) {
        var target = e.target;
        var data = target[dataKey];
        if ((0, _type.isDefined)(data)) {
          return data;
        }
        var proxyData = getProxyData(e);
        if (tooltipData && proxyData && proxyData.type !== 'inside-label') {
          return;
        }
        return proxyData && proxyData.id;
      },
      getNode: function getNode(index) {
        return that._items[index];
      },
      click: function click(e) {
        var proxyData = getProxyData(e.event);
        var dataType = proxyData && proxyData.type;
        var event = dataType === 'legend' ? 'legendClick' : 'itemClick';
        that._eventTrigger(event, {
          item: e.node,
          event: e.event
        });
      }
    });
    this._dataKey = dataKey;
  },
  dispose: function dispose() {
    this._tracker.dispose();
  },
  extenders: {
    _change_TILING: function _change_TILING() {
      var dataKey = this._dataKey;
      this._items.forEach(function (item, index) {
        item.element.data(dataKey, index);
      });
    }
  }
};
exports.plugin = plugin;

/***/ }),

/***/ 44898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.dxBarGauge = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _object = __webpack_require__(48013);
var _common = __webpack_require__(20576);
var _m_base_chart = __webpack_require__(14107);
var _extend2 = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _base_gauge = __webpack_require__(18029);
var _circular_gauge = _interopRequireDefault(__webpack_require__(31500));
var _legend = __webpack_require__(16342);
var _center_template = __webpack_require__(56672);
var _math = __webpack_require__(60810);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var PI_DIV_180 = Math.PI / 180;
var _abs = Math.abs;
var _round = Math.round;
var _floor = Math.floor;
var _min = Math.min;
var _max = Math.max;
var _getSampleText = _base_gauge.getSampleText;
var _formatValue = _base_gauge.formatValue;
var _compareArrays = _base_gauge.compareArrays;
var _isArray = Array.isArray;
var _convertAngleToRendererSpace = _utils.convertAngleToRendererSpace;
var _getCosAndSin = _utils.getCosAndSin;
var _patchFontOptions = _utils.patchFontOptions;
var _Number = Number;
var _isFinite = isFinite;
var _noop = _common.noop;
var _extend = _extend2.extend;
var ARC_COORD_PREC = 5;
var OPTION_VALUES = 'values';
var BarWrapper;
var dxBarGauge = _base_gauge.BaseGauge.inherit({
  _rootClass: 'dxbg-bar-gauge',
  _themeSection: 'barGauge',
  _fontFields: ['label.font', 'legend.font', 'legend.title.font', 'legend.title.subtitle.font'],
  _initCore: function _initCore() {
    var that = this;
    that.callBase.apply(that, arguments);
    that._barsGroup = that._renderer.g().attr({
      'class': 'dxbg-bars'
    }).linkOn(that._renderer.root, 'bars');
    that._values = [];
    that._context = {
      renderer: that._renderer,
      translator: that._translator,
      tracker: that._tracker,
      group: that._barsGroup
    };
    that._animateStep = function (pos) {
      var bars = that._bars;
      var i;
      var ii;
      for (i = 0, ii = bars.length; i < ii; ++i) {
        bars[i].animate(pos);
      }
    };
    that._animateComplete = function () {
      that._bars.forEach(function (bar) {
        return bar.endAnimation();
      });
      that._checkOverlap();
    };
  },
  _disposeCore: function _disposeCore() {
    var that = this;
    that._barsGroup.linkOff();
    that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null;
    that.callBase.apply(that, arguments);
  },
  _setupDomainCore: function _setupDomainCore() {
    var that = this;
    var startValue = that.option('startValue');
    var endValue = that.option('endValue');
    _isFinite(startValue) || (startValue = 0);
    _isFinite(endValue) || (endValue = 100);
    that._translator.setDomain(startValue, endValue);
    that._baseValue = that._translator.adjust(that.option('baseValue'));
    _isFinite(that._baseValue) || (that._baseValue = startValue < endValue ? startValue : endValue);
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 300,
      height: 300
    };
  },
  _setupCodomain: _circular_gauge.default.prototype._setupCodomain,
  _getApproximateScreenRange: function _getApproximateScreenRange() {
    var that = this;
    var sides = that._area.sides;
    var width = that._canvas.width / (sides.right - sides.left);
    var height = that._canvas.height / (sides.down - sides.up);
    var r = width < height ? width : height;
    return -that._translator.getCodomainRange() * r * PI_DIV_180;
  },
  _setupAnimationSettings: function _setupAnimationSettings() {
    var that = this;
    that.callBase.apply(that, arguments);
    if (that._animationSettings) {
      that._animationSettings.step = that._animateStep;
      that._animationSettings.complete = that._animateComplete;
    }
  },
  _cleanContent: function _cleanContent() {
    var that = this;
    that._barsGroup.linkRemove();
    that._animationSettings && that._barsGroup.stopAnimation();
    that._barsGroup.clear();
  },
  _renderContent: function _renderContent() {
    var that = this;
    var labelOptions = that.option('label');
    var text;
    var bBox;
    var context = that._context;
    that._barsGroup.linkAppend();
    context.textEnabled = labelOptions === undefined || labelOptions && (!('visible' in labelOptions) || labelOptions.visible);
    if (context.textEnabled) {
      context.textColor = labelOptions && labelOptions.font && labelOptions.font.color || null;
      labelOptions = _extend(true, {}, that._themeManager.theme().label, labelOptions);
      context.formatOptions = {
        format: labelOptions.format !== undefined ? labelOptions.format : that._defaultFormatOptions,
        customizeText: labelOptions.customizeText
      };
      context.textOptions = {
        align: 'center'
      };
      context.fontStyles = _patchFontOptions(_extend({}, that._themeManager.theme().label.font, labelOptions.font, {
        color: null
      }));
      that._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;
      context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;
      context.lineColor = labelOptions.connectorColor || null;
      text = that._renderer.text(_getSampleText(that._translator, context.formatOptions), 0, 0).attr(context.textOptions).css(context.fontStyles).append(that._barsGroup);
      bBox = text.getBBox();
      text.remove();
      context.textY = bBox.y;
      context.textWidth = bBox.width;
      context.textHeight = bBox.height;
    }
    _circular_gauge.default.prototype._applyMainLayout.call(that);
    that._renderBars();
  },
  _measureMainElements: function _measureMainElements() {
    var result = {
      maxRadius: this._area.radius
    };
    if (this._context.textEnabled) {
      result.horizontalMargin = this._context.textWidth;
      result.verticalMargin = this._context.textHeight;
      result.inverseHorizontalMargin = this._context.textWidth / 2;
      result.inverseVerticalMargin = this._context.textHeight / 2;
    }
    return result;
  },
  _renderBars: function _renderBars() {
    var that = this;
    var options = _extend({}, that._themeManager.theme(), that.option());
    var radius;
    var area = that._area;
    var relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : 0.1;
    radius = area.radius;
    if (that._context.textEnabled) {
      //  B253614
      that._textIndent = _round(_min(that._textIndent, radius / 2));
      radius -= that._textIndent;
    }
    that._outerRadius = _floor(radius);
    that._innerRadius = _floor(radius * relativeInnerRadius);
    that._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;
    _extend(that._context, {
      backgroundColor: options.backgroundColor,
      x: area.x,
      y: area.y,
      startAngle: area.startCoord,
      endAngle: area.endCoord,
      baseAngle: that._translator.translate(that._baseValue)
    });
    that._arrangeBars();
  },
  _arrangeBars: function _arrangeBars() {
    var that = this;
    var radius = that._outerRadius - that._innerRadius;
    var context = that._context;
    var i;
    var count = that._bars.length;
    that._beginValueChanging();
    context.barSize = count > 0 ? _max((radius - (count - 1) * that._barSpacing) / count, 1) : 0;
    var spacing = count > 1 ? _max(_min((radius - count * context.barSize) / (count - 1), that._barSpacing), 0) : 0;
    var _count = _min(_floor((radius + spacing) / context.barSize), count);
    that._setBarsCount(count);
    radius = that._outerRadius;
    context.textRadius = radius;
    context.textIndent = that._textIndent;
    that._palette.reset();
    var unitOffset = context.barSize + spacing;
    var colors = that._palette.generateColors(_count);
    for (i = 0; i < _count; ++i, radius -= unitOffset) {
      that._bars[i].arrange({
        radius: radius,
        color: colors[i]
      });
    }
    for (var _i = _count; _i < count; _i++) {
      that._bars[_i].hide();
    }
    if (that._animationSettings && !that._noAnimation) {
      that._animateBars();
    } else {
      that._updateBars();
    }
    that._endValueChanging();
  },
  _setBarsCount: function _setBarsCount() {
    var that = this;
    if (that._bars.length > 0) {
      if (that._dummyBackground) {
        that._dummyBackground.dispose();
        that._dummyBackground = null;
      }
    } else {
      if (!that._dummyBackground) {
        that._dummyBackground = that._renderer.arc().attr({
          'stroke-linejoin': 'round'
        });
      }
      that._dummyBackground.attr({
        //  Because of vizMocks
        x: that._context.x,
        y: that._context.y,
        outerRadius: that._outerRadius,
        innerRadius: that._innerRadius,
        startAngle: that._context.endAngle,
        endAngle: that._context.startAngle,
        fill: that._context.backgroundColor
      }).append(that._barsGroup);
    }
  },
  _getCenter: function _getCenter() {
    return {
      x: this._context.x,
      y: this._context.y
    };
  },
  _updateBars: function _updateBars() {
    this._bars.forEach(function (bar) {
      return bar.applyValue();
    });
    this._checkOverlap();
  },
  _checkOverlap: function _checkOverlap() {
    var that = this;
    var overlapStrategy = (0, _utils.normalizeEnum)(that._getOption('resolveLabelOverlapping', true));
    function shiftFunction(box, length) {
      return (0, _utils.getVerticallyShiftedAngularCoords)(box, -length, that._context);
    }
    if (overlapStrategy === 'none') {
      return;
    }
    if (overlapStrategy === 'shift') {
      var newBars = that._dividePoints();
      _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(newBars.left, that._canvas, false, false, shiftFunction);
      _m_base_chart.overlapping.resolveLabelOverlappingInOneDirection(newBars.right, that._canvas, false, false, shiftFunction);
      that._clearLabelsCrossTitle();
      that._drawConnector();
    } else {
      that._clearOverlappingLabels();
    }
  },
  _drawConnector() {
    var that = this;
    var bars = that._bars;
    var _that$_getOption = that._getOption('label'),
      connectorWidth = _that$_getOption.connectorWidth;
    bars.forEach(function (bar) {
      if (!bar._isLabelShifted) {
        return;
      }
      var x = bar._bar.attr('x');
      var y = bar._bar.attr('y');
      var innerRadius = bar._bar.attr('innerRadius');
      var outerRadius = bar._bar.attr('outerRadius');
      var startAngle = bar._bar.attr('startAngle');
      var endAngle = bar._bar.attr('endAngle');
      var coordStart = getStartCoordsArc.apply(null, (0, _utils.normalizeArcParams)(x, y, innerRadius, outerRadius, startAngle, endAngle));
      var _getCosAndSin2 = _getCosAndSin(bar._angle),
        cos = _getCosAndSin2.cos,
        sin = _getCosAndSin2.sin;
      var xStart = coordStart.x - sin * connectorWidth / 2 - cos;
      var yStart = coordStart.y - cos * connectorWidth / 2 + sin;
      var box = bar._text.getBBox();
      var lastCoords = bar._text._lastCoords;
      var indentFromLabel = that._context.textWidth / 2;
      var originalXLabelCoord = box.x + box.width / 2 + lastCoords.x;
      var originalPoints = [xStart, yStart, originalXLabelCoord, box.y + lastCoords.y];
      if (bar._angle > 90) {
        originalPoints[2] += indentFromLabel;
      } else {
        originalPoints[2] -= indentFromLabel;
      }
      if (bar._angle <= 180 && bar._angle > 0) {
        originalPoints[3] += box.height;
      }
      if (connectorWidth % 2) {
        var xDeviation = -sin / 2;
        var yDeviation = -cos / 2;
        if (bar._angle > 180) {
          originalPoints[0] -= xDeviation;
          originalPoints[1] -= yDeviation;
        } else if (bar._angle > 0 && bar._angle <= 90) {
          originalPoints[0] += xDeviation;
          originalPoints[1] += yDeviation;
        }
      }
      var points = originalPoints.map(function (coordinate) {
        return (0, _math.roundFloatPart)(coordinate, 4);
      });
      bar._line.attr({
        points
      });
      bar._line.rotate(0);
      bar._isLabelShifted = false;
    });
  },
  _dividePoints() {
    var that = this;
    var bars = that._bars;
    return bars.reduce(function (stackBars, bar) {
      var angle = (0, _utils.normalizeAngle)(bar._angle);
      var isRightSide = angle <= 90 || angle >= 270;
      bar._text._lastCoords = {
        x: 0,
        y: 0
      };
      var barToExtend = isRightSide ? stackBars.right : stackBars.left;
      barToExtend.push({
        series: {
          isStackedSeries: function isStackedSeries() {
            return false;
          },
          isFullStackedSeries: function isFullStackedSeries() {
            return false;
          }
        },
        getLabels: function getLabels() {
          return [{
            isVisible: function isVisible() {
              return true;
            },
            getBoundingRect: function getBoundingRect() {
              var _bar$_text$getBBox = bar._text.getBBox(),
                height = _bar$_text$getBBox.height,
                width = _bar$_text$getBBox.width,
                x = _bar$_text$getBBox.x,
                y = _bar$_text$getBBox.y;
              var lastCoords = bar._text._lastCoords;
              return {
                x: x + lastCoords.x,
                y: y + lastCoords.y,
                width,
                height
              };
            },
            shift: function shift(x, y) {
              var box = bar._text.getBBox();
              bar._text._lastCoords = {
                x: x - box.x,
                y: y - box.y
              };
              bar._text.attr({
                translateX: x - box.x,
                translateY: y - box.y
              });
              bar._isLabelShifted = true;
            },
            draw: function draw() {
              return bar.hideLabel();
            },
            getData: function getData() {
              return {
                value: bar.getValue()
              };
            },
            hideInsideLabel: function hideInsideLabel() {
              return false;
            }
          }];
        }
      });
      return stackBars;
    }, {
      left: [],
      right: []
    });
  },
  _clearOverlappingLabels() {
    var that = this;
    var bars = that._bars;
    var currentIndex = 0;
    var nextIndex = 1;
    var sortedBars = bars.concat().sort(function (a, b) {
      return a.getValue() - b.getValue();
    });
    while (currentIndex < sortedBars.length && nextIndex < sortedBars.length) {
      var current = sortedBars[currentIndex];
      var next = sortedBars[nextIndex];
      if (current.checkIntersect(next)) {
        next.hideLabel();
        nextIndex++;
      } else {
        currentIndex = nextIndex;
        nextIndex = currentIndex + 1;
      }
    }
  },
  _clearLabelsCrossTitle() {
    var that = this;
    var bars = that._bars;
    var titleCoords = that._title.getLayoutOptions() || {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    };
    var minY = titleCoords.y + titleCoords.height;
    bars.forEach(function (bar) {
      var box = bar._text.getBBox();
      var lastCoords = bar._text._lastCoords;
      if (minY > box.y + lastCoords.y) {
        bar.hideLabel();
      }
    });
  },
  _animateBars: function _animateBars() {
    var that = this;
    var i;
    var ii = that._bars.length;
    if (ii > 0) {
      for (i = 0; i < ii; ++i) {
        that._bars[i].beginAnimation();
      }
      that._barsGroup.animate({
        _: 0
      }, that._animationSettings);
    }
  },
  _buildNodes() {
    var that = this;
    var options = that._options.silent();
    that._palette = that._themeManager.createPalette(options.palette, {
      useHighlight: true,
      extensionMode: options.paletteExtensionMode
    });
    that._palette.reset();
    that._bars = that._bars || [];
    that._animationSettings && that._barsGroup.stopAnimation();
    var barValues = that._values.filter(_isFinite);
    var count = barValues.length;
    if (that._bars.length > count) {
      var ii = that._bars.length;
      for (var i = count; i < ii; ++i) {
        that._bars[i].dispose();
      }
      that._bars.splice(count, ii - count);
    } else if (that._bars.length < count) {
      for (var _i2 = that._bars.length; _i2 < count; ++_i2) {
        that._bars.push(new BarWrapper(_i2, that._context));
      }
    }
    that._bars.forEach(function (bar, index) {
      bar.update({
        color: that._palette.getNextColor(count),
        value: barValues[index]
      });
    });
  },
  _updateValues: function _updateValues(values) {
    var that = this;
    var list = _isArray(values) && values || _isFinite(values) && [values] || [];
    var i;
    var ii = list.length;
    var value;
    that._values.length = ii;
    for (i = 0; i < ii; ++i) {
      value = list[i];
      that._values[i] = _Number(_isFinite(value) ? value : that._values[i]);
    }
    if (!that._resizing) {
      if (!_compareArrays(that._values, that.option(OPTION_VALUES))) {
        that.option(OPTION_VALUES, that._values.slice());
      }
    }
    this._change(['NODES']);
  },
  values: function values(arg) {
    if (arg !== undefined) {
      this._updateValues(arg);
      return this;
    } else {
      return this._values.slice(0);
    }
  },
  _optionChangesMap: {
    backgroundColor: 'MOSTLY_TOTAL',
    relativeInnerRadius: 'MOSTLY_TOTAL',
    barSpacing: 'MOSTLY_TOTAL',
    label: 'MOSTLY_TOTAL',
    resolveLabelOverlapping: 'MOSTLY_TOTAL',
    palette: 'MOSTLY_TOTAL',
    paletteExtensionMode: 'MOSTLY_TOTAL',
    values: 'VALUES'
  },
  _change_VALUES: function _change_VALUES() {
    this._updateValues(this.option(OPTION_VALUES));
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory),
  _optionChangesOrder: ['VALUES', 'NODES'],
  _initialChanges: ['VALUES'],
  _change_NODES() {
    this._buildNodes();
  },
  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {
    this._change(['NODES']);
    this.callBase();
  },
  _proxyData: [],
  _getLegendData() {
    var that = this;
    var formatOptions = {};
    var options = that._options.silent();
    var labelFormatOptions = (options.label || {}).format;
    var legendFormatOptions = (options.legend || {}).itemTextFormat;
    if (legendFormatOptions) {
      formatOptions.format = legendFormatOptions;
    } else {
      formatOptions.format = labelFormatOptions || that._defaultFormatOptions;
    }
    return (this._bars || []).map(function (b) {
      return {
        id: b.index,
        item: {
          value: b.getValue(),
          color: b.getColor(),
          index: b.index
        },
        text: _formatValue(b.getValue(), formatOptions),
        visible: true,
        states: {
          normal: {
            fill: b.getColor()
          }
        }
      };
    });
  }
});
exports.dxBarGauge = dxBarGauge;
BarWrapper = function BarWrapper(index, context) {
  var that = this;
  that._context = context;
  that._tracker = context.renderer.arc().attr({
    'stroke-linejoin': 'round'
  });
  that.index = index;
};
_extend(BarWrapper.prototype, {
  dispose: function dispose() {
    var that = this;
    that._background.dispose();
    that._bar.dispose();
    if (that._context.textEnabled) {
      that._line.dispose();
      that._text.dispose();
    }
    that._context.tracker.detach(that._tracker);
    that._context = that._settings = that._background = that._bar = that._line = that._text = that._tracker = null;
    return that;
  },
  arrange: function arrange(options) {
    var that = this;
    var context = that._context;
    this._visible = true;
    context.tracker.attach(that._tracker, that, {
      index: that.index
    });
    that._background = context.renderer.arc().attr({
      'stroke-linejoin': 'round',
      fill: context.backgroundColor
    }).append(context.group);
    that._settings = that._settings || {
      x: context.x,
      y: context.y,
      startAngle: context.baseAngle,
      endAngle: context.baseAngle
    };
    that._bar = context.renderer.arc().attr(_extend({
      'stroke-linejoin': 'round'
    }, that._settings)).append(context.group);
    if (context.textEnabled) {
      that._line = context.renderer.path([], 'line').attr({
        'stroke-width': context.lineWidth
      }).append(context.group);
      that._text = context.renderer.text().css(context.fontStyles).attr(context.textOptions).append(context.group);
    }
    that._angle = isFinite(that._angle) ? that._angle : context.baseAngle;
    that._settings.outerRadius = options.radius;
    that._settings.innerRadius = options.radius - context.barSize;
    that._settings.x = context.x;
    that._settings.y = context.y;
    that._background.attr(_extend({}, that._settings, {
      startAngle: context.endAngle,
      endAngle: context.startAngle,
      fill: that._context.backgroundColor
    }));
    that._bar.attr({
      x: context.x,
      y: context.y,
      outerRadius: that._settings.outerRadius,
      innerRadius: that._settings.innerRadius,
      fill: that._color
    });
    that._tracker.attr(that._settings);
    if (context.textEnabled) {
      that._line.attr({
        points: [context.x, context.y - that._settings.innerRadius, context.x, context.y - context.textRadius - context.textIndent],
        stroke: context.lineColor || that._color
      }).sharp();
      that._text.css({
        fill: context.textColor || that._color
      });
    }
    return that;
  },
  getTooltipParameters: function getTooltipParameters() {
    var that = this;
    var cosSin = _getCosAndSin((that._angle + that._context.baseAngle) / 2);
    return {
      x: _round(that._context.x + (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.cos),
      y: _round(that._context.y - (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.sin),
      offset: 0,
      color: that._color,
      value: that._value
    };
  },
  setAngle: function setAngle(angle) {
    var that = this;
    var context = that._context;
    var settings = that._settings;
    var cosSin;
    that._angle = angle;
    setAngles(settings, context.baseAngle, angle);
    that._bar.attr(settings);
    that._tracker.attr(settings);
    if (context.textEnabled) {
      cosSin = _getCosAndSin(angle);
      var indent = context.textIndent;
      var radius = context.textRadius + indent;
      var x = context.x + radius * cosSin.cos;
      var y = context.y - radius * cosSin.sin;
      var halfWidth = context.textWidth * 0.5;
      var textHeight = context.textHeight;
      var textY = context.textY;
      if (_abs(x - context.x) > indent) {
        x += x < context.x ? -halfWidth : halfWidth;
      }
      if (_abs(y - context.y) <= indent) {
        y -= textY + textHeight * 0.5;
      } else {
        y -= y < context.y ? textY + textHeight : textY;
      }
      var text = _formatValue(that._value, context.formatOptions, {
        index: that.index
      });
      var visibility = text === '' ? 'hidden' : null;
      that._text.attr({
        text: text,
        x: x,
        y: y,
        visibility: visibility
      });
      that._line.attr({
        visibility: visibility
      });
      that._line.rotate(_convertAngleToRendererSpace(angle), context.x, context.y);
    }
    return that;
  },
  hideLabel: function hideLabel() {
    this._text.attr({
      visibility: 'hidden'
    });
    this._line.attr({
      visibility: 'hidden'
    });
  },
  checkIntersect: function checkIntersect(anotherBar) {
    var coords = this.calculateLabelCoords();
    var anotherCoords = anotherBar.calculateLabelCoords();
    if (!coords || !anotherCoords) {
      return false;
    }
    var width = Math.max(0, Math.min(coords.bottomRight.x, anotherCoords.bottomRight.x) - Math.max(coords.topLeft.x, anotherCoords.topLeft.x));
    var height = Math.max(0, Math.min(coords.bottomRight.y, anotherCoords.bottomRight.y) - Math.max(coords.topLeft.y, anotherCoords.topLeft.y));
    return width * height !== 0;
  },
  calculateLabelCoords: function calculateLabelCoords() {
    if (!this._text) {
      return;
    }
    var box = this._text.getBBox();
    return {
      topLeft: {
        x: box.x,
        y: box.y
      },
      bottomRight: {
        x: box.x + box.width,
        y: box.y + box.height
      }
    };
  },
  _processValue: function _processValue(value) {
    return this._context.translator.translate(this._context.translator.adjust(value));
  },
  applyValue() {
    if (!this._visible) {
      return this;
    }
    return this.setAngle(this._processValue(this.getValue()));
  },
  update(_ref) {
    var color = _ref.color,
      value = _ref.value;
    this._color = color;
    this._value = value;
  },
  hide() {
    this._visible = false;
  },
  getColor() {
    return this._color;
  },
  getValue() {
    return this._value;
  },
  beginAnimation: function beginAnimation() {
    if (!this._visible) {
      return this;
    }
    var that = this;
    var angle = this._processValue(this.getValue());
    if (!compareFloats(that._angle, angle)) {
      that._start = that._angle;
      that._delta = angle - that._angle;
      that._tracker.attr({
        visibility: 'hidden'
      });
      if (that._context.textEnabled) {
        that._line.attr({
          visibility: 'hidden'
        });
        that._text.attr({
          visibility: 'hidden'
        });
      }
    } else {
      that.animate = _noop;
      that.setAngle(that._angle);
    }
  },
  animate: function animate(pos) {
    if (!this._visible) {
      return this;
    }
    var that = this;
    that._angle = that._start + that._delta * pos;
    setAngles(that._settings, that._context.baseAngle, that._angle);
    that._bar.attr(that._settings);
  },
  endAnimation: function endAnimation() {
    var that = this;
    if (that._delta !== undefined) {
      if (compareFloats(that._angle, that._start + that._delta)) {
        that._tracker.attr({
          visibility: null
        });
        that.setAngle(that._angle);
      }
    } else {
      delete that.animate;
    }
    delete that._start;
    delete that._delta;
  }
});
function setAngles(target, angle1, angle2) {
  target.startAngle = angle1 < angle2 ? angle1 : angle2;
  target.endAngle = angle1 < angle2 ? angle2 : angle1;
}
function compareFloats(value1, value2) {
  return _abs(value1 - value2) < 0.0001;
}
function getStartCoordsArc(x, y, innerR, outerR, startAngleCos, startAngleSin) {
  return {
    x: (x + outerR * startAngleCos).toFixed(ARC_COORD_PREC),
    y: (y - outerR * startAngleSin).toFixed(ARC_COORD_PREC)
  };
}
(0, _component_registrator.default)('dxBarGauge', dxBarGauge);
dxBarGauge.addPlugin(_legend.plugin);
dxBarGauge.addPlugin(_center_template.plugins.gauge);

/***/ }),

/***/ 18029:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.BaseGauge = void 0;
exports.compareArrays = compareArrays;
exports.getSampleText = exports.formatValue = void 0;
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _translator1d = __webpack_require__(17953);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _theme_manager = _interopRequireDefault(__webpack_require__(41802));
var _tracker = _interopRequireDefault(__webpack_require__(57298));
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _tooltip = __webpack_require__(14371);
var _loading_indicator = __webpack_require__(64758);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _Number = Number;
var _extend = _extend2.extend;
var _format = _format_helper.default.format;
var BaseGauge = _m_base_widget.default.inherit({
  _rootClassPrefix: 'dxg',
  _themeSection: 'gauge',
  _createThemeManager: function _createThemeManager() {
    return new _theme_manager.default.ThemeManager(this._getThemeManagerOptions());
  },
  _initCore: function _initCore() {
    var that = this;
    var root = that._renderer.root;
    that._valueChangingLocker = 0;
    that._translator = that._factory.createTranslator();
    that._tracker = that._factory.createTracker({
      renderer: that._renderer,
      container: root
    });
    that._setTrackerCallbacks();
  },
  _beginValueChanging: function _beginValueChanging() {
    this._resetIsReady();
    this._onBeginUpdate();
    ++this._valueChangingLocker;
  },
  _endValueChanging: function _endValueChanging() {
    if (--this._valueChangingLocker === 0) {
      this._drawn();
    }
  },
  _setTrackerCallbacks: function _setTrackerCallbacks() {
    var that = this;
    var renderer = that._renderer;
    var tooltip = that._tooltip;
    that._tracker.setCallbacks({
      'tooltip-show': function tooltipShow(target, info, callback) {
        var tooltipParameters = target.getTooltipParameters();
        var offset = renderer.getRootOffset();
        var formatObject = _extend({
          value: tooltipParameters.value,
          valueText: tooltip.formatValue(tooltipParameters.value),
          color: tooltipParameters.color
        }, info);
        return tooltip.show(formatObject, {
          x: tooltipParameters.x + offset.left,
          y: tooltipParameters.y + offset.top,
          offset: tooltipParameters.offset
        }, {
          target: info
        }, undefined, callback);
      },
      'tooltip-hide': function tooltipHide() {
        return tooltip.hide();
      }
    });
  },
  _dispose: function _dispose() {
    this._cleanCore();
    this.callBase.apply(this, arguments);
  },
  _disposeCore: function _disposeCore() {
    var that = this;
    that._themeManager.dispose();
    that._tracker.dispose();
    that._translator = that._tracker = null;
  },
  _cleanCore: function _cleanCore() {
    var that = this;
    that._tracker.deactivate();
    that._cleanContent();
  },
  _renderCore: function _renderCore() {
    var that = this;
    if (!that._isValidDomain) return;
    that._renderContent();
    that._renderGraphicObjects();
    that._tracker.setTooltipState(that._tooltip.isEnabled());
    that._tracker.activate();
    that._noAnimation = false;
  },
  _applyChanges: function _applyChanges() {
    this.callBase.apply(this, arguments);
    this._resizing = this._noAnimation = false;
  },
  _setContentSize: function _setContentSize() {
    var that = this;
    that._resizing = that._noAnimation = that._changes.count() === 2;
    that.callBase.apply(that, arguments);
  },
  _applySize: function _applySize(rect) {
    var that = this;
    that._innerRect = {
      left: rect[0],
      top: rect[1],
      right: rect[2],
      bottom: rect[3]
    };
    // If loading indicator is shown it is got hidden at the end of "_renderCore" - during "_drawn". Then "loadingIndicator" option is changed.
    // It causes another "_setContentSize" execution (inside of the first one). Layout backwards during inner "_setContentSize" and clears its cache and
    // then backwards again during outer "_setContentSize" when "_cache" is null - so it fails.
    // The following code dirtily preserves layout cache for the outer backward.
    // The appropriate solution is to remove heavy rendering from "_applySize" - it should be done later during some other change processing.
    // It would be even better to somehow defer any inside option changes - so they all are applied after all changes are processed.
    var layoutCache = that._layout._cache;
    that._cleanCore();
    that._renderCore();
    that._layout._cache = that._layout._cache || layoutCache;
    return [rect[0], that._innerRect.top, rect[2], that._innerRect.bottom];
  },
  _initialChanges: ['DOMAIN'],
  _themeDependentChanges: ['DOMAIN'],
  _optionChangesMap: {
    subtitle: 'MOSTLY_TOTAL',
    indicator: 'MOSTLY_TOTAL',
    geometry: 'MOSTLY_TOTAL',
    animation: 'MOSTLY_TOTAL',
    startValue: 'DOMAIN',
    endValue: 'DOMAIN'
  },
  _optionChangesOrder: ['DOMAIN', 'MOSTLY_TOTAL'],
  _change_DOMAIN: function _change_DOMAIN() {
    this._setupDomain();
  },
  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {
    this._applyMostlyTotalChange();
  },
  _updateExtraElements: _common.noop,
  _setupDomain: function _setupDomain() {
    var that = this;
    that._setupDomainCore();
    // T130599
    that._isValidDomain = isFinite(1 / (that._translator.getDomain()[1] - that._translator.getDomain()[0]));
    if (!that._isValidDomain) {
      that._incidentOccurred('W2301');
    }
    that._change(['MOSTLY_TOTAL']);
  },
  _applyMostlyTotalChange: function _applyMostlyTotalChange() {
    var that = this;
    that._setupCodomain();
    that._setupAnimationSettings();
    that._setupDefaultFormat();
    that._change(['LAYOUT']);
  },
  _setupAnimationSettings: function _setupAnimationSettings() {
    var that = this;
    var option = that.option('animation');
    that._animationSettings = null;
    if (option === undefined || option) {
      option = _extend({
        enabled: true,
        duration: 1000,
        easing: 'easeOutCubic'
      }, option);
      if (option.enabled && option.duration > 0) {
        that._animationSettings = {
          duration: _Number(option.duration),
          easing: option.easing
        };
      }
    }
    //  It is better to place it here than to create separate function for one line of code
    that._containerBackgroundColor = that.option('containerBackgroundColor') || that._themeManager.theme().containerBackgroundColor;
  },
  _setupDefaultFormat: function _setupDefaultFormat() {
    var domain = this._translator.getDomain();
    this._defaultFormatOptions = (0, _utils.getAppropriateFormat)(domain[0], domain[1], this._getApproximateScreenRange());
  },
  _setupDomainCore: null,
  _calculateSize: null,
  _cleanContent: null,
  _renderContent: null,
  _setupCodomain: null,
  _getApproximateScreenRange: null,
  _factory: {
    createTranslator: function createTranslator() {
      return new _translator1d.Translator1D();
    },
    createTracker: function createTracker(parameters) {
      return new _tracker.default(parameters);
    }
  }
});

//  TODO: find a better place for it
exports.BaseGauge = BaseGauge;
var formatValue = function formatValue(value, options, extra) {
  if (Object.is(value, -0)) {
    value = 0;
  }
  options = options || {};
  var text = _format(value, options.format);
  var formatObject;
  if (typeof options.customizeText === 'function') {
    formatObject = _extend({
      value: value,
      valueText: text
    }, extra);
    return String(options.customizeText.call(formatObject, formatObject));
  }
  return text;
};

//  TODO: find a better place for it
exports.formatValue = formatValue;
var getSampleText = function getSampleText(translator, options) {
  var text1 = formatValue(translator.getDomainStart(), options);
  var text2 = formatValue(translator.getDomainEnd(), options);
  return text1.length >= text2.length ? text1 : text2;
};
exports.getSampleText = getSampleText;
function compareArrays(array1, array2) {
  return array1 && array2 && array1.length === array2.length && compareArraysElements(array1, array2);
}
function compareArraysElements(array1, array2) {
  var i;
  var ii = array1.length;
  var array1ValueIsNaN;
  var array2ValueIsNaN;
  for (i = 0; i < ii; ++i) {
    array1ValueIsNaN = array1[i] !== array1[i];
    array2ValueIsNaN = array2[i] !== array2[i];
    if (array1ValueIsNaN && array2ValueIsNaN) {
      continue;
    }
    if (array1[i] !== array2[i]) return false;
  }
  return true;
}

// PLUGINS_SECTION
BaseGauge.addPlugin(_export.plugin);
BaseGauge.addPlugin(_title.plugin);
BaseGauge.addPlugin(_tooltip.plugin);
BaseGauge.addPlugin(_loading_indicator.plugin);

// These are gauges specifics on using tooltip - they require refactoring.
var _setTooltipOptions = BaseGauge.prototype._setTooltipOptions;
BaseGauge.prototype._setTooltipOptions = function () {
  _setTooltipOptions.apply(this, arguments);
  this._tracker && this._tracker.setTooltipState(this._tooltip.isEnabled());
};

/***/ }),

/***/ 3446:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.BaseTextCloudMarker = exports.BaseRangeBar = exports.BaseIndicator = exports.BaseElement = void 0;
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _base_gauge = __webpack_require__(18029);
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
var _class = _interopRequireDefault(__webpack_require__(38377));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _isFinite = isFinite;
var _Number = Number;
var _round = Math.round;
var _formatValue = _base_gauge.formatValue;
var _getSampleText = _base_gauge.getSampleText;
var BaseElement = _class.default.inherit({
  ctor: function ctor(parameters) {
    var that = this;
    (0, _iterator.each)(parameters, function (name, value) {
      that['_' + name] = value;
    });
    that._init();
  },
  dispose: function dispose() {
    var that = this;
    that._dispose();
    (0, _iterator.each)(that, function (name) {
      that[name] = null;
    });
    return that;
  },
  getOffset: function getOffset() {
    return _Number(this._options.offset) || 0;
  }
});
exports.BaseElement = BaseElement;
var BaseIndicator = BaseElement.inherit({
  _init: function _init() {
    var that = this;
    that._rootElement = that._createRoot().linkOn(that._owner, {
      name: 'value-indicator',
      after: 'core'
    });
    that._trackerElement = that._createTracker();
  },
  _dispose: function _dispose() {
    this._rootElement.linkOff();
  },
  _setupAnimation: function _setupAnimation() {
    var that = this;
    if (that._options.animation) {
      that._animation = {
        step: function step(pos) {
          that._actualValue = that._animation.start + that._animation.delta * pos;
          that._actualPosition = that._translator.translate(that._actualValue);
          that._move();
        },
        duration: that._options.animation.duration > 0 ? _Number(that._options.animation.duration) : 0,
        easing: that._options.animation.easing
      };
    }
  },
  _runAnimation: function _runAnimation(value) {
    var that = this;
    var animation = that._animation;
    animation.start = that._actualValue;
    animation.delta = value - that._actualValue;
    that._rootElement.animate({
      _: 0
    }, {
      step: animation.step,
      duration: animation.duration,
      easing: animation.easing
    });
  },
  _createRoot: function _createRoot() {
    return this._renderer.g().attr({
      'class': this._className
    });
  },
  _createTracker: function _createTracker() {
    return this._renderer.path([], 'area');
  },
  _getTrackerSettings: _common.noop,
  clean: function clean() {
    var that = this;
    that._animation && that._rootElement.stopAnimation();
    that._rootElement.linkRemove().clear();
    that._clear();
    that._tracker.detach(that._trackerElement);
    that._options = that.enabled = that._animation = null;
    return that;
  },
  render: function render(options) {
    var that = this;
    that.type = options.type;
    that._options = options;
    that._actualValue = that._currentValue = that._translator.adjust(that._options.currentValue);
    that.enabled = that._isEnabled();
    if (that.enabled) {
      that._setupAnimation();
      that._rootElement.attr({
        fill: (0, _utils.extractColor)(that._options.color)
      }).linkAppend();
      that._tracker.attach(that._trackerElement, that, that._trackerInfo);
    }
    return that;
  },
  resize: function resize(layout) {
    var that = this;
    that._rootElement.clear();
    that._clear();
    that.visible = that._isVisible(layout);
    if (that.visible) {
      (0, _extend.extend)(that._options, layout);
      that._actualPosition = that._translator.translate(that._actualValue);
      that._render();
      that._trackerElement.attr(that._getTrackerSettings());
      that._move();
    }
    return that;
  },
  value: function value(arg, _noAnimation) {
    var that = this;
    var val;
    var rootElement = this._rootElement;
    var visibility = null;
    if (arg === undefined) {
      return that._currentValue;
    }
    if (arg === null) {
      visibility = 'hidden';
      that._currentValue = arg;
    } else {
      val = that._translator.adjust(arg);
      if (that._currentValue !== val && _isFinite(val)) {
        that._currentValue = val;
        if (that.visible) {
          if (that._animation && !_noAnimation) {
            that._runAnimation(val);
          } else {
            that._actualValue = val;
            that._actualPosition = that._translator.translate(val);
            that._move();
          }
        }
      }
    }
    rootElement.attr({
      visibility: visibility
    });
    return that;
  },
  _isEnabled: null,
  _isVisible: null,
  _render: null,
  _clear: null,
  _move: null
});

// The following is from baseMarker.js
exports.BaseIndicator = BaseIndicator;
var COEFFICIENTS_MAP = {};
COEFFICIENTS_MAP['right-bottom'] = COEFFICIENTS_MAP['rb'] = [0, -1, -1, 0, 0, 1, 1, 0];
COEFFICIENTS_MAP['bottom-right'] = COEFFICIENTS_MAP['br'] = [-1, 0, 0, -1, 1, 0, 0, 1];
COEFFICIENTS_MAP['left-bottom'] = COEFFICIENTS_MAP['lb'] = [0, -1, 1, 0, 0, 1, -1, 0];
COEFFICIENTS_MAP['bottom-left'] = COEFFICIENTS_MAP['bl'] = [1, 0, 0, -1, -1, 0, 0, 1];
COEFFICIENTS_MAP['left-top'] = COEFFICIENTS_MAP['lt'] = [0, 1, 1, 0, 0, -1, -1, 0];
COEFFICIENTS_MAP['top-left'] = COEFFICIENTS_MAP['tl'] = [1, 0, 0, 1, -1, 0, 0, -1];
COEFFICIENTS_MAP['right-top'] = COEFFICIENTS_MAP['rt'] = [0, 1, -1, 0, 0, -1, 1, 0];
COEFFICIENTS_MAP['top-right'] = COEFFICIENTS_MAP['tr'] = [-1, 0, 0, 1, 1, 0, 0, -1];
function getTextCloudInfo(options) {
  var x = options.x;
  var y = options.y;
  var type = COEFFICIENTS_MAP[options.type];
  var cloudWidth = options.cloudWidth;
  var cloudHeight = options.cloudHeight;
  var tailWidth;
  var tailHeight;
  var cx = x;
  var cy = y;
  tailWidth = tailHeight = options.tailLength;
  if (type[0] & 1) {
    tailHeight = Math.min(tailHeight, cloudHeight / 3);
  } else {
    tailWidth = Math.min(tailWidth, cloudWidth / 3);
  }
  return {
    cx: _round(cx + type[0] * tailWidth + (type[0] + type[2]) * cloudWidth / 2),
    cy: _round(cy + type[1] * tailHeight + (type[1] + type[3]) * cloudHeight / 2),
    points: [_round(x), _round(y), _round(x += type[0] * (cloudWidth + tailWidth)), _round(y += type[1] * (cloudHeight + tailHeight)), _round(x += type[2] * cloudWidth), _round(y += type[3] * cloudHeight), _round(x += type[4] * cloudWidth), _round(y += type[5] * cloudHeight), _round(x += type[6] * (cloudWidth - tailWidth)), _round(y += type[7] * (cloudHeight - tailHeight))]
  };
}
var BaseTextCloudMarker = BaseIndicator.inherit({
  _move: function _move() {
    var that = this;
    var options = that._options;
    var textCloudOptions = that._getTextCloudOptions();
    var text = _formatValue(that._actualValue, options.text);
    that._text.attr({
      text: text
    });
    var bBox = that._text.getBBox();
    var x = textCloudOptions.x;
    var y = textCloudOptions.y;
    var cloudWidth = (bBox.width || text.length * that._textUnitWidth) + 2 * options.horizontalOffset;
    var cloudHeight = (bBox.height || that._textHeight) + 2 * options.verticalOffset;
    var info = getTextCloudInfo({
      x,
      y,
      cloudWidth,
      cloudHeight,
      tailLength: options.arrowLength,
      type: that._correctCloudType(textCloudOptions.type, {
        x,
        y
      }, {
        width: cloudWidth,
        height: cloudHeight
      })
    });
    that._text.attr({
      x: info.cx,
      y: info.cy + that._textVerticalOffset
    });
    that._cloud.attr({
      points: info.points
    });
    that._trackerElement && that._trackerElement.attr({
      points: info.points
    });
  },
  _measureText: function _measureText() {
    var that = this;
    var root;
    var text;
    var bBox;
    var sampleText;
    if (!that._textVerticalOffset) {
      root = that._createRoot().append(that._owner);
      sampleText = _getSampleText(that._translator, that._options.text);
      text = that._renderer.text(sampleText, 0, 0).attr({
        align: 'center'
      }).css((0, _utils.patchFontOptions)(that._options.text.font)).append(root);
      bBox = text.getBBox();
      root.remove();
      that._textVerticalOffset = -bBox.y - bBox.height / 2;
      that._textWidth = bBox.width;
      that._textHeight = bBox.height;
      that._textUnitWidth = that._textWidth / sampleText.length;
      that._textFullWidth = that._textWidth + 2 * that._options.horizontalOffset;
      that._textFullHeight = that._textHeight + 2 * that._options.verticalOffset;
    }
  },
  _render: function _render() {
    var that = this;
    that._measureText();
    that._cloud = that._cloud || that._renderer.path([], 'area').append(that._rootElement);
    that._text = that._text || that._renderer.text().append(that._rootElement);
    that._text.attr({
      align: 'center'
    }).css((0, _utils.patchFontOptions)(that._options.text.font));
  },
  _clear: function _clear() {
    delete this._cloud;
    delete this._text;
  },
  getTooltipParameters: function getTooltipParameters() {
    var position = this._getTextCloudOptions();
    return {
      x: position.x,
      y: position.y,
      value: this._currentValue,
      color: this._options.color
    };
  },
  _correctCloudType(type) {
    return type;
  }
});

// The following is from baseRangeBar.js
exports.BaseTextCloudMarker = BaseTextCloudMarker;
var BaseRangeBar = BaseIndicator.inherit({
  _measureText: function _measureText() {
    var that = this;
    var root;
    var text;
    var bBox;
    that._hasText = that._isTextVisible();
    if (that._hasText && !that._textVerticalOffset) {
      root = that._createRoot().append(that._owner);
      text = that._renderer.text(_getSampleText(that._translator, that._options.text), 0, 0).attr({
        'class': 'dxg-text',
        align: 'center'
      }).css((0, _utils.patchFontOptions)(that._options.text.font)).append(root);
      bBox = text.getBBox();
      root.remove();
      that._textVerticalOffset = -bBox.y - bBox.height / 2;
      that._textWidth = bBox.width;
      that._textHeight = bBox.height;
    }
  },
  _move: function _move() {
    var that = this;
    that._updateBarItemsPositions();
    if (that._hasText) {
      that._text.attr({
        text: _formatValue(that._actualValue, that._options.text)
      });
      that._updateTextPosition();
      that._updateLinePosition();
    }
  },
  _updateBarItems: function _updateBarItems() {
    var that = this;
    var options = that._options;
    var spaceColor;
    var translator = that._translator;
    that._setBarSides();
    that._startPosition = translator.translate(translator.getDomainStart());
    that._endPosition = translator.translate(translator.getDomainEnd());
    that._basePosition = translator.translate(options.baseValue);
    that._space = that._getSpace();
    var backgroundColor = options.backgroundColor || 'none';
    if (backgroundColor !== 'none' && that._space > 0) {
      spaceColor = options.containerBackgroundColor || 'none';
    } else {
      that._space = 0;
      spaceColor = 'none';
    }
    that._backItem1.attr({
      fill: backgroundColor
    });
    that._backItem2.attr({
      fill: backgroundColor
    });
    that._spaceItem1.attr({
      fill: spaceColor
    });
    that._spaceItem2.attr({
      fill: spaceColor
    });
  },
  _getSpace: function _getSpace() {
    return 0;
  },
  _updateTextItems: function _updateTextItems() {
    var that = this;
    if (that._hasText) {
      that._line = that._line || that._renderer.path([], 'line').attr({
        'class': 'dxg-main-bar',
        'stroke-linecap': 'square'
      }).append(that._rootElement);
      that._text = that._text || that._renderer.text('', 0, 0).attr({
        'class': 'dxg-text'
      }).append(that._rootElement);
      that._text.attr({
        align: that._getTextAlign()
      }).css(that._getFontOptions());
      that._setTextItemsSides();
    } else {
      if (that._line) {
        that._line.remove();
        delete that._line;
      }
      if (that._text) {
        that._text.remove();
        delete that._text;
      }
    }
  },
  _isTextVisible: function _isTextVisible() {
    return false;
  },
  _getTextAlign: function _getTextAlign() {
    return 'center';
  },
  _getFontOptions: function _getFontOptions() {
    var options = this._options;
    var font = options.text.font;
    if (!font || !font.color) {
      font = (0, _extend.extend)({}, font, {
        color: options.color
      });
    }
    return (0, _utils.patchFontOptions)(font);
  },
  _updateBarItemsPositions: function _updateBarItemsPositions() {
    var that = this;
    var positions = that._getPositions();
    that._backItem1.attr(that._buildItemSettings(positions.start, positions.back1));
    that._backItem2.attr(that._buildItemSettings(positions.back2, positions.end));
    that._spaceItem1.attr(that._buildItemSettings(positions.back1, positions.main1));
    that._spaceItem2.attr(that._buildItemSettings(positions.main2, positions.back2));
    that._mainItem.attr(that._buildItemSettings(positions.main1, positions.main2));
    that._trackerElement && that._trackerElement.attr(that._buildItemSettings(positions.main1, positions.main2));
  },
  _render: function _render() {
    var that = this;
    that._measureText();
    if (!that._backItem1) {
      that._backItem1 = that._createBarItem();
      that._backItem1.attr({
        'class': 'dxg-back-bar'
      });
    }
    if (!that._backItem2) {
      that._backItem2 = that._createBarItem();
      that._backItem2.attr({
        'class': 'dxg-back-bar'
      });
    }
    if (!that._spaceItem1) {
      that._spaceItem1 = that._createBarItem();
      that._spaceItem1.attr({
        'class': 'dxg-space-bar'
      });
    }
    if (!that._spaceItem2) {
      that._spaceItem2 = that._createBarItem();
      that._spaceItem2.attr({
        'class': 'dxg-space-bar'
      });
    }
    if (!that._mainItem) {
      that._mainItem = that._createBarItem();
      that._mainItem.attr({
        'class': 'dxg-main-bar'
      });
    }
    that._updateBarItems();
    that._updateTextItems();
  },
  _clear: function _clear() {
    var that = this;
    delete that._backItem1;
    delete that._backItem2;
    delete that._spaceItem1;
    delete that._spaceItem2;
    delete that._mainItem;
    delete that._hasText;
    delete that._line;
    delete that._text;
  },
  getTooltipParameters: function getTooltipParameters() {
    var position = this._getTooltipPosition();
    return {
      x: position.x,
      y: position.y,
      value: this._currentValue,
      color: this._options.color,
      offset: 0
    };
  }
});
exports.BaseRangeBar = BaseRangeBar;

/***/ }),

/***/ 84165:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _base_indicators = __webpack_require__(3446);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _Number = Number;
var _isArray = Array.isArray;
var _isFinite = isFinite;
var BaseRangeContainer = _base_indicators.BaseElement.inherit({
  _init: function _init() {
    this._root = this._renderer.g().attr({
      'class': 'dxg-range-container'
    }).linkOn(this._container, 'range-container');
  },
  _dispose: function _dispose() {
    this._root.linkOff();
  },
  clean: function clean() {
    this._root.linkRemove().clear();
    this._options = this.enabled = null;
    return this;
  },
  _getRanges: function _getRanges() {
    var that = this;
    var options = that._options;
    var translator = that._translator;
    var totalStart = translator.getDomain()[0];
    var totalEnd = translator.getDomain()[1];
    var totalDelta = totalEnd - totalStart;
    var isValidSegment = totalDelta >= 0 ? isValidSegmentAsc : isValidSegmentDesc;
    var subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDesc;
    var list = [];
    var ranges = [];
    var backgroundRanges = [{
      start: totalStart,
      end: totalEnd
    }];
    var backgroundColor = (0, _utils.extractColor)(options.backgroundColor) || 'none';
    var width = options.width || {};
    var startWidth = _Number(width > 0 ? width : width.start);
    var endWidth = _Number(width > 0 ? width : width.end);
    var deltaWidth = endWidth - startWidth;
    if (options.ranges !== undefined && !_isArray(options.ranges)) {
      return null;
    }
    if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {
      return null;
    }
    list = (_isArray(options.ranges) ? options.ranges : []).reduce(function (result, rangeOptions, i) {
      rangeOptions = rangeOptions || {};
      var start = translator.adjust(rangeOptions.startValue);
      var end = translator.adjust(rangeOptions.endValue);
      if (_isFinite(start) && _isFinite(end) && isValidSegment(start, end, rangeOptions)) {
        result.push({
          start: start,
          end: end,
          color: (0, _utils.extractColor)(rangeOptions.color),
          classIndex: i
        });
      }
      return result;
    }, []);
    var palette = that._themeManager.createPalette(options.palette, {
      type: 'indicatingSet',
      extensionMode: options.paletteExtensionMode,
      keepLastColorInEnd: true,
      count: list.length
    });
    (0, _iterator.each)(list, function (_, item) {
      var paletteColor = palette.getNextColor();
      item.color = (0, _type.isString)(item.color) && item.color || paletteColor || 'none';
      item.className = 'dxg-range dxg-range-' + item.classIndex;
      delete item.classIndex;
    });
    (0, _iterator.each)(list, function (_, item) {
      var i;
      var ii;
      var sub;
      var subs;
      var range;
      var newRanges = [];
      var newBackgroundRanges = [];
      for (i = 0, ii = ranges.length; i < ii; ++i) {
        range = ranges[i];
        subs = subtractSegment(range.start, range.end, item.start, item.end);
        (sub = subs[0]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
        (sub = subs[1]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);
      }
      newRanges.push(item);
      ranges = newRanges;
      for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {
        range = backgroundRanges[i];
        subs = subtractSegment(range.start, range.end, item.start, item.end);
        (sub = subs[0]) && newBackgroundRanges.push(sub);
        (sub = subs[1]) && newBackgroundRanges.push(sub);
      }
      backgroundRanges = newBackgroundRanges;
    });
    (0, _iterator.each)(backgroundRanges, function (_, range) {
      range.color = backgroundColor;
      range.className = 'dxg-range dxg-background-range';
      ranges.push(range);
    });
    (0, _iterator.each)(ranges, function (_, range) {
      range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;
      range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth;
    });
    return ranges;
  },
  render: function render(options) {
    var that = this;
    that._options = options;
    that._processOptions();
    that._ranges = that._getRanges();
    if (that._ranges) {
      that.enabled = true;
      that._root.linkAppend();
    }
    return that;
  },
  resize: function resize(layout) {
    var that = this;
    that._root.clear();
    if (that._isVisible(layout)) {
      (0, _iterator.each)(that._ranges, function (_, range) {
        that._createRange(range, layout).attr({
          fill: range.color,
          'class': range.className
        }).append(that._root);
      });
    }
    return that;
  },
  _processOptions: null,
  _isVisible: null,
  _createRange: null,
  // S170193
  getColorForValue: function getColorForValue(value) {
    var color = null;
    (0, _iterator.each)(this._ranges, function (_, range) {
      if (range.start <= value && value <= range.end || range.start >= value && value >= range.end) {
        color = range.color;
        return false;
      }
    });
    return color;
  }
});
function subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {
  var result;
  if (otherStart > segmentStart && otherEnd < segmentEnd) {
    result = [{
      start: segmentStart,
      end: otherStart
    }, {
      start: otherEnd,
      end: segmentEnd
    }];
  } else if (otherStart >= segmentEnd || otherEnd <= segmentStart) {
    result = [{
      start: segmentStart,
      end: segmentEnd
    }];
  } else if (otherStart <= segmentStart && otherEnd >= segmentEnd) {
    result = [];
  } else if (otherStart > segmentStart) {
    result = [{
      start: segmentStart,
      end: otherStart
    }];
  } else if (otherEnd < segmentEnd) {
    result = [{
      start: otherEnd,
      end: segmentEnd
    }];
  }
  return result;
}
function subtractSegmentDesc(segmentStart, segmentEnd, otherStart, otherEnd) {
  var result;
  if (otherStart < segmentStart && otherEnd > segmentEnd) {
    result = [{
      start: segmentStart,
      end: otherStart
    }, {
      start: otherEnd,
      end: segmentEnd
    }];
  } else if (otherStart <= segmentEnd || otherEnd >= segmentStart) {
    result = [{
      start: segmentStart,
      end: segmentEnd
    }];
  } else if (otherStart >= segmentStart && otherEnd <= segmentEnd) {
    result = [];
  } else if (otherStart < segmentStart) {
    result = [{
      start: segmentStart,
      end: otherStart
    }];
  } else if (otherEnd > segmentEnd) {
    result = [{
      start: otherEnd,
      end: segmentEnd
    }];
  }
  return result;
}
function areEqualValues(start, end, _ref) {
  var startValue = _ref.startValue,
    endValue = _ref.endValue;
  return endValue === startValue && startValue === start && end === start;
}
function isValidSegmentAsc(start, end, options) {
  return end - start > 0 || areEqualValues(start, end, options);
}
function isValidSegmentDesc(start, end, options) {
  return start - end > 0 || areEqualValues(start, end, options);
}
var _default = BaseRangeContainer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 31500:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _object = __webpack_require__(48013);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _base_gauge = __webpack_require__(18029);
var _common = __webpack_require__(88917);
var _utils = __webpack_require__(19157);
var _center_template = __webpack_require__(56672);
var circularIndicators = _interopRequireWildcard(__webpack_require__(16030));
var _circular_range_container = _interopRequireDefault(__webpack_require__(27172));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _isFinite = isFinite;
var _normalizeAngle = _utils.normalizeAngle;
var _getCosAndSin = _utils.getCosAndSin;
var _abs = Math.abs;
var _max = Math.max;
var _min = Math.min;
var _round = Math.round;
var _each = _iterator.each;
var PI = Math.PI;
function getSides(startAngle, endAngle) {
  var startCosSin = _getCosAndSin(startAngle);
  var endCosSin = _getCosAndSin(endAngle);
  var startCos = startCosSin.cos;
  var startSin = startCosSin.sin;
  var endCos = endCosSin.cos;
  var endSin = endCosSin.sin;
  return {
    left: startSin <= 0 && endSin >= 0 || startSin <= 0 && endSin <= 0 && startCos <= endCos || startSin >= 0 && endSin >= 0 && startCos >= endCos ? -1 : _min(startCos, endCos, 0),
    right: startSin >= 0 && endSin <= 0 || startSin >= 0 && endSin >= 0 && startCos >= endCos || startSin <= 0 && endSin <= 0 && startCos <= endCos ? 1 : _max(startCos, endCos, 0),
    up: startCos <= 0 && endCos >= 0 || startCos <= 0 && endCos <= 0 && startSin >= endSin || startCos >= 0 && endCos >= 0 && startSin <= endSin ? -1 : -_max(startSin, endSin, 0),
    down: startCos >= 0 && endCos <= 0 || startCos >= 0 && endCos >= 0 && startSin <= endSin || startCos <= 0 && endCos <= 0 && startSin >= endSin ? 1 : -_min(startSin, endSin, 0)
  };
}
var dxCircularGauge = _common.dxGauge.inherit({
  _rootClass: 'dxg-circular-gauge',
  _factoryMethods: {
    rangeContainer: 'createCircularRangeContainer',
    indicator: 'createCircularIndicator'
  },
  _gridSpacingFactor: 17,
  _scaleTypes: {
    type: 'polarAxes',
    drawingType: 'circular'
  },
  _getThemeManagerOptions() {
    var options = this.callBase.apply(this, arguments);
    options.subTheme = '_circular';
    return options;
  },
  _updateScaleTickIndent: function _updateScaleTickIndent(scaleOptions) {
    var indentFromTick = scaleOptions.label.indentFromTick;
    var length = scaleOptions.tick.visible ? scaleOptions.tick.length : 0;
    var textParams = this._scale.measureLabels((0, _extend.extend)({}, this._canvas));
    var scaleOrientation = scaleOptions.orientation;
    var tickCorrection = length;
    var indentFromAxis = indentFromTick;
    if (indentFromTick >= 0) {
      if (scaleOrientation === 'outside') {
        indentFromAxis += tickCorrection;
      } else if (scaleOrientation === 'center') {
        indentFromAxis += tickCorrection / 2;
      }
    } else {
      var labelCorrection = _max(textParams.width, textParams.height);
      indentFromAxis -= labelCorrection;
      if (scaleOrientation === 'inside') {
        indentFromAxis -= tickCorrection;
      } else if (scaleOrientation === 'center') {
        indentFromAxis -= tickCorrection / 2;
      }
    }
    scaleOptions.label.indentFromAxis = indentFromAxis;
    this._scale.updateOptions(scaleOptions);
  },
  _setupCodomain: function _setupCodomain() {
    var that = this;
    var geometry = that.option('geometry') || {};
    var startAngle = geometry.startAngle;
    var endAngle = geometry.endAngle;
    var sides;
    startAngle = _isFinite(startAngle) ? _normalizeAngle(startAngle) : 225;
    endAngle = _isFinite(endAngle) ? _normalizeAngle(endAngle) : -45;
    if (_abs(startAngle - endAngle) < 1) {
      endAngle -= 360;
      sides = {
        left: -1,
        up: -1,
        right: 1,
        down: 1
      };
    } else {
      startAngle < endAngle && (endAngle -= 360);
      sides = getSides(startAngle, endAngle);
    }
    that._area = {
      x: 0,
      y: 0,
      radius: 100,
      startCoord: startAngle,
      endCoord: endAngle,
      sides: sides
    };
    that._translator.setCodomain(startAngle, endAngle);
  },
  _getCenter: function _getCenter() {
    return this._getElementLayout();
  },
  _shiftScale: function _shiftScale(layout) {
    var scale = this._scale;
    var canvas = scale.getCanvas();
    canvas.width = canvas.height = layout.radius * 2;
    scale.draw(canvas);
    var centerCoords = scale.getCenter();
    scale.shift({
      right: layout.x - centerCoords.x,
      bottom: layout.y - centerCoords.y
    });
  },
  _getScaleLayoutValue: function _getScaleLayoutValue() {
    return this._area.radius;
  },
  _getTicksOrientation: function _getTicksOrientation(scaleOptions) {
    return scaleOptions.orientation;
  },
  _getTicksCoefficients: function _getTicksCoefficients(options) {
    var coefs = {
      inner: 0,
      outer: 1
    };
    if (options.orientation === 'inside') {
      coefs.inner = 1;
      coefs.outer = 0;
    } else if (options.orientation === 'center') {
      coefs.inner = coefs.outer = 0.5;
    }
    return coefs;
  },
  _correctScaleIndents: function _correctScaleIndents(result, indentFromTick, textParams) {
    if (indentFromTick >= 0) {
      result.horizontalOffset = indentFromTick + textParams.width;
      result.verticalOffset = indentFromTick + textParams.height;
    } else {
      result.horizontalOffset = result.verticalOffset = 0;
      result.min -= -indentFromTick + _max(textParams.width, textParams.height);
    }
    result.inverseHorizontalOffset = textParams.width / 2;
    result.inverseVerticalOffset = textParams.height / 2;
  },
  _measureMainElements: function _measureMainElements(elements, scaleMeasurement) {
    var that = this;
    var radius = that._area.radius;
    var maxRadius = 0;
    var minRadius = Infinity;
    var maxHorizontalOffset = 0;
    var maxVerticalOffset = 0;
    var maxInverseHorizontalOffset = 0;
    var maxInverseVerticalOffset = 0;
    var scale = that._scale;
    _each(elements.concat(scale), function (_, element) {
      var bounds = element.measure ? element.measure({
        radius: radius - element.getOffset()
      }) : scaleMeasurement;
      bounds.min > 0 && (minRadius = _min(minRadius, bounds.min));
      bounds.max > 0 && (maxRadius = _max(maxRadius, bounds.max));
      bounds.horizontalOffset > 0 && (maxHorizontalOffset = _max(maxHorizontalOffset, bounds.max + bounds.horizontalOffset));
      bounds.verticalOffset > 0 && (maxVerticalOffset = _max(maxVerticalOffset, bounds.max + bounds.verticalOffset));
      bounds.inverseHorizontalOffset > 0 && (maxInverseHorizontalOffset = _max(maxInverseHorizontalOffset, bounds.inverseHorizontalOffset));
      bounds.inverseVerticalOffset > 0 && (maxInverseVerticalOffset = _max(maxInverseVerticalOffset, bounds.inverseVerticalOffset));
    });
    maxHorizontalOffset = _max(maxHorizontalOffset - maxRadius, 0);
    maxVerticalOffset = _max(maxVerticalOffset - maxRadius, 0);
    return {
      minRadius: minRadius,
      maxRadius: maxRadius,
      horizontalMargin: maxHorizontalOffset,
      verticalMargin: maxVerticalOffset,
      inverseHorizontalMargin: maxInverseHorizontalOffset,
      inverseVerticalMargin: maxInverseVerticalOffset
    };
  },
  _applyMainLayout: function _applyMainLayout(elements, scaleMeasurement) {
    var measurements = this._measureMainElements(elements, scaleMeasurement);
    var area = this._area;
    var sides = area.sides;
    var margins = {
      left: (sides.left < -0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
      right: (sides.right > 0.1 ? measurements.horizontalMargin : measurements.inverseHorizontalMargin) || 0,
      top: (sides.up < -0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0,
      bottom: (sides.down > 0.1 ? measurements.verticalMargin : measurements.inverseVerticalMargin) || 0
    };
    var rect = selectRectByAspectRatio(this._innerRect, (sides.down - sides.up) / (sides.right - sides.left), margins);
    var radius = _min(getWidth(rect) / (sides.right - sides.left), getHeight(rect) / (sides.down - sides.up));
    radius = radius - measurements.maxRadius + area.radius;
    var x = rect.left - getWidth(rect) * sides.left / (sides.right - sides.left);
    var y = rect.top - getHeight(rect) * sides.up / (sides.down - sides.up);
    area.x = _round(x);
    area.y = _round(y);
    area.radius = radius;
    rect.left -= margins.left;
    rect.right += margins.right;
    rect.top -= margins.top;
    rect.bottom += margins.bottom;
    this._innerRect = rect;
  },
  _getElementLayout: function _getElementLayout() {
    var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return {
      x: this._area.x,
      y: this._area.y,
      radius: _round(this._area.radius - offset)
    };
  },
  _getApproximateScreenRange: function _getApproximateScreenRange() {
    var that = this;
    var area = that._area;
    var r = _min(that._canvas.width / (area.sides.right - area.sides.left), that._canvas.height / (area.sides.down - area.sides.up));
    r > area.totalRadius && (r = area.totalRadius);
    r = 0.8 * r;
    return -that._translator.getCodomainRange() * r * PI / 180;
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 300,
      height: 300
    };
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory)
});
function getWidth(rect) {
  return rect.right - rect.left;
}
function getHeight(rect) {
  return rect.bottom - rect.top;
}
function selectRectByAspectRatio(srcRect, aspectRatio, margins) {
  var rect = (0, _extend.extend)({}, srcRect);
  var selfAspectRatio;
  var width = 0;
  var height = 0;
  margins = margins || {};
  if (aspectRatio > 0) {
    rect.left += margins.left || 0;
    rect.right -= margins.right || 0;
    rect.top += margins.top || 0;
    rect.bottom -= margins.bottom || 0;
    if (getWidth(rect) > 0 && getHeight(rect) > 0) {
      selfAspectRatio = getHeight(rect) / getWidth(rect);
      if (selfAspectRatio > 1) {
        aspectRatio < selfAspectRatio ? width = getWidth(rect) : height = getHeight(rect);
      } else {
        aspectRatio > selfAspectRatio ? height = getHeight(rect) : width = getWidth(rect);
      }
      width > 0 || (width = height / aspectRatio);
      height > 0 || (height = width * aspectRatio);
      width = (getWidth(rect) - width) / 2;
      height = (getHeight(rect) - height) / 2;
      rect.left += width;
      rect.right -= width;
      rect.top += height;
      rect.bottom -= height;
    } else {
      rect.left = rect.right = (rect.left + rect.right) / 2;
      rect.top = rect.bottom = (rect.top + rect.bottom) / 2;
    }
  }
  return rect;
}
var indicators = dxCircularGauge.prototype._factory.indicators = {};
dxCircularGauge.prototype._factory.createIndicator = (0, _common.createIndicatorCreator)(indicators);

/* eslint-disable import/namespace */
indicators._default = circularIndicators._default;
indicators['rectangleneedle'] = circularIndicators['rectangleneedle'];
indicators['triangleneedle'] = circularIndicators['triangleneedle'];
indicators['twocolorneedle'] = circularIndicators['twocolorneedle'];
indicators['trianglemarker'] = circularIndicators['trianglemarker'];
indicators['textcloud'] = circularIndicators['textcloud'];
indicators['rangebar'] = circularIndicators['rangebar'];
/* eslint-enable import/namespace */

dxCircularGauge.prototype._factory.RangeContainer = _circular_range_container.default;
(0, _component_registrator.default)('dxCircularGauge', dxCircularGauge);
dxCircularGauge.addPlugin(_center_template.plugins.gauge);
var _default = dxCircularGauge;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 16030:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.twocolorneedle = exports.triangleneedle = exports.trianglemarker = exports.textcloud = exports.rectangleneedle = exports.rangebar = exports._default = void 0;
var _base_indicators = __webpack_require__(3446);
var _utils = __webpack_require__(19157);
var _Number = Number;
var _getCosAndSin = _utils.getCosAndSin;
var _convertAngleToRendererSpace = _utils.convertAngleToRendererSpace;
function correctRadius(layout, size) {
  if (layout && layout.radius - size <= 0) {
    layout.radius = size + 1;
  }
  return layout;
}
var SimpleIndicator = _base_indicators.BaseIndicator.inherit({
  _move: function _move() {
    var that = this;
    var options = that._options;
    var angle = _convertAngleToRendererSpace(that._actualPosition);
    that._rootElement.rotate(angle, options.x, options.y);
    that._trackerElement && that._trackerElement.rotate(angle, options.x, options.y);
  },
  _isEnabled: function _isEnabled() {
    return this._options.width > 0;
  },
  _isVisible: function _isVisible(layout) {
    return layout.radius - _Number(this._options.indentFromCenter) > 0;
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var options = this._options;
    var radius = this._getRadius();
    var indentFromCenter = this._getIndentFromCenter();
    var x = options.x;
    var y = options.y - (radius + indentFromCenter) / 2;
    var width = options.width / 2;
    var length = (radius - indentFromCenter) / 2;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    return {
      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
    };
  },
  _render: function _render() {
    var that = this;
    that._renderPointer();
  },
  _clearPointer: function _clearPointer() {
    delete this._element;
  },
  _clear: function _clear() {
    this._clearPointer();
  },
  _getIndentFromCenter: function _getIndentFromCenter(radius) {
    return Number(this._options.indentFromCenter) || 0;
  },
  _getRadius: function _getRadius() {
    return 0;
  },
  measure: function measure(layout) {
    var result = {
      max: layout.radius
    };
    if (this._options.indentFromCenter < 0) {
      result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter);
    }
    return result;
  },
  getTooltipParameters: function getTooltipParameters() {
    var options = this._options;
    var cosSin = _getCosAndSin(this._actualPosition);
    var r = (this._getRadius() + this._getIndentFromCenter()) / 2;
    return {
      x: options.x + cosSin.cos * r,
      y: options.y - cosSin.sin * r,
      value: this._currentValue,
      color: options.color,
      offset: options.width / 2
    };
  }
});
var NeedleIndicator = SimpleIndicator.inherit({
  _isVisible: function _isVisible(layout) {
    var indentFromCenter = this._adjustOffset(Number(this._options.indentFromCenter), layout.radius);
    var offset = this._adjustOffset(Number(this._options.offset), layout.radius);
    return layout.radius - indentFromCenter - offset > 0;
  },
  getOffset: function getOffset() {
    return 0;
  },
  _adjustOffset: function _adjustOffset(value, radius) {
    var minRadius = Number(this._options.beginAdaptingAtRadius);
    var diff = radius / minRadius;
    if (diff < 1) {
      value = Math.floor(value * diff);
    }
    return value || 0;
  },
  _getIndentFromCenter: function _getIndentFromCenter(radius) {
    return this._adjustOffset(Number(this._options.indentFromCenter), this._options.radius);
  },
  _getRadius: function _getRadius() {
    var options = this._options;
    return options.radius - this._adjustOffset(Number(options.offset), options.radius);
  },
  _renderSpindle: function _renderSpindle() {
    var that = this;
    var options = that._options;
    var radius = options.radius;
    var spindleSize = this._adjustOffset(_Number(options.spindleSize) / 2, radius) * 2;
    var gapSize = this._adjustOffset(_Number(options.spindleGapSize) / 2, radius) * 2 || 0;
    if (gapSize > 0) {
      gapSize = gapSize <= spindleSize ? gapSize : spindleSize;
    }
    if (spindleSize > 0) {
      that._spindleOuter = that._spindleOuter || that._renderer.circle().append(that._rootElement);
      that._spindleInner = that._spindleInner || that._renderer.circle().append(that._rootElement);
      that._spindleOuter.attr({
        'class': 'dxg-spindle-border',
        cx: options.x,
        cy: options.y,
        r: spindleSize / 2
      });
      that._spindleInner.attr({
        'class': 'dxg-spindle-hole',
        cx: options.x,
        cy: options.y,
        r: gapSize / 2,
        fill: options.containerBackgroundColor
      });
    }
  },
  _render: function _render() {
    var that = this;
    that.callBase();
    that._renderSpindle();
  },
  _clear: function _clear() {
    this.callBase();
    delete this._spindleOuter;
    delete this._spindleInner;
  }
});
var rectangleNeedle = NeedleIndicator.inherit({
  _renderPointer: function _renderPointer() {
    var that = this;
    var options = that._options;
    var y2 = options.y - this._getRadius();
    var y1 = options.y - this._getIndentFromCenter();
    var x1 = options.x - options.width / 2;
    var x2 = x1 + _Number(options.width);
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
  }
});
exports.rectangleneedle = exports._default = rectangleNeedle;
var triangleNeedle = NeedleIndicator.inherit({
  _renderPointer: function _renderPointer() {
    var that = this;
    var options = that._options;
    var y2 = options.y - this._getRadius();
    var y1 = options.y - this._getIndentFromCenter();
    var x1 = options.x - options.width / 2;
    var x2 = options.x + options.width / 2;
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x1, y1, options.x, y2, x2, y1]
    });
  }
});
exports.triangleneedle = triangleNeedle;
var twoColorNeedle = NeedleIndicator.inherit({
  _renderPointer: function _renderPointer() {
    var that = this;
    var options = that._options;
    var x1 = options.x - options.width / 2;
    var x2 = options.x + options.width / 2;
    var y4 = options.y - this._getRadius();
    var y1 = options.y - this._getIndentFromCenter();
    var fraction = _Number(options.secondFraction) || 0;
    var y2;
    var y3;
    //  B253863
    if (fraction >= 1) {
      y2 = y3 = y1;
    } else if (fraction <= 0) {
      y2 = y3 = y4;
    } else {
      y3 = y4 + (y1 - y4) * fraction;
      y2 = y3 + _Number(options.space);
    }
    that._firstElement = that._firstElement || that._renderer.path([], 'area').append(that._rootElement);
    that._spaceElement = that._spaceElement || that._renderer.path([], 'area').append(that._rootElement);
    that._secondElement = that._secondElement || that._renderer.path([], 'area').append(that._rootElement);
    that._firstElement.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
    that._spaceElement.attr({
      points: [x1, y2, x1, y3, x2, y3, x2, y2],
      'class': 'dxg-hole',
      fill: options.containerBackgroundColor
    });
    that._secondElement.attr({
      points: [x1, y3, x1, y4, x2, y4, x2, y3],
      'class': 'dxg-part',
      fill: options.secondColor
    });
  },
  _clearPointer: function _clearPointer() {
    delete this._firstElement;
    delete this._secondElement;
    delete this._spaceElement;
  }
});

// The following is from circularMarker.js
exports.twocolorneedle = twoColorNeedle;
var triangleMarker = SimpleIndicator.inherit({
  _isEnabled: function _isEnabled() {
    return this._options.length > 0 && this._options.width > 0;
  },
  _isVisible(layout) {
    return true;
  },
  resize(layout) {
    return this.callBase(correctRadius(layout, 0));
  },
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x = options.x;
    var y1 = options.y - options.radius;
    var dx = options.width / 2 || 0;
    var y2 = y1 - _Number(options.length);
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    var settings = {
      points: [x, y1, x - dx, y2, x + dx, y2],
      stroke: 'none',
      'stroke-width': 0,
      'stroke-linecap': 'square'
    };
    if (options.space > 0) {
      settings['stroke-width'] = Math.min(options.space, options.width / 4) || 0;
      settings.stroke = settings['stroke-width'] > 0 ? options.containerBackgroundColor || 'none' : 'none';
    }
    that._element.attr(settings).sharp();
  },
  _clear: function _clear() {
    delete this._element;
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var options = this._options;
    var x = options.x;
    var y = options.y - options.radius - options.length / 2;
    var width = options.width / 2;
    var length = options.length / 2;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    return {
      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]
    };
  },
  measure: function measure(layout) {
    return {
      min: layout.radius,
      max: layout.radius + _Number(this._options.length)
    };
  },
  getTooltipParameters: function getTooltipParameters() {
    var options = this._options;
    var cosSin = _getCosAndSin(this._actualPosition);
    var r = options.radius + options.length / 2;
    var parameters = this.callBase();
    parameters.x = options.x + cosSin.cos * r;
    parameters.y = options.y - cosSin.sin * r;
    parameters.offset = options.length / 2;
    return parameters;
  }
});
exports.trianglemarker = triangleMarker;
var textCloud = _base_indicators.BaseTextCloudMarker.inherit({
  _isEnabled: function _isEnabled() {
    return true;
  },
  _isVisible(layout) {
    return true;
  },
  resize(layout) {
    return this.callBase(correctRadius(layout, 0));
  },
  _getTextCloudOptions: function _getTextCloudOptions() {
    var that = this;
    var cosSin = _getCosAndSin(that._actualPosition);
    var nAngle = (0, _utils.normalizeAngle)(that._actualPosition);
    return {
      x: that._options.x + cosSin.cos * that._options.radius,
      y: that._options.y - cosSin.sin * that._options.radius,
      type: nAngle > 270 ? 'left-top' : nAngle > 180 ? 'top-right' : nAngle > 90 ? 'right-bottom' : 'bottom-left'
    };
  },
  measure: function measure(layout) {
    var that = this;
    var arrowLength = _Number(that._options.arrowLength) || 0;
    that._measureText();
    var verticalOffset = that._textFullHeight + arrowLength;
    var horizontalOffset = that._textFullWidth + arrowLength;
    return {
      min: layout.radius,
      max: layout.radius,
      horizontalOffset: horizontalOffset,
      verticalOffset: verticalOffset,
      inverseHorizontalOffset: horizontalOffset,
      inverseVerticalOffset: verticalOffset
    };
  }
});

// The following is from circularRangeBar.js
exports.textcloud = textCloud;
var rangeBar = _base_indicators.BaseRangeBar.inherit({
  _isEnabled: function _isEnabled() {
    return this._options.size > 0;
  },
  _isVisible(layout) {
    return true;
  },
  resize(layout) {
    return this.callBase(correctRadius(layout, _Number(this._options.size)));
  },
  _createBarItem: function _createBarItem() {
    return this._renderer.arc().attr({
      'stroke-linejoin': 'round'
    }).append(this._rootElement);
  },
  _createTracker: function _createTracker() {
    return this._renderer.arc().attr({
      'stroke-linejoin': 'round'
    });
  },
  _setBarSides: function _setBarSides() {
    var that = this;
    that._maxSide = that._options.radius;
    that._minSide = that._maxSide - _Number(that._options.size);
  },
  _getSpace: function _getSpace() {
    var options = this._options;
    return options.space > 0 ? options.space * 180 / options.radius / Math.PI : 0;
  },
  _isTextVisible: function _isTextVisible() {
    var options = this._options.text || {};
    return options.indent > 0;
  },
  _setTextItemsSides: function _setTextItemsSides() {
    var that = this;
    var options = that._options;
    var indent = _Number(options.text.indent);
    that._lineFrom = options.y - options.radius;
    that._lineTo = that._lineFrom - indent;
    that._textRadius = options.radius + indent;
  },
  _getPositions: function _getPositions() {
    var that = this;
    var basePosition = that._basePosition;
    var actualPosition = that._actualPosition;
    var mainPosition1;
    var mainPosition2;
    if (basePosition >= actualPosition) {
      mainPosition1 = basePosition;
      mainPosition2 = actualPosition;
    } else {
      mainPosition1 = actualPosition;
      mainPosition2 = basePosition;
    }
    return {
      start: that._startPosition,
      end: that._endPosition,
      main1: mainPosition1,
      main2: mainPosition2,
      back1: Math.min(mainPosition1 + that._space, that._startPosition),
      back2: Math.max(mainPosition2 - that._space, that._endPosition)
    };
  },
  _buildItemSettings: function _buildItemSettings(from, to) {
    var that = this;
    return {
      x: that._options.x,
      y: that._options.y,
      innerRadius: that._minSide,
      outerRadius: that._maxSide,
      startAngle: to,
      endAngle: from
    };
  },
  _updateTextPosition: function _updateTextPosition() {
    var that = this;
    var cosSin = _getCosAndSin(that._actualPosition);
    var x = that._options.x + that._textRadius * cosSin.cos;
    var y = that._options.y - that._textRadius * cosSin.sin;
    x += cosSin.cos * that._textWidth * 0.6;
    y -= cosSin.sin * that._textHeight * 0.6;
    that._text.attr({
      x: x,
      y: y + that._textVerticalOffset
    });
  },
  _updateLinePosition: function _updateLinePosition() {
    var that = this;
    var x = that._options.x;
    var x1;
    var x2;
    if (that._basePosition > that._actualPosition) {
      x1 = x - 2;
      x2 = x;
    } else if (that._basePosition < that._actualPosition) {
      x1 = x;
      x2 = x + 2;
    } else {
      x1 = x - 1;
      x2 = x + 1;
    }
    that._line.attr({
      points: [x1, that._lineFrom, x1, that._lineTo, x2, that._lineTo, x2, that._lineFrom]
    }).rotate(_convertAngleToRendererSpace(that._actualPosition), x, that._options.y).sharp();
  },
  _getTooltipPosition: function _getTooltipPosition() {
    var that = this;
    var cosSin = _getCosAndSin((that._basePosition + that._actualPosition) / 2);
    var r = (that._minSide + that._maxSide) / 2;
    return {
      x: that._options.x + cosSin.cos * r,
      y: that._options.y - cosSin.sin * r
    };
  },
  measure: function measure(layout) {
    var that = this;
    var result = {
      min: layout.radius - _Number(that._options.size),
      max: layout.radius
    };
    that._measureText();
    if (that._hasText) {
      result.max += _Number(that._options.text.indent);
      result.horizontalOffset = that._textWidth;
      result.verticalOffset = that._textHeight;
    }
    return result;
  }
});

/* eslint-disable spellcheck/spell-checker */
exports.rangebar = rangeBar;

/***/ }),

/***/ 27172:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _base_range_container = _interopRequireDefault(__webpack_require__(84165));
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _Number = Number;
var _max = Math.max;
var CircularRangeContainer = _base_range_container.default.inherit({
  _processOptions: function _processOptions() {
    var that = this;
    that._inner = that._outer = 0;
    switch ((0, _utils.normalizeEnum)(that._options.orientation)) {
      case 'inside':
        that._inner = 1;
        break;
      case 'center':
        that._inner = that._outer = 0.5;
        break;
      default:
        that._outer = 1;
        break;
    }
  },
  _isVisible: function _isVisible(layout) {
    var width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    return layout.radius - this._inner * width > 0;
  },
  _createRange: function _createRange(range, layout) {
    var that = this;
    var width = (range.startWidth + range.endWidth) / 2;
    return that._renderer.arc(layout.x, layout.y, layout.radius - that._inner * width, layout.radius + that._outer * width, that._translator.translate(range.end), that._translator.translate(range.start)).attr({
      'stroke-linejoin': 'round'
    });
  },
  measure: function measure(layout) {
    var width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    return {
      min: layout.radius - this._inner * width,
      max: layout.radius + this._outer * width
    };
  }
});
var _default = CircularRangeContainer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 88917:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createIndicatorCreator = createIndicatorCreator;
exports.dxGauge = void 0;
var _base_gauge = __webpack_require__(18029);
var _type = __webpack_require__(35922);
var _extend2 = __webpack_require__(13306);
var _base_axis = __webpack_require__(41278);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
var _isArray = Array.isArray;
var _isFinite = isFinite;
var _Number = Number;
var _min = Math.min;
var _max = Math.max;
var _extend = _extend2.extend;
var SHIFT_ANGLE = 90;
var OPTION_VALUE = 'value';
var OPTION_SUBVALUES = 'subvalues';
var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 5;
var DEFAULT_NUMBER_MULTIPLIERS = [1, 2, 5];
function processValue(value, fallbackValue) {
  if (value === null) {
    return value;
  }
  return _isFinite(value) ? _Number(value) : fallbackValue;
}
function parseArrayOfNumbers(arg) {
  return _isArray(arg) ? arg : (0, _type.isNumeric)(arg) ? [arg] : null;
}
var dxGauge = _base_gauge.BaseGauge.inherit({
  _initCore: function _initCore() {
    var that = this;
    var renderer = that._renderer;
    that._setupValue(that.option(OPTION_VALUE));
    that.__subvalues = parseArrayOfNumbers(that.option(OPTION_SUBVALUES));
    that._setupSubvalues(that.__subvalues);
    selectMode(that);
    that.callBase.apply(that, arguments);
    that._rangeContainer = new that._factory.RangeContainer({
      renderer: renderer,
      container: renderer.root,
      translator: that._translator,
      themeManager: that._themeManager
    });
    that._initScale();
    that._subvalueIndicatorContainer = that._renderer.g().attr({
      class: 'dxg-subvalue-indicators'
    }).linkOn(that._renderer.root, 'valueIndicator').enableLinks();
  },
  _fontFields: ['scale.label.font', 'valueIndicators.rangebar.text.font', 'valueIndicators.textcloud.text.font', 'indicator.text.font'],
  _initScale: function _initScale() {
    var that = this;
    that._scaleGroup = that._renderer.g().attr({
      'class': 'dxg-scale'
    }).linkOn(that._renderer.root, 'scale');
    that._labelsAxesGroup = that._renderer.g().attr({
      'class': 'dxg-scale-elements'
    }).linkOn(that._renderer.root, 'scale-elements');
    that._scale = new _base_axis.Axis({
      incidentOccurred: that._incidentOccurred,
      renderer: that._renderer,
      axesContainerGroup: that._scaleGroup,
      labelsAxesGroup: that._labelsAxesGroup,
      axisType: that._scaleTypes.type,
      drawingType: that._scaleTypes.drawingType,
      widgetClass: 'dxg',
      getTemplate() {}
    });
  },
  _disposeCore: function _disposeCore() {
    var that = this;
    that.callBase.apply(that, arguments);
    that._scale.dispose();
    that._scaleGroup.linkOff();
    that._labelsAxesGroup.linkOff();
    that._rangeContainer.dispose();
    that._disposeValueIndicators();
    that._subvalueIndicatorContainer.linkOff();
    that._scale = that._scaleGroup = that._labelsAxesGroup = that._rangeContainer = null;
  },
  _disposeValueIndicators: function _disposeValueIndicators() {
    var that = this;
    that._valueIndicator && that._valueIndicator.dispose();
    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.dispose();
    that._valueIndicator = that._subvalueIndicatorsSet = null;
  },
  _setupDomainCore: function _setupDomainCore() {
    var that = this;
    var scaleOption = that.option('scale') || {};
    var startValue = that.option('startValue');
    var endValue = that.option('endValue');
    startValue = (0, _type.isNumeric)(startValue) ? _Number(startValue) : (0, _type.isNumeric)(scaleOption.startValue) ? _Number(scaleOption.startValue) : 0;
    endValue = (0, _type.isNumeric)(endValue) ? _Number(endValue) : (0, _type.isNumeric)(scaleOption.endValue) ? _Number(scaleOption.endValue) : 100;
    that._baseValue = startValue < endValue ? startValue : endValue;
    that._translator.setDomain(startValue, endValue);
  },
  _cleanContent: function _cleanContent() {
    var that = this;
    that._rangeContainer.clean();
    that._cleanValueIndicators();
  },
  _measureScale: function _measureScale(scaleOptions) {
    var that = this;
    var majorTick = scaleOptions.tick;
    var majorTickEnabled = majorTick.visible && majorTick.length > 0 && majorTick.width > 0;
    var minorTick = scaleOptions.minorTick;
    var minorTickEnabled = minorTick.visible && minorTick.length > 0 && minorTick.width > 0;
    var label = scaleOptions.label;
    var indentFromTick = Number(label.indentFromTick);
    if (!majorTickEnabled && !minorTickEnabled && !label.visible) {
      return {};
    }
    var textParams = that._scale.measureLabels((0, _extend2.extend)({}, that._canvas));
    var layoutValue = that._getScaleLayoutValue();
    var result = {
      min: layoutValue,
      max: layoutValue
    };
    var coefs = that._getTicksCoefficients(scaleOptions);
    var innerCoef = coefs.inner;
    var outerCoef = coefs.outer;
    if (majorTickEnabled) {
      result.min = _min(result.min, layoutValue - innerCoef * majorTick.length);
      result.max = _max(result.max, layoutValue + outerCoef * majorTick.length);
    }
    if (minorTickEnabled) {
      result.min = _min(result.min, layoutValue - innerCoef * minorTick.length);
      result.max = _max(result.max, layoutValue + outerCoef * minorTick.length);
    }
    label.visible && that._correctScaleIndents(result, indentFromTick, textParams);
    return result;
  },
  _renderContent: function _renderContent() {
    var that = this;
    var scaleOptions = that._prepareScaleSettings();
    that._rangeContainer.render(_extend(that._getOption('rangeContainer'), {
      vertical: that._area.vertical
    }));
    that._renderScale(scaleOptions);
    that._subvalueIndicatorContainer.linkAppend();
    var elements = (0, _utils.map)([that._rangeContainer].concat(that._prepareValueIndicators()), function (element) {
      return element && element.enabled ? element : null;
    });
    that._applyMainLayout(elements, that._measureScale(scaleOptions));
    elements.forEach(function (element) {
      return element.resize(that._getElementLayout(element.getOffset()));
    });
    that._shiftScale(that._getElementLayout(0), scaleOptions);
    that._beginValueChanging();
    that._updateActiveElements();
    that._endValueChanging();
  },
  _prepareScaleSettings: function _prepareScaleSettings() {
    var that = this;
    var userOptions = that.option('scale');
    var scaleOptions = (0, _extend2.extend)(true, {}, that._themeManager.theme('scale'), userOptions);
    scaleOptions.label.indentFromAxis = 0;
    scaleOptions.isHorizontal = !that._area.vertical;
    scaleOptions.forceUserTickInterval |= (0, _type.isDefined)(userOptions) && (0, _type.isDefined)(userOptions.tickInterval) && !(0, _type.isDefined)(userOptions.scaleDivisionFactor);
    scaleOptions.axisDivisionFactor = scaleOptions.scaleDivisionFactor || that._gridSpacingFactor;
    scaleOptions.minorAxisDivisionFactor = scaleOptions.minorScaleDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
    scaleOptions.numberMultipliers = DEFAULT_NUMBER_MULTIPLIERS;
    scaleOptions.tickOrientation = that._getTicksOrientation(scaleOptions);
    if (scaleOptions.label.useRangeColors) {
      scaleOptions.label.customizeColor = function () {
        return that._rangeContainer.getColorForValue(this.value);
      };
    }
    return scaleOptions;
  },
  _renderScale: function _renderScale(scaleOptions) {
    var that = this;
    var bounds = that._translator.getDomain();
    var startValue = bounds[0];
    var endValue = bounds[1];
    var angles = that._translator.getCodomain();
    var invert = !!(startValue > endValue ^ scaleOptions.inverted);
    var min = _min(startValue, endValue);
    var max = _max(startValue, endValue);
    scaleOptions.min = min;
    scaleOptions.max = max;
    scaleOptions.startAngle = SHIFT_ANGLE - angles[0];
    scaleOptions.endAngle = SHIFT_ANGLE - angles[1];
    scaleOptions.skipViewportExtending = true;
    scaleOptions.inverted = invert;
    that._scale.updateOptions(scaleOptions);
    that._scale.setBusinessRange({
      axisType: 'continuous',
      dataType: 'numeric',
      min: min,
      max: max,
      invert: invert
    });
    that._updateScaleTickIndent(scaleOptions);
    that._scaleGroup.linkAppend();
    that._labelsAxesGroup.linkAppend();
    that._scale.draw((0, _extend2.extend)({}, that._canvas));
  },
  _updateIndicatorSettings: function _updateIndicatorSettings(settings) {
    var that = this;
    settings.currentValue = settings.baseValue = _isFinite(that._translator.translate(settings.baseValue)) ? _Number(settings.baseValue) : that._baseValue;
    settings.vertical = that._area.vertical;
    if (settings.text && !settings.text.format) {
      settings.text.format = that._defaultFormatOptions;
    }
  },
  _prepareIndicatorSettings: function _prepareIndicatorSettings(options, defaultTypeField) {
    var that = this;
    var theme = that._themeManager.theme('valueIndicators');
    var type = (0, _utils.normalizeEnum)(options.type || that._themeManager.theme(defaultTypeField));
    var settings = _extend(true, {}, theme._default, theme[type], options);
    settings.type = type;
    settings.animation = that._animationSettings;
    settings.containerBackgroundColor = that._containerBackgroundColor;
    that._updateIndicatorSettings(settings);
    return settings;
  },
  _cleanValueIndicators: function _cleanValueIndicators() {
    this._valueIndicator && this._valueIndicator.clean();
    this._subvalueIndicatorsSet && this._subvalueIndicatorsSet.clean();
  },
  _prepareValueIndicators: function _prepareValueIndicators() {
    var that = this;
    that._prepareValueIndicator();
    that.__subvalues !== null && that._prepareSubvalueIndicators();
    return [that._valueIndicator, that._subvalueIndicatorsSet];
  },
  _updateActiveElements: function _updateActiveElements() {
    this._updateValueIndicator();
    this._updateSubvalueIndicators();
  },
  _prepareValueIndicator: function _prepareValueIndicator() {
    var that = this;
    var target = that._valueIndicator;
    var settings = that._prepareIndicatorSettings(that.option('valueIndicator') || {}, 'valueIndicatorType');
    if (target && target.type !== settings.type) {
      target.dispose();
      target = null;
    }
    if (!target) {
      target = that._valueIndicator = that._createIndicator(settings.type, that._renderer.root, 'dxg-value-indicator', 'value-indicator');
    }
    target.render(settings);
  },
  _createSubvalueIndicatorsSet: function _createSubvalueIndicatorsSet() {
    var that = this;
    var root = that._subvalueIndicatorContainer;
    return new ValueIndicatorsSet({
      createIndicator: function createIndicator(type, i) {
        return that._createIndicator(type, root, 'dxg-subvalue-indicator', 'subvalue-indicator', i);
      },
      createPalette: function createPalette(palette) {
        return that._themeManager.createPalette(palette);
      }
    });
  },
  _prepareSubvalueIndicators: function _prepareSubvalueIndicators() {
    var that = this;
    var target = that._subvalueIndicatorsSet;
    var settings = that._prepareIndicatorSettings(that.option('subvalueIndicator') || {}, 'subvalueIndicatorType');
    if (!target) {
      target = that._subvalueIndicatorsSet = that._createSubvalueIndicatorsSet();
    }
    var isRecreate = settings.type !== target.type;
    target.type = settings.type;
    var dummy = that._createIndicator(settings.type, that._renderer.root);
    if (dummy) {
      dummy.dispose();
      target.render(settings, isRecreate);
    }
  },
  _setupValue: function _setupValue(value) {
    this.__value = processValue(value, this.__value);
  },
  _setupSubvalues: function _setupSubvalues(subvalues) {
    var vals = subvalues === undefined ? this.__subvalues : parseArrayOfNumbers(subvalues);
    var i;
    var ii;
    var list;
    if (vals === null) return;
    for (i = 0, ii = vals.length, list = []; i < ii; ++i) {
      list.push(processValue(vals[i], this.__subvalues[i]));
    }
    this.__subvalues = list;
  },
  _updateValueIndicator: function _updateValueIndicator() {
    var that = this;
    that._valueIndicator && that._valueIndicator.value(that.__value, that._noAnimation);
  },
  _updateSubvalueIndicators: function _updateSubvalueIndicators() {
    var that = this;
    that._subvalueIndicatorsSet && that._subvalueIndicatorsSet.values(that.__subvalues, that._noAnimation);
  },
  value: function value(arg) {
    if (arg !== undefined) {
      this._changeValue(arg);
      return this;
    }
    return this.__value;
  },
  subvalues: function subvalues(arg) {
    if (arg !== undefined) {
      this._changeSubvalues(arg);
      return this;
    }
    return this.__subvalues !== null ? this.__subvalues.slice() : undefined;
  },
  _changeValue: function _changeValue(value) {
    this._setupValue(value);
    this._beginValueChanging();
    this._updateValueIndicator();
    this._updateExtraElements();
    if (this.__value !== this.option(OPTION_VALUE)) {
      this.option(OPTION_VALUE, this.__value);
    }
    this._endValueChanging();
  },
  _changeSubvalues: function _changeSubvalues(subvalues) {
    if (this.__subvalues !== null) {
      this._setupSubvalues(subvalues);
      this._beginValueChanging();
      this._updateSubvalueIndicators();
      this._updateExtraElements();
      this._endValueChanging();
    } else {
      this.__subvalues = parseArrayOfNumbers(subvalues);
      this._setContentSize();
      this._renderContent();
    }
    if (!(0, _base_gauge.compareArrays)(this.__subvalues, this.option(OPTION_SUBVALUES))) {
      this.option(OPTION_SUBVALUES, this.__subvalues);
    }
  },
  _optionChangesMap: {
    scale: 'DOMAIN',
    rangeContainer: 'MOSTLY_TOTAL',
    valueIndicator: 'MOSTLY_TOTAL',
    subvalueIndicator: 'MOSTLY_TOTAL',
    containerBackgroundColor: 'MOSTLY_TOTAL',
    value: 'VALUE',
    subvalues: 'SUBVALUES',
    valueIndicators: 'MOSTLY_TOTAL'
  },
  _customChangesOrder: ['VALUE', 'SUBVALUES'],
  _change_VALUE: function _change_VALUE() {
    this._changeValue(this.option(OPTION_VALUE));
  },
  _change_SUBVALUES: function _change_SUBVALUES() {
    this._changeSubvalues(this.option(OPTION_SUBVALUES));
  },
  _applyMainLayout: null,
  _getElementLayout: null,
  _createIndicator: function _createIndicator(type, owner, className, trackerType, trackerIndex, _strict) {
    var that = this;
    var indicator = that._factory.createIndicator({
      renderer: that._renderer,
      translator: that._translator,
      owner: owner,
      tracker: that._tracker,
      className: className
    }, type, _strict);
    if (indicator) {
      indicator.type = type;
      indicator._trackerInfo = {
        type: trackerType,
        index: trackerIndex
      };
    }
    return indicator;
  },
  _getApproximateScreenRange: null
});
exports.dxGauge = dxGauge;
function valueGetter(arg) {
  return arg ? arg.value : null;
}
function setupValues(that, fieldName, optionItems) {
  var currentValues = that[fieldName];
  var newValues = _isArray(optionItems) ? (0, _utils.map)(optionItems, valueGetter) : [];
  var i = 0;
  var ii = newValues.length;
  var list = [];
  for (; i < ii; ++i) {
    list.push(processValue(newValues[i], currentValues[i]));
  }
  that[fieldName] = list;
}
function selectMode(gauge) {
  if (gauge.option(OPTION_VALUE) === undefined && gauge.option(OPTION_SUBVALUES) === undefined) {
    if (gauge.option('valueIndicators') !== undefined) {
      disableDefaultMode(gauge);
      selectHardMode(gauge);
    }
  }
}
function disableDefaultMode(that) {
  that.value = that.subvalues = _common.noop;
  that._setupValue = that._setupSubvalues = that._updateValueIndicator = that._updateSubvalueIndicators = null;
}
function selectHardMode(that) {
  that._indicatorValues = [];
  setupValues(that, '_indicatorValues', that.option('valueIndicators'));
  that._valueIndicators = [];
  var _applyMostlyTotalChange = that._applyMostlyTotalChange;
  that._applyMostlyTotalChange = function () {
    setupValues(this, '_indicatorValues', this.option('valueIndicators'));
    _applyMostlyTotalChange.call(this);
  };
  that._updateActiveElements = updateActiveElements_hardMode;
  that._prepareValueIndicators = prepareValueIndicators_hardMode;
  that._disposeValueIndicators = disposeValueIndicators_hardMode;
  that._cleanValueIndicators = cleanValueIndicators_hardMode;
  that.indicatorValue = indicatorValue_hardMode;
}
function updateActiveElements_hardMode() {
  var that = this;
  that._valueIndicators.forEach(function (valueIndicator) {
    valueIndicator.value(that._indicatorValues[valueIndicator.index], that._noAnimation);
  });
}
function prepareValueIndicators_hardMode() {
  var that = this;
  var valueIndicators = that._valueIndicators || [];
  var userOptions = that.option('valueIndicators');
  var optionList = [];
  var i = 0;
  var ii;
  for (ii = _isArray(userOptions) ? userOptions.length : 0; i < ii; ++i) {
    optionList.push(userOptions[i]);
  }
  for (ii = valueIndicators.length; i < ii; ++i) {
    optionList.push(null);
  }
  var newValueIndicators = [];
  optionList.forEach(function (userSettings, i) {
    var valueIndicator = valueIndicators[i];
    if (!userSettings) {
      valueIndicator && valueIndicator.dispose();
      return;
    }
    var settings = that._prepareIndicatorSettings(userSettings, 'valueIndicatorType');
    if (valueIndicator && valueIndicator.type !== settings.type) {
      valueIndicator.dispose();
      valueIndicator = null;
    }
    if (!valueIndicator) {
      valueIndicator = that._createIndicator(settings.type, that._renderer.root, 'dxg-value-indicator', 'value-indicator', i, true);
    }
    if (valueIndicator) {
      valueIndicator.index = i;
      valueIndicator.render(settings);
      newValueIndicators.push(valueIndicator);
    }
  });
  that._valueIndicators = newValueIndicators;
  return that._valueIndicators;
}
function disposeValueIndicators_hardMode() {
  this._valueIndicators.forEach(function (valueIndicator) {
    return valueIndicator.dispose();
  });
  this._valueIndicators = null;
}
function cleanValueIndicators_hardMode() {
  this._valueIndicators.forEach(function (valueIndicator) {
    return valueIndicator.clean();
  });
}
function indicatorValue_hardMode(index, value) {
  return accessPointerValue(this, this._valueIndicators, this._indicatorValues, index, value);
}
function accessPointerValue(that, pointers, values, index, value) {
  if (value !== undefined) {
    if (values[index] !== undefined) {
      values[index] = processValue(value, values[index]);
      pointers[index] && pointers[index].value(values[index]);
    }
    return that;
  } else {
    return values[index];
  }
}
function ValueIndicatorsSet(parameters) {
  this._parameters = parameters;
  this._indicators = [];
}
ValueIndicatorsSet.prototype = {
  constructor: ValueIndicatorsSet,
  dispose: function dispose() {
    var that = this;
    that._indicators.forEach(function (indicator) {
      return indicator.dispose();
    });
    that._parameters = that._options = that._indicators = that._colorPalette = that._palette = null;
    return that;
  },
  clean: function clean() {
    var that = this;
    that._sample && that._sample.clean().dispose();
    that._indicators.forEach(function (indicator) {
      return indicator.clean();
    });
    that._sample = that._options = that._palette = null;
    return that;
  },
  render: function render(options, isRecreate) {
    var that = this;
    that._options = options;
    that._sample = that._parameters.createIndicator(that.type);
    that._sample.render(options);
    that.enabled = that._sample.enabled;
    that._palette = (0, _type.isDefined)(options.palette) ? that._parameters.createPalette(options.palette) : null;
    if (that.enabled) {
      that._generatePalette(that._indicators.length);
      that._indicators = (0, _utils.map)(that._indicators, function (indicator, i) {
        if (isRecreate) {
          indicator.dispose();
          indicator = that._parameters.createIndicator(that.type, i);
        }
        indicator.render(that._getIndicatorOptions(i));
        return indicator;
      });
    }
    return that;
  },
  getOffset: function getOffset() {
    return this._sample.getOffset();
  },
  resize: function resize(layout) {
    var that = this;
    that._layout = layout;
    that._indicators.forEach(function (indicator) {
      return indicator.resize(layout);
    });
    return that;
  },
  measure: function measure(layout) {
    return this._sample.measure(layout);
  },
  _getIndicatorOptions: function _getIndicatorOptions(index) {
    var result = this._options;
    if (this._colorPalette) {
      result = _extend({}, result, {
        color: this._colorPalette[index]
      });
    }
    return result;
  },
  _generatePalette: function _generatePalette(count) {
    var that = this;
    var colors = null;
    if (that._palette) {
      that._palette.reset();
      colors = that._palette.generateColors(count, {
        repeat: true
      });
    }
    that._colorPalette = colors;
  },
  _adjustIndicatorsCount: function _adjustIndicatorsCount(count) {
    var that = this;
    var indicators = that._indicators;
    var i;
    var ii;
    var indicator;
    var indicatorsLen = indicators.length;
    if (indicatorsLen > count) {
      for (i = count, ii = indicatorsLen; i < ii; ++i) {
        indicators[i].clean().dispose();
      }
      that._indicators = indicators.slice(0, count);
      that._generatePalette(indicators.length);
    } else if (indicatorsLen < count) {
      that._generatePalette(count);
      for (i = indicatorsLen, ii = count; i < ii; ++i) {
        indicator = that._parameters.createIndicator(that.type, i);
        indicator.render(that._getIndicatorOptions(i)).resize(that._layout);
        indicators.push(indicator);
      }
    }
  },
  values: function values(arg, _noAnimation) {
    var that = this;
    if (!that.enabled) return;
    if (arg !== undefined) {
      if (!_isArray(arg)) {
        arg = _isFinite(arg) ? [Number(arg)] : null;
      }
      if (arg) {
        that._adjustIndicatorsCount(arg.length);
        that._indicators.forEach(function (indicator, i) {
          return indicator.value(arg[i], _noAnimation);
        });
      }
      return that;
    }
    return (0, _utils.map)(that._indicators, function (indicator) {
      return indicator.value();
    });
  }
};
function createIndicatorCreator(indicators) {
  return function (parameters, type, _strict) {
    var indicatorType = indicators[(0, _utils.normalizeEnum)(type)] || !_strict && indicators._default;
    return indicatorType ? new indicatorType(parameters) : null;
  };
}

/***/ }),

/***/ 62987:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _extend = __webpack_require__(13306);
var _object = __webpack_require__(48013);
var _base_gauge = __webpack_require__(18029);
var _common = __webpack_require__(88917);
var _utils = __webpack_require__(19157);
var linearIndicators = _interopRequireWildcard(__webpack_require__(79615));
var _linear_range_container = _interopRequireDefault(__webpack_require__(74425));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _max = Math.max;
var _min = Math.min;
var _round = Math.round;
var dxLinearGauge = _common.dxGauge.inherit({
  _rootClass: 'dxg-linear-gauge',
  _factoryMethods: {
    rangeContainer: 'createLinearRangeContainer',
    indicator: 'createLinearIndicator'
  },
  _gridSpacingFactor: 25,
  _scaleTypes: {
    type: 'xyAxes',
    drawingType: 'linear'
  },
  _getTicksOrientation: function _getTicksOrientation(scaleOptions) {
    return scaleOptions.isHorizontal ? scaleOptions.verticalOrientation : scaleOptions.horizontalOrientation;
  },
  _getThemeManagerOptions() {
    var options = this.callBase.apply(this, arguments);
    options.subTheme = '_linear';
    return options;
  },
  _getInvertedState() {
    return !this._area.vertical && this.option('rtlEnabled');
  },
  _prepareScaleSettings: function _prepareScaleSettings() {
    var scaleOptions = this.callBase();
    scaleOptions.inverted = this._getInvertedState();
    return scaleOptions;
  },
  _updateScaleTickIndent: function _updateScaleTickIndent(scaleOptions) {
    var indentFromTick = scaleOptions.label.indentFromTick;
    var length = scaleOptions.tick.length;
    var textParams = this._scale.measureLabels((0, _extend.extend)({}, this._canvas));
    var verticalTextCorrection = scaleOptions.isHorizontal ? textParams.height + textParams.y : 0;
    var isIndentPositive = indentFromTick > 0;
    var orientation;
    var textCorrection;
    var tickCorrection;
    if (scaleOptions.isHorizontal) {
      orientation = isIndentPositive ? {
        center: 0.5,
        top: 0,
        bottom: 1
      } : {
        center: 0.5,
        top: 1,
        bottom: 0
      };
      tickCorrection = length * orientation[scaleOptions.verticalOrientation];
      textCorrection = textParams.y;
    } else {
      orientation = isIndentPositive ? {
        center: 0.5,
        left: 0,
        right: 1
      } : {
        center: 0.5,
        left: 1,
        right: 0
      };
      tickCorrection = length * orientation[scaleOptions.horizontalOrientation];
      textCorrection = -textParams.width;
    }
    scaleOptions.label.indentFromAxis = -indentFromTick + (isIndentPositive ? -tickCorrection + textCorrection : tickCorrection - verticalTextCorrection);
    this._scale.updateOptions(scaleOptions);
  },
  _shiftScale: function _shiftScale(layout, scaleOptions) {
    var that = this;
    var canvas = (0, _extend.extend)({}, that._canvas);
    var isHorizontal = scaleOptions.isHorizontal;
    var scale = that._scale;
    canvas[isHorizontal ? 'left' : 'top'] = that._area[isHorizontal ? 'startCoord' : 'endCoord'];
    canvas[isHorizontal ? 'right' : 'bottom'] = canvas[isHorizontal ? 'width' : 'height'] - that._area[isHorizontal ? 'endCoord' : 'startCoord'];
    scale.draw(canvas);
    scale.shift({
      left: -layout.x,
      top: -layout.y
    });
  },
  _setupCodomain: function _setupCodomain() {
    var that = this;
    var geometry = that.option('geometry') || {};
    var vertical = (0, _utils.normalizeEnum)(geometry.orientation) === 'vertical';
    var initialStartCoord = -100;
    var initialEndCoord = 100;
    that._area = {
      vertical: vertical,
      x: 0,
      y: 0,
      startCoord: initialStartCoord,
      endCoord: initialEndCoord
    };
    that._rangeContainer.vertical = vertical;
    that._translator.setInverted(that._getInvertedState());
    that._translator.setCodomain(initialStartCoord, initialEndCoord);
  },
  _getScaleLayoutValue: function _getScaleLayoutValue() {
    return this._area[this._area.vertical ? 'x' : 'y'];
  },
  _getTicksCoefficients: function _getTicksCoefficients(options) {
    var coefs = {
      inner: 0,
      outer: 1
    };
    if (this._area.vertical) {
      if (options.horizontalOrientation === 'left') {
        coefs.inner = 1;
        coefs.outer = 0;
      } else if (options.horizontalOrientation === 'center') {
        coefs.inner = coefs.outer = 0.5;
      }
    } else {
      if (options.verticalOrientation === 'top') {
        coefs.inner = 1;
        coefs.outer = 0;
      } else if (options.verticalOrientation === 'center') {
        coefs.inner = coefs.outer = 0.5;
      }
    }
    return coefs;
  },
  _correctScaleIndents: function _correctScaleIndents(result, indentFromTick, textParams) {
    var vertical = this._area.vertical;
    if (indentFromTick >= 0) {
      result.max += indentFromTick + textParams[vertical ? 'width' : 'height'];
    } else {
      result.min -= -indentFromTick + textParams[vertical ? 'width' : 'height'];
    }
    result.indent = textParams[vertical ? 'height' : 'width'] / 2;
  },
  _measureMainElements: function _measureMainElements(elements, scaleMeasurement) {
    var that = this;
    var x = that._area.x;
    var y = that._area.y;
    var minBound = 1000;
    var maxBound = 0;
    var indent = 0;
    var scale = that._scale;
    (0, _iterator.each)(elements.concat(scale), function (_, element) {
      var bounds = element.measure ? element.measure({
        x: x + element.getOffset(),
        y: y + element.getOffset()
      }) : scaleMeasurement;
      bounds.max !== undefined && (maxBound = _max(maxBound, bounds.max));
      bounds.min !== undefined && (minBound = _min(minBound, bounds.min));
      bounds.indent > 0 && (indent = _max(indent, bounds.indent));
    });
    return {
      minBound: minBound,
      maxBound: maxBound,
      indent: indent
    };
  },
  _applyMainLayout: function _applyMainLayout(elements, scaleMeasurement) {
    var that = this;
    var measurements = that._measureMainElements(elements, scaleMeasurement);
    var area = that._area;
    var rect;
    var offset;
    if (area.vertical) {
      rect = selectRectBySizes(that._innerRect, {
        width: measurements.maxBound - measurements.minBound
      });
      offset = (rect.left + rect.right) / 2 - (measurements.minBound + measurements.maxBound) / 2;
      area.startCoord = rect.bottom - measurements.indent;
      area.endCoord = rect.top + measurements.indent;
      area.x = _round(area.x + offset);
    } else {
      rect = selectRectBySizes(that._innerRect, {
        height: measurements.maxBound - measurements.minBound
      });
      offset = (rect.top + rect.bottom) / 2 - (measurements.minBound + measurements.maxBound) / 2;
      area.startCoord = rect.left + measurements.indent;
      area.endCoord = rect.right - measurements.indent;
      area.y = _round(area.y + offset);
    }
    that._translator.setCodomain(area.startCoord, area.endCoord);
    that._innerRect = rect;
  },
  _getElementLayout: function _getElementLayout(offset) {
    return {
      x: _round(this._area.x + offset),
      y: _round(this._area.y + offset)
    };
  },
  _getApproximateScreenRange: function _getApproximateScreenRange() {
    var that = this;
    var area = that._area;
    var s = area.vertical ? that._canvas.height : that._canvas.width;
    s > area.totalSize && (s = area.totalSize);
    s = s * 0.8;
    return s;
  },
  _getDefaultSize: function _getDefaultSize() {
    var geometry = this.option('geometry') || {};
    if (geometry.orientation === 'vertical') {
      return {
        width: 100,
        height: 300
      };
    } else {
      return {
        width: 300,
        height: 100
      };
    }
  },
  _factory: (0, _object.clone)(_base_gauge.BaseGauge.prototype._factory)
});
function selectRectBySizes(srcRect, sizes, margins) {
  var rect = (0, _extend.extend)({}, srcRect);
  var step;
  margins = margins || {};
  if (sizes) {
    rect.left += margins.left || 0;
    rect.right -= margins.right || 0;
    rect.top += margins.top || 0;
    rect.bottom -= margins.bottom || 0;
    if (sizes.width > 0) {
      step = (rect.right - rect.left - sizes.width) / 2;
      if (step > 0) {
        rect.left += step;
        rect.right -= step;
      }
    }
    if (sizes.height > 0) {
      step = (rect.bottom - rect.top - sizes.height) / 2;
      if (step > 0) {
        rect.top += step;
        rect.bottom -= step;
      }
    }
  }
  return rect;
}
var indicators = dxLinearGauge.prototype._factory.indicators = {};
dxLinearGauge.prototype._factory.createIndicator = (0, _common.createIndicatorCreator)(indicators);

/* eslint-disable import/namespace */
indicators._default = linearIndicators._default;
indicators['rectangle'] = linearIndicators['rectangle'];
indicators['rhombus'] = linearIndicators['rhombus'];
indicators['circle'] = linearIndicators['circle'];
indicators['trianglemarker'] = linearIndicators['trianglemarker'];
indicators['textcloud'] = linearIndicators['textcloud'];
indicators['rangebar'] = linearIndicators['rangebar'];
/* eslint-enable import/namespace */

dxLinearGauge.prototype._factory.RangeContainer = _linear_range_container.default;
(0, _component_registrator.default)('dxLinearGauge', dxLinearGauge);
var _default = dxLinearGauge;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 79615:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.trianglemarker = exports.textcloud = exports.rhombus = exports.rectangle = exports.rangebar = exports.circle = exports._default = void 0;
var _base_indicators = __webpack_require__(3446);
var _utils = __webpack_require__(19157);
var _Number = Number;
var SimpleIndicator = _base_indicators.BaseIndicator.inherit({
  _move: function _move() {
    var that = this;
    var delta = that._actualPosition - that._zeroPosition;
    that._rootElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
    that._trackerElement && that._trackerElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);
  },
  _isEnabled: function _isEnabled() {
    this.vertical = this._options.vertical;
    return this._options.length > 0 && this._options.width > 0;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var options = this._options;
    var x1;
    var x2;
    var y1;
    var y2;
    var width = options.width / 2;
    var length = options.length / 2;
    var p = this._zeroPosition;
    width > 10 || (width = 10);
    length > 10 || (length = 10);
    if (this.vertical) {
      x1 = options.x - length;
      x2 = options.x + length;
      y1 = p + width;
      y2 = p - width;
    } else {
      x1 = p - width;
      x2 = p + width;
      y1 = options.y + length;
      y2 = options.y - length;
    }
    return {
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    };
  },
  _render: function _render() {
    var that = this;
    that._zeroPosition = that._translator.getCodomainStart();
  },
  _clear: function _clear() {
    delete this._element;
  },
  measure: function measure(layout) {
    var p = this.vertical ? layout.x : layout.y;
    return {
      min: p - this._options.length / 2,
      max: p + this._options.length / 2
    };
  },
  getTooltipParameters: function getTooltipParameters() {
    var that = this;
    var options = that._options;
    var p = that._actualPosition;
    var parameters = {
      x: p,
      y: p,
      value: that._currentValue,
      color: options.color,
      offset: options.width / 2
    };
    that.vertical ? parameters.x = options.x : parameters.y = options.y;
    return parameters;
  }
});
var rectangle = SimpleIndicator.inherit({
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x1;
    var x2;
    var y1;
    var y2;
    that.callBase();
    var p = that._zeroPosition;
    if (that.vertical) {
      x1 = options.x - options.length / 2;
      x2 = options.x + options.length / 2;
      y1 = p + options.width / 2;
      y2 = p - options.width / 2;
    } else {
      x1 = p - options.width / 2;
      x2 = p + options.width / 2;
      y1 = options.y + options.length / 2;
      y2 = options.y - options.length / 2;
    }
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x1, y1, x1, y2, x2, y2, x2, y1]
    });
  }
});
exports.rectangle = rectangle;
var rhombus = SimpleIndicator.inherit({
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x;
    var y;
    var dx;
    var dy;
    that.callBase();
    if (that.vertical) {
      x = options.x;
      y = that._zeroPosition;
      dx = options.length / 2 || 0;
      dy = options.width / 2 || 0;
    } else {
      x = that._zeroPosition;
      y = options.y;
      dx = options.width / 2 || 0;
      dy = options.length / 2 || 0;
    }
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr({
      points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy]
    });
  }
});
exports.rhombus = rhombus;
var circle = SimpleIndicator.inherit({
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x;
    var y;
    that.callBase();
    if (that.vertical) {
      x = options.x;
      y = that._zeroPosition;
    } else {
      x = that._zeroPosition;
      y = options.y;
    }
    var r = options.length / 2 || 0;
    that._element = that._element || that._renderer.circle().append(that._rootElement);
    that._element.attr({
      cx: x,
      cy: y,
      r: r
    });
  }
});

// The following is from linearMarker.js
exports.circle = circle;
var triangleMarker = SimpleIndicator.inherit({
  _isEnabled: function _isEnabled() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return that._options.length > 0 && that._options.width > 0;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _render: function _render() {
    var that = this;
    var options = that._options;
    var x1;
    var x2;
    var y1;
    var y2;
    var settings = {
      stroke: 'none',
      'stroke-width': 0,
      'stroke-linecap': 'square'
    };
    that.callBase();
    if (that.vertical) {
      x1 = options.x;
      y1 = that._zeroPosition;
      x2 = x1 + _Number(that._inverted ? options.length : -options.length);
      settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2];
    } else {
      y1 = options.y;
      x1 = that._zeroPosition;
      y2 = y1 + _Number(that._inverted ? options.length : -options.length);
      settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2];
    }
    if (options.space > 0) {
      settings['stroke-width'] = Math.min(options.space, options.width / 4) || 0;
      settings.stroke = settings['stroke-width'] > 0 ? options.containerBackgroundColor || 'none' : 'none';
    }
    that._element = that._element || that._renderer.path([], 'area').append(that._rootElement);
    that._element.attr(settings).sharp();
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var that = this;
    var options = that._options;
    var width = options.width / 2;
    var length = _Number(options.length);
    var x1;
    var x2;
    var y1;
    var y2;
    var result;
    width > 10 || (width = 10);
    length > 20 || (length = 20);
    if (that.vertical) {
      x1 = options.x;
      x2 = x1 + (that._inverted ? length : -length);
      y1 = that._zeroPosition + width;
      y2 = that._zeroPosition - width;
      result = [x1, y1, x2, y1, x2, y2, x1, y2];
    } else {
      y1 = options.y;
      y2 = y1 + (that._inverted ? length : -length);
      x1 = that._zeroPosition - width;
      x2 = that._zeroPosition + width;
      result = [x1, y1, x1, y2, x2, y2, x2, y1];
    }
    return {
      points: result
    };
  },
  measure: function measure(layout) {
    var that = this;
    var length = _Number(that._options.length);
    var minBound;
    var maxBound;
    if (that.vertical) {
      minBound = maxBound = layout.x;
      if (that._inverted) {
        maxBound = minBound + length;
      } else {
        minBound = maxBound - length;
      }
    } else {
      minBound = maxBound = layout.y;
      if (that._inverted) {
        maxBound = minBound + length;
      } else {
        minBound = maxBound - length;
      }
    }
    return {
      min: minBound,
      max: maxBound
    };
  },
  getTooltipParameters: function getTooltipParameters() {
    var that = this;
    var options = that._options;
    var s = (that._inverted ? options.length : -options.length) / 2;
    var parameters = that.callBase();
    that.vertical ? parameters.x += s : parameters.y += s;
    parameters.offset = options.length / 2;
    return parameters;
  }
});
exports.trianglemarker = triangleMarker;
var textCloud = _base_indicators.BaseTextCloudMarker.inherit({
  _isEnabled: function _isEnabled() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return true;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _getTextCloudOptions: function _getTextCloudOptions() {
    var that = this;
    var x = that._actualPosition;
    var y = that._actualPosition;
    var type;
    if (that.vertical) {
      x = that._options.x;
      type = that._inverted ? 'top-left' : 'top-right';
    } else {
      y = that._options.y;
      type = that._inverted ? 'right-top' : 'right-bottom';
    }
    return {
      x: x,
      y: y,
      type: type
    };
  },
  measure: function measure(layout) {
    var that = this;
    var minBound;
    var maxBound;
    var arrowLength = _Number(that._options.arrowLength) || 0;
    that._measureText();
    if (that.vertical) {
      if (that._inverted) {
        minBound = layout.x;
        maxBound = layout.x + arrowLength + that._textFullWidth;
      } else {
        minBound = layout.x - arrowLength - that._textFullWidth;
        maxBound = layout.x;
      }
    } else {
      if (that._inverted) {
        minBound = layout.y;
        maxBound = layout.y + arrowLength + that._textFullHeight;
      } else {
        minBound = layout.y - arrowLength - that._textFullHeight;
        maxBound = layout.y;
      }
    }
    return {
      min: minBound,
      max: maxBound,
      indent: 0
    };
  },
  _correctCloudType(type, _ref, _ref2) {
    var x = _ref.x,
      y = _ref.y;
    var width = _ref2.width,
      height = _ref2.height;
    if (type === 'right-top' || type === 'right-bottom') {
      if (x - width < this._translator.getCodomainStart()) {
        type = "left-".concat(type.split('-')[1]);
      }
    } else if (type === 'top-left' || type === 'top-right') {
      if (y + height > this._translator.getCodomainStart()) {
        type = "bottom-".concat(type.split('-')[1]);
      }
    }
    return type;
  }
});

// The following is from linearRangeBar.js
exports.textcloud = textCloud;
var rangeBar = _base_indicators.BaseRangeBar.inherit({
  _isEnabled: function _isEnabled() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inverted = that.vertical ? (0, _utils.normalizeEnum)(that._options.horizontalOrientation) === 'right' : (0, _utils.normalizeEnum)(that._options.verticalOrientation) === 'bottom';
    return that._options.size > 0;
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _createBarItem: function _createBarItem() {
    return this._renderer.path([], 'area').append(this._rootElement);
  },
  _createTracker: function _createTracker() {
    return this._renderer.path([], 'area');
  },
  _setBarSides: function _setBarSides() {
    var that = this;
    var options = that._options;
    var size = _Number(options.size);
    var minSide;
    var maxSide;
    if (that.vertical) {
      if (that._inverted) {
        minSide = options.x;
        maxSide = options.x + size;
      } else {
        minSide = options.x - size;
        maxSide = options.x;
      }
    } else {
      if (that._inverted) {
        minSide = options.y;
        maxSide = options.y + size;
      } else {
        minSide = options.y - size;
        maxSide = options.y;
      }
    }
    that._minSide = minSide;
    that._maxSide = maxSide;
    that._minBound = minSide;
    that._maxBound = maxSide;
  },
  _getSpace: function _getSpace() {
    var options = this._options;
    return options.space > 0 ? _Number(options.space) : 0;
  },
  _isTextVisible: function _isTextVisible() {
    var textOptions = this._options.text || {};
    return textOptions.indent > 0 || textOptions.indent < 0;
  },
  _getTextAlign: function _getTextAlign() {
    return this.vertical ? this._options.text.indent > 0 ? 'left' : 'right' : 'center';
  },
  _setTextItemsSides: function _setTextItemsSides() {
    var that = this;
    var indent = _Number(that._options.text.indent);
    if (indent > 0) {
      that._lineStart = that._maxSide;
      that._lineEnd = that._maxSide + indent;
      that._textPosition = that._lineEnd + (that.vertical ? 2 : that._textHeight / 2);
      that._maxBound = that._textPosition + (that.vertical ? that._textWidth : that._textHeight / 2);
    } else if (indent < 0) {
      that._lineStart = that._minSide;
      that._lineEnd = that._minSide + indent;
      that._textPosition = that._lineEnd - (that.vertical ? 2 : that._textHeight / 2);
      that._minBound = that._textPosition - (that.vertical ? that._textWidth : that._textHeight / 2);
    }
  },
  _getPositions: function _getPositions() {
    var that = this;
    var startPosition = that._startPosition;
    var endPosition = that._endPosition;
    var space = that._space;
    var basePosition = that._basePosition;
    var actualPosition = that._actualPosition;
    var mainPosition1;
    var mainPosition2;
    var backPosition1;
    var backPosition2;
    if (startPosition < endPosition) {
      if (basePosition < actualPosition) {
        mainPosition1 = basePosition;
        mainPosition2 = actualPosition;
      } else {
        mainPosition1 = actualPosition;
        mainPosition2 = basePosition;
      }
      backPosition1 = mainPosition1 - space;
      backPosition2 = mainPosition2 + space;
    } else {
      if (basePosition > actualPosition) {
        mainPosition1 = basePosition;
        mainPosition2 = actualPosition;
      } else {
        mainPosition1 = actualPosition;
        mainPosition2 = basePosition;
      }
      backPosition1 = mainPosition1 + space;
      backPosition2 = mainPosition2 - space;
    }
    return {
      start: startPosition,
      end: endPosition,
      main1: mainPosition1,
      main2: mainPosition2,
      back1: backPosition1,
      back2: backPosition2
    };
  },
  _buildItemSettings: function _buildItemSettings(from, to) {
    var that = this;
    var side1 = that._minSide;
    var side2 = that._maxSide;
    var points = that.vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];
    return {
      points: points
    };
  },
  _updateTextPosition: function _updateTextPosition() {
    var that = this;
    that._text.attr(that.vertical ? {
      x: that._textPosition,
      y: that._actualPosition + that._textVerticalOffset
    } : {
      x: that._actualPosition,
      y: that._textPosition + that._textVerticalOffset
    });
  },
  _updateLinePosition: function _updateLinePosition() {
    var that = this;
    var actualPosition = that._actualPosition;
    var side1;
    var side2;
    var points;
    if (that.vertical) {
      if (that._basePosition >= actualPosition) {
        side1 = actualPosition;
        side2 = actualPosition + 2;
      } else {
        side1 = actualPosition - 2;
        side2 = actualPosition;
      }
      points = [that._lineStart, side1, that._lineStart, side2, that._lineEnd, side2, that._lineEnd, side1];
    } else {
      if (that._basePosition <= actualPosition) {
        side1 = actualPosition - 2;
        side2 = actualPosition;
      } else {
        side1 = actualPosition;
        side2 = actualPosition + 2;
      }
      points = [side1, that._lineStart, side1, that._lineEnd, side2, that._lineEnd, side2, that._lineStart];
    }
    that._line.attr({
      points: points
    }).sharp();
  },
  _getTooltipPosition: function _getTooltipPosition() {
    var that = this;
    var crossCenter = (that._minSide + that._maxSide) / 2;
    var alongCenter = (that._basePosition + that._actualPosition) / 2;
    return that.vertical ? {
      x: crossCenter,
      y: alongCenter
    } : {
      x: alongCenter,
      y: crossCenter
    };
  },
  measure: function measure(layout) {
    var that = this;
    var size = _Number(that._options.size);
    var textIndent = _Number(that._options.text.indent);
    var minBound;
    var maxBound;
    var indent;
    that._measureText();
    if (that.vertical) {
      minBound = maxBound = layout.x;
      if (that._inverted) {
        maxBound = maxBound + size;
      } else {
        minBound = minBound - size;
      }
      if (that._hasText) {
        indent = that._textHeight / 2;
        if (textIndent > 0) {
          maxBound += textIndent + that._textWidth;
        }
        if (textIndent < 0) {
          minBound += textIndent - that._textWidth;
        }
      }
    } else {
      minBound = maxBound = layout.y;
      if (that._inverted) {
        maxBound = maxBound + size;
      } else {
        minBound = minBound - size;
      }
      if (that._hasText) {
        indent = that._textWidth / 2;
        if (textIndent > 0) {
          maxBound += textIndent + that._textHeight;
        }
        if (textIndent < 0) {
          minBound += textIndent - that._textHeight;
        }
      }
    }
    return {
      min: minBound,
      max: maxBound,
      indent: indent
    };
  }
});
/* eslint-disable spellcheck/spell-checker */
exports.rangebar = exports._default = rangeBar;

/***/ }),

/***/ 74425:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _base_range_container = _interopRequireDefault(__webpack_require__(84165));
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _Number = Number;
var _max = Math.max;
var LinearRangeContainer = _base_range_container.default.inherit({
  _processOptions: function _processOptions() {
    var that = this;
    that.vertical = that._options.vertical;
    that._inner = that._outer = 0;
    if (that.vertical) {
      switch ((0, _utils.normalizeEnum)(that._options.horizontalOrientation)) {
        case 'left':
          that._inner = 1;
          break;
        case 'center':
          that._inner = that._outer = 0.5;
          break;
        default:
          that._outer = 1;
          break;
      }
    } else {
      switch ((0, _utils.normalizeEnum)(that._options.verticalOrientation)) {
        case 'top':
          that._inner = 1;
          break;
        case 'center':
          that._inner = that._outer = 0.5;
          break;
        default:
          that._outer = 1;
          break;
      }
    }
  },
  _isVisible: function _isVisible() {
    return true;
  },
  _createRange: function _createRange(range, layout) {
    var that = this;
    var inner = that._inner;
    var outer = that._outer;
    var startPosition = that._translator.translate(range.start);
    var endPosition = that._translator.translate(range.end);
    var points;
    var x = layout.x;
    var y = layout.y;
    var startWidth = range.startWidth;
    var endWidth = range.endWidth;
    if (that.vertical) {
      points = [x - startWidth * inner, startPosition, x - endWidth * inner, endPosition, x + endWidth * outer, endPosition, x + startWidth * outer, startPosition];
    } else {
      points = [startPosition, y + startWidth * outer, startPosition, y - startWidth * inner, endPosition, y - endWidth * inner, endPosition, y + endWidth * outer];
    }
    return that._renderer.path(points, 'area');
  },
  measure: function measure(layout) {
    var result = {};
    var width;
    result.min = result.max = layout[this.vertical ? 'x' : 'y'];
    width = this._options.width;
    width = _Number(width) || _max(_Number(width.start), _Number(width.end));
    result.min -= this._inner * width;
    result.max += this._outer * width;
    return result;
  }
});
var _default = LinearRangeContainer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 41802:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _base_theme_manager = __webpack_require__(43637);
var _extend = _extend2.extend;
var ThemeManager = _base_theme_manager.BaseThemeManager.inherit({
  ctor(options) {
    this.callBase.apply(this, arguments);
    this._subTheme = options.subTheme;
  },
  _initializeTheme: function _initializeTheme() {
    var that = this;
    var subTheme;
    if (that._subTheme) {
      subTheme = _extend(true, {}, that._theme[that._subTheme], that._theme);
      _extend(true, that._theme, subTheme);
    }
    that.callBase.apply(that, arguments);
  }
});
var _default = {
  ThemeManager
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57298:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _class = _interopRequireDefault(__webpack_require__(38377));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _wheel = __webpack_require__(765);
var _ready_callbacks = _interopRequireDefault(__webpack_require__(24311));
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var EVENT_NS = 'gauge-tooltip';
var TOOLTIP_HIDE_DELAY = 100;
var ready = _ready_callbacks.default.add;
var Tracker = _class.default.inherit({
  ctor: function ctor(parameters) {
    var that = this;
    that._element = parameters.renderer.g().attr({
      'class': 'dxg-tracker',
      stroke: 'none',
      'stroke-width': 0,
      fill: '#000000',
      opacity: 0.0001
    }).linkOn(parameters.container, {
      name: 'tracker',
      after: 'peripheral'
    });
    that._showTooltipCallback = function () {
      var target = that._tooltipEvent.target;
      var data_target = target['gauge-data-target'];
      var data_info = target['gauge-data-info'];
      that._targetEvent = null; //  Internal state must be reset strictly BEFORE callback is invoked
      if (that._tooltipTarget !== target) {
        var callback = function callback(result) {
          result && (that._tooltipTarget = target);
        };
        callback(that._callbacks['tooltip-show'](data_target, data_info, callback));
      }
    };
    that._hideTooltipCallback = function () {
      that._hideTooltipTimeout = null;
      that._targetEvent = null;
      if (that._tooltipTarget) {
        that._callbacks['tooltip-hide']();
        that._tooltipTarget = null;
      }
    };
    that._dispose = function () {
      clearTimeout(that._hideTooltipTimeout);
      that._showTooltipCallback = that._hideTooltipCallback = that._dispose = null;
    };
  },
  dispose: function dispose() {
    var that = this;
    that._dispose();
    that.deactivate();
    that._element.off('.' + EVENT_NS);
    that._element.linkOff();
    that._element = that._context = that._callbacks = null;
    return that;
  },
  activate: function activate() {
    this._element.linkAppend();
    return this;
  },
  deactivate: function deactivate() {
    this._element.linkRemove().clear();
    return this;
  },
  attach: function attach(element, target, info) {
    element.data({
      'gauge-data-target': target,
      'gauge-data-info': info
    }).append(this._element);
    return this;
  },
  detach: function detach(element) {
    element.remove();
    return this;
  },
  setTooltipState: function setTooltipState(state) {
    var that = this;
    that._element.off('.' + EVENT_NS);
    if (state) {
      var data = {
        tracker: that
      };
      that._element.on((0, _index.addNamespace)([_pointer.default.move], EVENT_NS), data, handleTooltipMouseOver).on((0, _index.addNamespace)([_pointer.default.out], EVENT_NS), data, handleTooltipMouseOut).on((0, _index.addNamespace)([_pointer.default.down], EVENT_NS), data, handleTooltipTouchStart).on((0, _index.addNamespace)([_pointer.default.up], EVENT_NS), data, handleTooltipTouchEnd).on((0, _index.addNamespace)([_wheel.name], EVENT_NS), data, handleTooltipMouseWheel);
    }
    return that;
  },
  setCallbacks: function setCallbacks(callbacks) {
    this._callbacks = callbacks;
    return this;
  },
  _showTooltip: function _showTooltip(event) {
    var that = this;
    clearTimeout(that._hideTooltipTimeout);
    that._hideTooltipTimeout = null;
    if (that._tooltipTarget === event.target) {
      return;
    }
    that._tooltipEvent = event;
    that._showTooltipCallback();
  },
  _hideTooltip: function _hideTooltip(delay) {
    var that = this;
    clearTimeout(that._hideTooltipTimeout);
    if (delay) {
      that._hideTooltipTimeout = setTimeout(that._hideTooltipCallback, delay);
    } else {
      that._hideTooltipCallback();
    }
  }
});
var active_touch_tooltip_tracker = null;
function handleTooltipMouseOver(event) {
  var tracker = event.data.tracker;
  tracker._x = event.pageX;
  tracker._y = event.pageY;
  tracker._showTooltip(event);
}
function handleTooltipMouseOut(event) {
  event.data.tracker._hideTooltip(TOOLTIP_HIDE_DELAY);
}
function handleTooltipMouseWheel(event) {
  event.data.tracker._hideTooltip();
}
function handleTooltipTouchStart(event) {
  var tracker = active_touch_tooltip_tracker = event.data.tracker;
  tracker._touch = true;
  handleTooltipMouseOver(event);
}
function handleTooltipTouchEnd() {
  active_touch_tooltip_tracker._touch = false;
}
function handleDocumentTooltipTouchStart(event) {
  var tracker = active_touch_tooltip_tracker;
  if (tracker && !tracker._touch) {
    tracker._hideTooltip(TOOLTIP_HIDE_DELAY);
    active_touch_tooltip_tracker = null;
  }
}
ready(function () {
  _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), (0, _index.addNamespace)([_pointer.default.down], EVENT_NS), handleDocumentTooltipTouchStart);
});
var _default = Tracker;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 99630:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _linear_gauge = _interopRequireDefault(__webpack_require__(62987));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _linear_gauge.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 23696:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.createPalette = createPalette;
exports.currentPalette = currentPalette;
exports.generateColors = generateColors;
exports.getAccentColor = getAccentColor;
exports.getDiscretePalette = getDiscretePalette;
exports.getGradientPalette = getGradientPalette;
exports.getPalette = getPalette;
exports.registerPalette = registerPalette;
var _utils = __webpack_require__(19157);
var _extend = __webpack_require__(13306);
var _color = _interopRequireDefault(__webpack_require__(52752));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _floor = Math.floor;
var _ceil = Math.ceil;
var _isArray = Array.isArray;
var HIGHLIGHTING_STEP = 50;
var DEFAULT_PALETTE = 'material';
var officePalette = {
  simpleSet: ['#5f8b95', '#ba4d51', '#af8a53', '#955f71', '#859666', '#7e688c'],
  indicatingSet: ['#a3b97c', '#e1b676', '#ec7f83'],
  gradientSet: ['#5f8b95', '#ba4d51'],
  accentColor: '#ba4d51'
};
var palettes = {
  [DEFAULT_PALETTE]: {
    simpleSet: ['#1db2f5', '#f5564a', '#97c95c', '#ffc720', '#eb3573', '#a63db8'],
    indicatingSet: ['#97c95c', '#ffc720', '#f5564a'],
    gradientSet: ['#1db2f5', '#97c95c'],
    accentColor: '#1db2f5'
  },
  'office': officePalette,
  'harmony light': {
    simpleSet: ['#fcb65e', '#679ec5', '#ad79ce', '#7abd5c', '#e18e92', '#b6d623', '#b7abea', '#85dbd5'],
    indicatingSet: ['#b6d623', '#fcb65e', '#e18e92'],
    gradientSet: ['#7abd5c', '#fcb65e'],
    accentColor: '#679ec5'
  },
  'soft pastel': {
    simpleSet: ['#60a69f', '#78b6d9', '#6682bb', '#a37182', '#eeba69', '#90ba58', '#456c68', '#7565a4'],
    indicatingSet: ['#90ba58', '#eeba69', '#a37182'],
    gradientSet: ['#78b6d9', '#eeba69'],
    accentColor: '#60a69f'
  },
  'pastel': {
    simpleSet: ['#bb7862', '#70b3a1', '#bb626a', '#057d85', '#ab394b', '#dac599', '#153459', '#b1d2c6'],
    indicatingSet: ['#70b3a1', '#dac599', '#bb626a'],
    gradientSet: ['#bb7862', '#70b3a1'],
    accentColor: '#bb7862'
  },
  'bright': {
    simpleSet: ['#70c92f', '#f8ca00', '#bd1550', '#e97f02', '#9d419c', '#7e4452', '#9ab57e', '#36a3a6'],
    indicatingSet: ['#70c92f', '#f8ca00', '#bd1550'],
    gradientSet: ['#e97f02', '#f8ca00'],
    accentColor: '#e97f02'
  },
  'soft': {
    simpleSet: ['#cbc87b', '#9ab57e', '#e55253', '#7e4452', '#e8c267', '#565077', '#6babac', '#ad6082'],
    indicatingSet: ['#9ab57e', '#e8c267', '#e55253'],
    gradientSet: ['#9ab57e', '#e8c267'],
    accentColor: '#565077'
  },
  'ocean': {
    simpleSet: ['#75c099', '#acc371', '#378a8a', '#5fa26a', '#064970', '#38c5d2', '#00a7c6', '#6f84bb'],
    indicatingSet: ['#c8e394', '#7bc59d', '#397c8b'],
    gradientSet: ['#acc371', '#38c5d2'],
    accentColor: '#378a8a'
  },
  'vintage': {
    simpleSet: ['#dea484', '#efc59c', '#cb715e', '#eb9692', '#a85c4c', '#f2c0b5', '#c96374', '#dd956c'],
    indicatingSet: ['#ffe5c6', '#f4bb9d', '#e57660'],
    gradientSet: ['#efc59c', '#cb715e'],
    accentColor: '#cb715e'
  },
  'violet': {
    simpleSet: ['#d1a1d1', '#eeacc5', '#7b5685', '#7e7cad', '#a13d73', '#5b41ab', '#e287e2', '#689cc1'],
    indicatingSet: ['#d8e2f6', '#d0b2da', '#d56a8a'],
    gradientSet: ['#eeacc5', '#7b5685'],
    accentColor: '#7b5685'
  },
  // generic color schemes related palettes
  'carmine': {
    simpleSet: ['#fb7764', '#73d47f', '#fed85e', '#d47683', '#dde392', '#757ab2'],
    indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
    gradientSet: ['#fb7764', '#73d47f'],
    accentColor: '#f05b41'
  },
  'dark moon': {
    simpleSet: ['#4ddac1', '#f4c99a', '#80dd9b', '#f998b3', '#4aaaa0', '#a5aef1'],
    indicatingSet: ['#59d8a4', '#f0ad4e', '#f9517e'],
    gradientSet: ['#4ddac1', '#f4c99a'],
    accentColor: '#3debd3'
  },
  'soft blue': {
    simpleSet: ['#7ab8eb', '#97da97', '#facb86', '#e78683', '#839bda', '#4db7be'],
    indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
    gradientSet: ['#7ab8eb', '#97da97'],
    accentColor: '#7ab8eb'
  },
  'dark violet': {
    simpleSet: ['#9c63ff', '#64c064', '#eead51', '#d2504b', '#4b6bbf', '#2da7b0'],
    indicatingSet: ['#5cb85c', '#f0ad4e', '#d9534f'],
    gradientSet: ['#9c63ff', '#64c064'],
    accentColor: '#9c63ff'
  },
  'green mist': {
    simpleSet: ['#3cbab2', '#8ed962', '#5b9d95', '#efcc7c', '#f1929f', '#4d8dab'],
    indicatingSet: ['#72d63c', '#ffc852', '#f74a5e'],
    gradientSet: ['#3cbab2', '#8ed962'],
    accentColor: '#3cbab2'
  }
};
var currentPaletteName;
function currentPalette(name) {
  if (name === undefined) {
    return currentPaletteName || DEFAULT_PALETTE;
  } else {
    name = (0, _utils.normalizeEnum)(name);
    currentPaletteName = name in palettes ? name : undefined;
  }
}
function generateColors(palette, count) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    keepLastColorInEnd: false
  };
  options.type = options.baseColorSet;
  options.extensionMode = options.paletteExtensionMode;
  return createPalette(palette, options).generateColors(count);
}
function getPalette(palette, parameters) {
  parameters = parameters || {};
  palette = palette || (currentPaletteName === undefined ? parameters.themeDefault : currentPalette());
  var result;
  var type = parameters.type;
  if (_isArray(palette)) {
    return palette.slice(0);
  } else {
    if ((0, _type.isString)(palette)) {
      result = palettes[(0, _utils.normalizeEnum)(palette)];
    }
    if (!result) {
      result = palettes[currentPalette()];
    }
  }
  return type ? result[type].slice(0) : result;
}
function registerPalette(name, palette) {
  var item = {};
  var paletteName;
  if (_isArray(palette)) {
    item.simpleSet = palette.slice(0);
  } else if (palette) {
    item.simpleSet = _isArray(palette.simpleSet) ? palette.simpleSet.slice(0) : undefined;
    item.indicatingSet = _isArray(palette.indicatingSet) ? palette.indicatingSet.slice(0) : undefined;
    item.gradientSet = _isArray(palette.gradientSet) ? palette.gradientSet.slice(0) : undefined;
    item.accentColor = palette.accentColor;
  }
  if (!item.accentColor) {
    item.accentColor = item.simpleSet && item.simpleSet[0];
  }
  if (item.simpleSet || item.indicatingSet || item.gradientSet) {
    paletteName = (0, _utils.normalizeEnum)(name);
    (0, _extend.extend)(palettes[paletteName] = palettes[paletteName] || {}, item);
  }
}
function getAccentColor(palette, themeDefault) {
  palette = getPalette(palette, {
    themeDefault
  });
  return palette.accentColor || palette[0];
}
function RingBuf(buf) {
  var ind = 0;
  this.next = function () {
    var res = buf[ind++];
    if (ind === buf.length) {
      this.reset();
    }
    return res;
  };
  this.reset = function () {
    ind = 0;
  };
}
function getAlternateColorsStrategy(palette, parameters) {
  var stepHighlight = parameters.useHighlight ? HIGHLIGHTING_STEP : 0;
  var paletteSteps = new RingBuf([0, stepHighlight, -stepHighlight]);
  var currentPalette = [];
  function _reset() {
    var step = paletteSteps.next();
    currentPalette = step ? getAlteredPalette(palette, step) : palette.slice(0);
  }
  return {
    getColor: function getColor(index) {
      var color = currentPalette[index % palette.length];
      if (index % palette.length === palette.length - 1) {
        _reset();
      }
      return color;
    },
    generateColors: function generateColors(count) {
      var colors = [];
      count = count || parameters.count;
      for (var i = 0; i < count; i++) {
        colors.push(this.getColor(i));
      }
      return colors;
    },
    reset: function reset() {
      paletteSteps.reset();
      _reset();
    }
  };
}
function getExtrapolateColorsStrategy(palette, parameters) {
  function convertColor(color, cycleIndex, cycleCount) {
    var hsl = new _color.default(color).hsl;
    var l = hsl.l / 100;
    var diapason = cycleCount - 1 / cycleCount;
    var minL = l - diapason * 0.5;
    var maxL = l + diapason * 0.5;
    var cycleMiddle = (cycleCount - 1) / 2;
    var cycleDiff = cycleIndex - cycleMiddle;
    if (minL < Math.min(0.5, l * 0.9)) {
      minL = Math.min(0.5, l * 0.9);
    }
    if (maxL > Math.max(0.8, l + (1 - l) * 0.15)) {
      maxL = Math.max(0.8, l + (1 - l) * 0.15);
    }
    if (cycleDiff < 0) {
      l = l - (minL - l) * cycleDiff / cycleMiddle;
    } else {
      l = l + (maxL - l) * (cycleDiff / cycleMiddle);
    }
    hsl.l = l * 100;
    return _color.default.prototype.fromHSL(hsl).toHex();
  }
  return {
    getColor: function getColor(index, count) {
      var paletteCount = palette.length;
      var cycles = _floor((count - 1) / paletteCount + 1);
      var color = palette[index % paletteCount];
      if (cycles > 1) {
        return convertColor(color, _floor(index / paletteCount), cycles);
      }
      return color;
    },
    generateColors: function generateColors(count) {
      var colors = [];
      count = count || parameters.count;
      for (var i = 0; i < count; i++) colors.push(this.getColor(i, count));
      return colors;
    },
    reset: function reset() {}
  };
}
function getColorMixer(palette, parameters) {
  var paletteCount = palette.length;
  var extendedPalette = [];
  function distributeColors(count, colorsCount, startIndex, distribution) {
    var groupSize = Math.floor(count / colorsCount);
    var extraItems = count - colorsCount * groupSize;
    var i = startIndex;
    var middleIndex;
    var size;
    while (i < startIndex + count) {
      size = groupSize;
      if (extraItems > 0) {
        size += 1;
        extraItems--;
      }
      middleIndex = size > 2 ? Math.floor(size / 2) : 0;
      distribution.push(i + middleIndex);
      i += size;
    }
    return distribution.sort(function (a, b) {
      return a - b;
    });
  }
  function getColorAndDistance(arr, startIndex, count) {
    startIndex = (count + startIndex) % count;
    var distance = 0;
    for (var i = startIndex; i < count * 2; i += 1) {
      var index = (count + i) % count;
      if (arr[index]) {
        return [arr[index], distance];
      }
      distance++;
    }
  }
  function blendColors(paletteWithEmptyColors, paletteLength) {
    for (var i = 0; i < paletteLength; i++) {
      var color = paletteWithEmptyColors[i];
      if (!color) {
        var color1 = paletteWithEmptyColors[i - 1];
        if (!color1) {
          continue;
        } else {
          var c2 = getColorAndDistance(paletteWithEmptyColors, i, paletteLength);
          var color2 = new _color.default(c2[0]);
          color1 = new _color.default(color1);
          for (var j = 0; j < c2[1]; j++, i++) {
            paletteWithEmptyColors[i] = color1.blend(color2, (j + 1) / (c2[1] + 1)).toHex();
          }
        }
      }
    }
    return paletteWithEmptyColors;
  }
  function extendPalette(count) {
    if (count <= paletteCount) {
      return palette;
    }
    var result = [];
    var colorInGroups = paletteCount - 2;
    var currentColorIndex = 0;
    var cleanColorIndices = [];
    if (parameters.keepLastColorInEnd) {
      cleanColorIndices = distributeColors(count - 2, colorInGroups, 1, [0, count - 1]);
    } else {
      cleanColorIndices = distributeColors(count - 1, paletteCount - 1, 1, [0]);
    }
    for (var i = 0; i < count; i++) {
      if (cleanColorIndices.indexOf(i) > -1) {
        result[i] = palette[currentColorIndex++];
      }
    }
    result = blendColors(result, count);
    return result;
  }
  return {
    getColor: function getColor(index, count) {
      count = count || parameters.count || paletteCount;
      if (extendedPalette.length !== count) {
        extendedPalette = extendPalette(count);
      }
      return extendedPalette[index % count];
    },
    generateColors: function generateColors(count, repeat) {
      count = count || parameters.count || paletteCount;
      if (repeat && count > paletteCount) {
        var colors = extendPalette(paletteCount);
        for (var i = 0; i < count - paletteCount; i++) {
          colors.push(colors[i]);
        }
        return colors;
      } else {
        return paletteCount > 0 ? extendPalette(count).slice(0, count) : [];
      }
    },
    reset: function reset() {}
  };
}
function createPalette(palette, parameters, themeDefaultPalette) {
  var paletteObj = {
    dispose() {
      this._extensionStrategy = null;
    },
    getNextColor(count) {
      return this._extensionStrategy.getColor(this._currentColor++, count);
    },
    generateColors(count, parameters) {
      return this._extensionStrategy.generateColors(count, (parameters || {}).repeat);
    },
    reset() {
      this._currentColor = 0;
      this._extensionStrategy.reset();
      return this;
    }
  };
  parameters = parameters || {};
  var extensionMode = (parameters.extensionMode || '').toLowerCase();
  var colors = getPalette(palette, {
    type: parameters.type || 'simpleSet',
    themeDefault: themeDefaultPalette
  });
  if (extensionMode === 'alternate') {
    paletteObj._extensionStrategy = getAlternateColorsStrategy(colors, parameters);
  } else if (extensionMode === 'extrapolate') {
    paletteObj._extensionStrategy = getExtrapolateColorsStrategy(colors, parameters);
  } else {
    paletteObj._extensionStrategy = getColorMixer(colors, parameters);
  }
  paletteObj.reset();
  return paletteObj;
}
function getAlteredPalette(originalPalette, step) {
  var palette = [];
  var i;
  var ii = originalPalette.length;
  for (i = 0; i < ii; ++i) {
    palette.push(getNewColor(originalPalette[i], step));
  }
  return palette;
}
function getNewColor(currentColor, step) {
  var newColor = new _color.default(currentColor).alter(step);
  var lightness = getLightness(newColor);
  if (lightness > 200 || lightness < 55) {
    newColor = new _color.default(currentColor).alter(-step / 2);
  }
  return newColor.toHex();
}
function getLightness(color) {
  return color.r * 0.3 + color.g * 0.59 + color.b * 0.11;
}
function getDiscretePalette(source, size, themeDefaultPalette) {
  var palette = size > 0 ? createDiscreteColors(getPalette(source, {
    type: 'gradientSet',
    themeDefault: themeDefaultPalette
  }), size) : [];
  return {
    getColor: function getColor(index) {
      return palette[index] || null;
    }
  };
}
function createDiscreteColors(source, count) {
  var colorCount = count - 1;
  var sourceCount = source.length - 1;
  var colors = [];
  var gradient = [];
  var i;
  function addColor(pos) {
    var k = sourceCount * pos;
    var kl = _floor(k);
    var kr = _ceil(k);
    gradient.push(colors[kl].blend(colors[kr], k - kl).toHex());
  }
  for (i = 0; i <= sourceCount; ++i) {
    colors.push(new _color.default(source[i]));
  }
  if (colorCount > 0) {
    for (i = 0; i <= colorCount; ++i) {
      addColor(i / colorCount);
    }
  } else {
    addColor(0.5);
  }
  return gradient;
}
function getGradientPalette(source, themeDefaultPalette) {
  // TODO: Looks like some new set is going to be added
  var palette = getPalette(source, {
    type: 'gradientSet',
    themeDefault: themeDefaultPalette
  });
  var color1 = new _color.default(palette[0]);
  var color2 = new _color.default(palette[1]);
  return {
    getColor: function getColor(ratio) {
      return 0 <= ratio && ratio <= 1 ? color1.blend(color2, ratio).toHex() : null;
    }
  };
}

/***/ }),

/***/ 72111:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_pie_chart = _interopRequireDefault(__webpack_require__(88647));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _m_pie_chart.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 80919:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _m_polar_chart = _interopRequireDefault(__webpack_require__(86139));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _m_polar_chart.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 82879:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _range_selector = _interopRequireDefault(__webpack_require__(91009));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _range_selector.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 11378:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.utils = exports.formatValue = exports.consts = exports.HEIGHT_COMPACT_MODE = void 0;
var _smart_formatter = __webpack_require__(41583);
var _type = __webpack_require__(35922);
var HEIGHT_COMPACT_MODE = 24;
exports.HEIGHT_COMPACT_MODE = HEIGHT_COMPACT_MODE;
var POINTER_SIZE = 4;
var EMPTY_SLIDER_MARKER_TEXT = '. . .';
var utils = {
  trackerSettings: {
    fill: 'grey',
    stroke: 'grey',
    opacity: 0.0001
  },
  animationSettings: {
    duration: 250
  }
};
exports.utils = utils;
var consts = {
  emptySliderMarkerText: EMPTY_SLIDER_MARKER_TEXT,
  pointerSize: POINTER_SIZE
};
exports.consts = consts;
var formatValue = function formatValue(value, formatOptions, tickIntervalsInfo, valueType, type, logarithmBase) {
  var formatObject = {
    value: value,
    valueText: (0, _smart_formatter.smartFormatter)(value, {
      labelOptions: formatOptions,
      ticks: tickIntervalsInfo ? tickIntervalsInfo.ticks : [],
      tickInterval: tickIntervalsInfo ? tickIntervalsInfo.tickInterval : undefined,
      dataType: valueType,
      type: type,
      logarithmBase: logarithmBase
    })
  };
  return String((0, _type.isFunction)(formatOptions.customizeText) ? formatOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText);
};
exports.formatValue = formatValue;

/***/ }),

/***/ 91009:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _type2 = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _math = __webpack_require__(60810);
var _range = __webpack_require__(21177);
var _base_axis = __webpack_require__(41278);
var _parse_utils = __webpack_require__(8587);
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _common = __webpack_require__(11378);
var _sliders_controller = __webpack_require__(56481);
var _tracker = __webpack_require__(43695);
var _range_view = __webpack_require__(25104);
var _series_data_source = __webpack_require__(79302);
var _tick_generator = __webpack_require__(45971);
var _axes_constants = _interopRequireDefault(__webpack_require__(53805));
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _loading_indicator = __webpack_require__(64758);
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _max = Math.max;
var _ceil = Math.ceil;
var _floor = Math.floor;
var START_VALUE = 'startValue';
var END_VALUE = 'endValue';
var DATETIME = 'datetime';
var VALUE = 'value';
var DISCRETE = 'discrete';
var SEMIDISCRETE = 'semidiscrete';
var STRING = 'string';
var VALUE_CHANGED = VALUE + 'Changed';
var CONTAINER_BACKGROUND_COLOR = 'containerBackgroundColor';
var SLIDER_MARKER = 'sliderMarker';
var OPTION_BACKGROUND = 'background';
var LOGARITHMIC = 'logarithmic';
var KEEP = 'keep';
var SHIFT = 'shift';
var RESET = 'reset';
var INVISIBLE_POS = -1000;
var SEMIDISCRETE_GRID_SPACING_FACTOR = 50;
var DEFAULT_AXIS_DIVISION_FACTOR = 30;
var DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;
var logarithmBase = 10;
function calculateMarkerHeight(renderer, value, sliderMarkerOptions) {
  var formattedText = value === undefined ? _common.consts.emptySliderMarkerText : (0, _common.formatValue)(value, sliderMarkerOptions);
  var textBBox = getTextBBox(renderer, formattedText, sliderMarkerOptions.font);
  return _ceil(textBBox.height) + 2 * sliderMarkerOptions.paddingTopBottom + _common.consts.pointerSize;
}
function calculateScaleLabelHalfWidth(renderer, value, scaleOptions, tickIntervalsInfo) {
  var formattedText = (0, _common.formatValue)(value, scaleOptions.label, tickIntervalsInfo, scaleOptions.valueType, scaleOptions.type, scaleOptions.logarithmBase);
  var textBBox = getTextBBox(renderer, formattedText, scaleOptions.label.font);
  return _ceil(textBBox.width / 2);
}
function calculateIndents(renderer, scale, sliderMarkerOptions, indentOptions, tickIntervalsInfo) {
  var leftMarkerHeight;
  var leftScaleLabelWidth = 0;
  var rightScaleLabelWidth = 0;
  var rightMarkerHeight;
  var placeholderWidthLeft;
  var placeholderWidthRight;
  var placeholderHeight;
  var ticks = scale.type === 'semidiscrete' ? scale.customTicks : tickIntervalsInfo.ticks;
  var startTickValue;
  var endTickValue;
  indentOptions = indentOptions || {};
  placeholderWidthLeft = indentOptions.left;
  placeholderWidthRight = indentOptions.right;
  placeholderHeight = sliderMarkerOptions.placeholderHeight;
  if (sliderMarkerOptions.visible) {
    leftMarkerHeight = calculateMarkerHeight(renderer, scale.startValue, sliderMarkerOptions);
    rightMarkerHeight = calculateMarkerHeight(renderer, scale.endValue, sliderMarkerOptions);
    if (placeholderHeight === undefined) {
      placeholderHeight = _max(leftMarkerHeight, rightMarkerHeight);
    }
  }
  if (scale.label.visible) {
    startTickValue = (0, _type2.isDefined)(scale.startValue) ? ticks[0] : undefined;
    endTickValue = (0, _type2.isDefined)(scale.endValue) ? ticks[ticks.length - 1] : undefined;
    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, startTickValue, scale, tickIntervalsInfo);
    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, endTickValue, scale, tickIntervalsInfo);
  }
  placeholderWidthLeft = placeholderWidthLeft !== undefined ? placeholderWidthLeft : leftScaleLabelWidth;
  placeholderWidthRight = (placeholderWidthRight !== undefined ? placeholderWidthRight : rightScaleLabelWidth) || 1; // T240698

  return {
    left: placeholderWidthLeft,
    right: placeholderWidthRight,
    top: placeholderHeight || 0,
    bottom: 0
  };
}
function calculateValueType(firstValue, secondValue) {
  var typeFirstValue = (0, _type2.type)(firstValue);
  var typeSecondValue = (0, _type2.type)(secondValue);
  var validType = function validType(type) {
    return typeFirstValue === type || typeSecondValue === type;
  };
  return validType('date') ? DATETIME : validType('number') ? 'numeric' : validType(STRING) ? STRING : '';
}
function showScaleMarkers(scaleOptions) {
  return scaleOptions.valueType === DATETIME && scaleOptions.marker.visible;
}
function updateTranslatorRangeInterval(translatorRange, scaleOptions) {
  var intervalX = scaleOptions.minorTickInterval || scaleOptions.tickInterval;
  if (scaleOptions.valueType === 'datetime') {
    intervalX = _date.default.dateToMilliseconds(intervalX);
  }
  translatorRange.addRange({
    interval: intervalX
  });
}
function checkLogarithmicOptions(options, defaultLogarithmBase, incidentOccurred) {
  if (!options) {
    return;
  }
  var logarithmBase = options.logarithmBase;
  if (options.type === LOGARITHMIC && logarithmBase <= 0 || logarithmBase && !(0, _type2.isNumeric)(logarithmBase)) {
    options.logarithmBase = defaultLogarithmBase;
    incidentOccurred('E2104');
  } else if (options.type !== LOGARITHMIC) {
    options.logarithmBase = undefined;
  }
}
function calculateScaleAreaHeight(renderer, scaleOptions, visibleMarkers, tickIntervalsInfo) {
  var labelScaleOptions = scaleOptions.label;
  var markerScaleOptions = scaleOptions.marker;
  var placeholderHeight = scaleOptions.placeholderHeight;
  var ticks = scaleOptions.type === 'semidiscrete' ? scaleOptions.customTicks : tickIntervalsInfo.ticks;
  var text = (0, _common.formatValue)(ticks[0], labelScaleOptions);
  if (placeholderHeight) {
    return placeholderHeight;
  } else {
    return (labelScaleOptions.visible ? labelScaleOptions.topIndent + getTextBBox(renderer, text, labelScaleOptions.font).height : 0) + (visibleMarkers ? markerScaleOptions.topIndent + markerScaleOptions.separatorHeight : 0);
  }
}
function getMinorTickIntervalUnit(tickInterval, minorTickInterval, withCorrection) {
  var interval = _date.default.getDateUnitInterval(minorTickInterval);
  var majorUnit = _date.default.getDateUnitInterval(tickInterval);
  var idx = _date.default.dateUnitIntervals.indexOf(interval);
  if (withCorrection && interval === majorUnit && idx > 0) {
    interval = _date.default.dateUnitIntervals[idx - 1];
  }
  return interval;
}
function getNextTickInterval(tickInterval, minorTickInterval, isDateType) {
  if (!tickInterval) {
    tickInterval = minorTickInterval;
  } else {
    if (isDateType) {
      tickInterval = _date.default.getNextDateUnit(tickInterval);
    } else {
      tickInterval += minorTickInterval;
    }
  }
  return tickInterval;
}
function calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta) {
  var minorTickInterval = scaleOptions.minorTickInterval;
  var tickInterval = scaleOptions.tickInterval;
  var interval;
  var isDateType = scaleOptions.valueType === 'datetime';
  var gridSpacingFactor = scaleOptions.axisDivisionFactor || {};
  var tickCountByInterval;
  var tickCountByScreen;
  if (!tickInterval) {
    do {
      interval = getNextTickInterval(tickInterval, minorTickInterval, isDateType);
      if (tickInterval !== interval) {
        tickInterval = interval;
      } else {
        break;
      }
      if (isDateType) {
        interval = _date.default.dateToMilliseconds(tickInterval);
      }
      tickCountByInterval = _ceil((max - min) / interval);
      tickCountByScreen = _floor(screenDelta / (gridSpacingFactor[tickInterval] || SEMIDISCRETE_GRID_SPACING_FACTOR)) || 1;
    } while (interval && tickCountByInterval > tickCountByScreen);
  }
  return {
    tickInterval: tickInterval,
    minorTickInterval: minorTickInterval,
    bounds: {
      minVisible: min,
      maxVisible: max
    },
    ticks: []
  };
}
function updateTickIntervals(scaleOptions, screenDelta, incidentOccurred, range) {
  var result;
  var min = (0, _type2.isDefined)(range.minVisible) ? range.minVisible : range.min;
  var max = (0, _type2.isDefined)(range.maxVisible) ? range.maxVisible : range.max;
  var categoriesInfo = scaleOptions._categoriesInfo;
  var ticksInfo;
  var length;
  var bounds = {};
  if (scaleOptions.type === SEMIDISCRETE) {
    result = calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta);
  } else {
    ticksInfo = (0, _tick_generator.tickGenerator)({
      axisType: scaleOptions.type,
      dataType: scaleOptions.valueType,
      logBase: scaleOptions.logarithmBase,
      allowNegatives: true,
      linearThreshold: Math.abs(scaleOptions.linearThreshold || 0),
      axisDivisionFactor: scaleOptions.axisDivisionFactor,
      minorAxisDivisionFactor: scaleOptions.minorAxisDivisionFactor,
      calculateMinors: true,
      allowDecimals: scaleOptions.allowDecimals,
      endOnTick: scaleOptions.endOnTick,
      incidentOccurred: incidentOccurred,
      rangeIsEmpty: range.isEmpty()
    })({
      min: min,
      max: max,
      categories: (0, _type2.isDefined)(categoriesInfo) ? categoriesInfo.categories : []
    }, screenDelta, scaleOptions.tickInterval, scaleOptions.forceUserTickInterval, undefined, scaleOptions.minorTickInterval, scaleOptions.minorTickCount);
    length = ticksInfo.ticks.length;
    bounds.minVisible = ticksInfo.ticks[0] < min ? ticksInfo.ticks[0] : min;
    bounds.maxVisible = ticksInfo.ticks[length - 1] > max ? ticksInfo.ticks[length - 1] : max;
    result = {
      tickInterval: ticksInfo.tickInterval,
      minorTickInterval: scaleOptions.minorTickInterval === 0 ? 0 : ticksInfo.minorTickInterval,
      bounds: bounds,
      ticks: ticksInfo.ticks
    };
  }
  return result;
}
function getFirstDayOfWeek(options) {
  var _options$workWeek;
  return (_options$workWeek = options.workWeek) === null || _options$workWeek === void 0 ? void 0 : _options$workWeek[0];
}
function calculateTranslatorRange(seriesDataSource, scaleOptions) {
  var minValue;
  var maxValue;
  var inverted = false;
  var startValue = scaleOptions.startValue;
  var endValue = scaleOptions.endValue;
  var categories;
  var categoriesInfo;
  // TODO: There should be something like "seriesDataSource.getArgumentRange()"
  var translatorRange = seriesDataSource ? seriesDataSource.getBoundRange().arg : new _range.Range();
  var rangeForCategories;
  var isDate = scaleOptions.valueType === 'datetime';
  var firstDayOfWeek = getFirstDayOfWeek(scaleOptions);
  var minRange = scaleOptions.minRange;
  if (scaleOptions.type === DISCRETE) {
    rangeForCategories = new _range.Range({
      minVisible: startValue,
      maxVisible: endValue
    });
    rangeForCategories.addRange(translatorRange);
    translatorRange = rangeForCategories;
    categories = seriesDataSource ? seriesDataSource.argCategories : scaleOptions.categories || startValue && endValue && [startValue, endValue];
    categories = categories || [];
    scaleOptions._categoriesInfo = categoriesInfo = (0, _utils.getCategoriesInfo)(categories, startValue, endValue);
  }
  if (scaleOptions.type === SEMIDISCRETE) {
    startValue = scaleOptions.startValue = correctValueByInterval(scaleOptions.startValue, isDate, minRange, firstDayOfWeek);
    endValue = scaleOptions.endValue = correctValueByInterval(scaleOptions.endValue, isDate, minRange, firstDayOfWeek);
    translatorRange.minVisible = correctValueByInterval(translatorRange.minVisible, isDate, minRange, firstDayOfWeek);
    translatorRange.maxVisible = correctValueByInterval(translatorRange.maxVisible, isDate, minRange, firstDayOfWeek);
    translatorRange.min = correctValueByInterval(translatorRange.min, isDate, minRange, firstDayOfWeek);
    translatorRange.max = correctValueByInterval(translatorRange.max, isDate, minRange, firstDayOfWeek);
  }
  if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
    inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;
    minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;
    maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue;
  } else if ((0, _type2.isDefined)(startValue) || (0, _type2.isDefined)(endValue)) {
    minValue = startValue;
    maxValue = endValue;
  } else if (categoriesInfo) {
    minValue = categoriesInfo.start;
    maxValue = categoriesInfo.end;
  }
  translatorRange.addRange({
    invert: inverted,
    min: minValue,
    max: maxValue,
    minVisible: minValue,
    maxVisible: maxValue,
    dataType: scaleOptions.valueType
  });
  translatorRange.addRange({
    categories: !seriesDataSource ? categories : undefined,
    base: scaleOptions.logarithmBase,
    axisType: scaleOptions.type,
    dataType: scaleOptions.valueType
  });
  seriesDataSource && translatorRange.sortCategories(categories);
  return translatorRange;
}
function startEndNotDefined(start, end) {
  return !(0, _type2.isDefined)(start) || !(0, _type2.isDefined)(end);
}
function getTextBBox(renderer, text, fontOptions) {
  var textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
  var textBBox = textElement.getBBox();
  textElement.remove();
  return textBBox;
}
function getDateMarkerVisibilityChecker(screenDelta) {
  return function (isDateScale, isMarkerVisible, min, max, tickInterval) {
    if (isMarkerVisible && isDateScale) {
      if (!(0, _type2.isDefined)(tickInterval) || tickInterval.years || tickInterval.months >= 6 || screenDelta / SEMIDISCRETE_GRID_SPACING_FACTOR < _ceil((max - min) / _date.default.dateToMilliseconds('year')) + 1) {
        isMarkerVisible = false;
      }
    }
    return isMarkerVisible;
  };
}
function updateScaleOptions(scaleOptions, seriesDataSource, translatorRange, tickIntervalsInfo, checkDateMarkerVisibility) {
  var bounds;
  var isEmptyInterval;
  var categoriesInfo = scaleOptions._categoriesInfo;
  var intervals;
  var isDateTime = scaleOptions.valueType === DATETIME;
  if (seriesDataSource && !seriesDataSource.isEmpty() && !translatorRange.isEmpty()) {
    bounds = tickIntervalsInfo.bounds;
    translatorRange.addRange(bounds);
    scaleOptions.startValue = translatorRange.invert ? bounds.maxVisible : bounds.minVisible;
    scaleOptions.endValue = translatorRange.invert ? bounds.minVisible : bounds.maxVisible;
  }
  scaleOptions.marker.visible = checkDateMarkerVisibility(isDateTime && scaleOptions.type.indexOf(DISCRETE) === -1, scaleOptions.marker.visible, scaleOptions.startValue, scaleOptions.endValue, tickIntervalsInfo.tickInterval);
  if (categoriesInfo) {
    scaleOptions.startValue = categoriesInfo.start;
    scaleOptions.endValue = categoriesInfo.end;
  }
  if (scaleOptions.type.indexOf(DISCRETE) === -1) {
    isEmptyInterval = (0, _type2.isDate)(scaleOptions.startValue) && (0, _type2.isDate)(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue;
  }
  scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;
  if (scaleOptions.isEmpty) {
    scaleOptions.startValue = scaleOptions.endValue = undefined;
  } else {
    scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;
    scaleOptions.tickInterval = tickIntervalsInfo.tickInterval;
    if (isDateTime && (!(0, _type2.isDefined)(scaleOptions.label.format) || scaleOptions.type === SEMIDISCRETE && scaleOptions.minorTickInterval !== scaleOptions.tickInterval)) {
      if (scaleOptions.type === DISCRETE) {
        scaleOptions.label.format = _format_helper.default.getDateFormatByTicks(tickIntervalsInfo.ticks);
      } else {
        if (!scaleOptions.marker.visible) {
          scaleOptions.label.format = _format_helper.default.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.tickInterval);
        } else {
          scaleOptions.label.format = _date.default.getDateFormatByTickInterval(scaleOptions.tickInterval);
        }
      }
    }
  }
  if (scaleOptions.type === SEMIDISCRETE) {
    intervals = getIntervalCustomTicks(scaleOptions);
    scaleOptions.customMinorTicks = intervals.altIntervals;
    scaleOptions.customTicks = intervals.intervals;
    scaleOptions.customBoundTicks = [scaleOptions.customTicks[0]];
  }
}
function prepareScaleOptions(scaleOption, calculatedValueType, incidentOccurred, containerColor) {
  var parsedValue = 0;
  var valueType = (0, _parse_utils.correctValueType)((0, _utils.normalizeEnum)(scaleOption.valueType));
  var validateStartEndValues = function validateStartEndValues(field, parser) {
    var messageToIncidentOccurred = field === START_VALUE ? 'start' : 'end';
    if ((0, _type2.isDefined)(scaleOption[field])) {
      parsedValue = parser(scaleOption[field]);
      if ((0, _type2.isDefined)(parsedValue)) {
        scaleOption[field] = parsedValue;
      } else {
        scaleOption[field] = undefined;
        incidentOccurred('E2202', [messageToIncidentOccurred]);
      }
    }
  };
  valueType = calculatedValueType || valueType;
  if (!valueType) {
    valueType = calculateValueType(scaleOption.startValue, scaleOption.endValue) || 'numeric';
  }
  if (valueType === STRING || scaleOption.categories) {
    scaleOption.type = DISCRETE;
    valueType = STRING;
  }
  scaleOption.containerColor = containerColor;
  scaleOption.valueType = valueType;
  scaleOption.dataType = valueType;
  var parser = (0, _parse_utils.getParser)(valueType);
  validateStartEndValues(START_VALUE, parser);
  validateStartEndValues(END_VALUE, parser);
  checkLogarithmicOptions(scaleOption, logarithmBase, incidentOccurred);
  if (!scaleOption.type) {
    scaleOption.type = 'continuous';
  }
  scaleOption.parser = parser;
  if (scaleOption.type === SEMIDISCRETE) {
    scaleOption.minorTick.visible = false;
    scaleOption.minorTickInterval = scaleOption.minRange;
    scaleOption.marker.visible = false;
    scaleOption.maxRange = undefined;
  }
  scaleOption.forceUserTickInterval |= (0, _type2.isDefined)(scaleOption.tickInterval) && !(0, _type2.isDefined)(scaleOption.axisDivisionFactor);
  scaleOption.axisDivisionFactor = (0, _type2.isDefined)(scaleOption.axisDivisionFactor) ? scaleOption.axisDivisionFactor : DEFAULT_AXIS_DIVISION_FACTOR;
  scaleOption.minorAxisDivisionFactor = (0, _type2.isDefined)(scaleOption.minorAxisDivisionFactor) ? scaleOption.minorAxisDivisionFactor : DEFAULT_MINOR_AXIS_DIVISION_FACTOR;
  return scaleOption;
}
function correctValueByInterval(value, isDate, interval, firstDayOfWeek) {
  if ((0, _type2.isDefined)(value)) {
    value = isDate ? _date.default.correctDateWithUnitBeginning(new Date(value), interval, null, firstDayOfWeek) : (0, _math.adjust)(_floor((0, _math.adjust)(value / interval)) * interval);
  }
  return value;
}
function getIntervalCustomTicks(options) {
  var min = options.startValue;
  var max = options.endValue;
  var isDate = options.valueType === 'datetime';
  var firstDayOfWeek = getFirstDayOfWeek(options);
  var tickInterval = options.tickInterval;
  var res = {
    intervals: []
  };
  if (!(0, _type2.isDefined)(min) || !(0, _type2.isDefined)(max)) {
    return res;
  }
  res.intervals = _date.default.getSequenceByInterval(min, max, options.minorTickInterval);
  if (tickInterval !== options.minorTickInterval) {
    res.altIntervals = res.intervals;
    min = correctValueByInterval(min, isDate, tickInterval, firstDayOfWeek);
    max = correctValueByInterval(max, isDate, tickInterval, firstDayOfWeek);
    res.intervals = _date.default.getSequenceByInterval(min, max, tickInterval);
    res.intervals[0] = res.altIntervals[0];
  }
  return res;
}
function getPrecisionForSlider(startValue, endValue, screenDelta) {
  var d = Math.abs(endValue - startValue) / screenDelta;
  var tail = d - _floor(d);
  return tail > 0 ? _ceil(Math.abs((0, _math.adjust)((0, _utils.getLog)(tail, 10)))) : 0;
}
var dxRangeSelector = _m_base_widget.default.inherit({
  _toggleParentsScrollSubscription() {},
  _eventsMap: {
    'onValueChanged': {
      name: VALUE_CHANGED
    }
  },
  _rootClassPrefix: 'dxrs',
  _rootClass: 'dxrs-range-selector',
  _dataIsReady: function _dataIsReady() {
    return this._dataIsLoaded();
  },
  _initialChanges: ['DATA_SOURCE', 'VALUE'],
  _themeDependentChanges: ['MOSTLY_TOTAL'],
  _themeSection: 'rangeSelector',
  _fontFields: ['scale.label.font', 'sliderMarker.font'],
  _setDeprecatedOptions() {
    this.callBase();
    (0, _extend.extend)(this._deprecatedOptions, {
      'behavior.callValueChanged': {
        since: '23.1',
        message: 'Use the "behavior.valueChangeMode" property instead'
      },
      'scale.aggregateByCategory': {
        since: '23.1',
        message: 'Use the aggregation.enabled property'
      }
    });
  },
  _initCore: function _initCore() {
    var that = this;
    var renderer = that._renderer;
    var root = renderer.root;

    // TODO: Move it to the SlidersEventManager
    root.css({
      'touch-action': 'pan-y'
    });

    // RangeContainer
    that._clipRect = renderer.clipRect(); // TODO: Try to remove it
    // TODO: Groups could be created by the corresponding components
    var rangeViewGroup = renderer.g().attr({
      'class': 'dxrs-view'
    }).append(root);
    var slidersGroup = renderer.g().attr({
      'class': 'dxrs-slidersContainer',
      'clip-path': that._clipRect.id
    }).append(root);
    var scaleGroup = renderer.g().attr({
      'class': 'dxrs-scale',
      'clip-path': that._clipRect.id
    }).append(root);
    var labelsAxesGroup = renderer.g().attr({
      'class': 'dxrs-scale-elements',
      'clip-path': that._clipRect.id
    }).append(root);
    var scaleBreaksGroup = renderer.g().attr({
      'class': 'dxrs-scale-breaks'
    }).append(root);
    var trackersGroup = renderer.g().attr({
      'class': 'dxrs-trackers'
    }).append(root);
    that._axis = new AxisWrapper({
      renderer: renderer,
      root: scaleGroup,
      scaleBreaksGroup: scaleBreaksGroup,
      labelsAxesGroup: labelsAxesGroup,
      updateSelectedRange: function updateSelectedRange(range, e) {
        that.setValue((0, _utils.convertVisualRangeObject)(range), e);
      },
      incidentOccurred: that._incidentOccurred
    });
    that._rangeView = new _range_view.RangeView({
      renderer: renderer,
      root: rangeViewGroup,
      translator: that._axis.getTranslator()
    });
    that._slidersController = new _sliders_controller.SlidersController({
      renderer: renderer,
      root: slidersGroup,
      trackersGroup: trackersGroup,
      updateSelectedRange: function updateSelectedRange(range, lastSelectedRange, e) {
        if (!that._rangeOption) {
          that.option(VALUE, (0, _utils.convertVisualRangeObject)(range, (0, _type2.isPlainObject)(that._options.silent(VALUE))));
        }
        that._eventTrigger(VALUE_CHANGED, {
          value: (0, _utils.convertVisualRangeObject)(range),
          previousValue: (0, _utils.convertVisualRangeObject)(lastSelectedRange),
          event: e
        });
      },
      axis: that._axis,
      translator: that._axis.getTranslator()
    });
    that._tracker = new _tracker.Tracker({
      renderer: renderer,
      controller: that._slidersController
    });
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 160
    };
  },
  _disposeCore: function _disposeCore() {
    this._axis.dispose();
    this._slidersController.dispose();
    this._tracker.dispose();
  },
  _applySize: function _applySize(rect) {
    this._clientRect = rect.slice();
    this._change(['MOSTLY_TOTAL']);
  },
  _optionChangesMap: {
    scale: 'SCALE',
    value: 'VALUE',
    dataSource: 'DATA_SOURCE'
  },
  _optionChangesOrder: ['SCALE', 'DATA_SOURCE'],
  _change_SCALE: function _change_SCALE() {
    this._change(['MOSTLY_TOTAL']);
  },
  _setValueByDataSource() {
    var that = this;
    var options = that._options.silent();
    var axis = that._axis;
    if (options.dataSource) {
      var selectedRangeUpdateMode = that.option('selectedRangeUpdateMode');
      var value = that.getValue();
      var valueIsReady = (0, _type2.isDefined)(value[0]) && (0, _type2.isDefined)(value[1]);
      if ((0, _type2.isDefined)(selectedRangeUpdateMode)) {
        selectedRangeUpdateMode = (0, _utils.normalizeEnum)(selectedRangeUpdateMode);
        that.__skipAnimation = true;
      } else if (valueIsReady && !that._dataSourceIsAsync) {
        // T696409 T930471
        selectedRangeUpdateMode = RESET;
      }
      if (selectedRangeUpdateMode === 'auto' && valueIsReady) {
        var rangesInfo = axis.allScaleSelected(value);
        if (rangesInfo.startValue && rangesInfo.endValue) {
          selectedRangeUpdateMode = RESET;
        } else if (rangesInfo.endValue) {
          selectedRangeUpdateMode = SHIFT;
        } else {
          selectedRangeUpdateMode = KEEP;
        }
      }
      if (selectedRangeUpdateMode === RESET) {
        options[VALUE] = null;
      } else if (selectedRangeUpdateMode === SHIFT && valueIsReady) {
        var _value = that.getValue();
        that.__skipAnimation = true;
        options[VALUE] = {
          length: axis.getVisualRangeLength({
            minVisible: _value[0],
            maxVisible: _value[1]
          })
        };
      } else if (selectedRangeUpdateMode === KEEP) {
        that.__skipAnimation = true;
      }
    }
    that._dataSourceIsAsync = undefined;
  },
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    if (this._options.silent('dataSource')) {
      this._updateDataSource();
    }
  },
  _customChangesOrder: ['MOSTLY_TOTAL', 'VALUE', 'SLIDER_SELECTION'],
  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {
    this._applyMostlyTotalChange();
  },
  _change_SLIDER_SELECTION: function _change_SLIDER_SELECTION() {
    var that = this;
    var value = that._options.silent(VALUE);
    that._slidersController.setSelectedRange(value && (0, _utils.getVizRangeObject)(value));
  },
  _change_VALUE: function _change_VALUE() {
    var that = this;
    var option = that._rangeOption;
    that._dataSourceIsAsync = !that._dataIsReady();
    if (option) {
      that._options.silent(VALUE, option);
      that.setValue(option);
    }
  },
  _validateRange: function _validateRange(start, end) {
    var _this = this;
    var ensureValueInvalid = function ensureValueInvalid(value) {
      return (0, _type2.isDefined)(value) && !_this._axis.getTranslator().isValid(value);
    };
    if (this._dataIsReady() && (ensureValueInvalid(start) || ensureValueInvalid(end))) {
      this._incidentOccurred('E2203');
    }
  },
  _applyChanges: function _applyChanges() {
    var that = this;
    var value = that._options.silent(VALUE);
    if (that._changes.has('VALUE') && value) {
      that._rangeOption = value;
    }
    that.callBase.apply(that, arguments);
    that._rangeOption = null;
    that.__isResizing = that.__skipAnimation = false;
  },
  _applyMostlyTotalChange: function _applyMostlyTotalChange() {
    var that = this;
    var renderer = that._renderer;
    var rect = that._clientRect;
    var currentAnimationEnabled;
    var canvas = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };
    if (that.__isResizing || that.__skipAnimation) {
      currentAnimationEnabled = renderer.animationEnabled();
      renderer.updateAnimationOptions({
        enabled: false
      });
    }
    that._clipRect.attr({
      x: rect[0],
      y: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    });
    that._axis.getTranslator().update(new _range.Range(), canvas, {
      isHorizontal: true
    });
    that._updateContent({
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    });
    if (that.__isResizing || that.__skipAnimation) {
      renderer.updateAnimationOptions({
        enabled: currentAnimationEnabled
      });
    }
    that._drawn();
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._setValueByDataSource();
    this._requestChange(['MOSTLY_TOTAL']);
  },
  // It seems that we REALLY like to translate option structures from one form to another.
  // TODO: The more appropriate way is the following:
  // that._rangeView.update([
  //     that._getOption("background"),
  //     that._getOption("chart"),
  //     that.option("dataSource")
  // ]);
  // that._slidersController.update([
  //     that._getOption("sliderHandle"),
  //     that._getOption("sliderMarker"),
  //     that._getOption("shutter"),
  //     that._getOption("behavior")
  // ]);
  // that._axis.update(that._getOption("scale"));
  _completeSeriesDataSourceCreation(scaleOptions, seriesDataSource) {
    var rect = this._clientRect;
    var canvas = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };
    this._axis.updateOptions((0, _extend.extend)({}, scaleOptions, {
      isHorizontal: true,
      label: {}
    }));
    seriesDataSource.isShowChart() && this._axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));
    this._axis.updateCanvas(canvas);
    seriesDataSource.createPoints();
  },
  _updateContent: function _updateContent(canvas) {
    var that = this;
    var chartOptions = that.option('chart');
    var seriesDataSource = that._createSeriesDataSource(chartOptions);
    var isCompactMode = !(seriesDataSource && seriesDataSource.isShowChart() || that.option('background.image.url'));
    var scaleOptions = prepareScaleOptions(that._getOption('scale'), seriesDataSource && seriesDataSource.getCalculatedValueType(), that._incidentOccurred, this._getOption('containerBackgroundColor', true));
    seriesDataSource && that._completeSeriesDataSourceCreation(scaleOptions, seriesDataSource);
    var argTranslatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions);
    var tickIntervalsInfo = updateTickIntervals(scaleOptions, canvas.width, that._incidentOccurred, argTranslatorRange);
    var chartThemeManager = seriesDataSource && seriesDataSource.isShowChart() && seriesDataSource.getThemeManager();
    if (chartThemeManager) {
      // TODO: Looks like usage of "chartThemeManager" can be replaced with "that._getOption("chart").valueAxis.logarithmBase - check it
      checkLogarithmicOptions(chartOptions && chartOptions.valueAxis, chartThemeManager.getOptions('valueAxis').logarithmBase, that._incidentOccurred);
    }
    updateScaleOptions(scaleOptions, seriesDataSource, argTranslatorRange, tickIntervalsInfo, getDateMarkerVisibilityChecker(canvas.width));
    updateTranslatorRangeInterval(argTranslatorRange, scaleOptions);
    var sliderMarkerOptions = that._prepareSliderMarkersOptions(scaleOptions, canvas.width, tickIntervalsInfo, argTranslatorRange);
    var indents = calculateIndents(that._renderer, scaleOptions, sliderMarkerOptions, that.option('indent'), tickIntervalsInfo);
    var rangeContainerCanvas = {
      left: canvas.left + indents.left,
      top: canvas.top + indents.top,
      width: canvas.left + indents.left + _max(canvas.width - indents.left - indents.right, 1),
      height: _max(!isCompactMode ? canvas.height - indents.top - indents.bottom - calculateScaleAreaHeight(that._renderer, scaleOptions, showScaleMarkers(scaleOptions), tickIntervalsInfo) : _common.HEIGHT_COMPACT_MODE, 0),
      right: 0,
      bottom: 0
    };

    // TODO: There should be one call to some axis method (not 4 methods)
    that._axis.update(scaleOptions, isCompactMode, rangeContainerCanvas, argTranslatorRange, seriesDataSource);
    scaleOptions.minorTickInterval = scaleOptions.isEmpty ? 0 : scaleOptions.minorTickInterval;

    // RangeContainer
    that._updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, rangeContainerCanvas, seriesDataSource);
    if (chartThemeManager) {
      chartThemeManager.dispose(); // TODO: Move it inside "SeriesDataSource"
    }
  },

  _updateElements: function _updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, canvas, seriesDataSource) {
    var that = this;
    var behavior = that._getOption('behavior');
    var shutterOptions = that._getOption('shutter');
    var isNotSemiDiscrete = scaleOptions.type !== SEMIDISCRETE;
    shutterOptions.color = shutterOptions.color || that._getOption(CONTAINER_BACKGROUND_COLOR, true);
    that._rangeView.update(that.option('background'), that._themeManager.theme('background'), canvas, isCompactMode, behavior.animationEnabled && that._renderer.animationEnabled(), seriesDataSource);

    // TODO: Is entire options bag really needed for SlidersContainer?
    that._isUpdating = true;
    that._slidersController.update([canvas.top, canvas.top + canvas.height], behavior, isCompactMode, that._getOption('sliderHandle'), sliderMarkerOptions, shutterOptions, {
      minRange: isNotSemiDiscrete ? that.option('scale.minRange') : undefined,
      maxRange: isNotSemiDiscrete ? that.option('scale.maxRange') : undefined
    }, that._axis.getFullTicks(), that._getOption('selectedRangeColor', true));
    that._requestChange(['SLIDER_SELECTION']);
    that._isUpdating = false;
    that._tracker.update(!that._axis.getTranslator().getBusinessRange().isEmpty(), behavior);
  },
  _createSeriesDataSource: function _createSeriesDataSource(chartOptions) {
    var that = this;
    var seriesDataSource;
    var dataSource = that._dataSourceItems(); // TODO: This code can be executed when data source is not loaded (it is an error)!
    var scaleOptions = that._getOption('scale');
    var valueType = scaleOptions.valueType || calculateValueType(scaleOptions.startValue, scaleOptions.endValue);
    var valueAxis = new _base_axis.Axis({
      renderer: that._renderer,
      axisType: 'xyAxes',
      drawingType: 'linear'
    });
    valueAxis.updateOptions({
      isHorizontal: false,
      label: {},
      categoriesSortingMethod: that._getOption('chart').valueAxis.categoriesSortingMethod
    });
    if (dataSource || chartOptions && chartOptions.series) {
      chartOptions = (0, _extend.extend)({}, chartOptions, {
        theme: that.option('theme')
      });
      seriesDataSource = new _series_data_source.SeriesDataSource({
        renderer: that._renderer,
        dataSource: dataSource,
        valueType: (0, _utils.normalizeEnum)(valueType),
        axisType: scaleOptions.type,
        chart: chartOptions,
        dataSourceField: that.option('dataSourceField'),
        incidentOccurred: that._incidentOccurred,
        categories: scaleOptions.categories,
        argumentAxis: that._axis,
        valueAxis: valueAxis
      });
    }
    return seriesDataSource;
  },
  _prepareSliderMarkersOptions: function _prepareSliderMarkersOptions(scaleOptions, screenDelta, tickIntervalsInfo, argRange) {
    var that = this;
    var minorTickInterval = tickIntervalsInfo.minorTickInterval;
    var tickInterval = tickIntervalsInfo.tickInterval;
    var interval = tickInterval;
    var endValue = scaleOptions.endValue;
    var startValue = scaleOptions.startValue;
    var sliderMarkerOptions = that._getOption(SLIDER_MARKER);
    var doNotSnap = !that._getOption('behavior').snapToTicks;
    var isTypeDiscrete = scaleOptions.type === DISCRETE;
    var isValueTypeDatetime = scaleOptions.valueType === DATETIME;
    sliderMarkerOptions.borderColor = that._getOption(CONTAINER_BACKGROUND_COLOR, true);
    if (!sliderMarkerOptions.format && !argRange.isEmpty()) {
      if (doNotSnap && (0, _type2.isNumeric)(scaleOptions.startValue)) {
        sliderMarkerOptions.format = {
          type: 'fixedPoint',
          precision: getPrecisionForSlider(startValue, endValue, screenDelta)
        };
      }
      if (isValueTypeDatetime && !isTypeDiscrete) {
        if ((0, _type2.isDefined)(minorTickInterval) && minorTickInterval !== 0) {
          interval = getMinorTickIntervalUnit(tickInterval, minorTickInterval, doNotSnap);
        }
        if (!scaleOptions.marker.visible) {
          if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {
            sliderMarkerOptions.format = _format_helper.default.getDateFormatByTickInterval(startValue, endValue, interval);
          }
        } else {
          sliderMarkerOptions.format = _date.default.getDateFormatByTickInterval(interval);
        }
      }
      // T347293
      if (isValueTypeDatetime && isTypeDiscrete && tickIntervalsInfo.ticks.length) {
        sliderMarkerOptions.format = _format_helper.default.getDateFormatByTicks(tickIntervalsInfo.ticks);
      }
    }
    return sliderMarkerOptions;
  },
  getValue: function getValue() {
    return (0, _utils.convertVisualRangeObject)(this._slidersController.getSelectedRange());
  },
  setValue: function setValue(value, e) {
    var visualRange = (0, _utils.getVizRangeObject)(value);
    if (!this._isUpdating && value) {
      this._validateRange(visualRange.startValue, visualRange.endValue);
      !(0, _utils.rangesAreEqual)(visualRange, this._slidersController.getSelectedRange()) && this._slidersController.setSelectedRange(visualRange, e);
    }
  },
  _setContentSize: function _setContentSize() {
    this.__isResizing = this._changes.count() === 2;
    this.callBase.apply(this, arguments);
  }
});
(0, _iterator.each)(['selectedRangeColor', 'containerBackgroundColor', 'sliderMarker', 'sliderHandle', 'shutter', OPTION_BACKGROUND, 'behavior', 'chart', 'indent'], function (_, name) {
  dxRangeSelector.prototype._optionChangesMap[name] = 'MOSTLY_TOTAL';
});

// AxisWrapper

function prepareAxisOptions(scaleOptions, isCompactMode, height, axisPosition) {
  scaleOptions.marker.label.font = scaleOptions.label.font;
  scaleOptions.color = scaleOptions.marker.color = scaleOptions.tick.color;
  scaleOptions.opacity = scaleOptions.marker.opacity = scaleOptions.tick.opacity;
  scaleOptions.width = scaleOptions.marker.width = scaleOptions.tick.width;
  scaleOptions.placeholderSize = (scaleOptions.placeholderHeight || 0) + axisPosition;
  scaleOptions.argumentType = scaleOptions.valueType;
  scaleOptions.visible = isCompactMode;
  scaleOptions.isHorizontal = true;
  scaleOptions.calculateMinors = true;
  scaleOptions.semiDiscreteInterval = scaleOptions.minRange;
  if (!isCompactMode) {
    scaleOptions.minorTick.length = scaleOptions.tick.length = height;
  }
  scaleOptions.label.indentFromAxis = scaleOptions.label.topIndent + axisPosition;
  return scaleOptions;
}
function createDateMarkersEvent(scaleOptions, markerTrackers, setSelectedRange) {
  (0, _iterator.each)(markerTrackers, function (_, value) {
    value.on('dxpointerdown', onPointerDown);
  });
  function onPointerDown(e) {
    var range = e.target.range;
    var minRange = scaleOptions.minRange ? _date.default.addInterval(range.startValue, scaleOptions.minRange) : undefined;
    var maxRange = scaleOptions.maxRange ? _date.default.addInterval(range.startValue, scaleOptions.maxRange) : undefined;
    if (!(minRange && minRange > range.endValue || maxRange && maxRange < range.endValue)) {
      setSelectedRange(range, e);
    }
  }
}
function getSharpDirection() {
  return 1;
}
function getTickStartPositionShift(length) {
  return length % 2 === 1 ? -_floor(length / 2) : -length / 2;
}
function checkShiftedLabels(majorTicks, boxes, minSpacing, alignment) {
  function checkLabelsOverlapping(nearestLabelsIndexes) {
    if (nearestLabelsIndexes.length === 2 && _axes_constants.default.areLabelsOverlap(boxes[nearestLabelsIndexes[0]], boxes[nearestLabelsIndexes[1]], minSpacing, alignment)) {
      majorTicks[nearestLabelsIndexes[0]].removeLabel();
    }
  }
  function getTwoVisibleLabels(startIndex) {
    var labels = [];
    for (var i = startIndex; labels.length < 2 && i < majorTicks.length; i++) {
      majorTicks[i].label && labels.push(i);
    }
    return labels;
  }
  if (majorTicks.length < 3) {
    return;
  }
  checkLabelsOverlapping(getTwoVisibleLabels(0));
  checkLabelsOverlapping(getTwoVisibleLabels(majorTicks.length - 2).reverse());
}
function AxisWrapper(params) {
  var that = this;
  that._axis = new _base_axis.Axis({
    renderer: params.renderer,
    axesContainerGroup: params.root,
    scaleBreaksGroup: params.scaleBreaksGroup,
    labelsAxesGroup: params.labelsAxesGroup,
    incidentOccurred: params.incidentOccurred,
    // TODO: These dependencies should be statically resolved (not for every new instance)
    axisType: 'xyAxes',
    drawingType: 'linear',
    widgetClass: 'dxrs',
    axisClass: 'range-selector',
    isArgumentAxis: true,
    getTemplate() {}
  });
  that._updateSelectedRangeCallback = params.updateSelectedRange;
  that._axis.getAxisSharpDirection = that._axis.getSharpDirectionByCoords = getSharpDirection;
  that._axis.getTickStartPositionShift = getTickStartPositionShift;
  that._axis._checkShiftedLabels = checkShiftedLabels;
}
AxisWrapper.prototype = {
  constructor: AxisWrapper,
  update: function update(options, isCompactMode, canvas, businessRange, seriesDataSource) {
    var axis = this._axis;
    axis.updateOptions(prepareAxisOptions(options, isCompactMode, canvas.height, canvas.height / 2 - _ceil(options.width / 2)));
    axis.validate();
    axis.setBusinessRange(businessRange, true);
    if (seriesDataSource !== undefined && seriesDataSource.isShowChart()) {
      axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));
    }
    axis.draw(canvas);
    axis.shift({
      left: 0,
      bottom: -canvas.height / 2 + canvas.top
    });
    if (axis.getMarkerTrackers()) {
      // TODO: Check who is responsible for destroying events
      createDateMarkersEvent(options, axis.getMarkerTrackers(), this._updateSelectedRangeCallback);
    }
    axis.drawScaleBreaks({
      start: canvas.top,
      end: canvas.top + canvas.height
    });
  },
  visualRange: function visualRange() {},
  getViewport: function getViewport() {
    return {};
  },
  allScaleSelected(value) {
    var _this$_axis$visualRan = this._axis.visualRange(),
      startValue = _this$_axis$visualRan.startValue,
      endValue = _this$_axis$visualRan.endValue;
    return {
      startValue: value[0].valueOf() === startValue.valueOf(),
      endValue: value[1].valueOf() === endValue.valueOf()
    };
  },
  getOptions() {
    return this._axis.getOptions() || {};
  }
};
(0, _iterator.each)(_base_axis.Axis.prototype, function (field) {
  if (field !== 'constructor' && field[0] !== '_' && (0, _type2.isFunction)(_base_axis.Axis.prototype[field]) && !(field in AxisWrapper.prototype)) {
    AxisWrapper.prototype[field] = function () {
      var axis = this._axis;
      return axis[field].apply(axis, arguments);
    };
  }
});
(0, _component_registrator.default)('dxRangeSelector', dxRangeSelector);
var _default = dxRangeSelector; // PLUGINS_SECTION
exports["default"] = _default;
dxRangeSelector.addPlugin(_export.plugin);
dxRangeSelector.addPlugin(_title.plugin);
dxRangeSelector.addPlugin(_loading_indicator.plugin);
dxRangeSelector.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 25104:
/***/ (function(__unused_webpack_module, exports) {



exports.RangeView = RangeView;
// TODO: Move it inside the "SeriesDataSource"
function drawSeriesView(root, seriesDataSource, canvas, isAnimationEnabled) {
  var seriesList = seriesDataSource.getSeries();
  if (!seriesList.length) {
    return;
  }
  var valueAxis = seriesList[0].getValueAxis();
  valueAxis.updateCanvas({
    top: canvas.top,
    bottom: 0,
    height: canvas.height + canvas.top
  });
  seriesDataSource.adjustSeriesDimensions();
  var valueRange = seriesDataSource.getBoundRange().val;
  valueRange.sortCategories(valueAxis.getCategoriesSorter());
  valueAxis.setBusinessRange(valueRange);
  seriesList.forEach(function (series) {
    series._extGroups.seriesGroup = series._extGroups.labelsGroup = root;
    series.draw(isAnimationEnabled);
  });
}
function merge(a, b) {
  return a !== undefined ? a : b;
}
function RangeView(params) {
  this._params = params;
  this._clipRect = params.renderer.clipRect();
  params.root.attr({
    'clip-path': this._clipRect.id
  });
}
RangeView.prototype = {
  constructor: RangeView,
  update: function update(backgroundOption, backgroundTheme, canvas, isCompactMode, isAnimationEnabled, seriesDataSource) {
    var renderer = this._params.renderer;
    var root = this._params.root;
    var canvasWidth = canvas.width - canvas.left;
    var seriesGroup;
    backgroundOption = backgroundOption || {};
    root.clear();
    this._clipRect.attr({
      x: canvas.left,
      y: canvas.top,
      width: canvasWidth,
      height: canvas.height
    });
    if (!isCompactMode) {
      if (merge(backgroundOption.visible, backgroundTheme.visible)) {
        if (backgroundOption.color) {
          renderer.rect(canvas.left, canvas.top, canvasWidth + 1, canvas.height).attr({
            // Seems that "backgroundTheme.color" is never used and so can be removed both from here and from themes
            // TODO: Check it (special attention to WidgetsGallery) and remove the option
            fill: merge(backgroundOption.color, backgroundTheme.color),
            'class': 'dx-range-selector-background'
          }).append(root);
        }
        if (backgroundOption.image && backgroundOption.image.url) {
          renderer.image(canvas.left, canvas.top, canvasWidth + 1, canvas.height, backgroundOption.image.url, merge(backgroundOption.image.location, backgroundTheme.image.location)).append(root);
        }
      }
      if (seriesDataSource && seriesDataSource.isShowChart()) {
        seriesGroup = renderer.g().attr({
          'class': 'dxrs-series-group'
        }).append(root);
        drawSeriesView(seriesGroup, seriesDataSource, canvas, isAnimationEnabled);
      }
    }
  }
};

/***/ }),

/***/ 79302:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SeriesDataSource = void 0;
var _base_series = __webpack_require__(54932);
var _series_family = __webpack_require__(1939);
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _range = __webpack_require__(21177);
var _data_validator = __webpack_require__(45865);
var _chart_theme_manager = __webpack_require__(99327);
var createThemeManager = function createThemeManager(chartOptions) {
  return new _chart_theme_manager.ThemeManager({
    options: chartOptions,
    themeSection: 'rangeSelector.chart',
    fontFields: ['commonSeriesSettings.label.font']
  });
};
var processSeriesFamilies = function processSeriesFamilies(series, minBubbleSize, maxBubbleSize, barOptions, negativesAsZeroes) {
  var families = [];
  var types = [];
  (0, _iterator.each)(series, function (i, item) {
    if (!types.includes(item.type)) {
      types.push(item.type);
    }
  });
  (0, _iterator.each)(types, function (_, type) {
    var family = new _series_family.SeriesFamily({
      type: type,
      minBubbleSize: minBubbleSize,
      maxBubbleSize: maxBubbleSize,
      barGroupPadding: barOptions.barGroupPadding,
      barGroupWidth: barOptions.barGroupWidth,
      negativesAsZeroes: negativesAsZeroes
    });
    family.add(series);
    family.adjustSeriesValues();
    families.push(family);
  });
  return families;
};
var SeriesDataSource = function SeriesDataSource(options) {
  var that = this;
  var themeManager = that._themeManager = createThemeManager(options.chart);
  themeManager.setTheme(options.chart.theme);
  var topIndent = themeManager.getOptions('topIndent');
  var bottomIndent = themeManager.getOptions('bottomIndent');
  that._indent = {
    top: topIndent >= 0 && topIndent < 1 ? topIndent : 0,
    bottom: bottomIndent >= 0 && bottomIndent < 1 ? bottomIndent : 0
  };
  that._valueAxis = themeManager.getOptions('valueAxisRangeSelector') || {};
  that._hideChart = false;
  that._series = that._calculateSeries(options);
  that._seriesFamilies = [];
};
exports.SeriesDataSource = SeriesDataSource;
SeriesDataSource.prototype = {
  constructor: SeriesDataSource,
  _calculateSeries: function _calculateSeries(options) {
    var that = this;
    var series = [];
    var particularSeriesOptions;
    var seriesTheme;
    var data = options.dataSource || [];
    var parsedData;
    var chartThemeManager = that._themeManager;
    var seriesTemplate = chartThemeManager.getOptions('seriesTemplate');
    var allSeriesOptions = seriesTemplate ? (0, _utils.processSeriesTemplate)(seriesTemplate, data) : options.chart.series;
    var dataSourceField;
    var valueAxis = that._valueAxis;
    var i;
    var newSeries;
    var groupsData;
    if (options.dataSource && !allSeriesOptions) {
      dataSourceField = options.dataSourceField || 'arg';
      allSeriesOptions = {
        argumentField: dataSourceField,
        valueField: dataSourceField
      };
      that._hideChart = true;
    }
    allSeriesOptions = Array.isArray(allSeriesOptions) ? allSeriesOptions : allSeriesOptions ? [allSeriesOptions] : [];
    for (i = 0; i < allSeriesOptions.length; i++) {
      particularSeriesOptions = (0, _extend.extend)(true, {}, allSeriesOptions[i]);
      particularSeriesOptions.rotated = false;
      seriesTheme = chartThemeManager.getOptions('series', particularSeriesOptions, allSeriesOptions.length);
      seriesTheme.argumentField = seriesTheme.argumentField || options.dataSourceField; // B253068
      if (!seriesTheme.name) {
        seriesTheme.name = 'Series ' + (i + 1).toString();
      }
      if (data && data.length > 0) {
        // TODO
        newSeries = new _base_series.Series({
          renderer: options.renderer,
          argumentAxis: options.argumentAxis,
          valueAxis: options.valueAxis,
          incidentOccurred: options.incidentOccurred
        }, seriesTheme);
        series.push(newSeries);
      }
    }
    if (series.length) {
      groupsData = {
        groups: [{
          series: series,
          valueAxis: options.valueAxis,
          valueOptions: {
            type: valueAxis.type,
            valueType: dataSourceField ? options.valueType : valueAxis.valueType
          }
        }],
        argumentOptions: {
          categories: options.categories,
          argumentType: options.valueType,
          type: options.axisType
        }
      };
      parsedData = (0, _data_validator.validateData)(data, groupsData, options.incidentOccurred, chartThemeManager.getOptions('dataPrepareSettings'));
      that.argCategories = groupsData.categories;
      for (i = 0; i < series.length; i++) {
        series[i].updateData(parsedData[series[i].getArgumentField()]);
      }
    }
    return series;
  },
  createPoints() {
    if (this._series.length === 0) {
      return;
    }
    var series = this._series;
    var viewport = new _range.Range();
    var axis = series[0].getArgumentAxis();
    var themeManager = this._themeManager;
    var negativesAsZeroes = themeManager.getOptions('negativesAsZeroes');
    var negativesAsZeros = themeManager.getOptions('negativesAsZeros'); // misspelling case

    series.forEach(function (s) {
      viewport.addRange(s.getArgumentRange());
    });
    axis.getTranslator().updateBusinessRange(viewport);
    series.forEach(function (s) {
      s.createPoints();
    });
    this._seriesFamilies = processSeriesFamilies(series, themeManager.getOptions('minBubbleSize'), themeManager.getOptions('maxBubbleSize'), {
      barGroupPadding: themeManager.getOptions('barGroupPadding'),
      barGroupWidth: themeManager.getOptions('barGroupWidth')
    }, (0, _type.isDefined)(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros);
  },
  adjustSeriesDimensions: function adjustSeriesDimensions() {
    (0, _iterator.each)(this._seriesFamilies, function (_, family) {
      family.adjustSeriesDimensions();
    });
  },
  getBoundRange: function getBoundRange() {
    var that = this;
    var rangeData;
    var valueAxis = that._valueAxis;
    var valRange = new _range.Range({
      min: valueAxis.min,
      minVisible: valueAxis.min,
      max: valueAxis.max,
      maxVisible: valueAxis.max,
      axisType: valueAxis.type,
      base: valueAxis.logarithmBase
    });
    var argRange = new _range.Range({});
    var rangeYSize;
    var rangeVisibleSizeY;
    var minIndent;
    var maxIndent;
    (0, _iterator.each)(that._series, function (_, series) {
      rangeData = series.getRangeData();
      valRange.addRange(rangeData.val);
      argRange.addRange(rangeData.arg);
    });
    if (!valRange.isEmpty() && !argRange.isEmpty()) {
      minIndent = valueAxis.inverted ? that._indent.top : that._indent.bottom;
      maxIndent = valueAxis.inverted ? that._indent.bottom : that._indent.top;
      rangeYSize = valRange.max - valRange.min;
      rangeVisibleSizeY = ((0, _type.isNumeric)(valRange.maxVisible) ? valRange.maxVisible : valRange.max) - ((0, _type.isNumeric)(valRange.minVisible) ? valRange.minVisible : valRange.min);
      // B253717
      if ((0, _type.isDate)(valRange.min)) {
        valRange.min = new Date(valRange.min.valueOf() - rangeYSize * minIndent);
      } else {
        valRange.min -= rangeYSize * minIndent;
      }
      if ((0, _type.isDate)(valRange.max)) {
        valRange.max = new Date(valRange.max.valueOf() + rangeYSize * maxIndent);
      } else {
        valRange.max += rangeYSize * maxIndent;
      }
      if ((0, _type.isNumeric)(rangeVisibleSizeY)) {
        valRange.maxVisible = valRange.maxVisible ? valRange.maxVisible + rangeVisibleSizeY * maxIndent : undefined;
        valRange.minVisible = valRange.minVisible ? valRange.minVisible - rangeVisibleSizeY * minIndent : undefined;
      }
      valRange.invert = valueAxis.inverted;
    }
    return {
      arg: argRange,
      val: valRange
    };
  },
  getMarginOptions: function getMarginOptions(canvas) {
    var bubbleSize = Math.min(canvas.width, canvas.height) * this._themeManager.getOptions('maxBubbleSize');
    return this._series.reduce(function (marginOptions, series) {
      var seriesOptions = series.getMarginOptions();
      if (seriesOptions.processBubbleSize === true) {
        seriesOptions.size = bubbleSize;
      }
      return (0, _utils.mergeMarginOptions)(marginOptions, seriesOptions);
    }, {});
  },
  getSeries: function getSeries() {
    return this._series;
  },
  isEmpty: function isEmpty() {
    return this.getSeries().length === 0;
  },
  isShowChart: function isShowChart() {
    return !this._hideChart;
  },
  getCalculatedValueType: function getCalculatedValueType() {
    var series = this._series[0];
    return series === null || series === void 0 ? void 0 : series.argumentType;
  },
  getThemeManager: function getThemeManager() {
    return this._themeManager;
  }
};

/***/ }),

/***/ 48942:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(11378);
var _slider_marker = _interopRequireDefault(__webpack_require__(79090));
var _support = __webpack_require__(60137);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var animationSettings = _common.utils.animationSettings;
var SPLITTER_WIDTH = 8;
var TOUCH_SPLITTER_WIDTH = 20;
function getSliderTrackerWidth(sliderHandleWidth) {
  return _support.touchEvents || _support.pointerEvents ? TOUCH_SPLITTER_WIDTH : SPLITTER_WIDTH < sliderHandleWidth ? sliderHandleWidth : SPLITTER_WIDTH;
}
function Slider(params, index) {
  var that = this;
  that._translator = params.translator;
  that._sliderGroup = params.renderer.g().attr({
    'class': 'slider'
  }).append(params.root);
  that._line = params.renderer.path(null, 'line').append(that._sliderGroup);
  that._marker = new _slider_marker.default(params.renderer, that._sliderGroup, index === 1);
  that._tracker = params.renderer.rect().attr({
    'class': 'slider-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).css({
    cursor: 'w-resize'
  }).append(params.trackersGroup);
}
Slider.prototype = {
  constructor: Slider,
  cancelAnimation: function cancelAnimation() {
    this._sliderGroup.stopAnimation();
    this._tracker.stopAnimation();
  },
  applyPosition: function applyPosition(isAnimated) {
    var that = this;
    var slider = that._sliderGroup;
    var tracker = that._tracker;
    var attrs = {
      translateX: that._position
    };
    that._marker.setPosition(that._position);
    if (isAnimated) {
      slider.animate(attrs, animationSettings);
      tracker.animate(attrs, animationSettings);
    } else {
      slider.attr(attrs);
      tracker.attr(attrs);
    }
  },
  _setValid: function _setValid(isValid) {
    this._marker.setValid(isValid);
    this._line.attr({
      stroke: this._colors[Number(isValid)]
    });
  },
  _setText: function _setText(text) {
    this._marker.setText(text);
  },
  update: function update(verticalRange, sliderHandleOptions, sliderMarkerOptions) {
    var that = this;
    that._formatOptions = {
      format: sliderMarkerOptions.format,
      customizeText: sliderMarkerOptions.customizeText
    };
    that._marker.applyOptions(sliderMarkerOptions, that._translator.getScreenRange());
    that._colors = [sliderMarkerOptions.invalidRangeColor, sliderHandleOptions.color];
    that._sliderGroup.attr({
      translateY: verticalRange[0]
    });
    that._line.attr({
      'stroke-width': sliderHandleOptions.width,
      stroke: sliderHandleOptions.color,
      'stroke-opacity': sliderHandleOptions.opacity,
      sharp: 'h',
      points: [0, 0, 0, verticalRange[1] - verticalRange[0]]
    });
    var trackerWidth = getSliderTrackerWidth(sliderHandleOptions.width);
    that._tracker.attr({
      x: -trackerWidth / 2,
      y: 0,
      width: trackerWidth,
      height: verticalRange[1] - verticalRange[0],
      translateY: verticalRange[0]
    });
  },
  toForeground: function toForeground() {
    this._sliderGroup.toForeground();
  },
  getSliderTracker: function getSliderTracker() {
    return this._tracker;
  },
  getPosition: function getPosition() {
    return this._position;
  },
  setDisplayValue: function setDisplayValue(value) {
    this._value = value;
    this._setText((0, _common.formatValue)(value, this._formatOptions));
  },
  setOverlapped: function setOverlapped(isOverlapped) {
    this._marker.setOverlapped(isOverlapped);
  },
  getValue: function getValue() {
    return this._value;
  },
  on: function on(event, handler) {
    this._tracker.on(event, handler);
    this._marker.getTracker().on(event, handler);
  },
  getCloudBorder: function getCloudBorder() {
    return this._marker.getBorderPosition();
  },
  dispose: function dispose() {
    this._marker.dispose();
  }
};
var _default = Slider;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 79090:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(11378);
var POINTER_SIZE = _common.consts.pointerSize;
var SLIDER_MARKER_UPDATE_DELAY = 75;
function SliderMarker(renderer, root, isLeftPointer) {
  var that = this;
  that._isLeftPointer = isLeftPointer;
  that._isOverlapped = false;
  that._group = renderer.g().attr({
    'class': 'slider-marker'
  }).append(root);
  that._area = renderer.path(null, 'area').append(that._group);
  that._label = renderer.text().attr({
    align: 'left'
  }).append(that._group);
  that._tracker = renderer.rect().attr({
    'class': 'slider-marker-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).css({
    cursor: 'pointer'
  }).append(that._group);
  that._border = renderer.rect(0, 0, 1, 0);
}
SliderMarker.prototype = {
  constructor: SliderMarker,
  _getRectSize: function _getRectSize(textSize) {
    return {
      width: Math.round(2 * this._paddingLeftRight + textSize.width),
      height: Math.round(2 * this._paddingTopBottom + textSize.height)
    };
  },
  _getTextSize: function _getTextSize() {
    var textSize = this._label.getBBox();
    if (!this._textHeight && isFinite(textSize.height)) {
      this._textHeight = textSize.height;
    }
    return {
      width: textSize.width,
      height: this._textHeight,
      y: textSize.y
    };
  },
  _getAreaPointsInfo: function _getAreaPointsInfo(textSize) {
    var that = this;
    var rectSize = that._getRectSize(textSize);
    var rectWidth = rectSize.width;
    var rectHeight = rectSize.height;
    var rectLeftBorder = -rectWidth;
    var rectRightBorder = 0;
    var pointerRightPoint = POINTER_SIZE;
    var pointerCenterPoint = 0;
    var pointerLeftPoint = -POINTER_SIZE;
    var position = that._position;
    var isLeft = that._isLeftPointer;
    var correctCloudBorders = function correctCloudBorders() {
      rectLeftBorder++;
      rectRightBorder++;
      pointerRightPoint++;
      pointerCenterPoint++;
      pointerLeftPoint++;
    };
    var checkPointerBorders = function checkPointerBorders() {
      if (pointerRightPoint > rectRightBorder) {
        pointerRightPoint = rectRightBorder;
      } else {
        if (pointerLeftPoint < rectLeftBorder) {
          pointerLeftPoint = rectLeftBorder;
        }
      }
      isLeft && correctCloudBorders();
    };
    var borderPosition = position;
    if (isLeft) {
      if (position > that._range[1] - rectWidth) {
        rectRightBorder = -position + that._range[1];
        rectLeftBorder = rectRightBorder - rectWidth;
        checkPointerBorders();
        borderPosition += rectLeftBorder;
      } else {
        rectLeftBorder = pointerLeftPoint = 0;
        rectRightBorder = rectWidth;
      }
    } else {
      if (position - that._range[0] < rectWidth) {
        rectLeftBorder = -(position - that._range[0]);
        rectRightBorder = rectLeftBorder + rectWidth;
        checkPointerBorders();
        borderPosition += rectRightBorder;
      } else {
        pointerRightPoint = 0;
        correctCloudBorders();
      }
    }
    that._borderPosition = borderPosition;
    return {
      offset: rectLeftBorder,
      isCut: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),
      points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]
    };
  },
  _update: function _update() {
    var that = this;
    var textSize;
    clearTimeout(that._timeout);
    that._label.attr({
      text: that._text || ''
    });
    var currentTextSize = that._getTextSize();
    var rectSize = that._getRectSize(currentTextSize);
    textSize = that._textSize || currentTextSize;
    textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;
    that._timeout = setTimeout(function () {
      updateSliderMarker(currentTextSize, rectSize);
      that._textSize = currentTextSize;
    }, SLIDER_MARKER_UPDATE_DELAY);
    function updateSliderMarker(size, rectSize) {
      rectSize = rectSize || that._getRectSize(size);
      that._group.attr({
        translateY: -(rectSize.height + POINTER_SIZE)
      });
      var pointsData = that._getAreaPointsInfo(size);
      var points = pointsData.points;
      var offset = pointsData.offset;
      that._area.attr({
        points: points
      });
      that._border.attr({
        x: that._isLeftPointer ? points[0] - 1 : points[2],
        height: pointsData.isCut ? rectSize.height : rectSize.height + POINTER_SIZE
      });
      that._tracker.attr({
        translateX: offset,
        width: rectSize.width,
        height: rectSize.height + POINTER_SIZE
      });
      that._label.attr({
        translateX: that._paddingLeftRight + offset,
        translateY: rectSize.height / 2 - (size.y + size.height / 2)
      });
    }
    updateSliderMarker(textSize);
  },
  setText: function setText(value) {
    this._text = value;
  },
  setPosition: function setPosition(position) {
    this._position = position;
    this._update();
  },
  applyOptions: function applyOptions(options, screenRange) {
    var that = this;
    that._range = screenRange;
    that._paddingLeftRight = options.paddingLeftRight;
    that._paddingTopBottom = options.paddingTopBottom;
    that._textHeight = null;
    that._colors = [options.invalidRangeColor, options.color];
    that._area.attr({
      fill: options.color
    });
    that._border.attr({
      fill: options.borderColor
    });
    that._label.css((0, _utils.patchFontOptions)(options.font));
    that._update();
  },
  getTracker: function getTracker() {
    return this._tracker;
  },
  setValid: function setValid(isValid) {
    this._area.attr({
      fill: this._colors[Number(isValid)]
    });
  },
  setColor: function setColor(color) {
    this._area.attr({
      fill: color
    });
  },
  dispose: function dispose() {
    clearTimeout(this._timeout);
  },
  setOverlapped: function setOverlapped(isOverlapped) {
    var that = this;
    if (that._isOverlapped !== isOverlapped) {
      if (isOverlapped) {
        that._border.append(that._group);
      } else {
        that._isOverlapped && that._border.remove();
      }
      that._isOverlapped = isOverlapped;
    }
  },
  getBorderPosition: function getBorderPosition() {
    return this._borderPosition;
  }
};
var _default = SliderMarker;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 56481:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.SlidersController = SlidersController;
var _common = __webpack_require__(20576);
var _common2 = __webpack_require__(11378);
var _slider = _interopRequireDefault(__webpack_require__(48942));
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var animationSettings = _common2.utils.animationSettings;
var emptySliderMarkerText = _common2.consts.emptySliderMarkerText;
function buildRectPoints(left, top, right, bottom) {
  return [left, top, right, top, right, bottom, left, bottom];
}
function isLess(a, b) {
  return a < b;
}
function isGreater(a, b) {
  return a > b;
}
function selectClosestValue(target, values) {
  var start = 0;
  var end = values ? values.length - 1 : 0;
  var middle;
  var val = target;
  while (end - start > 1) {
    middle = start + end >> 1;
    val = values[middle];
    if (val === target) {
      return target;
    } else if (target < val) {
      end = middle;
    } else {
      start = middle;
    }
  }
  if (values) {
    val = values[target - values[start] <= values[end] - target ? start : end];
  }
  return val;
}
function dummyProcessSelectionChanged() {
  this._lastSelectedRange = this.getSelectedRange();
  delete this._processSelectionChanged;
}

// See tests in "rangeSelectorWithAssertion.html", "'onSelectedRangeChanged' event" module
function suppressSetSelectedRange(controller) {
  controller.setSelectedRange = _common.noop;
  if (controller._processSelectionChanged === dummyProcessSelectionChanged) {
    controller._processSelectionChanged();
  }
}
function restoreSetSelectedRange(controller) {
  delete controller.setSelectedRange;
}
function SlidersController(params) {
  var that = this;
  var sliderParams = {
    renderer: params.renderer,
    root: params.root,
    trackersGroup: params.trackersGroup,
    translator: params.translator
  };
  that._params = params;
  that._areaTracker = params.renderer.path(null, 'area').attr({
    'class': 'area-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).append(params.trackersGroup);
  that._selectedAreaTracker = params.renderer.path(null, 'area').attr({
    'class': 'selected-area-tracker',
    fill: '#000000',
    opacity: 0.0001
  }).append(params.trackersGroup);
  // Shutter is appended before sliders because later (when they will be foregrounded) it will be at any case located before them.
  that._shutter = params.renderer.path(null, 'area').append(params.root);
  that._sliders = [new _slider.default(sliderParams, 0), new _slider.default(sliderParams, 1)];
  // It seems that there is no special reasons to suppress first event - it was accidentally suppressed.
  // Let it stay so for now.
  that._processSelectionChanged = dummyProcessSelectionChanged;
}
SlidersController.prototype = {
  constructor: SlidersController,
  dispose: function dispose() {
    this._sliders[0].dispose();
    this._sliders[1].dispose();
  },
  getTrackerTargets: function getTrackerTargets() {
    return {
      area: this._areaTracker,
      selectedArea: this._selectedAreaTracker,
      sliders: this._sliders
    };
  },
  _processSelectionChanged: function _processSelectionChanged(e) {
    var that = this;
    var selectedRange = that.getSelectedRange();
    if (!(0, _utils.rangesAreEqual)(selectedRange, that._lastSelectedRange)) {
      that._params.updateSelectedRange(selectedRange, that._lastSelectedRange, e);
      that._lastSelectedRange = selectedRange;
    }
  },
  update: function update(verticalRange, behavior, isCompactMode, sliderHandleOptions, sliderMarkerOptions, shutterOptions, rangeBounds, fullTicks, selectedRangeColor) {
    var that = this;
    var screenRange = that._params.translator.getScreenRange();
    that._verticalRange = verticalRange;
    that._minRange = rangeBounds.minRange;
    that._maxRange = rangeBounds.maxRange;
    // TODO: Investigate reasons of "renderer.animationEnabled" usage - it seems to be useless (if only for vml somehow)
    that._animationEnabled = behavior.animationEnabled && that._params.renderer.animationEnabled();
    that._allowSlidersSwap = behavior.allowSlidersSwap;
    that._sliders[0].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
    that._sliders[1].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);
    // This is required for placing sliders and shutter into initial position from which initial animation will be going.
    that._sliders[0]._position = that._sliders[1]._position = screenRange[0];
    that._values = !that._params.translator.isValueProlonged && behavior.snapToTicks ? fullTicks : null;
    that._areaTracker.attr({
      points: buildRectPoints(screenRange[0], verticalRange[0], screenRange[1], verticalRange[1])
    });

    // SlidersContainer
    that._isCompactMode = isCompactMode;
    that._shutterOffset = sliderHandleOptions.width / 2;
    that._updateSelectedView(shutterOptions, selectedRangeColor);
    that._isOnMoving = (0, _utils.normalizeEnum)(behavior.valueChangeMode) === 'onhandlemove' || (0, _utils.normalizeEnum)(behavior.callValueChanged) === 'onmoving';
    that._updateSelectedRange();
    // This is placing sliders and shutter into initial position. They all will be animated from that position when "setSelectedRange" is called.
    that._applyTotalPosition(false);
  },
  _updateSelectedView: function _updateSelectedView(shutterOptions, selectedRangeColor) {
    var settings = {
      fill: null,
      'fill-opacity': null,
      stroke: null,
      'stroke-width': null
    };
    if (this._isCompactMode) {
      settings.stroke = selectedRangeColor;
      settings['stroke-width'] = 3;
      settings.sharp = 'v';
    } else {
      settings.fill = shutterOptions.color;
      settings['fill-opacity'] = shutterOptions.opacity;
    }
    this._shutter.attr(settings);
  },
  _updateSelectedRange: function _updateSelectedRange() {
    var that = this;
    var sliders = that._sliders;
    sliders[0].cancelAnimation();
    sliders[1].cancelAnimation();
    that._shutter.stopAnimation();
    if (that._params.translator.getBusinessRange().isEmpty()) {
      sliders[0]._setText(emptySliderMarkerText);
      sliders[1]._setText(emptySliderMarkerText);
      sliders[0]._value = sliders[1]._value = undefined;
      sliders[0]._position = that._params.translator.getScreenRange()[0];
      sliders[1]._position = that._params.translator.getScreenRange()[1];
      that._applyTotalPosition(false);
      suppressSetSelectedRange(that);
    } else {
      restoreSetSelectedRange(that);
    }
  },
  _applyTotalPosition: function _applyTotalPosition(isAnimated) {
    var sliders = this._sliders;
    isAnimated = this._animationEnabled && isAnimated;
    sliders[0].applyPosition(isAnimated);
    sliders[1].applyPosition(isAnimated);
    var areOverlapped = sliders[0].getCloudBorder() > sliders[1].getCloudBorder();
    sliders[0].setOverlapped(areOverlapped);
    sliders[1].setOverlapped(areOverlapped);
    this._applyAreaTrackersPosition();
    this._applySelectedRangePosition(isAnimated);
  },
  _applyAreaTrackersPosition: function _applyAreaTrackersPosition() {
    var that = this;
    var position1 = that._sliders[0].getPosition();
    var position2 = that._sliders[1].getPosition();
    that._selectedAreaTracker.attr({
      points: buildRectPoints(position1, that._verticalRange[0], position2, that._verticalRange[1])
    }).css({
      cursor: Math.abs(that._params.translator.getScreenRange()[1] - that._params.translator.getScreenRange()[0] - position2 + position1) < 0.001 ? 'default' : 'pointer'
    });
  },
  _applySelectedRangePosition: function _applySelectedRangePosition(isAnimated) {
    var that = this;
    var verticalRange = that._verticalRange;
    var pos1 = that._sliders[0].getPosition();
    var pos2 = that._sliders[1].getPosition();
    var screenRange;
    var points;
    if (that._isCompactMode) {
      points = [pos1 + Math.ceil(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2, pos2 - Math.floor(that._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2];
    } else {
      screenRange = that._params.axis.getVisibleArea();
      points = [buildRectPoints(screenRange[0], verticalRange[0], Math.max(pos1 - Math.floor(that._shutterOffset), screenRange[0]), verticalRange[1]), buildRectPoints(screenRange[1], verticalRange[0], Math.min(pos2 + Math.ceil(that._shutterOffset), screenRange[1]), verticalRange[1])];
    }
    if (isAnimated) {
      that._shutter.animate({
        points: points
      }, animationSettings);
    } else {
      that._shutter.attr({
        points: points
      });
    }
  },
  getSelectedRange: function getSelectedRange() {
    return {
      startValue: this._sliders[0].getValue(),
      endValue: this._sliders[1].getValue()
    };
  },
  setSelectedRange: function setSelectedRange(visualRange, e) {
    visualRange = visualRange || {};
    var that = this;
    var translator = that._params.translator;
    var businessRange = translator.getBusinessRange();
    var compare = businessRange.axisType === 'discrete' ? function (a, b) {
      return a < b;
    } : function (a, b) {
      return a <= b;
    };
    var _adjustVisualRange = (0, _utils.adjustVisualRange)({
        dataType: businessRange.dataType,
        axisType: businessRange.axisType,
        base: businessRange.base
      }, {
        startValue: translator.isValid(visualRange.startValue) ? translator.getCorrectValue(visualRange.startValue, +1) : undefined,
        endValue: translator.isValid(visualRange.endValue) ? translator.getCorrectValue(visualRange.endValue, -1) : undefined,
        length: visualRange.length
      }, {
        min: businessRange.minVisible,
        max: businessRange.maxVisible,
        categories: businessRange.categories
      }),
      startValue = _adjustVisualRange.startValue,
      endValue = _adjustVisualRange.endValue;
    startValue = (0, _type.isNumeric)(startValue) ? (0, _math.adjust)(startValue) : startValue;
    endValue = (0, _type.isNumeric)(endValue) ? (0, _math.adjust)(endValue) : endValue;
    var values = compare(translator.to(startValue, -1), translator.to(endValue, +1)) ? [startValue, endValue] : [endValue, startValue];
    that._sliders[0].setDisplayValue(values[0]);
    that._sliders[1].setDisplayValue(values[1]);
    that._sliders[0]._position = translator.to(values[0], -1);
    that._sliders[1]._position = translator.to(values[1], +1);
    that._applyTotalPosition(true);
    that._processSelectionChanged(e);
  },
  beginSelectedAreaMoving: function beginSelectedAreaMoving(initialPosition) {
    var that = this;
    var sliders = that._sliders;
    var offset = (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - initialPosition;
    var currentPosition = initialPosition;
    move.complete = function (e) {
      that._dockSelectedArea(e);
    };
    return move;
    function move(position, e) {
      if (position !== currentPosition && position > currentPosition === position > (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - offset) {
        that._moveSelectedArea(position + offset, false, e);
      }
      currentPosition = position;
    }
  },
  _dockSelectedArea: function _dockSelectedArea(e) {
    var translator = this._params.translator;
    var sliders = this._sliders;
    sliders[0]._position = translator.to(sliders[0].getValue(), -1);
    sliders[1]._position = translator.to(sliders[1].getValue(), +1);
    this._applyTotalPosition(true);
    this._processSelectionChanged(e);
  },
  moveSelectedArea: function moveSelectedArea(screenPosition, e) {
    this._moveSelectedArea(screenPosition, true, e);
    this._dockSelectedArea(e);
  },
  _moveSelectedArea: function _moveSelectedArea(screenPosition, isAnimated, e) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var interval = sliders[1].getPosition() - sliders[0].getPosition();
    var startPosition = screenPosition - interval / 2;
    var endPosition = screenPosition + interval / 2;
    if (startPosition < translator.getScreenRange()[0]) {
      startPosition = translator.getScreenRange()[0];
      endPosition = startPosition + interval;
    }
    if (endPosition > translator.getScreenRange()[1]) {
      endPosition = translator.getScreenRange()[1];
      startPosition = endPosition - interval;
    }

    // Check for "minRange" and "maxRange" is not performed because it was not performed in the previous code, though I find it strange.
    var startValue = selectClosestValue(translator.from(startPosition, -1), that._values);
    sliders[0].setDisplayValue(startValue);
    sliders[1].setDisplayValue(selectClosestValue(translator.from(translator.to(startValue, -1) + interval, +1), that._values));
    sliders[0]._position = startPosition;
    sliders[1]._position = endPosition;
    that._applyTotalPosition(isAnimated);
    if (that._isOnMoving) {
      that._processSelectionChanged(e);
    }
  },
  placeSliderAndBeginMoving: function placeSliderAndBeginMoving(firstPosition, secondPosition, e) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var index = firstPosition < secondPosition ? 0 : 1;
    var dir = index > 0 ? +1 : -1;
    var compare = index > 0 ? isGreater : isLess;
    var antiCompare = index > 0 ? isLess : isGreater;
    var thresholdPosition;
    var positions = [];
    var values = [];
    values[index] = translator.from(firstPosition, dir);
    values[1 - index] = translator.from(secondPosition, -dir);
    positions[1 - index] = secondPosition;
    if (translator.isValueProlonged) {
      // Ensure that first value is strictly to the outer side from the "firstPosition".
      if (compare(firstPosition, translator.to(values[index], dir))) {
        values[index] = translator.from(firstPosition, -dir);
      }
      // Check - if "secondPosition" is closer to "firstPosition" than a span of a single category.
      if (compare(secondPosition, translator.to(values[index], -dir))) {
        values[1 - index] = values[index];
      }
    }
    if (that._minRange) {
      thresholdPosition = translator.to(translator.add(selectClosestValue(values[index], that._values), that._minRange, -dir), -dir);
      // Check - if "secondPosition" is closer to "firstPosition" than it is allowed by "minRange".
      if (compare(secondPosition, thresholdPosition)) {
        values[1 - index] = translator.add(values[index], that._minRange, -dir);
      }
      thresholdPosition = translator.to(translator.add(translator.getRange()[1 - index], that._minRange, dir), -dir);
      // Check - if "firstPosition" is closer to an end than it is allowed by "minRange".
      // So there is definitely not enough space for both sliders - the first  (as the one which is farther from the end) has to be moved away by "minRange".
      if (antiCompare(firstPosition, thresholdPosition)) {
        values[1 - index] = translator.getRange()[1 - index];
        values[index] = translator.add(values[1 - index], that._minRange, dir);
        positions[1 - index] = firstPosition;
      }
    }
    values[0] = selectClosestValue(values[0], that._values);
    values[1] = selectClosestValue(values[1], that._values);
    positions[index] = translator.to(values[index], dir);
    sliders[0].setDisplayValue(values[0]);
    sliders[1].setDisplayValue(values[1]);
    sliders[0]._position = positions[0];
    sliders[1]._position = positions[1];
    that._applyTotalPosition(true);
    if (that._isOnMoving) {
      that._processSelectionChanged(e);
    }
    var handler = that.beginSliderMoving(1 - index, secondPosition);
    sliders[1 - index]._sliderGroup.stopAnimation();
    that._shutter.stopAnimation();
    handler(secondPosition);
    return handler;
  },
  beginSliderMoving: function beginSliderMoving(initialIndex, initialPosition) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var minPosition = translator.getScreenRange()[0];
    var maxPosition = translator.getScreenRange()[1];
    var index = initialIndex;
    var staticPosition = sliders[1 - index].getPosition();
    var currentPosition = initialPosition;
    var dir = index > 0 ? +1 : -1;
    var compareMin = index > 0 ? isLess : isGreater;
    var compareMax = index > 0 ? isGreater : isLess;
    var moveOffset = sliders[index].getPosition() - initialPosition;
    var swapOffset = compareMin(sliders[index].getPosition(), initialPosition) ? -moveOffset : moveOffset;
    move.complete = function (e) {
      sliders[index]._setValid(true);
      that._dockSelectedArea(e);
    };
    return move;
    function move(position, e) {
      var isValid;
      var temp;
      var pos;
      var slider;
      var value;
      if (position !== currentPosition) {
        if (compareMin(position + swapOffset, staticPosition)) {
          isValid = that._allowSlidersSwap;
          // TODO: Validate "_minRange" so that for discrete translator it is always null - that will allow to split "isValueProlonged" and "_minRange" checks
          if (isValid && !translator.isValueProlonged && that._minRange) {
            isValid = translator.isValid(translator.add(sliders[1 - index].getValue(), that._minRange, -dir));
          }
          if (isValid) {
            that._changeMovingSlider(index);
            index = 1 - index;
            dir = -dir;
            temp = compareMin;
            compareMin = compareMax;
            compareMax = temp;
            moveOffset = -dir * Math.abs(moveOffset);
            swapOffset = -moveOffset;
          }
        }
        if (compareMax(position + moveOffset, staticPosition)) {
          slider = sliders[index];
          value = sliders[1 - index].getValue();
          pos = Math.max(Math.min(position + moveOffset, maxPosition), minPosition);
          // TODO: Write it as single operation (isValid = ... && ... && ...) when code is stable.
          // Check - if moving slider is closer to static slider than a span of a single category.
          isValid = translator.isValueProlonged ? !compareMin(pos, translator.to(value, dir)) : true;
          var invalidStateValue;
          // Check - if moving slider is closer to static slider than it is allowed "minRange".
          if (isValid && that._minRange) {
            isValid = !compareMin(pos, translator.to(translator.add(value, that._minRange, dir), dir));
            if (!isValid) {
              invalidStateValue = translator.add(value, that._minRange, dir);
            }
          }
          // Check - if moving slider is farther from static slider than it is allowed by "maxRange"
          if (isValid && that._maxRange) {
            isValid = !compareMax(pos, translator.to(translator.add(value, that._maxRange, dir), dir));
            if (!isValid) {
              invalidStateValue = translator.add(value, that._maxRange, dir);
            }
          }
          slider._setValid(isValid);
          slider.setDisplayValue(isValid ? selectClosestValue(translator.from(pos, dir), that._values) : (0, _type.isDefined)(invalidStateValue) ? invalidStateValue : slider.getValue());
          slider._position = pos;
          that._applyTotalPosition(false);
          slider.toForeground();
          if (that._isOnMoving) {
            that._processSelectionChanged(e);
          }
        }
      }
      currentPosition = position;
    }
  },
  _changeMovingSlider: function _changeMovingSlider(index) {
    var that = this;
    var translator = that._params.translator;
    var sliders = that._sliders;
    var position = sliders[1 - index].getPosition();
    var dir = index > 0 ? +1 : -1;
    var newValue;
    sliders[index].setDisplayValue(selectClosestValue(translator.from(position, dir), that._values));
    newValue = translator.from(position, -dir);
    if (translator.isValueProlonged) {
      newValue = translator.from(position, dir);
    } else if (that._minRange) {
      // TODO: Consider adding "translator.isValid" check - that will allow to split "if-else" into two "if"
      newValue = translator.add(newValue, that._minRange, -dir);
    }
    sliders[1 - index].setDisplayValue(selectClosestValue(newValue, that._values));
    sliders[index]._setValid(true);
    sliders[index]._marker._update(); // This is to update "text" element
    sliders[0]._position = sliders[1]._position = position;
  },
  foregroundSlider: function foregroundSlider(index) {
    this._sliders[index].toForeground();
  }
};

/***/ }),

/***/ 43695:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Tracker = Tracker;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _iterator = __webpack_require__(95479);
var _support = __webpack_require__(60137);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var MIN_MANUAL_SELECTING_WIDTH = 10;
var window = (0, _window.getWindow)();
function isLeftButtonPressed(event) {
  var e = event || window.event;
  var originalEvent = e.originalEvent;
  var touches = e.touches;
  var pointerType = originalEvent ? originalEvent.pointerType : false;
  var eventTouches = originalEvent ? originalEvent.touches : false;
  var isMSPointerLeftClick = originalEvent && pointerType !== undefined && (pointerType === (originalEvent.MSPOINTER_TYPE_TOUCH || 'touch') || pointerType === (originalEvent.MSPOINTER_TYPE_MOUSE || 'mouse') && originalEvent.buttons === 1);
  var isTouches = touches && touches.length > 0 || eventTouches && eventTouches.length > 0;
  return e.which === 1 || isMSPointerLeftClick || isTouches;
}
function isMultiTouches(event) {
  var originalEvent = event.originalEvent;
  var touches = event.touches;
  var eventTouches = originalEvent && originalEvent.touches;
  return touches && touches.length > 1 || eventTouches && eventTouches.length > 1 || null;
}
function preventDefault(e) {
  if (!isMultiTouches(e)) {
    e.preventDefault();
  }
}
function stopPropagationAndPreventDefault(e) {
  if (!isMultiTouches(e)) {
    e.stopPropagation();
    e.preventDefault();
  }
}

// Q375042
function isTouchEventArgs(e) {
  return e && e.type && e.type.indexOf('touch') === 0;
}
function getEventPageX(event) {
  var originalEvent = event.originalEvent;
  var result = 0;
  if (event.pageX) {
    result = event.pageX;
  } else if (originalEvent && originalEvent.pageX) {
    result = originalEvent.pageX;
  }
  if (originalEvent && originalEvent.touches) {
    if (originalEvent.touches.length > 0) {
      result = originalEvent.touches[0].pageX;
    } else if (originalEvent.changedTouches.length > 0) {
      result = originalEvent.changedTouches[0].pageX;
    }
  }
  return result;
}
function initializeAreaEvents(controller, area, state, getRootOffsetLeft) {
  var isTouchEvent;
  var isActive = false;
  var initialPosition;
  var movingHandler = null;
  var docEvents = {
    [_pointer.default.move](e) {
      var position;
      var offset;
      if (isTouchEvent !== isTouchEventArgs(e)) return;
      if (!isLeftButtonPressed(e)) {
        cancel(e);
      }
      if (isActive) {
        position = getEventPageX(e);
        offset = getRootOffsetLeft();
        if (movingHandler) {
          movingHandler(position - offset, e);
        } else {
          if (state.manualRangeSelectionEnabled && Math.abs(initialPosition - position) >= MIN_MANUAL_SELECTING_WIDTH) {
            movingHandler = controller.placeSliderAndBeginMoving(initialPosition - offset, position - offset, e);
          }
        }
      }
    },
    [_pointer.default.up](e) {
      var position;
      if (isActive) {
        position = getEventPageX(e);
        if (!movingHandler && state.moveSelectedRangeByClick && Math.abs(initialPosition - position) < MIN_MANUAL_SELECTING_WIDTH) {
          controller.moveSelectedArea(position - getRootOffsetLeft(), e);
        }
        cancel(e);
      }
    }
  };
  function cancel(e) {
    if (isActive) {
      isActive = false;
      if (movingHandler) {
        movingHandler.complete(e);
        movingHandler = null;
      }
    }
  }
  area.on(_pointer.default.down, function (e) {
    if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
    isActive = true;
    isTouchEvent = isTouchEventArgs(e);
    initialPosition = getEventPageX(e);
  });
  return docEvents;
}
function initializeSelectedAreaEvents(controller, area, state, getRootOffsetLeft) {
  var isTouchEvent;
  var isActive = false;
  var movingHandler = null;
  var docEvents = {
    [_pointer.default.move](e) {
      if (isTouchEvent !== isTouchEventArgs(e)) return;
      if (!isLeftButtonPressed(e)) {
        cancel(e);
      }
      if (isActive) {
        preventDefault(e);
        movingHandler(getEventPageX(e) - getRootOffsetLeft(), e);
      }
    },
    [_pointer.default.up]: cancel
  };
  function cancel(e) {
    if (isActive) {
      isActive = false;
      movingHandler.complete(e);
      movingHandler = null;
    }
  }
  area.on(_pointer.default.down, function (e) {
    if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
    isActive = true;
    isTouchEvent = isTouchEventArgs(e);
    movingHandler = controller.beginSelectedAreaMoving(getEventPageX(e) - getRootOffsetLeft());
    stopPropagationAndPreventDefault(e);
  });
  return docEvents;
}
function initializeSliderEvents(controller, sliders, state, getRootOffsetLeft) {
  var isTouchEvent;
  var isActive = false;
  var movingHandler = null;
  var docEvents = {
    [_pointer.default.move](e) {
      if (isTouchEvent !== isTouchEventArgs(e)) return;
      if (!isLeftButtonPressed(e)) {
        cancel(e);
      }
      if (isActive) {
        preventDefault(e);
        movingHandler(getEventPageX(e) - getRootOffsetLeft(), e);
      }
    },
    [_pointer.default.up]: cancel
  };
  (0, _iterator.each)(sliders, function (i, slider) {
    slider.on({
      [_pointer.default.down](e) {
        if (!state.enabled || !isLeftButtonPressed(e) || isActive) return;
        isActive = true;
        isTouchEvent = isTouchEventArgs(e);
        movingHandler = controller.beginSliderMoving(i, getEventPageX(e) - getRootOffsetLeft());
        stopPropagationAndPreventDefault(e);
      },
      [_pointer.default.move]() {
        if (!movingHandler) {
          controller.foregroundSlider(i);
        }
      }
    });
  });
  function cancel(e) {
    if (isActive) {
      isActive = false;
      movingHandler.complete(e);
      movingHandler = null;
    }
  }
  return docEvents;
}
function Tracker(params) {
  var state = this._state = {};
  var targets = params.controller.getTrackerTargets();
  if (_support.pointerEvents) {
    params.renderer.root.css({
      'msTouchAction': 'pinch-zoom'
    });
  }
  this._docEvents = [initializeSelectedAreaEvents(params.controller, targets.selectedArea, state, getRootOffsetLeft), initializeAreaEvents(params.controller, targets.area, state, getRootOffsetLeft), initializeSliderEvents(params.controller, targets.sliders, state, getRootOffsetLeft)];
  // TODO: 3 "move" and 3 "end" events - do we really need that much?
  (0, _iterator.each)(this._docEvents, function (_, events) {
    _events_engine.default.on(_dom_adapter.default.getDocument(), events);
  });
  function getRootOffsetLeft() {
    return params.renderer.getRootOffset().left;
  }
}
Tracker.prototype = {
  constructor: Tracker,
  dispose: function dispose() {
    (0, _iterator.each)(this._docEvents, function (_, events) {
      _events_engine.default.off(_dom_adapter.default.getDocument(), events);
    });
  },
  update: function update(enabled, behavior) {
    var state = this._state;
    state.enabled = enabled;
    state.moveSelectedRangeByClick = behavior.moveSelectedRangeByClick;
    state.manualRangeSelectionEnabled = behavior.manualRangeSelectionEnabled;
  }
};

/***/ }),

/***/ 34377:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _sankey = _interopRequireDefault(__webpack_require__(66422));
var _tooltip = __webpack_require__(38516);
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _tracker = __webpack_require__(29823);
var _tooltip2 = __webpack_require__(14371);
var _loading_indicator = __webpack_require__(64758);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
_sankey.default.addPlugin(_export.plugin);
_sankey.default.addPlugin(_title.plugin);
_sankey.default.addPlugin(_tracker.plugin);
_sankey.default.addPlugin(_loading_indicator.plugin);
_sankey.default.addPlugin(_tooltip2.plugin);
(0, _tooltip.setTooltipCustomOptions)(_sankey.default);
var _default = _sankey.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 74878:
/***/ (function(__unused_webpack_module, exports) {



exports.COLOR_MODE_TARGET = exports.COLOR_MODE_SOURCE = exports.COLOR_MODE_NONE = exports.COLOR_MODE_GRADIENT = void 0;
var COLOR_MODE_GRADIENT = 'gradient';
exports.COLOR_MODE_GRADIENT = COLOR_MODE_GRADIENT;
var COLOR_MODE_SOURCE = 'source';
exports.COLOR_MODE_SOURCE = COLOR_MODE_SOURCE;
var COLOR_MODE_TARGET = 'target';
exports.COLOR_MODE_TARGET = COLOR_MODE_TARGET;
var COLOR_MODE_NONE = 'none';
exports.COLOR_MODE_NONE = COLOR_MODE_NONE;

/***/ }),

/***/ 86547:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _graph = _interopRequireDefault(__webpack_require__(65538));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var validator = {
  validate: function validate(data, incidentOccurred) {
    var result = null;
    if (this._hasCycle(data)) {
      result = 'E2006';
      incidentOccurred('E2006');
    }
    return result;
  },
  _hasCycle: function _hasCycle(data) {
    return _graph.default.struct.hasCycle(data);
  }
};
var _default = validator;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 65538:
/***/ (function(module, exports) {



exports["default"] = void 0;
var WHITE = 'white';
var GRAY = 'gray';
var BLACK = 'black';
var routines = {
  maxOfArray: function maxOfArray(arr, callback) {
    var m = 0;
    var callback_function = function callback_function(v) {
      return v;
    };
    if (callback) {
      callback_function = callback;
    }
    for (var i = 0; i < arr.length; i++) {
      if (callback_function(arr[i]) > m) m = callback_function(arr[i]);
    }
    return m;
  }
};
var getVertices = function getVertices(links) {
  var vert = [];
  links.forEach(function (link) {
    if (vert.indexOf(link[0]) === -1) {
      vert.push(link[0]);
    }
    if (vert.indexOf(link[1]) === -1) {
      vert.push(link[1]);
    }
  });
  return vert;
};
var getAdjacentVertices = function getAdjacentVertices(links, vertex) {
  var avert = [];
  links.forEach(function (link) {
    if (link[0] === vertex && avert.indexOf(link[1]) === -1) {
      avert.push(link[1]);
    }
  });
  return avert;
};
var getReverseAdjacentVertices = function getReverseAdjacentVertices(links, vertex) {
  var avert = [];
  links.forEach(function (link) {
    if (link[1] === vertex && avert.indexOf(link[0]) === -1) {
      avert.push(link[0]);
    }
  });
  return avert;
};
var struct = {
  _hasCycle: false,
  _sortedList: [],
  hasCycle: function hasCycle(links) {
    var _this = this;
    // detects if the graph has cycle
    // sorts the vertices (modifies the _sortedList variable)
    this._hasCycle = false;
    this._sortedList = [];
    var vertices = {};
    var allVertices = getVertices(links);
    allVertices.forEach(function (vertex) {
      vertices[vertex] = {
        color: WHITE
      };
    });
    allVertices.forEach(function (vertex) {
      if (vertices[vertex].color === WHITE) {
        _this._depthFirstSearch(links, vertices, vertex);
      }
    });
    this._sortedList.reverse();
    return this._hasCycle;
  },
  _depthFirstSearch: function _depthFirstSearch(links, vertices, vertex) {
    vertices[vertex].color = GRAY;
    var averts = getAdjacentVertices(links, vertex);
    for (var a = 0; a < averts.length; a++) {
      if (vertices[averts[a]].color === WHITE) {
        this._depthFirstSearch(links, vertices, averts[a]);
      } else if (vertices[averts[a]].color === GRAY) {
        this._hasCycle = true;
      }
    }
    this._sortedList.push({
      name: vertex,
      lp: null,
      incoming: getReverseAdjacentVertices(links, vertex),
      outgoing: getAdjacentVertices(links, vertex)
    });
    vertices[vertex].color = BLACK;
  },
  computeLongestPaths(links) {
    // calculates longets paths for all vertices
    // method expects sorted vertices array to be in this._sortedList
    var sortedVertices = this._sortedList;
    sortedVertices.forEach(function (vertex) {
      var averts = getReverseAdjacentVertices(links, vertex.name); // neigbours who INCOME to the vertex
      if (averts.length === 0) {
        vertex.lp = 0; // 'lp' means 'Longest Path'
      } else {
        var maxLP = [];
        // get max through avertex.lp and add 1 to it
        averts.forEach(function (adjacentVertex) {
          maxLP.push(sortedVertices.filter(function (sv) {
            return sv.name === adjacentVertex;
          })[0].lp);
        });
        vertex.lp = routines.maxOfArray(maxLP) + 1;
      }
    });
    return this._sortedList;
  }
};
var _default = {
  struct: struct,
  routines: routines,
  getVertices: getVertices,
  getAdjacentVertices: getAdjacentVertices,
  getReverseAdjacentVertices: getReverseAdjacentVertices
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 68856:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.layout = void 0;
var _graph = _interopRequireDefault(__webpack_require__(65538));
var _data_validator = _interopRequireDefault(__webpack_require__(86547));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _SPLINE_TENSION = 0.3;
var _ALIGNMENT_CENTER = 'center';
var _ALIGNMENT_BOTTOM = 'bottom';
var _ALIGNMENT_DEFAULT = _ALIGNMENT_CENTER;
var layout = {
  _weightPerPixel: null,
  _getCascadeIdx: function _getCascadeIdx(nodeTitle, cascadesConfig) {
    var nodeInfo = cascadesConfig.filter(function (c) {
      return c.name === nodeTitle;
    })[0];
    if (nodeInfo.outgoing.length > 0) {
      // in common case number of cascade is the longest path to the node
      return nodeInfo.lp;
    } else {
      // but if the node is last (ie has no outgoing edges) lets move it to the LAST cascade
      return _graph.default.routines.maxOfArray(cascadesConfig.map(function (c) {
        return c.lp;
      }));
    }
  },
  _getInWeightForNode: function _getInWeightForNode(nodeTitle, links) {
    var w = 0;
    links.forEach(function (link) {
      if (link[1] === nodeTitle) {
        w += link[2];
      }
    });
    return w;
  },
  _getOutWeightForNode: function _getOutWeightForNode(nodeTitle, links) {
    var w = 0;
    links.forEach(function (link) {
      if (link[0] === nodeTitle) {
        w += link[2];
      }
    });
    return w;
  },
  _computeCascades: function _computeCascades(links) {
    var _this = this;
    var cascadesConfig = _graph.default.struct.computeLongestPaths(links);
    var maxCascade = _graph.default.routines.maxOfArray(cascadesConfig.map(function (c) {
      return c.lp;
    }));
    var cascades = [];

    // init cascades
    for (var i = 0; i < maxCascade + 1; i++) {
      cascades.push({});
    }

    // add nodes to cascades
    links.forEach(function (link) {
      var cascade = cascades[_this._getCascadeIdx(link[0], cascadesConfig)];
      if (!cascade[link[0]]) {
        cascade[link[0]] = {
          nodeTitle: link[0]
        };
      }
      cascade = cascades[_this._getCascadeIdx(link[1], cascadesConfig)];
      if (!cascade[link[1]]) {
        cascade[link[1]] = {
          nodeTitle: link[1]
        };
      }
    });

    // compute in and out weightes of all nodes of cascades
    cascades.forEach(function (cascade) {
      Object.keys(cascade).forEach(function (nodeTitle) {
        var node = cascade[nodeTitle];
        node.inWeight = _this._getInWeightForNode(node.nodeTitle, links);
        node.outWeight = _this._getOutWeightForNode(node.nodeTitle, links);
        node.maxWeight = Math.max(node.inWeight, node.outWeight);
      });
    });
    return cascades;
  },
  _getWeightForCascade: function _getWeightForCascade(cascades, cascadeIdx) {
    var wMax = 0;
    var cascade = cascades[cascadeIdx];
    Object.keys(cascade).forEach(function (nodeTitle) {
      wMax += Math.max(cascade[nodeTitle].inWeight, cascade[nodeTitle].outWeight);
    });
    return wMax;
  },
  _getMaxWeightThroughCascades: function _getMaxWeightThroughCascades(cascades) {
    var max = [];
    cascades.forEach(function (cascade) {
      var mW = 0;
      Object.keys(cascade).forEach(function (nodeTitle) {
        var node = cascade[nodeTitle];
        mW += Math.max(node.inWeight, node.outWeight);
      });
      max.push(mW);
    });
    return _graph.default.routines.maxOfArray(max);
  },
  _computeNodes: function _computeNodes(cascades, options) {
    var _this2 = this;
    var rects = [];
    var maxWeight = this._getMaxWeightThroughCascades(cascades);
    var maxNodeNum = _graph.default.routines.maxOfArray(cascades.map(function (nodesInCascade) {
      return Object.keys(nodesInCascade).length;
    }));
    var nodePadding = options.nodePadding;
    var heightAvailable = options.height - nodePadding * (maxNodeNum - 1);
    if (heightAvailable < 0) {
      // when the available height is too small, e.g. sum of all paddings is more then available height
      nodePadding = 0;
      heightAvailable = options.height - nodePadding * (maxNodeNum - 1);
    }
    this._weightPerPixel = maxWeight / heightAvailable;

    // compute in and out weightes of all nodes of cascades
    var cascadeIdx = 0;
    cascades.forEach(function (cascade) {
      var cascadeRects = [];
      var y = 0;
      var nodesInCascade = Object.keys(cascade).length;
      var cascadeHeight = _this2._getWeightForCascade(cascades, cascadeIdx) / _this2._weightPerPixel + nodePadding * (nodesInCascade - 1);
      var cascadeAlign;
      if (Array.isArray(options.nodeAlign)) {
        cascadeAlign = cascadeIdx < options.nodeAlign.length ? options.nodeAlign[cascadeIdx] : _ALIGNMENT_DEFAULT;
      } else {
        cascadeAlign = options.nodeAlign;
      }
      if (cascadeAlign === _ALIGNMENT_BOTTOM) {
        y = options.height - cascadeHeight;
      } else if (cascadeAlign === _ALIGNMENT_CENTER) {
        y = 0.5 * (options.height - cascadeHeight);
      }
      y = Math.round(y);
      Object.keys(cascade).forEach(function (nodeTitle) {
        cascade[nodeTitle].sort = _this2._sort && Object.prototype.hasOwnProperty.call(_this2._sort, nodeTitle) ? _this2._sort[nodeTitle] : 1;
      });
      Object.keys(cascade).sort(function (a, b) {
        return cascade[a].sort - cascade[b].sort;
      }).forEach(function (nodeTitle) {
        var node = cascade[nodeTitle];
        var height = Math.floor(heightAvailable * node.maxWeight / maxWeight);
        var x = Math.round(cascadeIdx * options.width / (cascades.length - 1)) - (cascadeIdx === 0 ? 0 : options.nodeWidth);
        var rect = {};
        rect._name = nodeTitle;
        rect.width = options.nodeWidth;
        rect.height = height;
        rect.x = x + options.x;
        rect.y = y + options.y;
        y += height + nodePadding;
        cascadeRects.push(rect);
      });
      cascadeIdx++;
      rects.push(cascadeRects);
    });
    return rects;
  },
  _findRectByName: function _findRectByName(rects, name) {
    for (var c = 0; c < rects.length; c++) {
      for (var r = 0; r < rects[c].length; r++) {
        if (name === rects[c][r]._name) return rects[c][r];
      }
    }
    return null;
  },
  _findIndexByName: function _findIndexByName(rects, nodeTitle) {
    var index = 0;
    for (var c = 0; c < rects.length; c++) {
      for (var r = 0; r < rects[c].length; r++) {
        if (nodeTitle === rects[c][r]._name) return index;
        index++;
      }
    }
    return null;
  },
  _computeLinks: function _computeLinks(links, rects, cascades) {
    var _this3 = this;
    var yOffsets = {};
    var paths = [];
    var result = [];
    cascades.forEach(function (cascade) {
      Object.keys(cascade).forEach(function (nodeTitle) {
        yOffsets[nodeTitle] = {
          in: 0,
          out: 0
        };
      });
    });
    rects.forEach(function (rectsOfCascade) {
      rectsOfCascade.forEach(function (nodeRect) {
        var nodeTitle = nodeRect._name;
        var rectFrom = _this3._findRectByName(rects, nodeTitle);
        var linksFromNode = links.filter(function (link) {
          return link[0] === nodeTitle;
        }); // all outgoing links from the node

        // all outgoing links should be sorted according to the order of their target nodes
        linksFromNode.forEach(function (link) {
          link.sort = _this3._findIndexByName(rects, link[1]);
        });
        linksFromNode.sort(function (a, b) {
          return a.sort - b.sort;
        }).forEach(function (link) {
          var rectTo = _this3._findRectByName(rects, link[1]);
          var height = Math.round(link[2] / _this3._weightPerPixel);
          var yOffsetFrom = yOffsets[link[0]].out;
          var yOffsetTo = yOffsets[link[1]].in;
          // heights of left and right parts of the link must fit the nodes on it's left and right
          var heightFrom = yOffsets[link[0]].out + height > rectFrom.height ? rectFrom.height - yOffsets[link[0]].out : height;
          var heightTo = yOffsets[link[1]].in + height > rectTo.height ? rectTo.height - yOffsets[link[1]].in : height;
          paths.push({
            from: {
              x: rectFrom.x,
              y: rectFrom.y + yOffsetFrom,
              width: rectFrom.width,
              height: heightFrom,
              node: rectFrom,
              weight: link[2]
            },
            to: {
              x: rectTo.x,
              y: rectTo.y + yOffsetTo,
              width: rectTo.width,
              height: heightTo,
              node: rectTo
            }
          });
          yOffsets[link[0]].out += height;
          yOffsets[link[1]].in += height;
        });
      });
    });
    paths.forEach(function (link) {
      var path = {
        d: _this3._spline(link.from, link.to),
        _boundingRect: {
          x: link.from.x + link.from.width,
          y: Math.min(link.from.y, link.to.y),
          width: link.to.x - (link.from.x + link.from.width),
          height: Math.max(link.from.x + link.from.height, link.to.y + link.to.height) - Math.min(link.from.y, link.to.y)
        },
        _weight: link.from.weight,
        _from: link.from.node,
        _to: link.to.node
      };
      result.push(path);
    });
    this._fitAllNodesHeight(rects, paths);
    return result;
  },
  _fitNodeHeight: function _fitNodeHeight(nodeName, nodeRects, paths) {
    var targetRect = this._findRectByName(nodeRects, nodeName);
    var heightOfLinksSummaryIn = 0;
    var heightOfLinksSummaryOut = 0;
    paths.forEach(function (path) {
      if (path.from.node._name === nodeName) {
        heightOfLinksSummaryOut += path.from.height;
      }
      if (path.to.node._name === nodeName) {
        heightOfLinksSummaryIn += path.to.height;
      }
    });
    targetRect.height = Math.max(heightOfLinksSummaryIn, heightOfLinksSummaryOut);
  },
  _fitAllNodesHeight: function _fitAllNodesHeight(nodeRects, paths) {
    for (var c = 0; c < nodeRects.length; c++) {
      for (var r = 0; r < nodeRects[c].length; r++) {
        this._fitNodeHeight(nodeRects[c][r]._name, nodeRects, paths);
      }
    }
  },
  _spline: function _spline(rectLeft, rectRight) {
    var p_UpLeft = {
      x: rectLeft.x + rectLeft.width,
      y: rectLeft.y
    };
    var p_DownLeft = {
      x: rectLeft.x + rectLeft.width,
      y: rectLeft.y + rectLeft.height
    };
    var p_UpRight = {
      x: rectRight.x,
      y: rectRight.y
    };
    var p_DownRight = {
      x: rectRight.x,
      y: rectRight.y + rectRight.height
    };
    var curve_width = _SPLINE_TENSION * (p_UpRight.x - p_UpLeft.x);
    var result = "M ".concat(p_UpLeft.x, " ").concat(p_UpLeft.y, " C ").concat(p_UpLeft.x + curve_width, " ").concat(p_UpLeft.y, " ").concat(p_UpRight.x - curve_width, " ").concat(p_UpRight.y, " ").concat(p_UpRight.x, " ").concat(p_UpRight.y, " L ").concat(p_DownRight.x, " ").concat(p_DownRight.y, " C ").concat(p_DownRight.x - curve_width, " ").concat(p_DownRight.y, " ").concat(p_DownLeft.x + curve_width, " ").concat(p_DownLeft.y, " ").concat(p_DownLeft.x, " ").concat(p_DownLeft.y, " Z");
    return result;
  },
  computeLayout: function computeLayout(linksData, sortData, options, incidentOccurred) {
    this._sort = sortData;
    var result = {};
    var validateResult = _data_validator.default.validate(linksData, incidentOccurred);
    if (!validateResult) {
      result.cascades = this._computeCascades(linksData);
      result.nodes = this._computeNodes(result.cascades, {
        width: options.availableRect.width,
        height: options.availableRect.height,
        x: options.availableRect.x,
        y: options.availableRect.y,
        nodePadding: options.nodePadding,
        nodeWidth: options.nodeWidth,
        nodeAlign: options.nodeAlign
      });
      result.links = this._computeLinks(linksData, result.nodes, result.cascades);
    } else {
      result.error = validateResult;
    }
    return result;
  },
  overlap: function overlap(box1, box2) {
    return !(box2.x > box1.x + box1.width || box2.x + box2.width < box1.x || box2.y >= box1.y + box1.height || box2.y + box2.height <= box1.y);
  }
};
exports.layout = layout;

/***/ }),

/***/ 18170:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _constants = __webpack_require__(74878);
var _type = __webpack_require__(35922);
var states = ['normal', 'adjacentNodeHover', 'hover'];
function compileAttrs(color, itemOptions, itemBaseOptions, gradient) {
  var border = itemOptions.border;
  var baseBorder = itemBaseOptions.border;
  var borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  var borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  var borderOpacity = (0, _type.isDefined)(border.opacity) ? border.opacity : (0, _type.isDefined)(baseBorder.opacity) ? baseBorder.opacity : 1;
  var opacity = (0, _type.isDefined)(itemOptions.opacity) ? itemOptions.opacity : (0, _type.isDefined)(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
  var fill = itemOptions.color || color;
  if (itemBaseOptions.colorMode === _constants.COLOR_MODE_TARGET || itemBaseOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
    fill = color;
  } else if (itemBaseOptions.colorMode === _constants.COLOR_MODE_GRADIENT && gradient && (0, _type.isDefined)(gradient.id)) {
    fill = gradient.id;
  }
  return {
    fill: fill,
    'stroke-width': borderVisible ? borderWidth : 0,
    stroke: itemOptions.border.color || itemBaseOptions.border.color,
    'stroke-opacity': borderOpacity,
    opacity: opacity,
    hatching: itemOptions.hatching
  };
}
function Link(widget, params) {
  var that = this;
  var widgetOffset = widget._renderer.getRootOffset();
  that.code = 0;
  that.widget = widget;
  that.color = params.color;
  that.connection = params.connection;
  that.d = params.d;
  that.options = params.options;
  that.boundingRect = params.boundingRect, that.coords = {
    x: params.boundingRect.x + params.boundingRect.width / 2 + widgetOffset.left,
    y: params.boundingRect.y + params.boundingRect.height / 2 + widgetOffset.top
  };
  that.states = {
    normal: compileAttrs(that.color, that.options, that.options, params.gradient),
    adjacentNodeHover: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options, params.gradient),
    hover: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options, params.gradient)
  };
  that.overlayStates = {
    normal: compileAttrs(that.color, {
      opacity: 0,
      border: {}
    }, that.options),
    adjacentNodeHover: compileAttrs(that.color, that.options.hoverStyle, that.options),
    hover: compileAttrs(that.color, that.options.hoverStyle, that.options)
  };
}
Link.prototype = {
  getState: function getState() {
    return states[this.code];
  },
  isHovered: function isHovered() {
    return this.code === 2;
  },
  isAdjacentNodeHovered: function isAdjacentNodeHovered() {
    return this.code === 1;
  },
  setState: function setState(code, state) {
    if (state) {
      this.code = code;
    } else {
      this.code = 0;
      this.hideTooltip();
    }
    this.widget._applyLinksAppearance();
  },
  setHover: function setHover() {
    this.hover(true);
  },
  hover: function hover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }
    this.widget._suspend();
    state && this.widget.clearHover();
    this.setState(2, state);
    this.widget._eventTrigger('linkHoverChanged', {
      target: this
    });
    this.widget._resume();
  },
  adjacentNodeHover: function adjacentNodeHover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isAdjacentNodeHovered()) {
      return;
    }
    this.widget._suspend();
    this.setState(1, state);
    this.widget._resume();
  },
  setAdjacentNodeHover: function setAdjacentNodeHover() {
    this.adjacentNodeHover(true);
  },
  showTooltip: function showTooltip(coords) {
    this.widget._getOption('hoverEnabled', true) && this.widget._tooltip && this.widget._tooltip.show({
      type: 'link',
      info: {
        source: this.connection.source,
        target: this.connection.target,
        weight: this.connection.weight
      }
    }, typeof coords !== 'undefined' ? {
      x: coords[0],
      y: coords[1]
    } : this.coords);
  },
  hideTooltip: function hideTooltip() {
    this.widget._tooltip && this.widget._tooltip.hide();
  }
};
var _default = Link;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 47248:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var states = ['normal', 'hover'];
function _compileAttrs(color, itemOptions, itemBaseOptions) {
  var border = itemOptions.border;
  var baseBorder = itemBaseOptions.border;
  var borderVisible = (0, _type.isDefined)(border.visible) ? border.visible : baseBorder.visible;
  var borderWidth = (0, _type.isDefined)(border.width) ? border.width : baseBorder.width;
  var borderOpacity = (0, _type.isDefined)(border.opacity) ? border.opacity : (0, _type.isDefined)(baseBorder.opacity) ? baseBorder.opacity : 1;
  var opacity = (0, _type.isDefined)(itemOptions.opacity) ? itemOptions.opacity : (0, _type.isDefined)(itemBaseOptions.opacity) ? itemBaseOptions.opacity : 1;
  return {
    fill: itemOptions.color || color,
    'stroke-width': borderVisible ? borderWidth : 0,
    stroke: itemOptions.border.color || itemBaseOptions.border.color,
    'stroke-opacity': borderOpacity,
    opacity: opacity,
    hatching: itemOptions.hatching
  };
}
function compileLabelAttrs(labelOptions, filter, node) {
  var _patchFontOptions = _utils.patchFontOptions;
  if (labelOptions.useNodeColors) {
    labelOptions.font.color = node.color;
  }
  var borderVisible = (0, _type.isDefined)(labelOptions.border.visible) ? labelOptions.border.visible : false;
  var borderWidth = (0, _type.isDefined)(labelOptions.border.width) ? labelOptions.border.width : 0;
  var borderColor = (0, _type.isDefined)(labelOptions.border.color) ? labelOptions.border.color : labelOptions.font.color;
  var borderOpacity = (0, _type.isDefined)(labelOptions.border.opacity) ? labelOptions.border.opacity : 1;
  var attr = {
    filter: filter
  };
  if (borderVisible && borderWidth) {
    attr.stroke = borderColor;
    attr['stroke-width'] = borderVisible ? borderWidth : 0;
    attr['stroke-opacity'] = borderOpacity;
  }
  return {
    attr: attr,
    css: _patchFontOptions(labelOptions.font)
  };
}
function Node(widget, params) {
  var that = this;
  var widgetOffset = widget._renderer.getRootOffset();
  that.code = 0;
  that.widget = widget;
  that.color = params.color;
  that.options = params.options;
  that.rect = params.rect;
  that.label = that.title = params.rect._name;
  that.coords = {
    x: params.rect.x + params.rect.width / 2 + widgetOffset.left,
    y: params.rect.y + params.rect.height / 2 + widgetOffset.top
  };
  that.id = params.id;
  that.linksIn = params.linksIn;
  that.linksOut = params.linksOut;
  this.states = {
    normal: _compileAttrs(this.color, that.options, that.options),
    hover: _compileAttrs(this.color, that.options.hoverStyle, that.options)
  };
}
Node.prototype = {
  compileAttrs: function compileAttrs() {
    return _compileAttrs(this.color, this.options);
  },
  getState: function getState() {
    return states[this.code];
  },
  isHovered: function isHovered() {
    return !!(this.code & 1);
  },
  setState: function setState(code, state) {
    var _this = this;
    if (state) {
      this.code |= code;
    } else {
      this.code &= ~code;
    }
    if (state) {
      this.linksIn.concat(this.linksOut).forEach(function (adjacentLink) {
        _this.widget._links[adjacentLink.index].setAdjacentNodeHover(true);
      });
    } else {
      this.widget._links.forEach(function (link) {
        link.isAdjacentNodeHovered() && link.adjacentNodeHover(false);
      });
      this.hideTooltip();
    }
    this.widget._applyNodesAppearance();
    this.widget._applyLinksAppearance();
  },
  hover: function hover(state) {
    if (!this.widget._getOption('hoverEnabled', true) || state === this.isHovered()) {
      return;
    }
    this.widget._suspend();
    state && this.widget.clearHover();
    this.setState(1, state);
    this.widget._eventTrigger('nodeHoverChanged', {
      target: this
    });
    this.widget._resume();
  },
  setHover: function setHover() {
    this.hover(true);
  },
  showTooltip: function showTooltip(coords) {
    this.widget._getOption('hoverEnabled', true) && this.widget._tooltip && this.widget._tooltip.show({
      type: 'node',
      info: {
        label: this.label,
        title: this.label,
        weightIn: this.linksIn.reduce(function (previousValue, currentValue) {
          return previousValue + currentValue.weight;
        }, 0),
        weightOut: this.linksOut.reduce(function (previousValue, currentValue) {
          return previousValue + currentValue.weight;
        }, 0)
      }
    }, typeof coords !== 'undefined' ? {
      x: coords[0],
      y: coords[1]
    } : this.coords);
  },
  hideTooltip: function hideTooltip() {
    this.widget._tooltip && this.widget._tooltip.hide();
  },
  getLabelAttributes: function getLabelAttributes(labelSettings, filter) {
    return compileLabelAttrs(labelSettings, filter, this);
  }
};
var _default = Node;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 66422:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _constants = __webpack_require__(74878);
var _common = __webpack_require__(20576);
var _node_item = _interopRequireDefault(__webpack_require__(47248));
var _link_item = _interopRequireDefault(__webpack_require__(18170));
var _layout = __webpack_require__(68856);
var _type = __webpack_require__(35922);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function moveLabel(node, labelOptions, availableLabelWidth, rect) {
  if (node._label.getBBox().width > availableLabelWidth) {
    node.labelText.applyEllipsis(availableLabelWidth);
  }
  var bBox = node._label.getBBox();
  var verticalOffset = labelOptions.verticalOffset;
  var horizontalOffset = labelOptions.horizontalOffset;
  var labelOffsetY = Math.round(node.rect.y + node.rect.height / 2 - bBox.y - bBox.height / 2) + verticalOffset;
  var labelOffsetX = node.rect.x + horizontalOffset + node.rect.width - bBox.x;
  if (labelOffsetX + bBox.width >= rect[2] - rect[0]) {
    labelOffsetX = node.rect.x - horizontalOffset - bBox.x - bBox.width;
  }
  if (labelOffsetY >= rect[3]) {
    labelOffsetY = rect[3];
  }
  if (labelOffsetY - bBox.height < rect[1]) {
    labelOffsetY = node.rect.y - bBox.y + verticalOffset;
  }
  node.labelText.attr({
    translateX: labelOffsetX,
    translateY: labelOffsetY
  });
}
function getConnectedLinks(layout, nodeName, linkType) {
  var result = [];
  var attrName = linkType === 'in' ? '_to' : '_from';
  var invertedAttrName = linkType === 'in' ? '_from' : '_to';
  layout.links.map(function (link) {
    return link[attrName]._name === nodeName;
  }).forEach(function (connected, idx) {
    connected && result.push({
      index: idx,
      weight: layout.links[idx]._weight,
      node: layout.links[idx][invertedAttrName]._name
    });
  });
  return result;
}
var dxSankey = _m_base_widget.default.inherit({
  _rootClass: 'dxs-sankey',
  _rootClassPrefix: 'dxs',
  _proxyData: [],
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    sortData: 'DATA_SOURCE',
    alignment: 'DATA_SOURCE',
    node: 'BUILD_LAYOUT',
    link: 'BUILD_LAYOUT',
    palette: 'BUILD_LAYOUT',
    paletteExtensionMode: 'BUILD_LAYOUT'
  },
  _themeDependentChanges: ['BUILD_LAYOUT'],
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'sankey',
  _fontFields: ['label.font'],
  _optionChangesOrder: ['DATA_SOURCE'],
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function _initCore() {
    this._groupLinks = this._renderer.g().append(this._renderer.root);
    this._groupNodes = this._renderer.g().append(this._renderer.root);
    this._groupLabels = this._renderer.g().attr({
      class: this._rootClassPrefix + '-labels'
    }).append(this._renderer.root);
    this._drawLabels = true;
    this._nodes = [];
    this._links = [];
    this._gradients = [];
  },
  _disposeCore: _common.noop,
  _applySize: function _applySize(rect) {
    this._rect = rect.slice();
    var adaptiveLayout = this._getOption('adaptiveLayout');
    if (adaptiveLayout.keepLabels || this._rect[2] - this._rect[0] > adaptiveLayout.width) {
      this._drawLabels = true;
    } else {
      this._drawLabels = false;
    }
    this._change(['BUILD_LAYOUT']);
    return this._rect;
  },
  _eventsMap: {
    onNodeHoverChanged: {
      name: 'nodeHoverChanged'
    },
    onLinkHoverChanged: {
      name: 'linkHoverChanged'
    }
  },
  _customChangesOrder: ['BUILD_LAYOUT', 'NODES_DRAW', 'LINKS_DRAW', 'LABELS', 'DRAWN'],
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._requestChange(['BUILD_LAYOUT']);
  },
  _change_DRAWN: function _change_DRAWN() {
    this._drawn();
  },
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._change(['DRAWN']);
    this._updateDataSource();
  },
  _change_LABELS: function _change_LABELS() {
    this._applyLabelsAppearance();
  },
  _change_BUILD_LAYOUT: function _change_BUILD_LAYOUT() {
    this._groupNodes.clear();
    this._groupLinks.clear();
    this._groupLabels.clear();
    this._buildLayout();
  },
  _change_NODES_DRAW: function _change_NODES_DRAW() {
    var that = this;
    var nodes = that._nodes;
    nodes.forEach(function (node, index) {
      var element = that._renderer.rect().attr(node.rect).append(that._groupNodes);
      node.element = element;
    });
    this._applyNodesAppearance();
  },
  _change_LINKS_DRAW: function _change_LINKS_DRAW() {
    var that = this;
    var links = that._links;
    links.forEach(function (link, index) {
      var group = that._renderer.g().attr({
        class: 'link',
        'data-link-idx': index
      }).append(that._groupLinks);
      link.overlayElement = that._renderer.path([], 'area').attr({
        d: link.d
      }).append(group);
      link.element = that._renderer.path([], 'area').attr({
        d: link.d
      }).append(group);
    });
    this._applyLinksAppearance();
  },
  _suspend: function _suspend() {
    if (!this._applyingChanges) {
      this._suspendChanges();
    }
  },
  _resume: function _resume() {
    if (!this._applyingChanges) {
      this._resumeChanges();
    }
  },
  _showTooltip: _common.noop,
  hideTooltip: _common.noop,
  clearHover: function clearHover() {
    this._suspend();
    this._nodes.forEach(function (node) {
      node.isHovered() && node.hover(false);
    });
    this._links.forEach(function (link) {
      link.isHovered() && link.hover(false);
      link.isAdjacentNodeHovered() && link.adjacentNodeHover(false);
    });
    this._resume();
  },
  _applyNodesAppearance: function _applyNodesAppearance() {
    this._nodes.forEach(function (node) {
      var state = node.getState();
      node.element.smartAttr(node.states[state]);
    });
  },
  _applyLinksAppearance: function _applyLinksAppearance() {
    this._links.forEach(function (link) {
      var state = link.getState();
      link.element.smartAttr(link.states[state]);
      link.overlayElement.smartAttr(link.overlayStates[state]);
    });
  },
  _hitTestTargets: function _hitTestTargets(x, y) {
    var that = this;
    var data;
    this._proxyData.some(function (callback) {
      data = callback.call(that, x, y);
      if (data) {
        return true;
      }
    });
    return data;
  },
  _getData: function _getData() {
    var that = this;
    var data = that._dataSourceItems() || [];
    var sourceField = that._getOption('sourceField', true);
    var targetField = that._getOption('targetField', true);
    var weightField = that._getOption('weightField', true);
    var processedData = [];
    data.forEach(function (item) {
      var hasItemOwnProperty = Object.prototype.hasOwnProperty.bind(item);
      if (!hasItemOwnProperty(sourceField)) {
        that._incidentOccurred('E2007', sourceField);
      } else if (!hasItemOwnProperty(targetField)) {
        that._incidentOccurred('E2007', targetField);
      } else if (!hasItemOwnProperty(weightField)) {
        that._incidentOccurred('E2007', weightField);
      } else {
        if (!(0, _type.isString)(item[sourceField])) {
          that._incidentOccurred('E2008', sourceField);
        } else if (!(0, _type.isString)(item[targetField])) {
          that._incidentOccurred('E2008', targetField);
        } else if (!(0, _type.isNumeric)(item[weightField]) || item[weightField] <= 0) {
          that._incidentOccurred('E2009', weightField);
        } else {
          processedData.push([item[sourceField], item[targetField], item[weightField]]);
        }
      }
    });
    return processedData;
  },
  _buildLayout: function _buildLayout() {
    var _this = this;
    var that = this;
    var data = that._getData();
    var availableRect = this._rect;
    var nodeOptions = that._getOption('node');
    var sortData = that._getOption('sortData');
    var layoutBuilder = that._getOption('layoutBuilder', true) || _layout.layout;
    var rect = {
      x: availableRect[0],
      y: availableRect[1],
      width: availableRect[2] - availableRect[0],
      height: availableRect[3] - availableRect[1]
    };
    var layout = layoutBuilder.computeLayout(data, sortData, {
      availableRect: rect,
      nodePadding: nodeOptions.padding,
      nodeWidth: nodeOptions.width,
      nodeAlign: that._getOption('alignment', true)
    }, that._incidentOccurred);
    that._layoutMap = layout;
    if (!Object.prototype.hasOwnProperty.call(layout, 'error')) {
      var nodeColors = {};
      var nodeIdx = 0;
      var linkOptions = that._getOption('link');
      var totalNodesNum = layout.nodes.map(function (item) {
        return item.length;
      }).reduce(function (previousValue, currentValue) {
        return previousValue + currentValue;
      }, 0);
      var palette = that._themeManager.createPalette(that._getOption('palette', true), {
        useHighlight: true,
        extensionMode: that._getOption('paletteExtensionMode', true),
        count: totalNodesNum
      });
      that._nodes = [];
      that._links = [];
      that._gradients.forEach(function (gradient) {
        gradient.dispose();
      });
      that._gradients = [];
      that._shadowFilter && that._shadowFilter.dispose();
      layout.nodes.forEach(function (cascadeNodes) {
        cascadeNodes.forEach(function (node) {
          var color = nodeOptions.color || palette.getNextColor();
          var nodeItem = new _node_item.default(that, {
            id: nodeIdx,
            color: color,
            rect: node,
            options: nodeOptions,
            linksIn: getConnectedLinks(layout, node._name, 'in'),
            linksOut: getConnectedLinks(layout, node._name, 'out')
          });
          that._nodes.push(nodeItem);
          nodeIdx++;
          nodeColors[node._name] = color;
        });
      });
      layout.links.forEach(function (link) {
        var gradient = null;
        if (linkOptions.colorMode === _constants.COLOR_MODE_GRADIENT) {
          gradient = that._renderer.linearGradient([{
            offset: '0%',
            'stop-color': nodeColors[link._from._name]
          }, {
            offset: '100%',
            'stop-color': nodeColors[link._to._name]
          }]);
          _this._gradients.push(gradient);
        }
        var color = linkOptions.color;
        if (linkOptions.colorMode === _constants.COLOR_MODE_SOURCE) {
          color = nodeColors[link._from._name];
        } else if (linkOptions.colorMode === _constants.COLOR_MODE_TARGET) {
          color = nodeColors[link._to._name];
        }
        var linkItem = new _link_item.default(that, {
          d: link.d,
          boundingRect: link._boundingRect,
          color: color,
          options: linkOptions,
          connection: {
            source: link._from._name,
            target: link._to._name,
            weight: link._weight
          },
          gradient: gradient
        });
        that._links.push(linkItem);
      });
      that._renderer.initDefsElements();
      that._change(['NODES_DRAW', 'LINKS_DRAW', 'LABELS']);
    }
    that._change(['DRAWN']);
  },
  _applyLabelsAppearance: function _applyLabelsAppearance() {
    var that = this;
    var labelOptions = that._getOption('label');
    var availableWidth = that._rect[2] - that._rect[0];
    var nodeOptions = that._getOption('node');
    that._shadowFilter = that._renderer.shadowFilter('-50%', '-50%', '200%', '200%').attr(labelOptions.shadow);
    that._groupLabels.clear();
    if (that._drawLabels && labelOptions.visible) {
      // emtpy space between cascades with 'labelOptions.horizontalOffset' subtracted
      var availableLabelWidth = (availableWidth - (nodeOptions.width + labelOptions.horizontalOffset) - that._layoutMap.cascades.length * nodeOptions.width) / (that._layoutMap.cascades.length - 1) - labelOptions.horizontalOffset;
      that._nodes.forEach(function (node) {
        that._createLabel(node, labelOptions, that._shadowFilter.id);
        moveLabel(node, labelOptions, availableLabelWidth, that._rect);
      });

      // test and handle labels overlapping here
      if (labelOptions.overlappingBehavior !== 'none') {
        that._nodes.forEach(function (thisNode) {
          var thisBox = thisNode._label.getBBox();
          that._nodes.forEach(function (otherNode) {
            var otherBox = otherNode._label.getBBox();
            if (thisNode.id !== otherNode.id && _layout.layout.overlap(thisBox, otherBox)) {
              if (labelOptions.overlappingBehavior === 'ellipsis') {
                thisNode.labelText.applyEllipsis(otherBox.x - thisBox.x);
              } else if (labelOptions.overlappingBehavior === 'hide') {
                thisNode.labelText.remove();
              }
            }
          });
        });
      }
    }
  },
  _createLabel: function _createLabel(node, labelOptions, filter) {
    var textData = labelOptions.customizeText(node);
    var settings = node.getLabelAttributes(labelOptions, filter);
    if (textData) {
      node._label = this._renderer.g().append(this._groupLabels);
      node.labelText = this._renderer.text(textData).attr(settings.attr).css(settings.css);
      node.labelText.append(node._label);
    }
  },
  _getMinSize: function _getMinSize() {
    var adaptiveLayout = this._getOption('adaptiveLayout');
    return [adaptiveLayout.width, adaptiveLayout.height];
  },
  getAllNodes: function getAllNodes() {
    return this._nodes.slice();
  },
  getAllLinks: function getAllLinks() {
    return this._links.slice();
  }
});
(0, _component_registrator.default)('dxSankey', dxSankey);
var _default = dxSankey; // PLUGINS_SECTION
exports["default"] = _default;
dxSankey.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38516:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.setTooltipCustomOptions = setTooltipCustomOptions;
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var defaultCustomizeLinkTooltip = function defaultCustomizeLinkTooltip(formatter) {
  return function (info) {
    return {
      html: "<strong>".concat(info.source, " > ").concat(info.target, "</strong><br/>Weight: ").concat(formatter(info.weight))
    };
  };
};
var defaultCustomizeNodeTooltip = function defaultCustomizeNodeTooltip(formatter) {
  return function (info) {
    return {
      html: "<strong>".concat(info.label, "</strong><br/>Incoming weight: ").concat(formatter(info.weightIn), "<br/>Outgoing weight: ").concat(formatter(info.weightOut))
    };
  };
};
var generateCustomCallback = function generateCustomCallback(customCallback, defaultCallback) {
  return function (objectInfo) {
    var res = (0, _type.isFunction)(customCallback) ? customCallback.call(objectInfo, objectInfo) : {};
    var hasOwnProperty = Object.prototype.hasOwnProperty.bind(res);
    if (!hasOwnProperty('html') && !hasOwnProperty('text')) {
      res = (0, _extend2.extend)(res, defaultCallback.call(objectInfo, objectInfo));
    }
    return res;
  };
};
function setTooltipCustomOptions(sankey) {
  sankey.prototype._setTooltipOptions = function () {
    var tooltip = this._tooltip;
    var options = tooltip && this._getOption('tooltip');
    var linkTemplate;
    var nodeTemplate;
    if (options.linkTooltipTemplate) {
      linkTemplate = this._getTemplate(options.linkTooltipTemplate);
    }
    if (options.nodeTooltipTemplate) {
      nodeTemplate = this._getTemplate(options.nodeTooltipTemplate);
    }
    tooltip && tooltip.update((0, _extend2.extend)({}, options, {
      customizeTooltip: function customizeTooltip(args) {
        if (!(linkTemplate && args.type === 'link' || nodeTemplate && args.type === 'node')) {
          args.skipTemplate = true;
        }
        var formatter = function formatter(value) {
          return tooltip.formatValue(value);
        };
        if (args.type === 'node') {
          return generateCustomCallback(options.customizeNodeTooltip, defaultCustomizeNodeTooltip(formatter))(args.info);
        } else if (args.type === 'link') {
          return generateCustomCallback(options.customizeLinkTooltip, defaultCustomizeLinkTooltip(formatter))(args.info);
        }
        return {};
      },
      contentTemplate(arg, div) {
        var templateArgs = {
          model: arg.info,
          container: div
        };
        if (linkTemplate && arg.type === 'link') {
          return linkTemplate.render(templateArgs);
        }
        if (nodeTemplate && arg.type === 'node') {
          return nodeTemplate.render(templateArgs);
        }
      },
      enabled: options.enabled
    }));
  };
  sankey.prototype.hideTooltip = function () {
    this._tooltip && this._tooltip.hide();
  };
}

/***/ }),

/***/ 29823:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.plugin = void 0;
var _sankey = _interopRequireDefault(__webpack_require__(66422));
var _tracker = __webpack_require__(88997);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _sankey.default.prototype;
var DATA_KEY_BASE = '__sankey_data_';
var dataKeyModifier = 0;
proto._eventsMap.onNodeClick = {
  name: 'nodeClick'
};
proto._eventsMap.onLinkClick = {
  name: 'linkClick'
};
var getDataKey = function getDataKey() {
  return DATA_KEY_BASE + dataKeyModifier++;
};
var plugin = {
  name: 'tracker',
  init: function init() {
    var that = this;
    var dataKey = getDataKey();
    that._tracker = new _tracker.Tracker({
      widget: that,
      root: that._renderer.root,
      getData: function getData(e) {
        var target = e.target;
        return target[dataKey];
      },
      getNode: function getNode(index) {
        if (index < that._nodes.length) {
          return that._nodes[index];
        } else {
          return that._links[index - that._nodes.length];
        }
      },
      click: function click(e) {
        var eventName = this.getData(e.event) < that._nodes.length ? 'nodeClick' : 'linkClick';
        that._eventTrigger(eventName, {
          target: e.node,
          event: e.event
        });
      }
    });
    this._dataKey = dataKey;
  },
  dispose: function dispose() {
    this._tracker.dispose();
  },
  extenders: {
    _change_LINKS_DRAW: function _change_LINKS_DRAW() {
      var dataKey = this._dataKey;
      this._nodes.concat(this._links).forEach(function (item, index) {
        item.element.data(dataKey, index);
      });
    }
  }
};
exports.plugin = plugin;

/***/ }),

/***/ 90048:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _object = __webpack_require__(48013);
var _extend2 = __webpack_require__(13306);
var _scatter_series = __webpack_require__(21667);
var _line_series = __webpack_require__(7222);
var _utils = __webpack_require__(19157);
// there are area, steparea, stackedarea, fullstackedarea, splinearea

var chartLineSeries = _line_series.chart.line;
var polarLineSeries = _line_series.polar.line;
var _extend = _extend2.extend;
var calculateBezierPoints = _line_series.chart['spline']._calculateBezierPoints;
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
var baseAreaMethods = {
  _createBorderElement: chartLineSeries._createMainElement,
  _createLegendState: function _createLegendState(styleOptions, defaultColor) {
    return {
      fill: (0, _utils.extractColor)(styleOptions.color) || defaultColor,
      opacity: styleOptions.opacity,
      hatching: styleOptions.hatching,
      filter: styleOptions.highlight
    };
  },
  _getColorId: function _getColorId(options) {
    var _options$color;
    return (_options$color = options.color) === null || _options$color === void 0 ? void 0 : _options$color.fillId;
  },
  getValueRangeInitialValue: function getValueRangeInitialValue() {
    if (this.valueAxisType !== 'logarithmic' && this.valueType !== 'datetime' && this.showZero !== false) {
      return 0;
    } else {
      return _scatter_series.chart.getValueRangeInitialValue.call(this);
    }
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    var defaultSegment = chartLineSeries._getDefaultSegment(segment);
    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());
    return defaultSegment;
  },
  _updateElement: function _updateElement(element, segment, animate, complete) {
    var lineParams = {
      points: segment.line
    };
    var areaParams = {
      points: segment.area
    };
    var borderElement = element.line;
    if (animate) {
      borderElement && borderElement.animate(lineParams);
      element.area.animate(areaParams, {}, complete);
    } else {
      borderElement && borderElement.attr(lineParams);
      element.area.attr(areaParams);
    }
  },
  _removeElement: function _removeElement(element) {
    element.line && element.line.remove();
    element.area.remove();
  },
  _drawElement: function _drawElement(segment) {
    return {
      line: this._bordersGroup && this._createBorderElement(segment.line, {
        'stroke-width': this._styles.normal.border['stroke-width']
      }).append(this._bordersGroup),
      area: this._createMainElement(segment.area).append(this._elementsGroup)
    };
  },
  _applyStyle: function _applyStyle(style) {
    var that = this;
    that._elementsGroup && that._elementsGroup.smartAttr(style.elements);
    that._bordersGroup && that._bordersGroup.attr(style.border);
    (that._graphics || []).forEach(function (graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.border['stroke-width']
      }).sharp();
    });
  },
  _parseStyle: function _parseStyle(options, defaultColor, defaultBorderColor) {
    var _options$highlight;
    var borderOptions = options.border || {};
    var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);
    borderStyle.stroke = borderOptions.visible && borderStyle['stroke-width'] ? borderStyle.stroke : 'none';
    borderStyle['stroke-width'] = borderStyle['stroke-width'] || 1;
    return {
      border: borderStyle,
      elements: {
        stroke: 'none',
        fill: (0, _utils.extractColor)(options.color) || defaultColor,
        hatching: options.hatching,
        opacity: options.opacity,
        filter: (_options$highlight = options.highlight) !== null && _options$highlight !== void 0 ? _options$highlight : null
      }
    };
  },
  _areBordersVisible: function _areBordersVisible() {
    var options = this._options;
    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible;
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'area').attr(settings);
  },
  _getTrackerSettings: function _getTrackerSettings(segment) {
    return {
      'stroke-width': segment.singlePointSegment ? this._defaultTrackerWidth : 0
    };
  },
  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {
    return segment.area;
  }
};
function createAreaPoints(points) {
  return (0, _utils.map)(points, function (pt) {
    return pt.getCoords();
  }).concat((0, _utils.map)(points.slice().reverse(), function (pt) {
    return pt.getCoords(true);
  }));
}
var areaSeries = chart['area'] = _extend({}, chartLineSeries, baseAreaMethods, {
  _prepareSegment(points, rotated) {
    var that = this;
    var processedPoints = that._processSinglePointsAreaSegment(points, rotated);
    var areaPoints = createAreaPoints(processedPoints);
    var argAxis = that.getArgumentAxis();
    if (argAxis.getAxisPosition) {
      var argAxisPosition = argAxis.getAxisPosition();
      var axisOptions = argAxis.getOptions();
      var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);
      if (axisOptions.visible) {
        areaPoints.forEach(function (p, i) {
          if (p) {
            var index = points.length === 1 ? 0 : i < points.length ? i : areaPoints.length - 1 - i;
            rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);
            !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset);
          }
        });
      }
    }
    return {
      line: processedPoints,
      area: areaPoints,
      singlePointSegment: processedPoints !== points
    };
  },
  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points, rotated) {
    if (points && points.length === 1) {
      var p = points[0];
      var p1 = (0, _object.clone)(p);
      p1[rotated ? 'y' : 'x'] += 1;
      p1.argument = null;
      return [p, p1];
    }
    return points;
  }
});
polar['area'] = _extend({}, polarLineSeries, baseAreaMethods, {
  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {
    lastSegment && polarLineSeries._closeSegment.call(this, points);
    return areaSeries._prepareSegment.call(this, points);
  },
  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points) {
    return _line_series.polar.line._prepareSegment.call(this, points).line;
  }
});
chart['steparea'] = _extend({}, areaSeries, {
  _prepareSegment: function _prepareSegment(points, rotated) {
    var stepLineSeries = _line_series.chart['stepline'];
    points = areaSeries._processSinglePointsAreaSegment(points, rotated);
    return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated);
  },
  getSeriesPairCoord: _line_series.chart['stepline'].getSeriesPairCoord
});
chart['splinearea'] = _extend({}, areaSeries, {
  _areaPointsToSplineAreaPoints: function _areaPointsToSplineAreaPoints(areaPoints) {
    var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];
    var middlePoint = areaPoints[areaPoints.length / 2];
    areaPoints.splice(areaPoints.length / 2, 0, {
      x: previousMiddlePoint.x,
      y: previousMiddlePoint.y
    }, {
      x: middlePoint.x,
      y: middlePoint.y
    });
  },
  _prepareSegment: function _prepareSegment(points, rotated) {
    var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);
    var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));
    this._areaPointsToSplineAreaPoints(areaSegment.area);
    areaSegment.singlePointSegment = processedPoints !== points;
    return areaSegment;
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    var areaDefaultSegment = areaSeries._getDefaultSegment(segment);
    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);
    return areaDefaultSegment;
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'bezierarea').attr(settings);
  },
  _createBorderElement: _line_series.chart['spline']._createMainElement,
  getSeriesPairCoord: _line_series.chart['spline'].getSeriesPairCoord,
  _getNearestPoints: _line_series.chart['spline']._getNearestPoints,
  _getBezierPoints: _line_series.chart['spline']._getBezierPoints,
  obtainCubicBezierTCoef: _line_series.chart['spline'].obtainCubicBezierTCoef
});

/***/ }),

/***/ 58821:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var scatterSeries = _interopRequireWildcard(__webpack_require__(21667));
var _area_series = __webpack_require__(90048);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var areaSeries = _area_series.chart.area;
var chartSeries = scatterSeries.chart;
var polarSeries = scatterSeries.polar;
var _extend = _extend2.extend;
var _each = _iterator.each;
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
var baseBarSeriesMethods = {
  _createLegendState: function _createLegendState(styleOptions, defaultColor) {
    return {
      fill: (0, _utils.extractColor)(styleOptions.color) || defaultColor,
      hatching: styleOptions.hatching,
      filter: styleOptions.highlight
    };
  },
  _getColorId: areaSeries._getColorId,
  _parsePointStyle: function _parsePointStyle(style, defaultColor, defaultBorderColor) {
    var color = (0, _utils.extractColor)(style.color) || defaultColor;
    var base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);
    base.fill = color;
    base.hatching = style.hatching;
    base.filter = style.highlight;
    base.dashStyle = style.border && style.border.dashStyle || 'solid';
    delete base.r;
    return base;
  },
  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {
    settings['clip-path'] = null;
  },
  _setGroupsSettings: function _setGroupsSettings(animationEnabled, firstDrawing) {
    var that = this;
    var settings = {};
    chartSeries._setGroupsSettings.apply(that, arguments);
    if (animationEnabled && firstDrawing) {
      settings = this._getAffineCoordOptions();
    } else if (!animationEnabled) {
      settings = {
        scaleX: 1,
        scaleY: 1,
        translateX: 0,
        translateY: 0
      };
    }
    that._markersGroup.attr(settings);
  },
  _drawPoint: function _drawPoint(options) {
    options.hasAnimation = options.hasAnimation && !options.firstDrawing;
    options.firstDrawing = false;
    chartSeries._drawPoint.call(this, options);
  },
  _getMainColor: function _getMainColor() {
    return this._options.mainSeriesColor;
  },
  _createPointStyles: function _createPointStyles(pointOptions) {
    var _pointOptions$color;
    var that = this;
    var mainColor = (0, _utils.extractColor)(pointOptions.color, true) || that._getMainColor();
    var colorId = (_pointOptions$color = pointOptions.color) === null || _pointOptions$color === void 0 ? void 0 : _pointOptions$color.fillId;
    var hoverStyle = pointOptions.hoverStyle || {};
    var selectionStyle = pointOptions.selectionStyle || {};
    if (colorId) {
      that._turnOffHatching(hoverStyle, selectionStyle);
    }
    return {
      labelColor: mainColor,
      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
      hover: that._parsePointStyle(hoverStyle, colorId || mainColor, mainColor),
      selection: that._parsePointStyle(selectionStyle, colorId || mainColor, mainColor)
    };
  },
  _updatePointsVisibility: function _updatePointsVisibility() {
    var visibility = this._options.visible;
    (0, _iterator.each)(this._points, function (_, point) {
      point._options.visible = visibility;
    });
  },
  _getOptionsForPoint: function _getOptionsForPoint() {
    return this._options;
  },
  _animate: function _animate(firstDrawing) {
    var that = this;
    var complete = function complete() {
      that._animateComplete();
    };
    var animateFunc = function animateFunc(drawnPoints, complete) {
      var lastPointIndex = drawnPoints.length - 1;
      _each(drawnPoints || [], function (i, point) {
        point.animate(i === lastPointIndex ? complete : undefined, point.getMarkerCoords());
      });
    };
    that._animatePoints(firstDrawing, complete, animateFunc);
  },
  getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,
  _patchMarginOptions: function _patchMarginOptions(options) {
    var _this$getArgumentAxis;
    options.checkInterval = !this.useAggregation() || ((_this$getArgumentAxis = this.getArgumentAxis()) === null || _this$getArgumentAxis === void 0 ? void 0 : _this$getArgumentAxis.aggregatedPointBetweenTicks());
    return options;
  },
  _defaultAggregator: 'sum',
  _defineDrawingState() {},
  usePointsToDefineAutoHiding() {
    return false;
  }
};
chart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {
  _getAffineCoordOptions: function _getAffineCoordOptions() {
    var rotated = this._options.rotated;
    var direction = rotated ? 'X' : 'Y';
    var settings = {
      scaleX: rotated ? 0.001 : 1,
      scaleY: rotated ? 1 : 0.001
    };
    settings['translate' + direction] = this.getValueAxis().getTranslator().translate('canvas_position_default');
    return settings;
  },
  _animatePoints: function _animatePoints(firstDrawing, complete, animateFunc) {
    var that = this;
    that._markersGroup.animate({
      scaleX: 1,
      scaleY: 1,
      translateY: 0,
      translateX: 0
    }, undefined, complete);
    if (!firstDrawing) {
      animateFunc(that._drawnPoints, complete);
    }
  },
  checkSeriesViewportCoord(axis, coord) {
    if (!chartSeries.checkSeriesViewportCoord.call(this)) {
      return false;
    }
    if (axis.isArgumentAxis) {
      return true;
    }
    var translator = axis.getTranslator();
    var range = this.getViewport();
    var min = translator.translate(range.categories ? range.categories[0] : range.min);
    var max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
    var rotated = this.getOptions().rotated;
    var inverted = axis.getOptions().inverted;
    return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min;
  },
  getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var rotated = this._options.rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = isOpposite ? 'vy' : 'vx';
    var oppositeCoordName = isOpposite ? 'vx' : 'vy';
    var points = this.getPoints();
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = void 0;
      if (isArgument) {
        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : undefined;
      } else {
        tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : undefined;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
});
polar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {
  _animatePoints: function _animatePoints(firstDrawing, complete, animateFunc) {
    animateFunc(this._drawnPoints, complete);
  },
  _setGroupsSettings: chartSeries._setGroupsSettings,
  _drawPoint: function _drawPoint(point, groups, animationEnabled) {
    chartSeries._drawPoint.call(this, point, groups, animationEnabled);
  },
  _parsePointStyle: function _parsePointStyle(style) {
    var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);
    base.opacity = style.opacity;
    return base;
  },
  _createGroups: chartSeries._createGroups,
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    var that = this;
    var markersSettings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
    markersSettings['class'] = 'dxc-markers';
    that._applyMarkerClipRect(markersSettings);
    var groupSettings = _extend({}, markersSettings);
    delete groupSettings.opacity; // T110796
    that._markersGroup.attr(groupSettings);
  },
  getSeriesPairCoord(params, isArgument) {
    var coords = null;
    var paramName = isArgument ? 'argument' : 'radius';
    var points = this.getVisiblePoints();
    var argAxis = this.getArgumentAxis();
    var startAngle = argAxis.getAngles()[0];
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? (0, _utils.convertPolarToXY)(argAxis.getCenter(), startAngle, -argAxis.getTranslatedAngle(p.angle), p.radius) : undefined;
      if ((0, _type.isDefined)(tmpPoint)) {
        coords = tmpPoint;
        break;
      }
    }
    return coords;
  },
  _createLegendState: areaSeries._createLegendState
});

/***/ }),

/***/ 54932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Series = Series;
exports.mixins = void 0;
var _type = __webpack_require__(35922);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _base_point = __webpack_require__(54497);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var scatterSeries = _interopRequireWildcard(__webpack_require__(21667));
var lineSeries = _interopRequireWildcard(__webpack_require__(7222));
var areaSeries = _interopRequireWildcard(__webpack_require__(90048));
var barSeries = _interopRequireWildcard(__webpack_require__(58821));
var _range_series = __webpack_require__(57402);
var _bubble_series = __webpack_require__(64216);
var pieSeries = _interopRequireWildcard(__webpack_require__(80610));
var financialSeries = _interopRequireWildcard(__webpack_require__(29788));
var stackedSeries = _interopRequireWildcard(__webpack_require__(92057));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var seriesNS = {};
var states = _consts.default.states;
var DISCRETE = 'discrete';
var SELECTED_STATE = states.selectedMark;
var HOVER_STATE = states.hoverMark;
var HOVER = states.hover;
var NORMAL = states.normal;
var SELECTION = states.selection;
var APPLY_SELECTED = states.applySelected;
var APPLY_HOVER = states.applyHover;
var RESET_ITEM = states.resetItem;
var NONE_MODE = 'none';
var INCLUDE_POINTS = 'includepoints';
var NEAREST_POINT = 'nearestpoint';
var SERIES_SELECTION_CHANGED = 'seriesSelectionChanged';
var POINT_SELECTION_CHANGED = 'pointSelectionChanged';
var SERIES_HOVER_CHANGED = 'seriesHoverChanged';
var POINT_HOVER_CHANGED = 'pointHoverChanged';
var ALL_SERIES_POINTS = 'allseriespoints';
var ALL_ARGUMENT_POINTS = 'allargumentpoints';
var POINT_HOVER = 'pointHover';
var CLEAR_POINT_HOVER = 'clearPointHover';
var SERIES_SELECT = 'seriesSelect';
var POINT_SELECT = 'pointSelect';
var POINT_DESELECT = 'pointDeselect';
var getEmptyBusinessRange = function getEmptyBusinessRange() {
  return {
    arg: {},
    val: {}
  };
};
function triggerEvent(element, event, point) {
  element && element.trigger(event, point);
}
seriesNS.mixins = {
  chart: {},
  pie: {},
  polar: {}
};
seriesNS.mixins.chart.scatter = scatterSeries.chart;
seriesNS.mixins.polar.scatter = scatterSeries.polar;
(0, _extend2.extend)(seriesNS.mixins.pie, pieSeries);
(0, _extend2.extend)(seriesNS.mixins.chart, lineSeries.chart, areaSeries.chart, barSeries.chart, _range_series.chart, _bubble_series.chart, financialSeries, stackedSeries.chart);
(0, _extend2.extend)(seriesNS.mixins.polar, lineSeries.polar, areaSeries.polar, barSeries.polar, stackedSeries.polar);
function includePointsMode(mode) {
  mode = (0, _utils.normalizeEnum)(mode);
  return mode === INCLUDE_POINTS || mode === ALL_SERIES_POINTS;
}
function getLabelOptions(labelOptions, defaultColor) {
  var opt = labelOptions || {};
  var labelFont = (0, _extend2.extend)({}, opt.font) || {};
  var labelBorder = opt.border || {};
  var labelConnector = opt.connector || {};
  var backgroundAttr = {
    fill: opt.backgroundColor || defaultColor,
    'stroke-width': labelBorder.visible ? labelBorder.width || 0 : 0,
    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : 'none',
    dashStyle: labelBorder.dashStyle
  };
  var connectorAttr = {
    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : 'none',
    'stroke-width': labelConnector.visible ? labelConnector.width || 0 : 0
  };
  labelFont.color = opt.backgroundColor === 'none' && (0, _utils.normalizeEnum)(labelFont.color) === '#ffffff' && opt.position !== 'inside' ? defaultColor : labelFont.color;
  return {
    alignment: opt.alignment,
    format: opt.format,
    argumentFormat: opt.argumentFormat,
    customizeText: (0, _type.isFunction)(opt.customizeText) ? opt.customizeText : undefined,
    attributes: {
      font: labelFont
    },
    visible: labelFont.size !== 0 ? opt.visible : false,
    showForZeroValues: opt.showForZeroValues,
    horizontalOffset: opt.horizontalOffset,
    verticalOffset: opt.verticalOffset,
    radialOffset: opt.radialOffset,
    background: backgroundAttr,
    position: opt.position,
    connector: connectorAttr,
    rotationAngle: opt.rotationAngle,
    wordWrap: opt.wordWrap,
    textOverflow: opt.textOverflow,
    cssClass: opt.cssClass,
    displayFormat: opt.displayFormat
  };
}
function setPointHoverState(point, legendCallback) {
  point.fullState |= HOVER_STATE;
  point.applyView(legendCallback);
}
function releasePointHoverState(point, legendCallback) {
  point.fullState &= ~HOVER_STATE;
  point.applyView(legendCallback);
  point.releaseHoverState();
}
function setPointSelectedState(point, legendCallback) {
  point.fullState |= SELECTED_STATE;
  point.applyView(legendCallback);
}
function releasePointSelectedState(point, legendCallback) {
  point.fullState &= ~SELECTED_STATE;
  point.applyView(legendCallback);
}
function mergePointOptionsCore(base, extra) {
  var options = (0, _extend2.extend)({}, base, extra);
  options.border = (0, _extend2.extend)({}, base && base.border, extra && extra.border);
  return options;
}
function mergePointOptions(base, extra) {
  var options = mergePointOptionsCore(base, extra);
  options.image = (0, _extend2.extend)(true, {}, base.image, extra.image);
  options.selectionStyle = mergePointOptionsCore(base.selectionStyle, extra.selectionStyle);
  options.hoverStyle = mergePointOptionsCore(base.hoverStyle, extra.hoverStyle);
  return options;
}
function Series(settings, options) {
  var that = this;
  that.fullState = 0;
  that._extGroups = settings;
  that._renderer = settings.renderer;
  that._group = settings.renderer.g().attr({
    'class': 'dxc-series'
  });
  that._eventTrigger = settings.eventTrigger;
  that._eventPipe = settings.eventPipe;
  that._incidentOccurred = settings.incidentOccurred;
  that._legendCallback = _common.noop;
  that.updateOptions(options, settings);
}
function getData(pointData) {
  return pointData.data;
}
function getValueChecker(axisType, axis) {
  if (!axis || axisType !== 'logarithmic' || axis.getOptions().allowNegatives !== false) {
    return function () {
      return true;
    };
  } else {
    return function (value) {
      return value > 0;
    };
  }
}
Series.prototype = {
  constructor: Series,
  _createLegendState: _common.noop,
  getLegendStyles: function getLegendStyles() {
    return this._styles.legendStyles;
  },
  _createStyles: function _createStyles(options) {
    var that = this;
    var mainSeriesColor = options.mainSeriesColor;
    var colorId = this._getColorId(options);
    var hoverStyle = options.hoverStyle || {};
    var selectionStyle = options.selectionStyle || {};
    if (colorId) {
      that._turnOffHatching(hoverStyle, selectionStyle);
    }
    that._styles = {
      labelColor: mainSeriesColor,
      normal: that._parseStyle(options, mainSeriesColor, mainSeriesColor),
      hover: that._parseStyle(hoverStyle, colorId || mainSeriesColor, mainSeriesColor),
      selection: that._parseStyle(selectionStyle, colorId || mainSeriesColor, mainSeriesColor),
      legendStyles: {
        normal: that._createLegendState(options, colorId || mainSeriesColor),
        hover: that._createLegendState(hoverStyle, colorId || mainSeriesColor),
        selection: that._createLegendState(selectionStyle, colorId || mainSeriesColor)
      }
    };
  },
  setClippingParams(baseId, wideId, forceClipping) {
    var clipLabels = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    this._paneClipRectID = baseId;
    this._widePaneClipRectID = wideId;
    this._forceClipping = forceClipping;
    this._clipLabels = clipLabels;
  },
  applyClip: function applyClip() {
    this._group.attr({
      'clip-path': this._paneClipRectID
    });
  },
  resetClip: function resetClip() {
    this._group.attr({
      'clip-path': null
    });
  },
  getTagField: function getTagField() {
    return this._options.tagField || 'tag';
  },
  getValueFields: _common.noop,
  getSizeField: _common.noop,
  getArgumentField: _common.noop,
  getPoints: function getPoints() {
    return this._points;
  },
  getPointsInViewPort: function getPointsInViewPort() {
    return _range_data_calculator.default.getPointsInViewPort(this);
  },
  _createPoint: function _createPoint(data, index, oldPoint) {
    data.index = index;
    var that = this;
    var pointsByArgument = that.pointsByArgument;
    var options = that._getCreatingPointOptions(data);
    var arg = data.argument.valueOf();
    var point = oldPoint;
    if (point) {
      point.update(data, options);
    } else {
      point = new _base_point.Point(that, data, options);
      if (that.isSelected() && includePointsMode(that.lastSelectionMode)) {
        point.setView(SELECTION);
      }
    }
    var pointByArgument = pointsByArgument[arg];
    if (pointByArgument) {
      pointByArgument.push(point);
    } else {
      pointsByArgument[arg] = [point];
    }
    if (point.hasValue()) {
      that.customizePoint(point, data);
    }
    return point;
  },
  getRangeData: function getRangeData() {
    return this._visible ? this._getRangeData() : getEmptyBusinessRange();
  },
  getArgumentRange: function getArgumentRange() {
    return this._visible ? _range_data_calculator.default.getArgumentRange(this) : getEmptyBusinessRange();
  },
  getViewport: function getViewport() {
    return _range_data_calculator.default.getViewport(this);
  },
  _deleteGroup: function _deleteGroup(groupName) {
    var group = this[groupName];
    if (group) {
      group.dispose();
      this[groupName] = null;
    }
  },
  updateOptions(newOptions, settings) {
    var that = this;
    var widgetType = newOptions.widgetType;
    var oldType = that.type;
    var newType = newOptions.type;
    that.type = newType && (0, _utils.normalizeEnum)(newType.toString());
    if (!that._checkType(widgetType) || that._checkPolarBarType(widgetType, newOptions)) {
      that.dispose();
      that.isUpdated = false;
      return;
    }
    if (oldType !== that.type) {
      that._firstDrawing = true;
      that._resetType(oldType, widgetType);
      that._setType(that.type, widgetType);
    } else {
      that._defineDrawingState();
    }
    that._options = newOptions;
    that._pointOptions = null;
    that.name = newOptions.name;
    that.pane = newOptions.pane;
    that.tag = newOptions.tag;
    if (settings) {
      that._seriesModes = settings.commonSeriesModes || that._seriesModes;
      that._valueAxis = settings.valueAxis || that._valueAxis;
      that.axis = that._valueAxis && that._valueAxis.name;
      that._argumentAxis = settings.argumentAxis || that._argumentAxis;
    }
    that._createStyles(newOptions);
    that._stackName = null;
    that._updateOptions(newOptions);
    that._visible = newOptions.visible;
    that.isUpdated = true;
    that.stack = newOptions.stack;
    that.barOverlapGroup = newOptions.barOverlapGroup;
    that._createGroups();
    that._processEmptyValue = newOptions.ignoreEmptyPoints ? function (x) {
      return x === null ? undefined : x;
    } : function (x) {
      return x;
    };
  },
  _defineDrawingState() {
    this._firstDrawing = true;
  },
  _disposePoints: function _disposePoints(points) {
    (0, _iterator.each)(points || [], function (_, p) {
      p.dispose();
    });
  },
  updateDataType: function updateDataType(settings) {
    var that = this;
    that.argumentType = settings.argumentType;
    that.valueType = settings.valueType;
    that.argumentAxisType = settings.argumentAxisType;
    that.valueAxisType = settings.valueAxisType;
    that.showZero = settings.showZero;
    this._argumentChecker = getValueChecker(settings.argumentAxisType, that.getArgumentAxis());
    this._valueChecker = getValueChecker(settings.valueAxisType, that.getValueAxis());
    return that;
  },
  _argumentChecker: function _argumentChecker() {
    return true;
  },
  _valueChecker: function _valueChecker() {
    return true;
  },
  getOptions: function getOptions() {
    return this._options;
  },
  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {
    var arg = data.argument && data.argument.valueOf();
    var point = (oldPointsByArgument[arg] || [])[0];
    if (point) {
      oldPointsByArgument[arg].splice(0, 1);
    }
    return point;
  },
  updateData: function updateData(data) {
    var that = this;
    var options = that._options;
    var nameField = options.nameField;
    data = data || [];
    if (data.length) {
      that._canRenderCompleteHandle = true;
    }
    var dataSelector = this._getPointDataSelector();
    var itemsWithoutArgument = 0;
    that._data = data.reduce(function (data, dataItem, index) {
      var pointDataItem = dataSelector(dataItem);
      if ((0, _type.isDefined)(pointDataItem.argument)) {
        if (!nameField || dataItem[nameField] === options.nameFieldValue) {
          pointDataItem.index = index;
          data.push(pointDataItem);
        }
      } else {
        itemsWithoutArgument++;
      }
      return data;
    }, []);
    if (itemsWithoutArgument && itemsWithoutArgument === data.length) {
      that._incidentOccurred('W2002', [that.name, that.getArgumentField()]);
    }
    that._endUpdateData();
  },
  _getData() {
    var data = this._data || [];
    if (this.useAggregation()) {
      var argumentRange = this.argumentAxisType !== DISCRETE ? this.getArgumentRange() : {};
      var aggregationInfo = this.getArgumentAxis().getAggregationInfo(this._useAllAggregatedPoints, argumentRange);
      data = this._resample(aggregationInfo, data);
    }
    return data;
  },
  useAggregation: function useAggregation() {
    var aggregation = this.getOptions().aggregation;
    return aggregation && aggregation.enabled;
  },
  autoHidePointMarkersEnabled: _common.noop,
  usePointsToDefineAutoHiding: _common.noop,
  createPoints(useAllAggregatedPoints) {
    this._normalizeUsingAllAggregatedPoints(useAllAggregatedPoints);
    this._createPoints();
  },
  _normalizeUsingAllAggregatedPoints: function _normalizeUsingAllAggregatedPoints(useAllAggregatedPoints) {
    this._useAllAggregatedPoints = this.useAggregation() && (this.argumentAxisType === DISCRETE || (this._data || []).length > 1 && !!useAllAggregatedPoints);
  },
  _createPoints: function _createPoints() {
    var that = this;
    var oldPointsByArgument = that.pointsByArgument || {};
    var data = that._getData();
    that.pointsByArgument = {};
    that._calculateErrorBars(data);
    var skippedFields = {};
    var points = data.reduce(function (points, pointDataItem) {
      if (that._checkData(pointDataItem, skippedFields)) {
        var pointIndex = points.length;
        var oldPoint = that._getOldPoint(pointDataItem, oldPointsByArgument, pointIndex);
        var point = that._createPoint(pointDataItem, pointIndex, oldPoint);
        points.push(point);
      }
      return points;
    }, []);
    for (var field in skippedFields) {
      if (skippedFields[field] === data.length) {
        that._incidentOccurred('W2002', [that.name, field]);
      }
    }
    Object.keys(oldPointsByArgument).forEach(function (key) {
      return that._disposePoints(oldPointsByArgument[key]);
    });
    that._points = points;
  },
  _removeOldSegments: function _removeOldSegments() {
    var that = this;
    var startIndex = that._segments.length;
    (0, _iterator.each)(that._graphics.splice(startIndex, that._graphics.length) || [], function (_, elem) {
      that._removeElement(elem);
    });
    if (that._trackers) {
      (0, _iterator.each)(that._trackers.splice(startIndex, that._trackers.length) || [], function (_, elem) {
        elem.remove();
      });
    }
  },
  _prepareSegmentsPosition() {
    var points = this._points || [];
    var isCloseSegment = points[0] && points[0].hasValue() && this._options.closed;
    var segments = points.reduce(function (segments, p) {
      var segment = segments.at(-1);
      if (!p.translated) {
        p.setDefaultCoords();
      }
      if (p.hasValue() && p.hasCoords()) {
        segment.push(p);
      } else if (!p.hasValue() && segment.length) {
        segments.push([]);
      }
      return segments;
    }, [[]]);
    this._drawSegments(segments, isCloseSegment, false);
  },
  _drawElements(animationEnabled, firstDrawing) {
    var that = this;
    var points = that._points || [];
    var isCloseSegment = points[0] && points[0].hasValue() && that._options.closed;
    var groupForPoint = {
      markers: that._markersGroup,
      errorBars: that._errorBarGroup
    };
    that._drawnPoints = [];
    that._graphics = that._graphics || [];
    that._segments = [];
    var segments = points.reduce(function (segments, p) {
      var segment = segments.at(-1);
      if (p.hasValue() && p.hasCoords()) {
        that._drawPoint({
          point: p,
          groups: groupForPoint,
          hasAnimation: animationEnabled,
          firstDrawing
        });
        segment.push(p);
      } else if (!p.hasValue()) {
        segment.length && segments.push([]);
      } else {
        p.setInvisibility();
      }
      return segments;
    }, [[]]);
    that._drawSegments(segments, isCloseSegment, animationEnabled);
    that._firstDrawing = !points.length;
    that._removeOldSegments();
    animationEnabled && that._animate(firstDrawing);
  },
  _drawSegments(segments, closeSegment, animationEnabled) {
    var _this = this;
    segments.forEach(function (segment, index) {
      if (segment.length) {
        var lastSegment = closeSegment && index === segments.length - 1;
        _this._drawSegment(segment, animationEnabled, index, lastSegment);
      }
    });
  },
  draw(animationEnabled, hideLayoutLabels, legendCallback) {
    var that = this;
    var firstDrawing = that._firstDrawing;
    that._legendCallback = legendCallback || that._legendCallback;
    if (!that._visible) {
      that._group.remove();
      return;
    }
    that._appendInGroup();
    if (!that._isAllPointsTranslated) {
      that.prepareCoordinatesForPoints();
    }
    that._setGroupsSettings(animationEnabled, firstDrawing);
    !firstDrawing && !that._resetApplyingAnimation && that._prepareSegmentsPosition();
    that._drawElements(animationEnabled, firstDrawing);
    hideLayoutLabels && that.hideLabels();
    if (that.isSelected()) {
      that._changeStyle(that.lastSelectionMode, undefined, true);
    } else if (that.isHovered()) {
      that._changeStyle(that.lastHoverMode, undefined, true);
    } else {
      that._applyStyle(that._styles.normal);
    }
    that._isAllPointsTranslated = false;
    that._resetApplyingAnimation = false;
  },
  _translatePoints() {
    var _this$_points;
    var points = (_this$_points = this._points) !== null && _this$_points !== void 0 ? _this$_points : [];
    points.forEach(function (p) {
      p.translate();
    });
  },
  prepareCoordinatesForPoints() {
    this._applyVisibleArea();
    this._translatePoints();
    this._isAllPointsTranslated = true;
  },
  _setLabelGroupSettings: function _setLabelGroupSettings(animationEnabled) {
    var settings = {
      'class': 'dxc-labels',
      'pointer-events': 'none'
    };
    this._clipLabels && this._applyElementsClipRect(settings);
    this._applyClearingSettings(settings);
    animationEnabled && (settings.opacity = 0.001);
    this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup);
  },
  _checkType: function _checkType(widgetType) {
    return !!seriesNS.mixins[widgetType][this.type];
  },
  _checkPolarBarType: function _checkPolarBarType(widgetType, options) {
    return widgetType === 'polar' && options.spiderWidget && this.type.indexOf('bar') !== -1;
  },
  _resetType: function _resetType(seriesType, widgetType) {
    var methodName;
    var methods;
    if (seriesType) {
      methods = seriesNS.mixins[widgetType][seriesType];
      for (methodName in methods) {
        delete this[methodName];
      }
    }
  },
  _setType: function _setType(seriesType, widgetType) {
    var methodName;
    var methods = seriesNS.mixins[widgetType][seriesType];
    for (methodName in methods) {
      this[methodName] = methods[methodName];
    }
  },
  _setPointsView: function _setPointsView(view, target) {
    this.getPoints().forEach(function (point) {
      if (target !== point) {
        point.setView(view);
      }
    });
  },
  _resetPointsView: function _resetPointsView(view, target) {
    this.getPoints().forEach(function (point) {
      if (target !== point) {
        point.resetView(view);
      }
    });
  },
  _resetNearestPoint: function _resetNearestPoint() {
    var that = this;
    that._nearestPoint && that._nearestPoint.series !== null && that._nearestPoint.resetView(HOVER);
    that._nearestPoint = null;
  },
  _setSelectedState: function _setSelectedState(mode) {
    var that = this;
    that.lastSelectionMode = (0, _utils.normalizeEnum)(mode || that._options.selectionMode);
    that.fullState = that.fullState | SELECTED_STATE;
    that._resetNearestPoint();
    that._changeStyle(that.lastSelectionMode);
    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
      that._resetPointsView(HOVER);
    }
  },
  _releaseSelectedState: function _releaseSelectedState() {
    var that = this;
    that.fullState = that.fullState & ~SELECTED_STATE;
    that._changeStyle(that.lastSelectionMode, SELECTION);
    if (that.lastSelectionMode !== NONE_MODE && that.isHovered() && includePointsMode(that.lastHoverMode)) {
      that._setPointsView(HOVER);
    }
  },
  isFullStackedSeries: function isFullStackedSeries() {
    return this.type.indexOf('fullstacked') === 0;
  },
  isStackedSeries: function isStackedSeries() {
    return this.type.indexOf('stacked') === 0;
  },
  resetApplyingAnimation: function resetApplyingAnimation(isFirstDrawing) {
    this._resetApplyingAnimation = true;
    if (isFirstDrawing) {
      this._firstDrawing = true;
    }
  },
  isFinancialSeries: function isFinancialSeries() {
    return this.type === 'stock' || this.type === 'candlestick';
  },
  _canChangeView: function _canChangeView() {
    return !this.isSelected() && (0, _utils.normalizeEnum)(this._options.hoverMode) !== NONE_MODE;
  },
  _changeStyle: function _changeStyle(mode, resetView, skipPoints) {
    var that = this;
    var state = that.fullState;
    var styles = [NORMAL, HOVER, SELECTION, SELECTION];
    if (that.lastHoverMode === 'none') {
      state &= ~HOVER_STATE;
    }
    if (that.lastSelectionMode === 'none') {
      state &= ~SELECTED_STATE;
    }
    if (includePointsMode(mode) && !skipPoints) {
      if (!resetView) {
        that._setPointsView(styles[state]);
      } else {
        that._resetPointsView(resetView);
      }
    }
    that._legendCallback([RESET_ITEM, APPLY_HOVER, APPLY_SELECTED, APPLY_SELECTED][state]);
    that._applyStyle(that._styles[styles[state]]);
  },
  updateHover: function updateHover(x, y) {
    var that = this;
    var currentNearestPoint = that._nearestPoint;
    var point = that.isHovered() && that.lastHoverMode === NEAREST_POINT && that.getNeighborPoint(x, y);
    if (point !== currentNearestPoint && !(that.isSelected() && that.lastSelectionMode !== NONE_MODE)) {
      that._resetNearestPoint();
      if (point) {
        point.setView(HOVER);
        that._nearestPoint = point;
      }
    }
  },
  _getMainAxisName: function _getMainAxisName() {
    return this._options.rotated ? 'X' : 'Y';
  },
  areLabelsVisible: function areLabelsVisible() {
    return !(0, _type.isDefined)(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount;
  },
  getLabelVisibility: function getLabelVisibility() {
    return this.areLabelsVisible() && this._options.label && this._options.label.visible;
  },
  customizePoint: function customizePoint(point, pointData) {
    var that = this;
    var options = that._options;
    var customizePoint = options.customizePoint;
    var customizeObject;
    var pointOptions;
    var customLabelOptions;
    var customOptions;
    var customizeLabel = options.customizeLabel;
    var useLabelCustomOptions;
    var usePointCustomOptions;
    if (customizeLabel && customizeLabel.call) {
      customizeObject = (0, _extend2.extend)({
        seriesName: that.name
      }, pointData);
      customizeObject.series = that;
      customLabelOptions = customizeLabel.call(customizeObject, customizeObject);
      useLabelCustomOptions = customLabelOptions && !(0, _type.isEmptyObject)(customLabelOptions);
      customLabelOptions = useLabelCustomOptions ? (0, _extend2.extend)(true, {}, options.label, customLabelOptions) : null;
    }
    if (customizePoint && customizePoint.call) {
      customizeObject = customizeObject || (0, _extend2.extend)({
        seriesName: that.name
      }, pointData);
      customizeObject.series = that;
      customOptions = customizePoint.call(customizeObject, customizeObject);
      usePointCustomOptions = customOptions && !(0, _type.isEmptyObject)(customOptions);
    }
    if (useLabelCustomOptions || usePointCustomOptions) {
      pointOptions = that._parsePointOptions(that._preparePointOptions(customOptions), customLabelOptions || options.label, pointData, point);
      pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;
      pointOptions.styles.usePointCustomOptions = usePointCustomOptions;
      point.updateOptions(pointOptions);
    }
  },
  show: function show() {
    if (!this._visible) {
      this._changeVisibility(true);
    }
  },
  hide: function hide() {
    if (this._visible) {
      this._changeVisibility(false);
    }
  },
  _changeVisibility: function _changeVisibility(visibility) {
    var that = this;
    that._visible = that._options.visible = visibility;
    that._updatePointsVisibility();
    that.hidePointTooltip();
    that._options.visibilityChanged(that);
  },
  // TODO. Problem related to 'point' option for bar-like series. Revisit this code once options parsing is changed
  // see T243839, T231939
  _updatePointsVisibility: _common.noop,
  hideLabels: function hideLabels() {
    (0, _iterator.each)(this._points, function (_, point) {
      point._label.draw(false);
    });
  },
  _turnOffHatching(hoverStyle, selectionStyle) {
    if (hoverStyle.hatching) {
      hoverStyle.hatching.direction = 'none';
    }
    if (selectionStyle.hatching) {
      selectionStyle.hatching.direction = 'none';
    }
  },
  _parsePointOptions: function _parsePointOptions(pointOptions, labelOptions, data, point) {
    var that = this;
    var options = that._options;
    var styles = that._createPointStyles(pointOptions, data, point);
    var parsedOptions = (0, _extend2.extend)({}, pointOptions, {
      type: options.type,
      rotated: options.rotated,
      styles: styles,
      widgetType: options.widgetType,
      visibilityChanged: options.visibilityChanged
    });
    parsedOptions.label = getLabelOptions(labelOptions, styles.labelColor);
    if (that.areErrorBarsVisible()) {
      parsedOptions.errorBars = options.valueErrorBar;
    }
    return parsedOptions;
  },
  _preparePointOptions: function _preparePointOptions(customOptions) {
    var pointOptions = this._getOptionsForPoint();
    return customOptions ? mergePointOptions(pointOptions, customOptions) : pointOptions;
  },
  _getMarkerGroupOptions: function _getMarkerGroupOptions() {
    return (0, _extend2.extend)(false, {}, this._getOptionsForPoint(), {
      hoverStyle: {},
      selectionStyle: {}
    });
  },
  _getAggregationMethod: function _getAggregationMethod(isDiscrete, aggregateByCategory) {
    var options = this.getOptions().aggregation;
    var method = (0, _utils.normalizeEnum)(options.method);
    var customAggregator = method === 'custom' && options.calculate;
    var aggregator;
    if (isDiscrete && !aggregateByCategory) {
      aggregator = function aggregator(_ref) {
        var data = _ref.data;
        return data[0];
      };
    } else {
      aggregator = this._aggregators[method] || this._aggregators[this._defaultAggregator];
    }
    return customAggregator || aggregator;
  },
  _resample(_ref2, data) {
    var interval = _ref2.interval,
      ticks = _ref2.ticks,
      aggregateByCategory = _ref2.aggregateByCategory;
    var that = this;
    var isDiscrete = that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE;
    var dataIndex = 0;
    var dataSelector = this._getPointDataSelector();
    var options = that.getOptions();
    var addAggregatedData = function addAggregatedData(target, data, aggregationInfo) {
      if (!data) {
        return;
      }
      var processData = function processData(d) {
        var pointData = d && dataSelector(d, options);
        if (pointData && that._checkData(pointData)) {
          pointData.aggregationInfo = aggregationInfo;
          target.push(pointData);
        }
      };
      if (Array.isArray(data)) {
        data.forEach(processData);
      } else {
        processData(data);
      }
    };
    var aggregationMethod = this._getAggregationMethod(isDiscrete, aggregateByCategory);
    if (isDiscrete) {
      if (aggregateByCategory) {
        var categories = this.getArgumentAxis().getTranslator().getBusinessRange().categories;
        var groups = categories.reduce(function (g, category) {
          g[category.valueOf()] = [];
          return g;
        }, {});
        data.forEach(function (dataItem) {
          groups[dataItem.argument.valueOf()].push(dataItem);
        });
        return categories.reduce(function (result, c) {
          addAggregatedData(result, aggregationMethod({
            aggregationInterval: null,
            intervalStart: c,
            intervalEnd: c,
            data: groups[c.valueOf()].map(getData)
          }, that));
          return result;
        }, []);
      } else {
        return data.reduce(function (result, dataItem, index, data) {
          result[1].push(dataItem);
          if (index === data.length - 1 || (index + 1) % interval === 0) {
            var dataInInterval = result[1];
            var aggregationInfo = {
              aggregationInterval: interval,
              data: dataInInterval.map(getData)
            };
            addAggregatedData(result[0], aggregationMethod(aggregationInfo, that));
            result[1] = [];
          }
          return result;
        }, [[], []])[0];
      }
    }
    var aggregatedData = [];
    if (ticks.length === 1) {
      var aggregationInfo = {
        intervalStart: ticks[0],
        intervalEnd: ticks[0],
        aggregationInterval: null,
        data: data.map(getData)
      };
      addAggregatedData(aggregatedData, aggregationMethod(aggregationInfo, that), aggregationInfo);
    } else {
      for (var i = 1; i < ticks.length; i++) {
        var intervalEnd = ticks[i];
        var intervalStart = ticks[i - 1];
        var dataInInterval = [];
        while (data[dataIndex] && data[dataIndex].argument < intervalEnd) {
          if (data[dataIndex].argument >= intervalStart) {
            dataInInterval.push(data[dataIndex]);
          }
          dataIndex++;
        }
        var _aggregationInfo = {
          intervalStart,
          intervalEnd,
          aggregationInterval: interval,
          data: dataInInterval.map(getData)
        };
        addAggregatedData(aggregatedData, aggregationMethod(_aggregationInfo, that), _aggregationInfo);
      }
    }
    that._endUpdateData();
    return aggregatedData;
  },
  canRenderCompleteHandle: function canRenderCompleteHandle() {
    var result = this._canRenderCompleteHandle;
    delete this._canRenderCompleteHandle;
    return !!result;
  },
  isHovered: function isHovered() {
    return !!(this.fullState & 1);
  },
  isSelected: function isSelected() {
    return !!(this.fullState & 2);
  },
  isVisible: function isVisible() {
    return this._visible;
  },
  getAllPoints: function getAllPoints() {
    this._createAllAggregatedPoints();
    return (this._points || []).slice();
  },
  getPointByPos: function getPointByPos(pos) {
    this._createAllAggregatedPoints();
    return (this._points || [])[pos];
  },
  getVisiblePoints: function getVisiblePoints() {
    return (this._drawnPoints || []).slice();
  },
  selectPoint: function selectPoint(point) {
    if (!point.isSelected()) {
      setPointSelectedState(point, this._legendCallback);
      this._eventPipe({
        action: POINT_SELECT,
        target: point
      });
      this._eventTrigger(POINT_SELECTION_CHANGED, {
        target: point
      });
    }
  },
  deselectPoint: function deselectPoint(point) {
    if (point.isSelected()) {
      releasePointSelectedState(point, this._legendCallback);
      this._eventPipe({
        action: POINT_DESELECT,
        target: point
      });
      this._eventTrigger(POINT_SELECTION_CHANGED, {
        target: point
      });
    }
  },
  hover: function hover(mode) {
    var that = this;
    var eventTrigger = that._eventTrigger;
    if (that.isHovered()) {
      return;
    }
    that.lastHoverMode = (0, _utils.normalizeEnum)(mode || that._options.hoverMode);
    that.fullState = that.fullState | HOVER_STATE;
    that._changeStyle(that.lastHoverMode, undefined, that.isSelected() && that.lastSelectionMode !== NONE_MODE);
    eventTrigger(SERIES_HOVER_CHANGED, {
      target: that
    });
  },
  clearHover: function clearHover() {
    var that = this;
    var eventTrigger = that._eventTrigger;
    if (!that.isHovered()) {
      return;
    }
    that._resetNearestPoint();
    that.fullState = that.fullState & ~HOVER_STATE;
    that._changeStyle(that.lastHoverMode, HOVER, that.isSelected() && that.lastSelectionMode !== NONE_MODE);
    eventTrigger(SERIES_HOVER_CHANGED, {
      target: that
    });
  },
  hoverPoint: function hoverPoint(point) {
    var that = this;
    if (!point.isHovered()) {
      point.clearHover();
      setPointHoverState(point, that._legendCallback);
      that._canChangeView() && that._applyStyle(that._styles.hover);
      that._eventPipe({
        action: POINT_HOVER,
        target: point
      });
      that._eventTrigger(POINT_HOVER_CHANGED, {
        target: point
      });
    }
  },
  clearPointHover: function clearPointHover() {
    var that = this;
    that.getPoints().some(function (currentPoint) {
      if (currentPoint.isHovered()) {
        releasePointHoverState(currentPoint, that._legendCallback);
        that._canChangeView() && that._applyStyle(that._styles.normal);
        that._eventPipe({
          action: CLEAR_POINT_HOVER,
          target: currentPoint
        });
        that._eventTrigger(POINT_HOVER_CHANGED, {
          target: currentPoint
        });
        return true;
      }
      return false;
    });
  },
  showPointTooltip: function showPointTooltip(point) {
    triggerEvent(this._extGroups.seriesGroup, 'showpointtooltip', point);
  },
  hidePointTooltip: function hidePointTooltip(point) {
    triggerEvent(this._extGroups.seriesGroup, 'hidepointtooltip', point);
  },
  select: function select() {
    var that = this;
    if (!that.isSelected()) {
      that._setSelectedState(that._options.selectionMode);
      that._eventPipe({
        action: SERIES_SELECT,
        target: that
      });
      that._group.toForeground();
      that._eventTrigger(SERIES_SELECTION_CHANGED, {
        target: that
      });
    }
  },
  clearSelection: function clearSelection() {
    var that = this;
    if (that.isSelected()) {
      that._releaseSelectedState();
      that._eventTrigger(SERIES_SELECTION_CHANGED, {
        target: that
      });
    }
  },
  getPointsByArg: function getPointsByArg(arg, skipPointsCreation) {
    var that = this;
    var argValue = arg.valueOf();
    var points = that.pointsByArgument[argValue];
    if (!points && !skipPointsCreation && that._createAllAggregatedPoints()) {
      points = that.pointsByArgument[argValue];
    }
    return points || [];
  },
  _createAllAggregatedPoints: function _createAllAggregatedPoints() {
    if (this.useAggregation() && !this._useAllAggregatedPoints) {
      this.createPoints(true);
      return true;
    }
    return false;
  },
  getPointsByKeys: function getPointsByKeys(arg) {
    return this.getPointsByArg(arg);
  },
  notify: function notify(data) {
    var that = this;
    var action = data.action;
    var seriesModes = that._seriesModes;
    var target = data.target;
    var targetOptions = target.getOptions();
    var pointHoverMode = (0, _utils.normalizeEnum)(targetOptions.hoverMode);
    var selectionModeOfPoint = (0, _utils.normalizeEnum)(targetOptions.selectionMode);
    if (action === POINT_HOVER) {
      that._hoverPointHandler(target, pointHoverMode, data.notifyLegend);
    } else if (action === CLEAR_POINT_HOVER) {
      that._clearPointHoverHandler(target, pointHoverMode, data.notifyLegend);
    } else if (action === SERIES_SELECT) {
      target !== that && seriesModes.seriesSelectionMode === 'single' && that.clearSelection();
    } else if (action === POINT_SELECT) {
      if (seriesModes.pointSelectionMode === 'single') {
        that.getPoints().some(function (currentPoint) {
          if (currentPoint !== target && currentPoint.isSelected()) {
            that.deselectPoint(currentPoint);
            return true;
          }
          return false;
        });
      }
      that._selectPointHandler(target, selectionModeOfPoint);
    } else if (action === POINT_DESELECT) {
      that._deselectPointHandler(target, selectionModeOfPoint);
    }
  },
  _selectPointHandler: function _selectPointHandler(target, mode) {
    var that = this;
    if (mode === ALL_SERIES_POINTS) {
      target.series === that && that._setPointsView(SELECTION, target);
    } else if (mode === ALL_ARGUMENT_POINTS) {
      that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint !== target && currentPoint.setView(SELECTION);
      });
    }
  },
  _deselectPointHandler: function _deselectPointHandler(target, mode) {
    if (mode === ALL_SERIES_POINTS) {
      target.series === this && this._resetPointsView(SELECTION, target);
    } else if (mode === ALL_ARGUMENT_POINTS) {
      this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint !== target && currentPoint.resetView(SELECTION);
      });
    }
  },
  _hoverPointHandler: function _hoverPointHandler(target, mode, notifyLegend) {
    var that = this;
    if (target.series !== that && mode === ALL_ARGUMENT_POINTS) {
      that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint.setView(HOVER);
      });
      notifyLegend && that._legendCallback(target);
    } else if (mode === ALL_SERIES_POINTS && target.series === that) {
      that._setPointsView(HOVER, target);
    }
  },
  _clearPointHoverHandler: function _clearPointHoverHandler(target, mode, notifyLegend) {
    var that = this;
    if (mode === ALL_ARGUMENT_POINTS) {
      target.series !== that && that.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {
        currentPoint.resetView(HOVER);
      });
      notifyLegend && that._legendCallback(target);
    } else if (mode === ALL_SERIES_POINTS && target.series === that) {
      that._resetPointsView(HOVER, target);
    }
  },
  _deletePoints: function _deletePoints() {
    var that = this;
    that._disposePoints(that._points);
    that._points = that._drawnPoints = null;
  },
  _deleteTrackers: function _deleteTrackers() {
    var that = this;
    (0, _iterator.each)(that._trackers || [], function (_, tracker) {
      tracker.remove();
    });
    that._trackersGroup && that._trackersGroup.dispose();
    that._trackers = that._trackersGroup = null;
  },
  dispose: function dispose() {
    var that = this;
    that._deletePoints();
    that._group.dispose();
    that._labelsGroup && that._labelsGroup.dispose();
    that._errorBarGroup && that._errorBarGroup.dispose();
    that._deleteTrackers();
    that._group = that._extGroups = that._markersGroup = that._elementsGroup = that._bordersGroup = that._labelsGroup = that._errorBarGroup = that._graphics = that._rangeData = that._renderer = that._styles = that._options = that._pointOptions = that._drawnPoints = that.pointsByArgument = that._segments = that._prevSeries = null;
  },
  correctPosition: _common.noop,
  drawTrackers: _common.noop,
  getNeighborPoint: _common.noop,
  areErrorBarsVisible: _common.noop,
  _getColorId: _common.noop,
  getMarginOptions: function getMarginOptions() {
    return this._patchMarginOptions({
      percentStick: this.isFullStackedSeries()
    });
  },
  getColor: function getColor() {
    return this.getLegendStyles().normal.fill;
  },
  getOpacity: function getOpacity() {
    return this._options.opacity;
  },
  getStackName: function getStackName() {
    return this._stackName;
  },
  getBarOverlapGroup: function getBarOverlapGroup() {
    return this._options.barOverlapGroup;
  },
  getPointByCoord: function getPointByCoord(x, y) {
    var point = this.getNeighborPoint(x, y);
    return point !== null && point !== void 0 && point.coordsIn(x, y) ? point : null;
  },
  getValueAxis: function getValueAxis() {
    return this._valueAxis;
  },
  getArgumentAxis: function getArgumentAxis() {
    return this._argumentAxis;
  },
  getMarkersGroup() {
    return this._markersGroup;
  },
  getRenderer() {
    return this._renderer;
  },
  removePointElements() {
    if (this._markersGroup) {
      (0, _iterator.each)(this._points, function (_, p) {
        return p.deleteMarker();
      });
      this._markersGroup.dispose();
      this._markersGroup = null;
    }
  },
  removeGraphicElements() {
    var that = this;
    if (that._elementsGroup) {
      that._elementsGroup.dispose();
      that._elementsGroup = null;
    }
    (0, _iterator.each)(that._graphics || [], function (_, elem) {
      that._removeElement(elem);
    });
    that._graphics = null;
  },
  removeBordersGroup() {
    if (this._bordersGroup) {
      this._bordersGroup.dispose();
      this._bordersGroup = null;
    }
  }
};
var mixins = seriesNS.mixins;
exports.mixins = mixins;

/***/ }),

/***/ 64216:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.chart = void 0;
var _line_series = __webpack_require__(7222);
var _scatter_series = __webpack_require__(21667);
var _area_series = __webpack_require__(90048);
var _bar_series = __webpack_require__(58821);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _common = __webpack_require__(20576);
var lineSeries = _line_series.chart.line;
var areaSeries = _area_series.chart.area;
var chartBarSeries = _bar_series.chart.bar;
var polarBarSeries = _bar_series.polar.bar;
var _extend = _extend2.extend;
var _each = _iterator.each;
var _noop = _common.noop;
var chart = {};
exports.chart = chart;
chart.bubble = _extend({}, _scatter_series.chart, {
  _calculateErrorBars: _noop,
  _getMainColor: chartBarSeries._getMainColor,
  _createPointStyles: chartBarSeries._createPointStyles,
  _updatePointsVisibility: chartBarSeries._updatePointsVisibility,
  _getOptionsForPoint: chartBarSeries._getOptionsForPoint,
  _applyMarkerClipRect: lineSeries._applyElementsClipRect,
  _parsePointStyle: polarBarSeries._parsePointStyle,
  _createLegendState: areaSeries._createLegendState,
  _getColorId: areaSeries._getColorId,
  _setMarkerGroupSettings: polarBarSeries._setMarkerGroupSettings,
  areErrorBarsVisible: _noop,
  _createErrorBarGroup: _noop,
  _checkData: function _checkData(data, skippedFields) {
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      value: this.getValueFields()[0],
      size: this.getSizeField()
    });
  },
  _getPointDataSelector: function _getPointDataSelector(data, options) {
    var sizeField = this.getSizeField();
    var baseGetter = _scatter_series.chart._getPointDataSelector.call(this);
    return function (data) {
      var pointData = baseGetter(data);
      pointData.size = data[sizeField];
      return pointData;
    };
  },
  _aggregators: {
    avg(_ref, series) {
      var data = _ref.data,
        intervalStart = _ref.intervalStart,
        intervalEnd = _ref.intervalEnd;
      if (!data.length) {
        return;
      }
      var valueField = series.getValueFields()[0];
      var sizeField = series.getSizeField();
      var aggregate = data.reduce(function (result, item) {
        result[0] += item[valueField];
        result[1] += item[sizeField];
        result[2]++;
        return result;
      }, [0, 0, 0]);
      return {
        [valueField]: aggregate[0] / aggregate[2],
        [sizeField]: aggregate[1] / aggregate[2],
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      };
    }
  },
  getValueFields: function getValueFields() {
    return [this._options.valueField || 'val'];
  },
  getSizeField: function getSizeField() {
    return this._options.sizeField || 'size';
  },
  _animate: function _animate() {
    var that = this;
    var lastPointIndex = that._drawnPoints.length - 1;
    var labelsGroup = that._labelsGroup;
    var labelAnimFunc = function labelAnimFunc() {
      labelsGroup && labelsGroup.animate({
        opacity: 1
      }, {
        duration: that._defaultDuration
      });
    };
    _each(that._drawnPoints || [], function (i, p) {
      p.animate(i === lastPointIndex ? labelAnimFunc : undefined, {
        r: p.bubbleSize,
        translateX: p.x,
        translateY: p.y
      });
    });
  },
  _patchMarginOptions: function _patchMarginOptions(options) {
    options.processBubbleSize = true;
    return options;
  }
});

/***/ }),

/***/ 29788:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.stock = exports.candlestick = void 0;
var _scatter_series = __webpack_require__(21667);
var _bar_series = __webpack_require__(58821);
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
// there are stock, candlestick

var barSeries = _bar_series.chart.bar;
var DEFAULT_FINANCIAL_POINT_SIZE = 10;
var stock = (0, _extend2.extend)({}, _scatter_series.chart, {
  _animate: _common.noop,
  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {
    settings['clip-path'] = this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID;
  },
  _updatePointsVisibility: barSeries._updatePointsVisibility,
  _getOptionsForPoint: barSeries._getOptionsForPoint,
  _createErrorBarGroup: _common.noop,
  areErrorBarsVisible: _common.noop,
  _createGroups: _scatter_series.chart._createGroups,
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    var that = this;
    var markersGroup = that._markersGroup;
    var styles = that._createPointStyles(that._getMarkerGroupOptions());
    var defaultStyle = (0, _extend2.extend)(styles.normal, {
      'class': 'default-markers'
    });
    var defaultPositiveStyle = (0, _extend2.extend)(styles.positive.normal, {
      'class': 'default-positive-markers'
    });
    var reductionStyle = (0, _extend2.extend)(styles.reduction.normal, {
      'class': 'reduction-markers'
    });
    var reductionPositiveStyle = (0, _extend2.extend)(styles.reductionPositive.normal, {
      'class': 'reduction-positive-markers'
    });
    var markerSettings = {
      'class': 'dxc-markers'
    };
    that._applyMarkerClipRect(markerSettings);
    markersGroup.attr(markerSettings);
    that._createGroup('defaultMarkersGroup', markersGroup, markersGroup, defaultStyle);
    that._createGroup('reductionMarkersGroup', markersGroup, markersGroup, reductionStyle);
    that._createGroup('defaultPositiveMarkersGroup', markersGroup, markersGroup, defaultPositiveStyle);
    that._createGroup('reductionPositiveMarkersGroup', markersGroup, markersGroup, reductionPositiveStyle);
  },
  _setGroupsSettings: function _setGroupsSettings() {
    _scatter_series.chart._setGroupsSettings.call(this, false);
  },
  _getCreatingPointOptions: function _getCreatingPointOptions() {
    var that = this;
    var defaultPointOptions;
    var creatingPointOptions = that._predefinedPointOptions;
    if (!creatingPointOptions) {
      defaultPointOptions = this._getPointOptions();
      that._predefinedPointOptions = creatingPointOptions = (0, _extend2.extend)(true, {
        styles: {}
      }, defaultPointOptions);
      creatingPointOptions.styles.normal = creatingPointOptions.styles.positive.normal = creatingPointOptions.styles.reduction.normal = creatingPointOptions.styles.reductionPositive.normal = {
        'stroke-width': defaultPointOptions.styles && defaultPointOptions.styles.normal && defaultPointOptions.styles.normal['stroke-width']
      };
    }
    return creatingPointOptions;
  },
  _checkData: function _checkData(data, skippedFields) {
    var valueFields = this.getValueFields();
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      openValue: valueFields[0],
      highValue: valueFields[1],
      lowValue: valueFields[2],
      closeValue: valueFields[3]
    }) && data.highValue === data.highValue && data.lowValue === data.lowValue;
  },
  _getPointDataSelector: function _getPointDataSelector(data, options) {
    var _this = this;
    var that = this;
    var level;
    var valueFields = that.getValueFields();
    var argumentField = that.getArgumentField();
    var openValueField = valueFields[0];
    var highValueField = valueFields[1];
    var lowValueField = valueFields[2];
    var closeValueField = valueFields[3];
    that.level = that._options.reduction.level;
    switch ((0, _utils.normalizeEnum)(that.level)) {
      case 'open':
        level = openValueField;
        break;
      case 'high':
        level = highValueField;
        break;
      case 'low':
        level = lowValueField;
        break;
      default:
        level = closeValueField;
        that.level = 'close';
        break;
    }
    var prevLevelValue;
    return function (data) {
      var reductionValue = data[level];
      var isReduction = false;
      if ((0, _type.isDefined)(reductionValue)) {
        if ((0, _type.isDefined)(prevLevelValue)) {
          isReduction = reductionValue < prevLevelValue;
        }
        prevLevelValue = reductionValue;
      }
      return {
        argument: data[argumentField],
        highValue: _this._processEmptyValue(data[highValueField]),
        lowValue: _this._processEmptyValue(data[lowValueField]),
        closeValue: _this._processEmptyValue(data[closeValueField]),
        openValue: _this._processEmptyValue(data[openValueField]),
        reductionValue: reductionValue,
        tag: data[that.getTagField()],
        isReduction: isReduction,
        data: data
      };
    };
  },
  _parsePointStyle: function _parsePointStyle(style, defaultColor, innerColor) {
    var color = (0, _utils.extractColor)(style.color, true);
    return {
      stroke: color || defaultColor,
      'stroke-width': style.width,
      fill: color || innerColor
    };
  },
  _getDefaultStyle: function _getDefaultStyle(options) {
    var that = this;
    var mainPointColor = (0, _utils.extractColor)(options.color, true) || that._options.mainSeriesColor;
    return {
      normal: that._parsePointStyle(options, mainPointColor, mainPointColor),
      hover: that._parsePointStyle(options.hoverStyle, mainPointColor, mainPointColor),
      selection: that._parsePointStyle(options.selectionStyle, mainPointColor, mainPointColor)
    };
  },
  _getReductionStyle: function _getReductionStyle(options) {
    var that = this;
    var reductionColor = options.reduction.color;
    return {
      normal: that._parsePointStyle({
        color: reductionColor,
        width: options.width,
        hatching: options.hatching
      }, reductionColor, reductionColor),
      hover: that._parsePointStyle(options.hoverStyle, reductionColor, reductionColor),
      selection: that._parsePointStyle(options.selectionStyle, reductionColor, reductionColor)
    };
  },
  _createPointStyles: function _createPointStyles(pointOptions) {
    var that = this;
    var innerColor = that._options.innerColor;
    var styles = that._getDefaultStyle(pointOptions);
    var positiveStyle = (0, _extend2.extend)(true, {}, styles);
    var reductionStyle = that._getReductionStyle(pointOptions);
    var reductionPositiveStyle = (0, _extend2.extend)(true, {}, reductionStyle);
    positiveStyle.normal.fill = positiveStyle.hover.fill = positiveStyle.selection.fill = innerColor;
    reductionPositiveStyle.normal.fill = reductionPositiveStyle.hover.fill = reductionPositiveStyle.selection.fill = innerColor;
    styles.positive = positiveStyle;
    styles.reduction = reductionStyle;
    styles.reductionPositive = reductionPositiveStyle;
    styles.labelColor = innerColor;
    return styles;
  },
  _endUpdateData: function _endUpdateData() {
    delete this._predefinedPointOptions;
  },
  _defaultAggregator: 'ohlc',
  _aggregators: {
    'ohlc': function ohlc(_ref, series) {
      var intervalStart = _ref.intervalStart,
        intervalEnd = _ref.intervalEnd,
        data = _ref.data;
      if (!data.length) {
        return;
      }
      var result = {};
      var valueFields = series.getValueFields();
      var highValueField = valueFields[1];
      var lowValueField = valueFields[2];
      result[highValueField] = -Infinity;
      result[lowValueField] = Infinity;
      result = data.reduce(function (result, item) {
        if (item[highValueField] !== null) {
          result[highValueField] = Math.max(result[highValueField], item[highValueField]);
        }
        if (item[lowValueField] !== null) {
          result[lowValueField] = Math.min(result[lowValueField], item[lowValueField]);
        }
        return result;
      }, result);
      result[valueFields[0]] = data[0][valueFields[0]];
      result[valueFields[3]] = data[data.length - 1][valueFields[3]];
      if (!isFinite(result[highValueField])) {
        result[highValueField] = null;
      }
      if (!isFinite(result[lowValueField])) {
        result[lowValueField] = null;
      }
      result[series.getArgumentField()] = series._getIntervalCenter(intervalStart, intervalEnd);
      return result;
    }
  },
  getValueFields: function getValueFields() {
    var options = this._options;
    return [options.openValueField || 'open', options.highValueField || 'high', options.lowValueField || 'low', options.closeValueField || 'close'];
  },
  getArgumentField: function getArgumentField() {
    return this._options.argumentField || 'date';
  },
  _patchMarginOptions: function _patchMarginOptions(options) {
    var pointOptions = this._getCreatingPointOptions();
    var styles = pointOptions.styles;
    var border = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {
      return Math.max(max, style['stroke-width']);
    }, 0);
    options.size = DEFAULT_FINANCIAL_POINT_SIZE + border;
    options.sizePointNormalState = DEFAULT_FINANCIAL_POINT_SIZE;
    return options;
  },
  getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var points = this.getVisiblePoints();
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = void 0;
      if (isArgument) {
        tmpCoord = p.vx === coord ? (p.openY + p.closeY) / 2 : undefined;
      } else {
        var coords = [Math.min(p.lowY, p.highY), Math.max(p.lowY, p.highY)];
        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p.vx : undefined;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  },
  usePointsToDefineAutoHiding() {
    return false;
  }
});
exports.stock = stock;
var candlestick = (0, _extend2.extend)({}, stock, {
  _parsePointStyle: function _parsePointStyle(style, defaultColor, innerColor) {
    var color = (0, _utils.extractColor)(style.color, true) || innerColor;
    var base = stock._parsePointStyle.call(this, style, defaultColor, color);
    base.fill = color;
    base.hatching = style.hatching;
    return base;
  }
});
exports.candlestick = candlestick;

/***/ }),

/***/ 10656:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.processDisplayFormat = processDisplayFormat;
var _localization = __webpack_require__(94484);
var startPlaceHolderChar = '{';
var endPlaceHolderChar = '}';
var placeholderFormatDelimiter = ':';
function formatValue(value, format) {
  if (format) {
    if (value instanceof Date) {
      return (0, _localization.formatDate)(value, format);
    }
    if (typeof value === 'number') {
      return (0, _localization.formatNumber)(value, format);
    }
  }
  return value;
}
function getValueByPlaceHolder(placeHolder, pointInfo) {
  var customFormat = '';
  var customFormatIndex = placeHolder.indexOf(placeholderFormatDelimiter);
  if (customFormatIndex > 0) {
    customFormat = placeHolder.substr(customFormatIndex + 1);
    placeHolder = placeHolder.substr(0, customFormatIndex);
  }
  return formatValue(pointInfo[placeHolder], customFormat);
}
function processDisplayFormat(displayFormat, pointInfo) {
  var actualText = displayFormat;
  var continueProcess = true;
  while (continueProcess) {
    var startBracketIndex = actualText.indexOf(startPlaceHolderChar);
    var endBracketIndex = actualText.indexOf(endPlaceHolderChar);
    if (startBracketIndex >= 0 && endBracketIndex > 0) {
      var placeHolder = actualText.substring(startBracketIndex + 1, endBracketIndex);
      var value = getValueByPlaceHolder(placeHolder, pointInfo);
      actualText = actualText.substr(0, startBracketIndex) + value + actualText.substr(endBracketIndex + 1);
    } else {
      continueProcess = false;
    }
  }
  return actualText;
}

/***/ }),

/***/ 63407:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
var DISCRETE = 'discrete';
var abs = Math.abs,
  floor = Math.floor,
  ceil = Math.ceil,
  min = Math.min;
function continuousRangeCalculator(range, minValue, maxValue) {
  range.min = range.min < minValue ? range.min : minValue;
  range.max = range.max > maxValue ? range.max : maxValue;
}
function createGetLogFunction(axisType, axis) {
  if (axisType !== 'logarithmic') {
    return null;
  }
  var base = axis.getOptions().logarithmBase;
  return function (value) {
    var log = (0, _utils.getLog)(abs(value), base);
    var round = log < 0 ? floor : ceil;
    return round(log);
  };
}
function getRangeCalculator(axisType, axis, getLog) {
  var rangeCalculator = continuousRangeCalculator;
  if (axisType === DISCRETE) {
    rangeCalculator = function rangeCalculator(range, minValue, maxValue) {
      if (minValue !== maxValue) {
        range.categories.push(maxValue);
      }
      range.categories.push(minValue);
    };
  } else if (axis) {
    rangeCalculator = function rangeCalculator(range, value) {
      var interval = axis.calculateInterval(value, range.prevValue);
      var minInterval = range.interval;
      range.interval = (minInterval < interval ? minInterval : interval) || minInterval;
      range.prevValue = value;
      continuousRangeCalculator(range, value, value);
    };
  }
  if (getLog) {
    return function (range, minValue, maxValue) {
      var minArgs = [];
      rangeCalculator(range, minValue, maxValue);
      minValue !== 0 && minArgs.push(getLog(minValue));
      maxValue !== 0 && minArgs.push(getLog(maxValue));
      var linearThreshold = min.apply(null, minArgs);
      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;
    };
  }
  return rangeCalculator;
}
function getInitialRange(axisType, dataType, firstValue) {
  var range = {
    axisType: axisType,
    dataType: dataType
  };
  if (axisType === DISCRETE) {
    range.categories = [];
  } else {
    range.min = (0, _type.isObject)(firstValue) ? firstValue.min : firstValue;
    range.max = (0, _type.isObject)(firstValue) ? firstValue.max : firstValue;
  }
  return range;
}
function processCategories(range) {
  if (range.categories) {
    range.categories = (0, _utils.unique)(range.categories);
  }
  return range;
}
function getValueForArgument(point, extraPoint, x, range) {
  if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {
    var y1 = point.value;
    var y2 = extraPoint.value;
    var x1 = point.argument;
    var x2 = extraPoint.argument;
    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();
    return range.dataType === 'datetime' ? new Date(r) : r;
  } else {
    return point.value;
  }
}
function calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {
  var value = getValueForArgument(point, prevPoint, bound, range);
  rangeCalculator(range, value, value);
}
function isLineSeries(series) {
  return series.type.toLowerCase().indexOf('line') >= 0 || series.type.toLowerCase().indexOf('area') >= 0;
}
function getViewportReducer(series) {
  var rangeCalculator = getRangeCalculator(series.valueAxisType);
  var argumentAxis = series.getArgumentAxis();
  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};
  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;
  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {
    var range = series.getArgumentAxis().getTranslator().getBusinessRange();
    var add = (0, _utils.getAddFunction)(range, false);
    var interval = range.interval;
    if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {
      viewport.startValue = add(viewport.startValue, interval, -1);
      viewport.endValue = add(viewport.endValue, interval);
    }
  }
  var viewportFilter = getViewPortFilter(viewport);
  return function (range, point, index, points) {
    var argument = point.argument;
    if (!point.hasValue()) {
      return range;
    }
    if (viewportFilter(argument)) {
      if (!range.startCalc) {
        range.startCalc = true;
        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);
      }
      rangeCalculator(range, point.getMinValue(), point.getMaxValue());
    } else if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {
      if (!range.startCalc) {
        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);
      }
      range.endCalc = true;
      calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);
    }
    return range;
  };
}
function getViewPortFilter(viewport) {
  if (viewport.categories) {
    var dictionary = viewport.categories.reduce(function (result, category) {
      result[category.valueOf()] = true;
      return result;
    }, {});
    return function (argument) {
      return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()];
    };
  }
  if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {
    return function () {
      return true;
    };
  }
  if (!(0, _type.isDefined)(viewport.endValue)) {
    return function (argument) {
      return argument >= viewport.startValue;
    };
  }
  if (!(0, _type.isDefined)(viewport.startValue)) {
    return function (argument) {
      return argument <= viewport.endValue;
    };
  }
  return function (argument) {
    return argument >= viewport.startValue && argument <= viewport.endValue;
  };
}
var _default = {
  getViewPortFilter,
  getArgumentRange: function getArgumentRange(series) {
    var data = series._data || [];
    var range = {};
    if (data.length) {
      if (series.argumentAxisType === DISCRETE) {
        range = {
          categories: data.map(function (item) {
            return item.argument;
          })
        };
      } else {
        var interval;
        if (data.length > 1) {
          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);
          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);
          interval = min(i1, i2);
        }
        range = {
          min: data[0].argument,
          max: data[data.length - 1].argument,
          interval
        };
      }
    }
    return processCategories(range);
  },
  getRangeData: function getRangeData(series) {
    var points = series.getPoints();
    var useAggregation = series.useAggregation();
    var argumentAxis = series.getArgumentAxis();
    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && argumentAxis, createGetLogFunction(series.argumentAxisType, argumentAxis));
    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));
    var viewportReducer = getViewportReducer(series);
    var range = points.reduce(function (range, point, index, points) {
      var argument = point.argument;
      if (!point.isArgumentCorrect()) {
        return range;
      }
      argumentCalculator(range.arg, argument, argument);
      if (point.hasValue()) {
        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());
        viewportReducer(range.viewport, point, index, points);
      }
      return range;
    }, {
      arg: getInitialRange(series.argumentAxisType, series.argumentType, argumentAxis !== null && argumentAxis !== void 0 && argumentAxis.aggregatedPointBetweenTicks() ? undefined : series.getArgumentRangeInitialValue()),
      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined),
      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined)
    });
    if (useAggregation) {
      var argumentRange = this.getArgumentRange(series);
      if (series.argumentAxisType === DISCRETE) {
        range.arg = argumentRange;
      } else {
        var viewport = argumentAxis.getViewport();
        if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {
          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);
        }
        if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {
          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);
        }
      }
    }
    processCategories(range.arg);
    processCategories(range.val);
    return range;
  },
  getViewport: function getViewport(series) {
    var points = series.getPoints();
    var range = {};
    var reducer = getViewportReducer(series);
    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : undefined);
    points.some(function (point, index) {
      reducer(range, point, index, points);
      return range.endCalc;
    });
    return range;
  },
  getPointsInViewPort: function getPointsInViewPort(series) {
    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});
    var valueViewPort = series.getValueAxis().visualRange() || {};
    var valueViewPortFilter = getViewPortFilter(valueViewPort);
    var points = series.getPoints();
    var addValue = function addValue(values, point, isEdge) {
      var minValue = point.getMinValue();
      var maxValue = point.getMaxValue();
      var isMinValueInViewPort = valueViewPortFilter(minValue);
      var isMaxValueInViewPort = valueViewPortFilter(maxValue);
      if (isMinValueInViewPort) {
        values.push(minValue);
      }
      if (maxValue !== minValue && isMaxValueInViewPort) {
        values.push(maxValue);
      }
      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {
        if (!values.length) {
          values.push(valueViewPort.startValue);
        } else {
          values.push(valueViewPort.endValue);
        }
      }
    };
    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {
      var point = points[index];
      var prevPoint = points[index - 1];
      var nextPoint = points[index + 1];
      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {
        addValue(result[1], point, true);
      }
      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {
        addValue(result[1], point, true);
      }
    } : _common.noop;
    var checkPointInViewport = function checkPointInViewport(result, point, index) {
      if (argumentViewPortFilter(point.argument)) {
        addValue(result[0], point);
      } else {
        addEdgePoints(result, points, index);
      }
      return result;
    };
    return points.reduce(checkPointInViewport, [[], []]);
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 7222:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _scatter_series = __webpack_require__(21667);
var _object = __webpack_require__(48013);
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _math = __webpack_require__(60810);
// there are line, stepline, stackedline, fullstackedline, spline

var DISCRETE = 'discrete';
var round = Math.round,
  sqrt = Math.sqrt,
  pow = Math.pow,
  min = Math.min,
  max = Math.max,
  abs = Math.abs;
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
function clonePoint(point, newX, newY, newAngle) {
  var p = (0, _object.clone)(point);
  p.x = newX;
  p.y = newY;
  p.angle = newAngle;
  return p;
}
function getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {
  var correctAngle = point.angle + nextStepAngle;
  var cosSin = (0, _utils.getCosAndSin)(correctAngle);
  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;
  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;
  return clonePoint(prevPoint, x, y, correctAngle);
}
function obtainCubicBezierTCoef(p, p0, p1, p2, p3) {
  var d = p0 - p;
  var c = 3 * p1 - 3 * p0;
  var b = 3 * p2 - 6 * p1 + 3 * p0;
  var a = p3 - 3 * p2 + 3 * p1 - p0;
  return (0, _math.solveCubicEquation)(a, b, c, d);
}
var lineMethods = {
  autoHidePointMarkersEnabled() {
    return true;
  },
  _applyGroupSettings: function _applyGroupSettings(style, settings, group) {
    var that = this;
    settings = (0, _extend.extend)(settings, style);
    that._applyElementsClipRect(settings);
    group.attr(settings);
  },
  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {
    var that = this;
    var style = that._styles.normal;
    that._applyGroupSettings(style.elements, {
      'class': 'dxc-elements'
    }, that._elementsGroup);
    that._bordersGroup && that._applyGroupSettings(style.border, {
      'class': 'dxc-borders'
    }, that._bordersGroup);
    _scatter_series.chart._setGroupsSettings.call(that, animationEnabled);
    animationEnabled && that._markersGroup && that._markersGroup.attr({
      opacity: 0.001
    });
  },
  _createGroups: function _createGroups() {
    var that = this;
    that._createGroup('_elementsGroup', that, that._group);
    that._areBordersVisible() && that._createGroup('_bordersGroup', that, that._group);
    _scatter_series.chart._createGroups.call(that);
  },
  _areBordersVisible: function _areBordersVisible() {
    return false;
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    return {
      line: (0, _utils.map)(segment.line || [], function (pt) {
        return pt.getDefaultCoords();
      })
    };
  },
  _prepareSegment: function _prepareSegment(points) {
    return {
      line: points
    };
  },
  _parseLineOptions: function _parseLineOptions(options, defaultColor) {
    return {
      stroke: (0, _utils.extractColor)(options.color, true) || defaultColor,
      'stroke-width': options.width,
      dashStyle: options.dashStyle || 'solid'
    };
  },
  _parseStyle: function _parseStyle(options, defaultColor) {
    return {
      elements: this._parseLineOptions(options, defaultColor)
    };
  },
  _applyStyle: function _applyStyle(style) {
    var that = this;
    that._elementsGroup && that._elementsGroup.attr(style.elements);
    (0, _iterator.each)(that._graphics || [], function (_, graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.elements['stroke-width']
      }).sharp();
    });
  },
  _drawElement: function _drawElement(segment, group) {
    return {
      line: this._createMainElement(segment.line, {
        'stroke-width': this._styles.normal.elements['stroke-width']
      }).append(group)
    };
  },
  _removeElement: function _removeElement(element) {
    element.line.remove();
  },
  _updateElement: function _updateElement(element, segment, animate, animationComplete) {
    var params = {
      points: segment.line
    };
    var lineElement = element.line;
    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);
  },
  _animateComplete: function _animateComplete() {
    var that = this;
    _scatter_series.chart._animateComplete.call(that);
    that._markersGroup && that._markersGroup.animate({
      opacity: 1
    }, {
      duration: that._defaultDuration
    });
  },
  _animate: function _animate() {
    var that = this;
    var lastIndex = that._graphics.length - 1;
    (0, _iterator.each)(that._graphics || [], function (i, elem) {
      var complete;
      if (i === lastIndex) {
        complete = function complete() {
          that._animateComplete();
        };
      }
      that._updateElement(elem, that._segments[i], true, complete);
    });
  },
  _drawPoint: function _drawPoint(options) {
    _scatter_series.chart._drawPoint.call(this, {
      point: options.point,
      groups: options.groups
    });
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'line').attr(settings);
  },
  _sortPoints: function _sortPoints(points, rotated) {
    return rotated ? points.sort(function (p1, p2) {
      return p2.y - p1.y;
    }) : points.sort(function (p1, p2) {
      return p1.x - p2.x;
    });
  },
  _drawSegment: function _drawSegment(points, animationEnabled, segmentCount, lastSegment) {
    var that = this;
    var rotated = that._options.rotated;
    var segment = that._prepareSegment(points, rotated, lastSegment);
    that._segments.push(segment);
    if (!that._graphics[segmentCount]) {
      that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);
    } else if (!animationEnabled) {
      that._updateElement(that._graphics[segmentCount], segment);
    }
  },
  _getTrackerSettings: function _getTrackerSettings() {
    var that = this;
    var defaultTrackerWidth = that._defaultTrackerWidth;
    var strokeWidthFromElements = that._styles.normal.elements['stroke-width'];
    return {
      'stroke-width': strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,
      fill: 'none'
    };
  },
  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {
    return segment.line;
  },
  _drawTrackerElement: function _drawTrackerElement(segment) {
    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));
  },
  _updateTrackerElement: function _updateTrackerElement(segment, element) {
    var settings = this._getTrackerSettings(segment);
    settings.points = this._getMainPointsFromSegment(segment);
    element.attr(settings);
  },
  checkSeriesViewportCoord(axis, coord) {
    if (!_scatter_series.chart.checkSeriesViewportCoord.call(this)) {
      return false;
    }
    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();
    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);
    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);
    var rotated = this.getOptions().rotated;
    var inverted = axis.getOptions().inverted;
    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;
  }
};
var lineSeries = chart['line'] = (0, _extend.extend)({}, _scatter_series.chart, lineMethods, {
  getPointCenterByArg(arg) {
    var value = this.getArgumentAxis().getTranslator().translate(arg);
    return {
      x: value,
      y: value
    };
  },
  getSeriesPairCoord(coord, isArgument) {
    var that = this;
    var oppositeCoord = null;
    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
    var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;
    for (var i = 0; i < nearestPoints.length; i++) {
      var p = nearestPoints[i];
      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);
      var b = p[0].vy - p[0].vx * k;
      var tmpCoord = void 0;
      if (p[1].vx - p[0].vx === 0) {
        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;
      } else {
        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
});
chart['stepline'] = (0, _extend.extend)({}, lineSeries, {
  _calculateStepLinePoints(points) {
    var segment = [];
    var coordName = this._options.rotated ? 'x' : 'y';
    (0, _iterator.each)(points, function (i, pt) {
      var point;
      if (!i) {
        segment.push(pt);
        return;
      }
      var step = segment[segment.length - 1][coordName];
      if (step !== pt[coordName]) {
        point = (0, _object.clone)(pt);
        point[coordName] = step;
        segment.push(point);
      }
      segment.push(pt);
    });
    return segment;
  },
  _prepareSegment: function _prepareSegment(points) {
    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));
  },
  getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord;
    var rotated = this._options.rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = !isOpposite ? 'vx' : 'vy';
    var oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
    for (var i = 0; i < nearestPoints.length; i++) {
      var p = nearestPoints[i];
      var tmpCoord = void 0;
      if (isArgument) {
        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];
      } else {
        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
});
chart['spline'] = (0, _extend.extend)({}, lineSeries, {
  _calculateBezierPoints: function _calculateBezierPoints(src, rotated) {
    var bezierPoints = [];
    var pointsCopy = src;
    var checkExtremum = function checkExtremum(otherPointCoord, pointCoord, controlCoord) {
      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;
    };
    if (pointsCopy.length !== 1) {
      pointsCopy.forEach(function (curPoint, i) {
        var leftControlX;
        var leftControlY;
        var rightControlX;
        var rightControlY;
        var prevPoint = pointsCopy[i - 1];
        var nextPoint = pointsCopy[i + 1];
        var x1;
        var x2;
        var y1;
        var y2;
        var lambda = 0.5;
        var a;
        var b;
        var c;
        var xc;
        var yc;
        var shift;
        if (!i || i === pointsCopy.length - 1) {
          bezierPoints.push(curPoint, curPoint);
          return;
        }
        var xCur = curPoint.x;
        var yCur = curPoint.y;
        x1 = prevPoint.x;
        x2 = nextPoint.x;
        y1 = prevPoint.y;
        y2 = nextPoint.y;

        // check for extremum
        var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));
        if (curIsExtremum) {
          if (!rotated) {
            rightControlY = leftControlY = yCur;
            rightControlX = (xCur + nextPoint.x) / 2;
            leftControlX = (xCur + prevPoint.x) / 2;
          } else {
            rightControlX = leftControlX = xCur;
            rightControlY = (yCur + nextPoint.y) / 2;
            leftControlY = (yCur + prevPoint.y) / 2;
          }
        } else {
          a = y2 - y1;
          b = x1 - x2;
          c = y1 * x2 - x1 * y2;
          if (!rotated) {
            if (!b) {
              bezierPoints.push(curPoint, curPoint, curPoint);
              return;
            }
            xc = xCur;
            yc = -1 * (a * xc + c) / b;
            shift = yc - yCur;
            y1 -= shift;
            y2 -= shift;
          } else {
            if (!a) {
              bezierPoints.push(curPoint, curPoint, curPoint);
              return;
            }
            yc = yCur;
            xc = -1 * (b * yc + c) / a;
            shift = xc - xCur;
            x1 -= shift;
            x2 -= shift;
          }
          rightControlX = (xCur + lambda * x2) / (1 + lambda);
          rightControlY = (yCur + lambda * y2) / (1 + lambda);
          leftControlX = (xCur + lambda * x1) / (1 + lambda);
          leftControlY = (yCur + lambda * y1) / (1 + lambda);
        }

        // check control points for extremum
        if (!rotated) {
          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);
          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);
        } else {
          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);
          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);
        }
        var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);
        var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);
        bezierPoints.push(leftPoint, curPoint, rightPoint);
      });
    } else {
      bezierPoints.push(pointsCopy[0]);
    }
    return bezierPoints;
  },
  _prepareSegment: function _prepareSegment(points, rotated) {
    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));
  },
  _createMainElement: function _createMainElement(points, settings) {
    return this._renderer.path(points, 'bezier').attr(settings);
  },
  getSeriesPairCoord(coord, isArgument) {
    var that = this;
    var oppositeCoord = null;
    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
    var coordName = !isOpposite ? 'vx' : 'vy';
    var bezierCoordName = !isOpposite ? 'x' : 'y';
    var oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    var bezierOppositeCoordName = !isOpposite ? 'y' : 'x';
    var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();
    var visibleArea = axis.getVisibleArea();
    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);
    var _loop = function _loop() {
      var p = nearestPoints[i];
      if (p.length === 1) {
        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);
      } else {
        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);
        ts.forEach(function (t) {
          if (t >= 0 && t <= 1) {
            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];
            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {
              oppositeCoord = tmpCoord;
            }
          }
        });
      }
      if (oppositeCoord !== null) {
        return "break";
      }
    };
    for (var i = 0; i < nearestPoints.length; i++) {
      var _ret = _loop();
      if (_ret === "break") break;
    }
    return oppositeCoord;
  },
  _getNearestPoints(point, nextPoint, bezierPoints) {
    var index = bezierPoints.indexOf(point);
    return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint];
  },
  _getBezierPoints() {
    return this._segments.length > 0 ? this._segments.reduce(function (a, seg) {
      return a.concat(seg.line);
    }, []) : [];
  }
});
polar.line = (0, _extend.extend)({}, _scatter_series.polar, lineMethods, {
  _sortPoints: function _sortPoints(points) {
    return points;
  },
  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {
    var preparedPoints = [];
    var centerPoint = this.getValueAxis().getCenter();
    var i;
    lastSegment && this._closeSegment(points);
    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {
      for (i = 1; i < points.length; i++) {
        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint, i === points.length - 1));
      }
      if (!preparedPoints.length) {
        // T174220
        preparedPoints = points;
      }
    } else {
      return lineSeries._prepareSegment.call(this, points);
    }
    return {
      line: preparedPoints
    };
  },
  _getRemainingAngle: function _getRemainingAngle(angle) {
    var normAngle = (0, _utils.normalizeAngle)(angle);
    return angle >= 0 ? 360 - normAngle : -normAngle;
  },
  _closeSegment(points) {
    var point = this._segments.length ? this._segments[0].line[0] : points[0];
    var newPoint = clonePoint(point, point.x, point.y, point.angle);
    newPoint = this._modifyReflectedPoint(newPoint, points.at(-1));
    if (newPoint) {
      points.push(newPoint);
    }
  },
  _modifyReflectedPoint(point, lastPoint) {
    if (lastPoint.angle === point.angle) {
      return undefined;
    }
    if ((0, _utils.normalizeAngle)(round(lastPoint.angle)) === (0, _utils.normalizeAngle)(round(point.angle))) {
      point.angle = lastPoint.angle;
    } else {
      var differenceAngle = lastPoint.angle - point.angle;
      point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle);
    }
    return point;
  },
  _getTangentPoints: function _getTangentPoints(point, prevPoint, centerPoint, isLastSegment) {
    var tangentPoints = [];
    var betweenAngle = Math.round(prevPoint.angle - point.angle);
    var tan = (prevPoint.radius - point.radius) / betweenAngle;
    var i;
    if (betweenAngle === 0) {
      tangentPoints = [prevPoint, point];
    } else if (betweenAngle > 0) {
      var angle = isLastSegment ? betweenAngle : betweenAngle - 1;
      for (i = angle; i >= 0; i--) {
        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));
      }
    } else {
      var _angle = isLastSegment ? betweenAngle : betweenAngle + 1;
      for (i = 0; i >= _angle; i--) {
        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));
      }
    }
    return tangentPoints;
  },
  getSeriesPairCoord(params, isArgument) {
    var that = this;
    var argAxis = that.getArgumentAxis();
    var paramName = isArgument ? 'angle' : 'radius';
    var coordParam = params[paramName];
    var centerPoint = argAxis.getCenter();
    var getLengthByCoords = function getLengthByCoords(p1, p2) {
      return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    };
    var isInsideInterval = function isInsideInterval(prevPoint, point, _ref) {
      var x = _ref.x,
        y = _ref.y;
      return getLengthByCoords({
        x,
        y
      }, centerPoint) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;
    };
    var coords;
    var neighborPoints = that.getNeighborPoints(coordParam, paramName);
    if (neighborPoints.length === 1) {
      coords = neighborPoints[0];
    } else if (neighborPoints.length > 1) {
      var prevPoint = neighborPoints[0];
      var point = neighborPoints[1];
      if (that.argumentAxisType !== DISCRETE && that.valueAxisType !== DISCRETE) {
        var tan;
        var stepAngle;
        if (isArgument) {
          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
          stepAngle = coordParam - point.angle;
        } else {
          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);
          stepAngle = (coordParam - point.radius) / tan;
        }
        coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle);
      } else {
        if (isArgument) {
          var cosSin = (0, _utils.getCosAndSin)(-coordParam);
          var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);
          var b1 = prevPoint.y - prevPoint.x * k1;
          var k2 = cosSin.sin / cosSin.cos;
          var b2 = centerPoint.y - k2 * centerPoint.x;
          var x = (b2 - b1) / (k1 - k2);
          var y = k1 * x + b1;
          if (isInsideInterval(prevPoint, point, {
            x,
            y
          })) {
            var quarter = abs((0, _math.trunc)((360 + coordParam) / 90) % 4);
            if (quarter === 0 && x >= centerPoint.x && y <= centerPoint.y || quarter === 1 && x <= centerPoint.x && y <= centerPoint.y || quarter === 2 && x <= centerPoint.x && y >= centerPoint.y || quarter === 3 && x >= centerPoint.x && y >= centerPoint.y) {
              coords = {
                x,
                y
              };
            }
          }
        } else {
          var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);
          var y0 = prevPoint.y - prevPoint.x * k;
          var a = 1 + k * k;
          var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;
          var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);
          var d = b * b - 4 * a * c;
          if (d >= 0) {
            var x1 = (-b - sqrt(d)) / (2 * a);
            var x2 = (-b + sqrt(d)) / (2 * a);
            var y1 = k * x1 + y0;
            var y2 = k * x2 + y0;
            coords = isInsideInterval(prevPoint, point, {
              x: x1,
              y: y1
            }) ? {
              x: x1,
              y: y1
            } : isInsideInterval(prevPoint, point, {
              x: x2,
              y: y2
            }) ? {
              x: x2,
              y: y2
            } : undefined;
          }
        }
      }
    }
    return coords;
  },
  getNeighborPoints(param, paramName) {
    var points = this.getPoints();
    var neighborPoints = [];
    if (this.getOptions().closed) {
      points = (0, _extend.extend)(true, [], points);
      var lastPoint = points[points.length - 1];
      var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);
      var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);
      var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);
      var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);
      if (forwardRefPoint) {
        points.unshift(forwardRefPoint);
      }
      if (rearwardRefPoint) {
        points.push(rearwardRefPoint);
      }
    }
    for (var i = 1; i < points.length; i++) {
      if (points[i - 1][paramName] === param) {
        neighborPoints.push(points[i - 1]);
      } else if (points[i][paramName] === param) {
        neighborPoints.push(points[i]);
      } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {
        neighborPoints.push(points[i - 1]);
        neighborPoints.push(points[i]);
      }
      if (neighborPoints.length > 0) {
        break;
      }
    }
    return neighborPoints;
  }
});

/***/ }),

/***/ 80610:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.pie = exports.doughnut = exports.donut = void 0;
var _common = __webpack_require__(20576);
var _iterator = __webpack_require__(95479);
var _scatter_series = __webpack_require__(21667);
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _bar_series = __webpack_require__(58821);
// there are pie, doughnut

var chartScatterSeries = _scatter_series.chart;
var barSeries = _bar_series.chart.bar;
var _extend = _extend2.extend;
var _each = _iterator.each;
var _noop = _common.noop;
var _map = _utils.map;
var _isFinite = isFinite;
var _max = Math.max;
var ANIMATION_DURATION = 0.7;
var INSIDE = 'inside';
var pie = _extend({}, barSeries, {
  _setGroupsSettings: function _setGroupsSettings() {
    chartScatterSeries._setGroupsSettings.apply(this, arguments);
    this._labelsGroup.attr({
      'pointer-events': null
    });
  },
  _createErrorBarGroup: _noop,
  _drawPoint: function _drawPoint(options) {
    var point = options.point;
    var legendCallback = this._legendCallback;
    chartScatterSeries._drawPoint.call(this, options);
    !point.isVisible() && point.setInvisibility();
    point.isSelected() && legendCallback();
  },
  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {
    var point = (this._points || [])[index];
    if (point) {
      oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function (p) {
        return p !== point;
      });
    }
    return point;
  },
  adjustLabels: function adjustLabels(moveLabelsFromCenter) {
    return (this._points || []).reduce(function (r, p) {
      if (p._label.isVisible()) {
        p.setLabelTrackerData();
        r = p.applyWordWrap(moveLabelsFromCenter) || r;
        p.updateLabelCoord(moveLabelsFromCenter);
        return r;
      }
    }, false);
  },
  _applyElementsClipRect: _noop,
  getColor: _noop,
  areErrorBarsVisible: _noop,
  drawLabelsWOPoints: function drawLabelsWOPoints() {
    var that = this;
    if (that._options.label.position === INSIDE) {
      return false;
    }
    that._labelsGroup.append(that._extGroups.labelsGroup);
    (that._points || []).forEach(function (point) {
      point.drawLabel();
    });
    return true;
  },
  getPointsCount: function getPointsCount() {
    var _this = this;
    return this._data.filter(function (d) {
      return _this._checkData(d);
    }).length;
  },
  setMaxPointsCount: function setMaxPointsCount(count) {
    this._pointsCount = count;
  },
  _getCreatingPointOptions: function _getCreatingPointOptions(data, dataIndex) {
    return this._getPointOptions(data, dataIndex);
  },
  _updateOptions: function _updateOptions(options) {
    this.labelSpace = 0;
    this.innerRadius = this.type === 'pie' ? 0 : options.innerRadius;
  },
  _checkData: function _checkData(data, skippedFields) {
    var base = barSeries._checkData.call(this, data, skippedFields, {
      value: this.getValueFields()[0]
    });
    return this._options.paintNullPoints ? base : base && data.value !== null;
  },
  _createGroups: chartScatterSeries._createGroups,
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    this._markersGroup.attr({
      'class': 'dxc-markers'
    });
  },
  _getMainColor(data, point) {
    var pointsByArg = this.getPointsByArg(data.argument);
    var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;
    return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount);
  },
  _getPointOptions: function _getPointOptions(data) {
    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data);
  },
  _getRangeData: function _getRangeData() {
    return this._rangeData;
  },
  _createPointStyles: function _createPointStyles(pointOptions, data, point) {
    var _pointOptions$color;
    var that = this;
    var mainColor = (0, _utils.extractColor)(pointOptions.color, true) || that._getMainColor(data, point);
    var colorId = (_pointOptions$color = pointOptions.color) === null || _pointOptions$color === void 0 ? void 0 : _pointOptions$color.fillId;
    var hoverStyle = pointOptions.hoverStyle || {};
    var selectionStyle = pointOptions.selectionStyle || {};
    if (colorId) {
      that._turnOffHatching(hoverStyle, selectionStyle);
    }
    return {
      labelColor: mainColor,
      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),
      hover: that._parsePointStyle(hoverStyle, colorId || mainColor, mainColor),
      selection: that._parsePointStyle(selectionStyle, colorId || mainColor, mainColor),
      legendStyles: {
        normal: that._createLegendState(pointOptions, mainColor),
        hover: that._createLegendState(hoverStyle, colorId || mainColor),
        selection: that._createLegendState(selectionStyle, colorId || mainColor)
      }
    };
  },
  _getArrangeMinShownValue: function _getArrangeMinShownValue(points, total) {
    var minSegmentSize = this._options.minSegmentSize;
    var totalMinSegmentSize = 0;
    var totalNotMinValues = 0;
    total = total || points.length;
    _each(points, function (_, point) {
      if (point.isVisible()) {
        if (point.normalInitialValue < minSegmentSize * total / 360) {
          totalMinSegmentSize += minSegmentSize;
        } else {
          totalNotMinValues += point.normalInitialValue;
        }
      }
    });
    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0;
  },
  _applyArrangeCorrection: function _applyArrangeCorrection(points, minShownValue, total) {
    var options = this._options;
    var isClockWise = options.segmentsDirection !== 'anticlockwise';
    var shiftedAngle = _isFinite(options.startAngle) ? (0, _utils.normalizeAngle)(options.startAngle) : 0;
    var minSegmentSize = options.minSegmentSize;
    var percent;
    var correction = 0;
    var zeroTotalCorrection = 0;
    if (total === 0) {
      total = points.filter(function (el) {
        return el.isVisible();
      }).length;
      zeroTotalCorrection = 1;
    }
    _each(isClockWise ? points : points.concat([]).reverse(), function (_, point) {
      var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;
      var updatedZeroValue;
      if (minSegmentSize && point.isVisible() && val < minShownValue) {
        updatedZeroValue = minShownValue;
      }
      percent = val / total;
      point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));
      point.shiftedAngle = shiftedAngle;
      correction = correction + (updatedZeroValue || val);
    });
    this._rangeData = {
      val: {
        min: 0,
        max: correction
      }
    };
  },
  _removePoint: function _removePoint(point) {
    var points = this.getPointsByArg(point.argument);
    points.splice(points.indexOf(point), 1); // T485210
    point.dispose();
  },
  arrangePoints: function arrangePoints() {
    var that = this;
    var originalPoints = that._points || [];
    var minSegmentSize = that._options.minSegmentSize;
    var minShownValue;
    var isAllPointsNegative = true;
    var i = 0;
    var len = originalPoints.length;
    while (i < len && isAllPointsNegative) {
      isAllPointsNegative = originalPoints[i].value <= 0;
      i++;
    }
    var points = that._points = _map(originalPoints, function (point) {
      if (point.value === null || !isAllPointsNegative && point.value < 0) {
        that._removePoint(point);
        return null;
      } else {
        return point;
      }
    });
    var maxValue = points.reduce(function (max, p) {
      return _max(max, Math.abs(p.initialValue));
    }, 0);
    points.forEach(function (p) {
      p.normalInitialValue = p.initialValue / (maxValue !== 0 ? maxValue : 1);
    });
    var total = points.reduce(function (total, point) {
      return total + (point.isVisible() ? point.normalInitialValue : 0);
    }, 0);
    if (minSegmentSize) {
      minShownValue = this._getArrangeMinShownValue(points, total);
    }
    that._applyArrangeCorrection(points, minShownValue, total);
  },
  correctPosition: function correctPosition(correction, canvas) {
    _each(this._points, function (_, point) {
      point.correctPosition(correction);
    });
    this.setVisibleArea(canvas);
  },
  correctRadius: function correctRadius(correction) {
    this._points.forEach(function (point) {
      point.correctRadius(correction);
    });
  },
  correctLabelRadius: function correctLabelRadius(labelRadius) {
    this._points.forEach(function (point) {
      point.correctLabelRadius(labelRadius);
    });
  },
  setVisibleArea: function setVisibleArea(canvas) {
    this._visibleArea = {
      minX: canvas.left,
      maxX: canvas.width - canvas.right,
      minY: canvas.top,
      maxY: canvas.height - canvas.bottom
    };
  },
  _applyVisibleArea: _noop,
  _animate: function _animate(firstDrawing) {
    var that = this;
    var points = that._points;
    var pointsCount = points && points.length;
    var completeFunc = function completeFunc() {
      that._animateComplete();
    };
    var animatePoint;
    if (firstDrawing) {
      animatePoint = function animatePoint(p, i) {
        p.animate(i === pointsCount - 1 ? completeFunc : undefined, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1));
      };
    } else {
      animatePoint = function animatePoint(p, i) {
        p.animate(i === pointsCount - 1 ? completeFunc : undefined);
      };
    }
    points.forEach(animatePoint);
  },
  getVisiblePoints: function getVisiblePoints() {
    return _map(this._points, function (p) {
      return p.isVisible() ? p : null;
    });
  },
  getPointsByKeys: function getPointsByKeys(arg, argumentIndex) {
    var pointsByArg = this.getPointsByArg(arg);
    return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || [];
  }
});
exports.pie = pie;
var doughnut = pie;
exports.doughnut = doughnut;
var donut = pie;
exports.donut = donut;

/***/ }),

/***/ 27428:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _extend = _extend2.extend;
var _math = Math;
var _floor = _math.floor;
var _abs = _math.abs;
var CANVAS_POSITION_DEFAULT = 'canvas_position_default';
var DEFAULT_BAR_TRACKER_SIZE = 9;
var CORRECTING_BAR_TRACKER_VALUE = 4;
var RIGHT = 'right';
var LEFT = 'left';
var TOP = 'top';
var BOTTOM = 'bottom';
function getLabelOrientation(point) {
  var initialValue = point.initialValue;
  var invert = point._getValTranslator().getBusinessRange().invert;
  var isDiscreteValue = point.series.valueAxisType === 'discrete';
  var isFullStacked = point.series.isFullStackedSeries();
  var notAxisInverted = !isDiscreteValue && (initialValue >= 0 && !invert || initialValue < 0 && invert) || isDiscreteValue && !invert || isFullStacked;
  return notAxisInverted ? TOP : BOTTOM;
}
var _default = _extend({}, _symbol_point.default, {
  correctCoordinates(correctOptions) {
    var that = this;
    var correction = _floor(correctOptions.offset - correctOptions.width / 2);
    if (that._options.rotated) {
      that.height = correctOptions.width;
      that.yCorrection = correction;
      that.xCorrection = null;
    } else {
      that.width = correctOptions.width;
      that.xCorrection = correction;
      that.yCorrection = null;
    }
  },
  _calculateVisibility: function _calculateVisibility(x, y, width, height) {
    var _this$_getVisibleArea = this._getVisibleArea(),
      minX = _this$_getVisibleArea.minX,
      maxX = _this$_getVisibleArea.maxX,
      minY = _this$_getVisibleArea.minY,
      maxY = _this$_getVisibleArea.maxY;
    this.inVisibleArea = minX <= x + width && maxX >= x && minY <= y + height && maxY >= y;
  },
  _cacheVisibility: function _cacheVisibility(x, y, minY, rotated) {
    y = Math.min(y, minY);
    var size = Math.abs(y - minY);
    if (rotated) {
      this._calculateVisibility(y, x, size, this.height);
    } else {
      this._calculateVisibility(x, y, this.width, size);
    }
  },
  _getGraphicBBox: function _getGraphicBBox(location) {
    var bBox = {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
    if (location) {
      var isTop = location === 'top';
      if (!this._options.rotated) {
        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
        bBox.height = 0;
      } else {
        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
        bBox.width = 0;
      }
    }
    return bBox;
  },
  _getLabelConnector: function _getLabelConnector(location) {
    return this._getGraphicBBox(location);
  },
  _getLabelPosition: function _getLabelPosition() {
    var position = getLabelOrientation(this);
    if (this._options.rotated) {
      position = position === TOP ? RIGHT : LEFT;
    }
    return position;
  },
  _getLabelCoords: function _getLabelCoords(label) {
    var that = this;
    var coords;
    if (that.initialValue === 0 && that.series.isFullStackedSeries()) {
      if (!this._options.rotated) {
        coords = that._getLabelCoordOfPosition(label, TOP);
      } else {
        coords = that._getLabelCoordOfPosition(label, RIGHT);
      }
    } else if (label.getLayoutOptions().position === 'inside') {
      coords = that._getLabelCoordOfPosition(label, 'inside');
    } else {
      coords = _symbol_point.default._getLabelCoords.call(this, label);
    }
    return coords;
  },
  _drawLabel: function _drawLabel() {
    this._label.pointPosition = this._label.getLayoutOptions().position !== 'inside' && getLabelOrientation(this);
    _symbol_point.default._drawLabel.call(this);
  },
  hideInsideLabel: function hideInsideLabel(label, coord) {
    var graphicBBox = this._getGraphicBBox();
    var labelBBox = label.getBoundingRect();
    if (this._options.resolveLabelsOverlapping) {
      if ((coord.y <= graphicBBox.y && coord.y + labelBBox.height >= graphicBBox.y + graphicBBox.height || coord.x <= graphicBBox.x && coord.x + labelBBox.width >= graphicBBox.x + graphicBBox.width) && !(coord.y > graphicBBox.y + graphicBBox.height || coord.y + labelBBox.height < graphicBBox.y || coord.x > graphicBBox.x + graphicBBox.width || coord.x + labelBBox.width < graphicBBox.x)) {
        label.draw(false);
        return true;
      }
    }
    return false;
  },
  _showForZeroValues: function _showForZeroValues() {
    return this._options.label.showForZeroValues || this.initialValue;
  },
  _drawMarker(renderer, group, animationEnabled) {
    var that = this;
    var style = that._getStyle();
    var r = that._options.cornerRadius;
    var rotated = that._options.rotated;
    var _that$getMarkerCoords = that.getMarkerCoords(),
      x = _that$getMarkerCoords.x,
      y = _that$getMarkerCoords.y,
      width = _that$getMarkerCoords.width,
      height = _that$getMarkerCoords.height;
    if (animationEnabled) {
      if (rotated) {
        width = 0;
        x = that.defaultX;
      } else {
        height = 0;
        y = that.defaultY;
      }
    }
    that.graphic = renderer.rect(x, y, width, height).attr({
      rx: r,
      ry: r
    }).smartAttr(style).data({
      'chart-data-point': that
    }).append(group);
  },
  _getSettingsForTracker: function _getSettingsForTracker() {
    var that = this;
    var y = that.y;
    var height = that.height;
    var x = that.x;
    var width = that.width;
    if (that._options.rotated) {
      if (width === 1) {
        width = DEFAULT_BAR_TRACKER_SIZE;
        x -= CORRECTING_BAR_TRACKER_VALUE;
      }
    } else {
      if (height === 1) {
        height = DEFAULT_BAR_TRACKER_SIZE;
        y -= CORRECTING_BAR_TRACKER_VALUE;
      }
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  getGraphicSettings: function getGraphicSettings() {
    var graphic = this.graphic;
    return {
      x: graphic.attr('x'),
      y: graphic.attr('y'),
      height: graphic.attr('height'),
      width: graphic.attr('width')
    };
  },
  _getEdgeTooltipParams() {
    var isPositive = this.value >= 0;
    var xCoord;
    var yCoord;
    var invertedBusinessRange = this._getValTranslator().getBusinessRange().invert;
    var x = this.x,
      y = this.y,
      width = this.width,
      height = this.height;
    if (this._options.rotated) {
      yCoord = y + height / 2;
      if (invertedBusinessRange) {
        xCoord = isPositive ? x : x + width;
      } else {
        xCoord = isPositive ? x + width : x;
      }
    } else {
      xCoord = x + width / 2;
      if (invertedBusinessRange) {
        yCoord = isPositive ? y + height : y;
      } else {
        yCoord = isPositive ? y : y + height;
      }
    }
    return {
      x: xCoord,
      y: yCoord,
      offset: 0
    };
  },
  getTooltipParams: function getTooltipParams(location) {
    if (location === 'edge') {
      return this._getEdgeTooltipParams();
    }
    var center = this.getCenterCoord();
    center.offset = 0;
    return center;
  },
  getCenterCoord() {
    var width = this.width,
      height = this.height,
      x = this.x,
      y = this.y;
    return {
      x: x + width / 2,
      y: y + height / 2
    };
  },
  _truncateCoord: function _truncateCoord(coord, bounds) {
    if (coord === null) {
      return coord;
    }
    if (coord < bounds[0]) {
      return bounds[0];
    }
    if (coord > bounds[1]) {
      return bounds[1];
    }
    return coord;
  },
  _getErrorBarBaseEdgeLength() {
    return this._options.rotated ? this.height : this.width;
  },
  _translateErrorBars: function _translateErrorBars(argVisibleArea) {
    _symbol_point.default._translateErrorBars.call(this);
    if (this._errorBarPos < argVisibleArea[0] || this._errorBarPos > argVisibleArea[1]) {
      this._errorBarPos = undefined;
    }
  },
  // TODO check & rework
  _translate: function _translate() {
    var that = this;
    var rotated = that._options.rotated;
    var valAxis = rotated ? 'x' : 'y';
    var argAxis = rotated ? 'y' : 'x';
    var valIntervalName = rotated ? 'width' : 'height';
    var argIntervalName = rotated ? 'height' : 'width';
    var argTranslator = that._getArgTranslator();
    var valTranslator = that._getValTranslator();
    var argVisibleArea = that.series.getArgumentAxis().getVisibleArea();
    var valVisibleArea = that.series.getValueAxis().getVisibleArea();
    var arg = argTranslator.translate(that.argument);
    var val = valTranslator.translate(that.value, 1);
    var minVal = valTranslator.translate(that.minValue, -1);
    that[argAxis] = arg = arg === null ? arg : arg + (that[argAxis + 'Correction'] || 0);
    that['v' + valAxis] = val;
    that['v' + argAxis] = arg + that[argIntervalName] / 2;
    this._cacheVisibility(arg, val, minVal, rotated);
    val = that._truncateCoord(val, valVisibleArea);
    minVal = that._truncateCoord(minVal, valVisibleArea);
    that[valIntervalName] = _abs(val - minVal);
    val = val < minVal ? val : minVal;
    that[valAxis] = val === null ? val : val + (that[valAxis + 'Correction'] || 0);
    that['min' + valAxis.toUpperCase()] = minVal === null ? minVal : minVal + (that[valAxis + 'Correction'] || 0);
    that['default' + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    that._translateErrorBars(argVisibleArea);
    if (that.inVisibleArea && that[argAxis] !== null) {
      if (that[argAxis] < argVisibleArea[0]) {
        that[argIntervalName] = that[argIntervalName] - (argVisibleArea[0] - that[argAxis]);
        that[argAxis] = argVisibleArea[0];
      }
      if (that[argAxis] + that[argIntervalName] > argVisibleArea[1]) {
        that[argIntervalName] = argVisibleArea[1] - that[argAxis];
      }
    }
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    this.graphic.smartAttr(_extend({}, style, !animationEnabled ? this.getMarkerCoords() : {}));
  },
  getMarkerCoords: function getMarkerCoords() {
    var that = this;
    var x = that.x;
    var y = that.y;
    var width = that.width;
    var height = that.height;
    var argAxis = that.series.getArgumentAxis();
    var rotated = that._options.rotated;
    if (argAxis.getAxisPosition) {
      var axisOptions = argAxis.getOptions();
      var edgeOffset = Math.round(axisOptions.width / 2);
      var argAxisPosition = argAxis.getAxisPosition();
      if (axisOptions.visible) {
        if (!rotated) {
          height -= that.minY === that.defaultY && that.minY === argAxisPosition - argAxis.getAxisShift() ? edgeOffset : 0;
          height < 0 && (height = 0);
        } else {
          var isStartFromAxis = that.minX === that.defaultX && that.minX === argAxisPosition - argAxis.getAxisShift();
          x += isStartFromAxis ? edgeOffset : 0;
          width -= isStartFromAxis ? edgeOffset : 0;
          width < 0 && (width = 0);
        }
      }
    }
    return {
      x,
      y,
      width,
      height
    };
  },
  coordsIn: function coordsIn(x, y) {
    var that = this;
    return x >= that.x && x <= that.x + that.width && y >= that.y && y <= that.y + that.height;
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 54497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Point = Point;
var _consts = _interopRequireDefault(__webpack_require__(32410));
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
var _bubble_point = _interopRequireDefault(__webpack_require__(37440));
var _pie_point = _interopRequireDefault(__webpack_require__(85912));
var _range_symbol_point = _interopRequireDefault(__webpack_require__(97319));
var _range_bar_point = _interopRequireDefault(__webpack_require__(73206));
var _candlestick_point = _interopRequireDefault(__webpack_require__(69297));
var _stock_point = _interopRequireDefault(__webpack_require__(71678));
var _polar_point = __webpack_require__(38234);
var _utils = __webpack_require__(19157);
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var mixins = {};
var _extend = _extend2.extend;
var statesConsts = _consts.default.states;
var SYMBOL_POINT = 'symbolPoint';
var POLAR_SYMBOL_POINT = 'polarSymbolPoint';
var BAR_POINT = 'barPoint';
var POLAR_BAR_POINT = 'polarBarPoint';
var PIE_POINT = 'piePoint';
var SELECTED_STATE = statesConsts.selectedMark;
var HOVER_STATE = statesConsts.hoverMark;
var NORMAL_STATE = statesConsts.normalMark;
var HOVER = statesConsts.hover;
var NORMAL = statesConsts.normal;
var SELECTION = statesConsts.selection;
var pointTypes = {
  chart: {
    'scatter': SYMBOL_POINT,
    'line': SYMBOL_POINT,
    'spline': SYMBOL_POINT,
    'stepline': SYMBOL_POINT,
    'stackedline': SYMBOL_POINT,
    'fullstackedline': SYMBOL_POINT,
    'stackedspline': SYMBOL_POINT,
    'fullstackedspline': SYMBOL_POINT,
    'stackedsplinearea': SYMBOL_POINT,
    'fullstackedsplinearea': SYMBOL_POINT,
    'area': SYMBOL_POINT,
    'splinearea': SYMBOL_POINT,
    'steparea': SYMBOL_POINT,
    'stackedarea': SYMBOL_POINT,
    'fullstackedarea': SYMBOL_POINT,
    'rangearea': 'rangeSymbolPoint',
    'bar': BAR_POINT,
    'stackedbar': BAR_POINT,
    'fullstackedbar': BAR_POINT,
    'rangebar': 'rangeBarPoint',
    'bubble': 'bubblePoint',
    'stock': 'stockPoint',
    'candlestick': 'candlestickPoint'
  },
  pie: {
    'pie': PIE_POINT,
    'doughnut': PIE_POINT,
    'donut': PIE_POINT
  },
  polar: {
    'scatter': POLAR_SYMBOL_POINT,
    'line': POLAR_SYMBOL_POINT,
    'area': POLAR_SYMBOL_POINT,
    'bar': POLAR_BAR_POINT,
    'stackedbar': POLAR_BAR_POINT
  }
};
function isNoneMode(mode) {
  return (0, _utils.normalizeEnum)(mode) === 'none';
}
function Point(series, dataItem, options) {
  this.fullState = NORMAL_STATE;
  this.series = series;
  this.update(dataItem, options);
  this._viewCounters = {
    hover: 0,
    selection: 0
  };
  this._emptySettings = {
    fill: null,
    stroke: null,
    dashStyle: null,
    filter: null
  };
}
mixins.symbolPoint = _symbol_point.default;
mixins.barPoint = _bar_point.default;
mixins.bubblePoint = _bubble_point.default;
mixins.piePoint = _pie_point.default;
mixins.rangeSymbolPoint = _range_symbol_point.default;
mixins.rangeBarPoint = _range_bar_point.default;
mixins.candlestickPoint = _candlestick_point.default;
mixins.stockPoint = _stock_point.default;
mixins.polarSymbolPoint = _polar_point.polarSymbolPoint;
mixins.polarBarPoint = _polar_point.polarBarPoint;
Point.prototype = {
  constructor: Point,
  getColor: function getColor() {
    if (!this.hasValue() && !this._styles.usePointCustomOptions) {
      this.series.customizePoint(this, this._dataItem);
    }
    return this._styles.normal.fill || this.series.getColor();
  },
  _getStyle: function _getStyle() {
    return this._styles[this._currentStyle || 'normal'];
  },
  update: function update(dataItem, options) {
    this.updateOptions(options);
    this.updateData(dataItem);
  },
  updateData: function updateData(dataItem) {
    var that = this;
    var argumentWasChanged = that.argument !== dataItem.argument;
    that.argument = that.initialArgument = that.originalArgument = dataItem.argument;
    that.tag = dataItem.tag;
    that.index = dataItem.index;
    that._dataItem = dataItem;
    that.data = dataItem.data;
    that.lowError = dataItem.lowError;
    that.highError = dataItem.highError;
    that.aggregationInfo = dataItem.aggregationInfo;
    that._updateData(dataItem, argumentWasChanged);
    !that.hasValue() && that.setInvisibility();
    that._fillStyle();
    that._updateLabelData();
  },
  deleteMarker: function deleteMarker() {
    var that = this;
    if (that.graphic) {
      that.graphic.dispose();
    }
    that.graphic = null;
  },
  draw: function draw(renderer, groups, animationEnabled, firstDrawing) {
    var that = this;
    if (that._needDeletingOnDraw || that.series.autoHidePointMarkers && !that.isSelected()) {
      that.deleteMarker();
      that._needDeletingOnDraw = false;
    }
    if (that._needClearingOnDraw) {
      that.clearMarker();
      that._needClearingOnDraw = false;
    }
    if (!that._hasGraphic()) {
      that.getMarkerVisibility() && !that.series.autoHidePointMarkers && that._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing);
    } else {
      that._updateMarker(animationEnabled, this._getStyle(), groups.markers);
    }
    that._drawLabel();
    that._drawErrorBar(renderer, groups.errorBars, animationEnabled);
    return that;
  },
  _getViewStyle: function _getViewStyle() {
    var state = NORMAL_STATE;
    var fullState = this.fullState;
    var styles = [NORMAL, HOVER, SELECTION, SELECTION];
    if (this._viewCounters.hover) {
      state |= HOVER_STATE;
    }
    if (this._viewCounters.selection) {
      state |= SELECTED_STATE;
    }
    if (isNoneMode(this.getOptions().selectionMode)) {
      fullState &= ~SELECTED_STATE;
    }
    if (isNoneMode(this.getOptions().hoverMode)) {
      fullState &= ~HOVER_STATE;
    }
    state |= fullState;
    return styles[state];
  },
  applyView: function applyView(legendCallback) {
    var that = this;
    var style = that._getViewStyle();
    that._currentStyle = style;
    if (!that.graphic && that.getMarkerVisibility() && that.series.autoHidePointMarkers && (style === SELECTION || style === HOVER)) {
      that._drawMarker(that.series.getRenderer(), that.series.getMarkersGroup());
    }
    if (that.graphic) {
      if (that.series.autoHidePointMarkers && style !== SELECTION && style !== HOVER) {
        that.deleteMarker();
      } else {
        if (style === 'normal') {
          that.clearMarker();
        } else {
          that.graphic.toForeground();
        }
        that._updateMarker(true, that._styles[style], undefined, legendCallback);
      }
    }
  },
  setView: function setView(style) {
    this._viewCounters[style]++;
    this.applyView();
  },
  resetView: function resetView(style) {
    var viewCounters = this._viewCounters;
    --viewCounters[style];
    if (viewCounters[style] < 0) {
      // T661080
      viewCounters[style] = 0;
    }
    this.applyView();
  },
  releaseHoverState: function releaseHoverState() {
    var that = this;
    if (that.graphic && !that.isSelected()) {
      that.graphic.toBackground();
    }
  },
  select: function select() {
    this.series.selectPoint(this);
  },
  clearSelection: function clearSelection() {
    this.series.deselectPoint(this);
  },
  hover: function hover() {
    this.series.hoverPoint(this);
  },
  clearHover: function clearHover() {
    this.series.clearPointHover();
  },
  showTooltip: function showTooltip() {
    this.series.showPointTooltip(this);
  },
  hideTooltip: function hideTooltip() {
    this.series.hidePointTooltip(this);
  },
  _checkLabelsChanging: function _checkLabelsChanging(oldType, newType) {
    var isNewRange = ~newType.indexOf('range');
    var isOldRange = ~oldType.indexOf('range');
    return isOldRange && !isNewRange || !isOldRange && isNewRange;
  },
  updateOptions: function updateOptions(newOptions) {
    if (!newOptions) {
      return;
    }
    var that = this;
    var oldOptions = that._options;
    var widgetType = newOptions.widgetType;
    var oldType = oldOptions && oldOptions.type;
    var newType = newOptions.type;
    var newPointTypeMixin = pointTypes[widgetType][newType];
    if (oldType !== newType) {
      that._needDeletingOnDraw = true;
      that._needClearingOnDraw = false;
      if (oldType) {
        that._checkLabelsChanging(oldType, newType) && that.deleteLabel();
        that._resetType(mixins[pointTypes[oldType]]);
      }
      that._setType(mixins[newPointTypeMixin]);
    } else {
      that._needDeletingOnDraw = that._checkSymbol(oldOptions, newOptions);
      that._needClearingOnDraw = that._checkCustomize(oldOptions, newOptions);
    }
    that._options = newOptions;
    that._fillStyle();
    that._updateLabelOptions(newPointTypeMixin);
  },
  translate: function translate() {
    if (this.hasValue()) {
      this._translate();
      this.translated = true;
    }
  },
  _checkCustomize: function _checkCustomize(oldOptions, newOptions) {
    return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions;
  },
  _getCustomLabelVisibility: function _getCustomLabelVisibility() {
    return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null;
  },
  getBoundingRect: function getBoundingRect() {
    return this._getGraphicBBox();
  },
  _resetType: function _resetType(methods) {
    for (var methodName in methods) {
      delete this[methodName];
    }
  },
  _setType: function _setType(methods) {
    for (var methodName in methods) {
      this[methodName] = methods[methodName];
    }
  },
  isInVisibleArea: function isInVisibleArea() {
    return this.inVisibleArea;
  },
  isSelected: function isSelected() {
    return !!(this.fullState & SELECTED_STATE);
  },
  isHovered: function isHovered() {
    return !!(this.fullState & HOVER_STATE);
  },
  getOptions: function getOptions() {
    return this._options;
  },
  animate: function animate(complete, settings, partitionDuration) {
    if (!this.graphic) {
      complete && complete();
      return;
    }
    this.graphic.animate(settings, {
      partitionDuration: partitionDuration
    }, complete);
  },
  getCoords: function getCoords(min) {
    var that = this;
    if (!min) {
      return {
        x: that.x,
        y: that.y
      };
    }
    if (!that._options.rotated) {
      return {
        x: that.x,
        y: that.minY + (that.y - that.minY ? 0 : 1)
      };
    }
    return {
      x: that.minX - (that.x - that.minX ? 0 : 1),
      y: that.y
    };
  },
  getDefaultCoords: function getDefaultCoords() {
    var that = this;
    return !that._options.rotated ? {
      x: that.x,
      y: that.defaultY
    } : {
      x: that.defaultX,
      y: that.y
    };
  },
  setDefaultCoords() {
    var coords = this.getDefaultCoords();
    this.x = coords.x;
    this.y = coords.y;
  },
  _getVisibleArea: function _getVisibleArea() {
    return this.series.getVisibleArea();
  },
  _getArgTranslator: function _getArgTranslator() {
    return this.series.getArgumentAxis().getTranslator();
  },
  _getValTranslator: function _getValTranslator() {
    return this.series.getValueAxis().getTranslator();
  },
  isArgumentCorrect() {
    return this.series._argumentChecker(this.argument);
  },
  isValueCorrect() {
    var valueChecker = this.series._valueChecker;
    return valueChecker(this.getMinValue()) && valueChecker(this.getMaxValue());
  },
  hasValue: function hasValue() {
    return this.value !== null && this.minValue !== null && this.isArgumentCorrect() && this.isValueCorrect();
  },
  hasCoords: _common.noop,
  correctPosition: _common.noop,
  correctRadius: _common.noop,
  correctLabelRadius: _common.noop,
  getCrosshairData: _common.noop,
  getPointRadius: _common.noop,
  _populatePointShape: _common.noop,
  _checkSymbol: _common.noop,
  getMarkerCoords: _common.noop,
  hide: _common.noop,
  show: _common.noop,
  hideMarker: _common.noop,
  setInvisibility: _common.noop,
  clearVisibility: _common.noop,
  isVisible: _common.noop,
  resetCorrection: _common.noop,
  correctValue: _common.noop,
  resetValue: _common.noop,
  setPercentValue: _common.noop,
  correctCoordinates: _common.noop,
  coordsIn: _common.noop,
  getTooltipParams: _common.noop,
  applyWordWrap: _common.noop,
  setLabelTrackerData: _common.noop,
  updateLabelCoord: _common.noop,
  drawLabel: _common.noop,
  correctLabelPosition: _common.noop,
  getMinValue: _common.noop,
  getMaxValue: _common.noop,
  _drawErrorBar: _common.noop,
  getMarkerVisibility: _common.noop,
  dispose: function dispose() {
    var that = this;
    that.deleteMarker();
    that.deleteLabel();
    that._errorBar && this._errorBar.dispose();
    that._options = that._styles = that.series = that._errorBar = null;
  },
  getTooltipFormatObject: function getTooltipFormatObject(tooltip, stackPoints) {
    var that = this;
    var tooltipFormatObject = that._getFormatObject(tooltip);
    var sharedTooltipValuesArray = [];
    var tooltipStackPointsFormatObject = [];
    if (stackPoints) {
      stackPoints.forEach(function (point) {
        if (!point.isVisible()) return;
        var formatObject = point._getFormatObject(tooltip);
        tooltipStackPointsFormatObject.push(formatObject);
        sharedTooltipValuesArray.push(formatObject.seriesName + ': ' + formatObject.valueText);
      });
      _extend(tooltipFormatObject, {
        points: tooltipStackPointsFormatObject,
        valueText: sharedTooltipValuesArray.join('\n'),
        stackName: that.series.getStackName() || null
      });
    }
    var aggregationInfo = that.aggregationInfo;
    if (aggregationInfo) {
      var axis = that.series.getArgumentAxis();
      var rangeText = axis.formatRange(aggregationInfo.intervalStart, aggregationInfo.intervalEnd, aggregationInfo.aggregationInterval, tooltip.getOptions().argumentFormat);
      if (rangeText) {
        tooltipFormatObject.valueText += "\n".concat(rangeText);
      }
    }
    return tooltipFormatObject;
  },
  setHole: function setHole(holeValue, position) {
    var that = this;
    var minValue = isFinite(that.minValue) ? that.minValue : 0;
    if ((0, _type.isDefined)(holeValue)) {
      if (position === 'left') {
        that.leftHole = that.value - holeValue;
        that.minLeftHole = minValue - holeValue;
      } else {
        that.rightHole = that.value - holeValue;
        that.minRightHole = minValue - holeValue;
      }
    }
  },
  resetHoles: function resetHoles() {
    this.leftHole = null;
    this.minLeftHole = null;
    this.rightHole = null;
    this.minRightHole = null;
  },
  getLabel: function getLabel() {
    return this._label;
  },
  getLabels: function getLabels() {
    return [this._label];
  },
  getCenterCoord() {
    return {
      x: this.x,
      y: this.y
    };
  }
};

/***/ }),

/***/ 37440:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _extend = _extend2.extend;
var MIN_BUBBLE_HEIGHT = 20;
var _default = _extend({}, _symbol_point.default, {
  correctCoordinates: function correctCoordinates(diameter) {
    this.bubbleSize = diameter / 2;
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {
    var that = this;
    var attr = _extend({
      translateX: that.x,
      translateY: that.y
    }, that._getStyle());
    that.graphic = renderer.circle(0, 0, animationEnabled ? 0 : that.bubbleSize).smartAttr(attr).data({
      'chart-data-point': that
    }).append(group);
  },
  getTooltipParams: function getTooltipParams(location) {
    var that = this;
    var graphic = that.graphic;
    if (!graphic) {
      return;
    }
    var height = graphic.getBBox().height;
    return {
      x: that.x,
      y: that.y,
      offset: height < MIN_BUBBLE_HEIGHT || location === 'edge' ? height / 2 : 0
    };
  },
  _getLabelFormatObject: function _getLabelFormatObject() {
    var formatObject = _symbol_point.default._getLabelFormatObject.call(this);
    formatObject.size = this.initialSize;
    return formatObject;
  },
  _updateData: function _updateData(data) {
    _symbol_point.default._updateData.call(this, data);
    this.size = this.initialSize = data.size;
  },
  _getGraphicBBox: function _getGraphicBBox() {
    var that = this;
    return that._getSymbolBBox(that.x, that.y, that.bubbleSize);
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    var that = this;
    if (!animationEnabled) {
      style = _extend({
        r: that.bubbleSize,
        translateX: that.x,
        translateY: that.y
      }, style);
    }
    that.graphic.smartAttr(style);
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var formatObject = _symbol_point.default._getFormatObject.call(this, tooltip);
    formatObject.sizeText = tooltip.formatValue(this.initialSize);
    return formatObject;
  },
  _storeTrackerR: function _storeTrackerR() {
    return this.bubbleSize;
  },
  _getLabelCoords: function _getLabelCoords(label) {
    var coords;
    if (label.getLayoutOptions().position === 'inside') {
      coords = this._getLabelCoordOfPosition(label, 'inside');
    } else {
      coords = _symbol_point.default._getLabelCoords.call(this, label);
    }
    return coords;
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 69297:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _math = Math;
var _abs = _math.abs;
var _min = _math.min;
var _max = _math.max;
var _round = _math.round;
var DEFAULT_FINANCIAL_TRACKER_MARGIN = 2;
var _default = (0, _extend2.extend)({}, _bar_point.default, {
  _calculateVisibility: _symbol_point.default._calculateVisibility,
  _getContinuousPoints: function _getContinuousPoints(openCoord, closeCoord) {
    var that = this;
    var x = that.x;
    var createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    var width = that.width;
    var highCoord = that.highY;
    var max = _abs(highCoord - openCoord) < _abs(highCoord - closeCoord) ? openCoord : closeCoord;
    var min = max === closeCoord ? openCoord : closeCoord;
    var points;
    if (min === max) {
      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, that.closeY)).concat(createPoint(x - width / 2, that.closeY)).concat(createPoint(x + width / 2, that.closeY)).concat(createPoint(x, that.closeY));
    } else {
      points = [].concat(createPoint(x, that.highY)).concat(createPoint(x, max)).concat(createPoint(x + width / 2, max)).concat(createPoint(x + width / 2, min)).concat(createPoint(x, min)).concat(createPoint(x, that.lowY)).concat(createPoint(x, min)).concat(createPoint(x - width / 2, min)).concat(createPoint(x - width / 2, max)).concat(createPoint(x, max));
    }
    return points;
  },
  _getCrockPoints: function _getCrockPoints(y) {
    var that = this;
    var x = that.x;
    var createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    return [].concat(createPoint(x, that.highY)).concat(createPoint(x, that.lowY)).concat(createPoint(x, y)).concat(createPoint(x - that.width / 2, y)).concat(createPoint(x + that.width / 2, y)).concat(createPoint(x, y));
  },
  _getPoints: function _getPoints() {
    var that = this;
    var points;
    var closeCoord = that.closeY;
    var openCoord = that.openY;
    if (closeCoord !== null && openCoord !== null) {
      points = that._getContinuousPoints(openCoord, closeCoord);
    } else {
      if (openCoord === closeCoord) {
        points = [that.x, that.highY, that.x, that.lowY];
      } else {
        points = that._getCrockPoints(openCoord !== null ? openCoord : closeCoord);
      }
    }
    return points;
  },
  getColor: function getColor() {
    var that = this;
    return that._isReduction ? that._options.reduction.color : that._styles.normal.stroke || that.series.getColor();
  },
  _drawMarkerInGroup: function _drawMarkerInGroup(group, attributes, renderer) {
    var that = this;
    that.graphic = renderer.path(that._getPoints(), 'area').attr({
      'stroke-linecap': 'square'
    }).attr(attributes).data({
      'chart-data-point': that
    }).sharp().append(group);
  },
  _fillStyle: function _fillStyle() {
    var that = this;
    var styles = that._options.styles;
    if (that._isReduction && that._isPositive) {
      that._styles = styles.reductionPositive;
    } else if (that._isReduction) {
      that._styles = styles.reduction;
    } else if (that._isPositive) {
      that._styles = styles.positive;
    } else {
      that._styles = styles;
    }
  },
  _getMinTrackerWidth: function _getMinTrackerWidth() {
    return 2 + 2 * this._styles.normal['stroke-width'];
  },
  correctCoordinates: function correctCoordinates(correctOptions) {
    var minWidth = this._getMinTrackerWidth();
    var maxWidth = 10;
    var width = correctOptions.width;
    width = width < minWidth ? minWidth : width > maxWidth ? maxWidth : width;
    this.width = width + width % 2;
    this.xCorrection = correctOptions.offset;
  },
  _getMarkerGroup: function _getMarkerGroup(group) {
    var that = this;
    var markerGroup;
    if (that._isReduction && that._isPositive) {
      markerGroup = group.reductionPositiveMarkersGroup;
    } else if (that._isReduction) {
      markerGroup = group.reductionMarkersGroup;
    } else if (that._isPositive) {
      markerGroup = group.defaultPositiveMarkersGroup;
    } else {
      markerGroup = group.defaultMarkersGroup;
    }
    return markerGroup;
  },
  _drawMarker: function _drawMarker(renderer, group) {
    this._drawMarkerInGroup(this._getMarkerGroup(group), this._getStyle(), renderer);
  },
  _getSettingsForTracker: function _getSettingsForTracker() {
    var that = this;
    var highY = that.highY;
    var lowY = that.lowY;
    var rotated = that._options.rotated;
    var x;
    var y;
    var width;
    var height;
    if (highY === lowY) {
      highY = rotated ? highY + DEFAULT_FINANCIAL_TRACKER_MARGIN : highY - DEFAULT_FINANCIAL_TRACKER_MARGIN;
      lowY = rotated ? lowY - DEFAULT_FINANCIAL_TRACKER_MARGIN : lowY + DEFAULT_FINANCIAL_TRACKER_MARGIN;
    }
    if (rotated) {
      x = _min(lowY, highY);
      y = that.x - that.width / 2;
      width = _abs(lowY - highY);
      height = that.width;
    } else {
      x = that.x - that.width / 2;
      y = _min(lowY, highY);
      width = that.width;
      height = _abs(lowY - highY);
    }
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  },
  _getGraphicBBox: function _getGraphicBBox(location) {
    var that = this;
    var rotated = that._options.rotated;
    var x = that.x;
    var width = that.width;
    var lowY = that.lowY;
    var highY = that.highY;
    if (location) {
      var valVisibleArea = that.series.getValueAxis().getVisibleArea();
      highY = that._truncateCoord(highY, valVisibleArea);
      lowY = that._truncateCoord(lowY, valVisibleArea);
    }
    var bBox = {
      x: !rotated ? x - _round(width / 2) : lowY,
      y: !rotated ? highY : x - _round(width / 2),
      width: !rotated ? width : highY - lowY,
      height: !rotated ? lowY - highY : width
    };
    if (location) {
      var isTop = location === 'top';
      if (!this._options.rotated) {
        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;
        bBox.height = 0;
      } else {
        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;
        bBox.width = 0;
      }
    }
    return bBox;
  },
  getTooltipParams: function getTooltipParams(location) {
    var that = this;
    if (that.graphic) {
      var minValue = _min(that.lowY, that.highY);
      var maxValue = _max(that.lowY, that.highY);
      var visibleArea = that._getVisibleArea();
      var rotated = that._options.rotated;
      var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
      var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
      var min = _max(minVisible, minValue);
      var max = _min(maxVisible, maxValue);
      var centerCoord = that.getCenterCoord();
      if (location === 'edge') {
        centerCoord[rotated ? 'x' : 'y'] = rotated ? max : min;
      }
      centerCoord.offset = 0;
      return centerCoord;
    }
  },
  getCenterCoord() {
    if (this.graphic) {
      var that = this;
      var x;
      var y;
      var minValue = _min(that.lowY, that.highY);
      var maxValue = _max(that.lowY, that.highY);
      var visibleArea = that._getVisibleArea();
      var rotated = that._options.rotated;
      var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
      var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
      var min = _max(minVisible, minValue);
      var max = _min(maxVisible, maxValue);
      var center = min + (max - min) / 2;
      if (rotated) {
        y = that.x;
        x = center;
      } else {
        x = that.x;
        y = center;
      }
      return {
        x: x,
        y: y
      };
    }
  },
  hasValue: function hasValue() {
    return this.highValue !== null && this.lowValue !== null;
  },
  hasCoords: function hasCoords() {
    return this.x !== null && this.lowY !== null && this.highY !== null;
  },
  _translate: function _translate() {
    var that = this;
    var rotated = that._options.rotated;
    var valTranslator = that._getValTranslator();
    var x = that._getArgTranslator().translate(that.argument);
    that.vx = that.vy = that.x = x === null ? x : x + (that.xCorrection || 0);
    that.openY = that.openValue !== null ? valTranslator.translate(that.openValue) : null;
    that.highY = valTranslator.translate(that.highValue);
    that.lowY = valTranslator.translate(that.lowValue);
    that.closeY = that.closeValue !== null ? valTranslator.translate(that.closeValue) : null;
    var centerValue = _min(that.lowY, that.highY) + _abs(that.lowY - that.highY) / 2;
    that._calculateVisibility(!rotated ? that.x : centerValue, !rotated ? centerValue : that.x);
  },
  getCrosshairData: function getCrosshairData(x, y) {
    var that = this;
    var rotated = that._options.rotated;
    var origY = rotated ? x : y;
    var yValue;
    var argument = that.argument;
    var coords;
    var coord = 'low';
    if (_abs(that.lowY - origY) < _abs(that.closeY - origY)) {
      yValue = that.lowY;
    } else {
      yValue = that.closeY;
      coord = 'close';
    }
    if (_abs(yValue - origY) >= _abs(that.openY - origY)) {
      yValue = that.openY;
      coord = 'open';
    }
    if (_abs(yValue - origY) >= _abs(that.highY - origY)) {
      yValue = that.highY;
      coord = 'high';
    }
    if (rotated) {
      coords = {
        y: that.vy,
        x: yValue,
        xValue: that[coord + 'Value'],
        yValue: argument
      };
    } else {
      coords = {
        x: that.vx,
        y: yValue,
        xValue: argument,
        yValue: that[coord + 'Value']
      };
    }
    coords.axis = that.series.axis;
    return coords;
  },
  _updateData: function _updateData(data) {
    var that = this;
    var label = that._label;
    var reductionColor = this._options.reduction.color;
    that.value = that.initialValue = data.reductionValue;
    that.originalValue = data.value;
    that.lowValue = that.originalLowValue = data.lowValue;
    that.highValue = that.originalHighValue = data.highValue;
    that.openValue = that.originalOpenValue = data.openValue;
    that.closeValue = that.originalCloseValue = data.closeValue;
    that._isPositive = data.openValue < data.closeValue;
    that._isReduction = data.isReduction;
    if (that._isReduction) {
      label.setColor(reductionColor);
    }
  },
  _updateMarker: function _updateMarker(animationEnabled, style, group) {
    var that = this;
    var graphic = that.graphic;
    graphic.attr({
      points: that._getPoints()
    }).smartAttr(style).sharp();
    group && graphic.append(that._getMarkerGroup(group));
  },
  _getLabelFormatObject: function _getLabelFormatObject() {
    var that = this;
    return {
      openValue: that.openValue,
      highValue: that.highValue,
      lowValue: that.lowValue,
      closeValue: that.closeValue,
      reductionValue: that.initialValue,
      argument: that.initialArgument,
      value: that.initialValue,
      seriesName: that.series.name,
      originalOpenValue: that.originalOpenValue,
      originalCloseValue: that.originalCloseValue,
      originalLowValue: that.originalLowValue,
      originalHighValue: that.originalHighValue,
      originalArgument: that.originalArgument,
      point: that
    };
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var that = this;
    var highValue = tooltip.formatValue(that.highValue);
    var openValue = tooltip.formatValue(that.openValue);
    var closeValue = tooltip.formatValue(that.closeValue);
    var lowValue = tooltip.formatValue(that.lowValue);
    var symbolMethods = _symbol_point.default;
    var formatObject = symbolMethods._getFormatObject.call(that, tooltip);
    return (0, _extend2.extend)({}, formatObject, {
      valueText: 'h: ' + highValue + (openValue !== '' ? ' o: ' + openValue : '') + (closeValue !== '' ? ' c: ' + closeValue : '') + ' l: ' + lowValue,
      highValueText: highValue,
      openValueText: openValue,
      closeValueText: closeValue,
      lowValueText: lowValue
    });
  },
  getMaxValue: function getMaxValue() {
    return this.highValue;
  },
  getMinValue: function getMinValue() {
    return this.lowValue;
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 28318:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Label = Label;
var _format_helper = _interopRequireDefault(__webpack_require__(30343));
var _utils = __webpack_require__(19157);
var _iterator = __webpack_require__(95479);
var _extend = __webpack_require__(13306);
var _display_format_parser = __webpack_require__(10656);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _format = _format_helper.default.format;
var _math = Math;
var _round = _math.round;
var _floor = _math.floor;
var _abs = _math.abs;
var CONNECTOR_LENGTH = 12;
var LABEL_BACKGROUND_PADDING_X = 8;
var LABEL_BACKGROUND_PADDING_Y = 4;
function getClosestCoord(point, coords) {
  var closestDistance = Infinity;
  var closestCoord;
  (0, _iterator.each)(coords, function (_, coord) {
    var x = point[0] - coord[0];
    var y = point[1] - coord[1];
    var distance = x * x + y * y;
    if (distance < closestDistance) {
      closestDistance = distance;
      closestCoord = coord;
    }
  });
  return [_floor(closestCoord[0]), _floor(closestCoord[1])];
}
function getCrossCoord(rect, coord, indexOffset) {
  return (coord - rect[0 + indexOffset]) / (rect[2 + indexOffset] - rect[0 + indexOffset]) * (rect[3 - indexOffset] - rect[1 - indexOffset]) + rect[1 - indexOffset];
}

// We could always conside center of label as label point (with appropriate connector path clipping). In that case we do not depend neither on background nor on rotation.

var barPointStrategy = {
  isLabelInside: function isLabelInside(labelPoint, figure) {
    var xc = labelPoint.x + labelPoint.width / 2;
    var yc = labelPoint.y + labelPoint.height / 2;
    return figure.x <= xc && xc <= figure.x + figure.width && figure.y <= yc && yc <= figure.y + figure.height;
  },
  prepareLabelPoints: function prepareLabelPoints(bBox, rotatedBBox, isHorizontal, angle, figureCenter) {
    var x1 = rotatedBBox.x;
    var xc = x1 + rotatedBBox.width / 2;
    var x2 = x1 + rotatedBBox.width - 1;
    var y1 = rotatedBBox.y;
    var yc = y1 + rotatedBBox.height / 2;
    var y2 = y1 + rotatedBBox.height - 1;
    var labelPoints;
    var isRectangular = _abs(angle) % 90 === 0;
    if (figureCenter[0] > x1 && figureCenter[0] < x2) {
      if (isRectangular) {
        labelPoints = [[figureCenter[0], _abs(figureCenter[1] - y1) < _abs(figureCenter[1] - y2) ? y1 : y2]];
      } else {
        labelPoints = [[figureCenter[0], getCrossCoord([x1, y1, x2, y2], figureCenter[0], 0)]];
      }
    } else if (figureCenter[1] > y1 && figureCenter[1] < y2) {
      if (isRectangular) {
        labelPoints = [[_abs(figureCenter[0] - x1) < _abs(figureCenter[0] - x2) ? x1 : x2, figureCenter[1]]];
      } else {
        labelPoints = [[getCrossCoord([x1, y1, x2, y2], figureCenter[1], 1), figureCenter[1]]];
      }
    } else {
      if (isRectangular) {
        labelPoints = [[x1, y1], [isHorizontal ? x1 : xc, isHorizontal ? yc : y1], [x2, y1], [x1, y2], [isHorizontal ? x2 : xc, isHorizontal ? yc : y2], [x2, y2]];
      } else {
        labelPoints = [[xc, yc]];
      }
    }
    return labelPoints;
  },
  isHorizontal: function isHorizontal(bBox, figure) {
    return bBox.x > figure.x + figure.width || bBox.x + bBox.width < figure.x;
  },
  getFigureCenter: function getFigureCenter(figure) {
    return [_floor(figure.x + figure.width / 2), _floor(figure.y + figure.height / 2)];
  },
  findFigurePoint: function findFigurePoint(figure, labelPoint) {
    var figureCenter = barPointStrategy.getFigureCenter(figure);
    var point = getClosestCoord(labelPoint, [[figure.x, figureCenter[1]], [figureCenter[0], figure.y + figure.height], [figure.x + figure.width, figureCenter[1]], [figureCenter[0], figure.y]]);
    return point;
  },
  adjustPoints: function adjustPoints(points) {
    var lineIsVertical = _abs(points[1] - points[3]) <= 1;
    var lineIsHorizontal = _abs(points[0] - points[2]) <= 1;
    if (lineIsHorizontal) {
      points[0] = points[2];
    }
    if (lineIsVertical) {
      points[1] = points[3];
    }
    return points;
  }
};
var symbolPointStrategy = {
  isLabelInside: function isLabelInside() {
    return false;
  },
  prepareLabelPoints: barPointStrategy.prepareLabelPoints,
  isHorizontal: function isHorizontal(bBox, figure) {
    return bBox.x > figure.x + figure.r || bBox.x + bBox.width < figure.x - figure.r;
  },
  getFigureCenter: function getFigureCenter(figure) {
    return [figure.x, figure.y];
  },
  findFigurePoint: function findFigurePoint(figure, labelPoint) {
    var angle = Math.atan2(figure.y - labelPoint[1], labelPoint[0] - figure.x);
    return [_round(figure.x + figure.r * Math.cos(angle)), _round(figure.y - figure.r * Math.sin(angle))];
  },
  adjustPoints: barPointStrategy.adjustPoints
};
var piePointStrategy = {
  isLabelInside: function isLabelInside(_0, _1, isOutside) {
    return !isOutside;
  },
  prepareLabelPoints: function prepareLabelPoints(bBox, rotatedBBox, isHorizontal, angle) {
    var xl = bBox.x;
    var xr = xl + bBox.width;
    var xc = xl + _round(bBox.width / 2);
    var yt = bBox.y;
    var yb = yt + bBox.height;
    var yc = yt + _round(bBox.height / 2);
    var points = [[[xl, yt], [xr, yt]], [[xr, yt], [xr, yb]], [[xr, yb], [xl, yb]], [[xl, yb], [xl, yt]]];
    var cosSin = (0, _utils.getCosAndSin)(angle);
    if (angle === 0) {
      points = isHorizontal ? [[xl, yc], [xr, yc]] : [[xc, yt], [xc, yb]];
    } else {
      points = points.map(function (pair) {
        return pair.map(function (point) {
          return [_round((point[0] - xc) * cosSin.cos + (point[1] - yc) * cosSin.sin + xc), _round(-(point[0] - xc) * cosSin.sin + (point[1] - yc) * cosSin.cos + yc)];
        });
      }).reduce(function (r, pair) {
        var point1x = pair[0][0];
        var point1y = pair[0][1];
        var point2x = pair[1][0];
        var point2y = pair[1][1];
        if (isHorizontal) {
          if (point1y >= yc && yc >= point2y || point1y <= yc && yc <= point2y) {
            r.push([(yc - point1y) * (point2x - point1x) / (point2y - point1y) + point1x, yc]);
          }
        } else {
          if (point1x >= xc && xc >= point2x || point1x <= xc && xc <= point2x) {
            r.push([xc, (xc - point1x) * (point2y - point1y) / (point2x - point1x) + point1y]);
          }
        }
        return r;
      }, []);
    }
    return points;
  },
  isHorizontal: function isHorizontal(bBox, figure) {
    return bBox.x > figure.x || figure.x > bBox.x + bBox.width;
  },
  getFigureCenter: symbolPointStrategy.getFigureCenter,
  findFigurePoint: function findFigurePoint(figure, labelPoint, isHorizontal) {
    if (!isHorizontal) {
      return [figure.x, figure.y];
    }
    var labelX = labelPoint[0];
    var x = _round(figure.x + (figure.y - labelPoint[1]) / Math.tan((0, _utils.degreesToRadians)(figure.angle)));
    var points = [figure.x, figure.y, x, labelPoint[1]];
    if (!(figure.x <= x && x <= labelX) && !(labelX <= x && x <= figure.x)) {
      if (_abs(figure.x - labelX) < CONNECTOR_LENGTH) {
        points = [figure.x, figure.y];
      } else if (figure.x <= labelX) {
        points[2] = figure.x + CONNECTOR_LENGTH;
      } else {
        points[2] = figure.x - CONNECTOR_LENGTH;
      }
    }
    return points;
  },
  adjustPoints: function adjustPoints(points) {
    return points;
  }
};
function selectStrategy(figure) {
  return figure.angle !== undefined && piePointStrategy || figure.r !== undefined && symbolPointStrategy || barPointStrategy;
}
function disposeItem(obj, field) {
  obj[field] && obj[field].dispose();
  obj[field] = null;
}
function checkBackground(background) {
  return background && (background.fill && background.fill !== 'none' || background['stroke-width'] > 0 && background.stroke && background.stroke !== 'none');
}
function checkConnector(connector) {
  return connector && connector['stroke-width'] > 0 && connector.stroke && connector.stroke !== 'none';
}
function formatText(data, options) {
  var format = options.format;
  data.valueText = _format(data.value, format);
  data.argumentText = _format(data.argument, options.argumentFormat);
  if (data.percent !== undefined) {
    data.percentText = _format(data.percent, {
      type: 'percent',
      precision: format && format.percentPrecision
    });
  }
  if (data.total !== undefined) {
    data.totalText = _format(data.total, format);
  }
  if (data.openValue !== undefined) {
    data.openValueText = _format(data.openValue, format);
  }
  if (data.closeValue !== undefined) {
    data.closeValueText = _format(data.closeValue, format);
  }
  if (data.lowValue !== undefined) {
    data.lowValueText = _format(data.lowValue, format);
  }
  if (data.highValue !== undefined) {
    data.highValueText = _format(data.highValue, format);
  }
  if (data.reductionValue !== undefined) {
    data.reductionValueText = _format(data.reductionValue, format);
  }
  return options.customizeText ? options.customizeText.call(data, data) : options.displayFormat ? (0, _display_format_parser.processDisplayFormat)(options.displayFormat, data) : data.valueText;
}
function Label(renderSettings) {
  this._renderer = renderSettings.renderer;
  this._container = renderSettings.labelsGroup;
  this._point = renderSettings.point;
  this._strategy = renderSettings.strategy;
  this._rowCount = 1;
}
Label.prototype = {
  constructor: Label,
  setColor: function setColor(color) {
    this._color = color;
  },
  setOptions: function setOptions(options) {
    this._options = options;
  },
  setData: function setData(data) {
    this._data = data;
  },
  setDataField: function setDataField(fieldName, fieldValue) {
    // Is this laziness really required?
    this._data = this._data || {};
    this._data[fieldName] = fieldValue;
  },
  getData: function getData() {
    return this._data;
  },
  setFigureToDrawConnector: function setFigureToDrawConnector(figure) {
    this._figure = figure;
  },
  dispose: function dispose() {
    var that = this;
    disposeItem(that, '_group');
    that._data = that._options = that._textContent = that._visible = that._insideGroup = that._text = that._background = that._connector = that._figure = null;
  },
  // The following method is required because we support partial visibility for labels
  // entire labels group can be hidden and any particular label can be visible at the same time
  // in order to do that label must have visibility:"visible" attribute
  _setVisibility: function _setVisibility(value, state) {
    this._group && this._group.attr({
      visibility: value
    });
    this._visible = state;
  },
  isVisible: function isVisible() {
    return this._visible;
  },
  hide: function hide(holdInvisible) {
    this._holdVisibility = !!holdInvisible;
    this._hide();
  },
  _hide: function _hide() {
    this._setVisibility('hidden', false);
  },
  show: function show(holdVisible) {
    var correctPosition = !this._drawn;
    if (this._point.hasValue()) {
      this._holdVisibility = !!holdVisible;
      this._show();
      correctPosition && this._point.correctLabelPosition(this);
    }
  },
  _show: function _show() {
    var that = this;
    var renderer = that._renderer;
    var container = that._container;
    var options = that._options || {};
    var text = that._textContent = formatText(that._data, options) || null;
    if (text) {
      if (!that._group) {
        that._group = renderer.g().append(container);
        that._insideGroup = renderer.g().append(that._group);
        that._text = renderer.text('', 0, 0).append(that._insideGroup);
      }
      that._text.css(options.attributes ? (0, _utils.patchFontOptions)(options.attributes.font) : {});
      if (checkBackground(options.background)) {
        that._background = that._background || renderer.rect().append(that._insideGroup).toBackground();
        that._background.attr(options.background);
        // The following is because "this._options" is shared between all labels and so cannot be modified
        that._color && that._background.attr({
          fill: that._color
        });
      } else {
        disposeItem(that, '_background');
      }
      if (checkConnector(options.connector)) {
        that._connector = that._connector || renderer.path([], 'line').sharp().append(that._group).toBackground();
        that._connector.attr(options.connector);
        // The following is because "this._options" is shared between all labels and so cannot be modified
        that._color && that._connector.attr({
          stroke: that._color
        });
      } else {
        disposeItem(that, '_connector');
      }
      that._text.attr({
        text: text,
        align: options.textAlignment,
        'class': options.cssClass
      });
      that._updateBackground(that._text.getBBox());
      that._setVisibility('visible', true);
      that._drawn = true;
    } else {
      that._hide();
    }
  },
  _getLabelVisibility: function _getLabelVisibility(isVisible) {
    return this._holdVisibility ? this.isVisible() : isVisible;
  },
  draw: function draw(isVisible) {
    if (this._getLabelVisibility(isVisible)) {
      this._show();
      this._point && this._point.correctLabelPosition(this);
    } else {
      this._drawn = false;
      this._hide();
    }
    return this;
  },
  _updateBackground: function _updateBackground(bBox) {
    var that = this;
    if (that._background) {
      bBox.x -= LABEL_BACKGROUND_PADDING_X;
      bBox.y -= LABEL_BACKGROUND_PADDING_Y;
      bBox.width += 2 * LABEL_BACKGROUND_PADDING_X;
      bBox.height += 2 * LABEL_BACKGROUND_PADDING_Y;
      that._background.attr(bBox);
    }
    that._bBoxWithoutRotation = (0, _extend.extend)({}, bBox);
    var rotationAngle = that._options.rotationAngle || 0;
    that._insideGroup.rotate(rotationAngle, bBox.x + bBox.width / 2, bBox.y + bBox.height / 2);
    // Angle is transformed from svg to right-handed cartesian space
    bBox = (0, _utils.rotateBBox)(bBox, [bBox.x + bBox.width / 2, bBox.y + bBox.height / 2], -rotationAngle);
    that._bBox = bBox;
  },
  getFigureCenter() {
    var figure = this._figure;
    var strategy = this._strategy || selectStrategy(figure);
    return strategy.getFigureCenter(figure);
  },
  _getConnectorPoints: function _getConnectorPoints() {
    var that = this;
    var figure = that._figure;
    var options = that._options;
    var strategy = that._strategy || selectStrategy(figure);
    var bBox = that._shiftBBox(that._bBoxWithoutRotation);
    var rotatedBBox = that.getBoundingRect();
    var labelPoint;
    var points = [];
    var isHorizontal;
    if (!strategy.isLabelInside(bBox, figure, options.position !== 'inside')) {
      isHorizontal = strategy.isHorizontal(bBox, figure);
      var figureCenter = that.getFigureCenter();
      points = strategy.prepareLabelPoints(bBox, rotatedBBox, isHorizontal, -options.rotationAngle || 0, figureCenter);
      labelPoint = getClosestCoord(figureCenter, points);
      points = strategy.findFigurePoint(figure, labelPoint, isHorizontal);
      points = points.concat(labelPoint);
    }
    return strategy.adjustPoints(points);
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  fit: function fit(maxWidth) {
    var padding = this._background ? 2 * LABEL_BACKGROUND_PADDING_X : 0;
    var rowCountChanged = false;
    if (this._text) {
      var result = this._text.setMaxSize(maxWidth - padding, undefined, this._options);
      var rowCount = result.rowCount;
      if (rowCount === 0) {
        rowCount = 1;
      }
      if (rowCount !== this._rowCount) {
        rowCountChanged = true;
        this._rowCount = rowCount;
      }
      result.textIsEmpty && disposeItem(this, '_background');
    }
    this._updateBackground(this._text.getBBox());
    return rowCountChanged;
  },
  resetEllipsis: function resetEllipsis() {
    this._text && this._text.restoreText();
    this._updateBackground(this._text.getBBox());
  },
  setTrackerData: function setTrackerData(point) {
    this._text.data({
      'chart-data-point': point
    });
    this._background && this._background.data({
      'chart-data-point': point
    });
  },
  hideInsideLabel: function hideInsideLabel(coords) {
    return this._point.hideInsideLabel(this, coords);
  },
  getPoint() {
    return this._point;
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  shift: function shift(x, y) {
    var that = this;
    if (that._textContent) {
      that._insideGroup.attr({
        translateX: that._x = _round(x - that._bBox.x),
        translateY: that._y = _round(y - that._bBox.y)
      });
      if (that._connector) {
        that._connector.attr({
          points: that._getConnectorPoints()
        });
      }
    }
    return that;
  },
  // TODO: Should not be called when not invisible (check for "_textContent" is to be removed)
  getBoundingRect: function getBoundingRect() {
    return this._shiftBBox(this._bBox);
  },
  _shiftBBox: function _shiftBBox(bBox) {
    return this._textContent ? {
      x: bBox.x + this._x,
      y: bBox.y + this._y,
      width: bBox.width,
      height: bBox.height
    } : {};
  },
  getLayoutOptions: function getLayoutOptions() {
    var options = this._options;
    return {
      alignment: options.alignment,
      background: checkBackground(options.background),
      horizontalOffset: options.horizontalOffset,
      verticalOffset: options.verticalOffset,
      radialOffset: options.radialOffset,
      position: options.position,
      connectorOffset: (checkConnector(options.connector) ? CONNECTOR_LENGTH : 0) + (checkBackground(options.background) ? LABEL_BACKGROUND_PADDING_X : 0)
    };
  }
};

/***/ }),

/***/ 85912:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _consts = _interopRequireDefault(__webpack_require__(32410));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _extend = _extend2.extend;
var _round = Math.round;
var _sqrt = Math.sqrt;
var _acos = Math.acos;
var DEG = 180 / Math.PI;
var _abs = Math.abs;
var RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;
var _default = _extend({}, _symbol_point.default, {
  _updateData: function _updateData(data, argumentChanged) {
    var that = this;
    _symbol_point.default._updateData.call(this, data);
    if (argumentChanged || !(0, _type.isDefined)(that._visible)) {
      that._visible = true;
    }
    that.minValue = that.initialMinValue = that.originalMinValue = (0, _type.isDefined)(data.minValue) ? data.minValue : 0;
  },
  animate: function animate(complete, duration, delay) {
    var that = this;
    that.graphic.animate({
      x: that.centerX,
      y: that.centerY,
      outerRadius: that.radiusOuter,
      innerRadius: that.radiusInner,
      startAngle: that.toAngle,
      endAngle: that.fromAngle
    }, {
      delay: delay,
      partitionDuration: duration
    }, complete);
  },
  correctPosition: function correctPosition(correction) {
    var that = this;
    that.correctRadius(correction);
    that.correctLabelRadius(correction.radiusOuter + RADIAL_LABEL_INDENT);
    that.centerX = correction.centerX;
    that.centerY = correction.centerY;
  },
  correctRadius: function correctRadius(correction) {
    this.radiusInner = correction.radiusInner;
    this.radiusOuter = correction.radiusOuter;
  },
  correctLabelRadius: function correctLabelRadius(radiusLabels) {
    this.radiusLabels = radiusLabels;
  },
  correctValue: function correctValue(correction, percent, base) {
    var that = this;
    that.value = (base || that.normalInitialValue) + correction;
    that.minValue = correction;
    that.percent = percent;
    that._label.setDataField('percent', percent);
  },
  _updateLabelData: function _updateLabelData() {
    this._label.setData(this._getLabelFormatObject());
  },
  _getShiftLabelCoords: function _getShiftLabelCoords() {
    var that = this;
    var bBox = that._label.getBoundingRect();
    var coord = that._getLabelCoords(that._label);
    var visibleArea = that._getVisibleArea();
    if (that._isLabelDrawingWithoutPoints) {
      return that._checkLabelPosition(coord, bBox, visibleArea);
    } else {
      return that._getLabelExtraCoord(coord, that._checkVerticalLabelPosition(coord, bBox, visibleArea), bBox);
    }
  },
  _getLabelPosition: function _getLabelPosition(options) {
    return options.position;
  },
  getAnnotationCoords: function getAnnotationCoords(location) {
    return this._getElementCoords(location !== 'edge' ? 'inside' : 'outside', this.radiusOuter, 0);
  },
  _getElementCoords: function _getElementCoords(position, elementRadius, radialOffset) {
    var bBox = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var that = this;
    var angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    var radiusInner = that.radiusInner;
    var radiusOuter = that.radiusOuter;
    var columnsPosition = position === 'columns';
    var rad;
    var x;
    if (position === 'inside') {
      rad = radiusInner + (radiusOuter - radiusInner) / 2 + radialOffset;
      x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;
    } else {
      rad = elementRadius + radialOffset;
      if (angleFunctions.cos > 0.1 || columnsPosition && angleFunctions.cos >= 0) {
        x = that.centerX + rad * angleFunctions.cos;
      } else if (angleFunctions.cos < -0.1 || columnsPosition && angleFunctions.cos < 0) {
        x = that.centerX + rad * angleFunctions.cos - bBox.width;
      } else {
        x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;
      }
    }
    return {
      x: x,
      y: _round(that.centerY - rad * angleFunctions.sin - bBox.height / 2)
    };
  },
  _getLabelCoords: function _getLabelCoords(label) {
    var that = this;
    var bBox = label.getBoundingRect();
    var options = label.getLayoutOptions();
    var position = that._getLabelPosition(options);
    return that._getElementCoords(position, that.radiusLabels, options.radialOffset, bBox);
  },
  _correctLabelCoord: function _correctLabelCoord(coord, moveLabelsFromCenter) {
    var that = this;
    var label = that._label;
    var bBox = label.getBoundingRect();
    var labelWidth = bBox.width;
    var options = label.getLayoutOptions();
    var visibleArea = that._getVisibleArea();
    var rightBorderX = visibleArea.maxX - labelWidth;
    var leftBorderX = visibleArea.minX;
    var angleOfPoint = (0, _utils.normalizeAngle)(that.middleAngle);
    var centerX = that.centerX;
    var connectorOffset = options.connectorOffset;
    var x = coord.x;
    if (options.position === 'columns') {
      if (angleOfPoint <= 90 || angleOfPoint >= 270) {
        x = rightBorderX;
      } else {
        x = leftBorderX;
      }
      coord.x = x;
    } else if (options.position !== 'inside' && moveLabelsFromCenter) {
      if (angleOfPoint <= 90 || angleOfPoint >= 270) {
        if (x - connectorOffset < centerX) {
          x = centerX + connectorOffset;
        }
      } else {
        if (x + labelWidth + connectorOffset > centerX) {
          x = centerX - labelWidth - connectorOffset;
        }
      }
      coord.x = x;
    }
    return coord;
  },
  drawLabel: function drawLabel() {
    this.translate();

    // this function is called for drawing labels without points for checking size of labels
    this._isLabelDrawingWithoutPoints = true;
    this._drawLabel();
    this._isLabelDrawingWithoutPoints = false;
  },
  updateLabelCoord: function updateLabelCoord(moveLabelsFromCenter) {
    var that = this;
    var bBox = that._label.getBoundingRect();
    var coord = that._correctLabelCoord(bBox, moveLabelsFromCenter);
    coord = that._checkHorizontalLabelPosition(coord, bBox, that._getVisibleArea());
    that._label.shift(_round(coord.x), _round(bBox.y));
  },
  _checkVerticalLabelPosition: function _checkVerticalLabelPosition(coord, box, visibleArea) {
    var x = coord.x;
    var y = coord.y;
    if (coord.y + box.height > visibleArea.maxY) {
      y = visibleArea.maxY - box.height;
    } else if (coord.y < visibleArea.minY) {
      y = visibleArea.minY;
    }
    return {
      x: x,
      y: y
    };
  },
  _getLabelExtraCoord: function _getLabelExtraCoord(coord, shiftCoord, box) {
    return coord.y !== shiftCoord.y ? (0, _utils.getVerticallyShiftedAngularCoords)({
      x: coord.x,
      y: coord.y,
      width: box.width,
      height: box.height
    }, shiftCoord.y - coord.y, {
      x: this.centerX,
      y: this.centerY
    }) : coord;
  },
  _checkHorizontalLabelPosition: function _checkHorizontalLabelPosition(coord, box, visibleArea) {
    var x = coord.x;
    var y = coord.y;
    if (coord.x + box.width > visibleArea.maxX) {
      x = visibleArea.maxX - box.width;
    } else if (coord.x < visibleArea.minX) {
      x = visibleArea.minX;
    }
    return {
      x: x,
      y: y
    };
  },
  applyWordWrap: function applyWordWrap(moveLabelsFromCenter) {
    var that = this;
    var label = that._label;
    var box = label.getBoundingRect();
    var visibleArea = that._getVisibleArea();
    var position = label.getLayoutOptions().position;
    var width = box.width;
    var rowCountChanged = false;
    if (position === 'columns' && that.series.index > 0) {
      width = visibleArea.maxX - that.centerX - that.radiusLabels;
    } else if (position === 'inside') {
      if (width > visibleArea.maxX - visibleArea.minX) {
        width = visibleArea.maxX - visibleArea.minX;
      }
    } else {
      if (moveLabelsFromCenter && box.x < that.centerX && box.width + box.x > that.centerX) {
        width = Math.floor((visibleArea.maxX - visibleArea.minX) / 2);
      } else if (box.x + width > visibleArea.maxX) {
        width = visibleArea.maxX - box.x;
      } else if (box.x < visibleArea.minX) {
        width = box.x + width - visibleArea.minX;
      }
    }
    if (width < box.width) {
      rowCountChanged = label.fit(width);
    }
    return rowCountChanged;
  },
  setLabelTrackerData: function setLabelTrackerData() {
    this._label.setTrackerData(this);
  },
  _checkLabelPosition: function _checkLabelPosition(coord, bBox, visibleArea) {
    coord = this._checkHorizontalLabelPosition(coord, bBox, visibleArea);
    return this._checkVerticalLabelPosition(coord, bBox, visibleArea);
  },
  _getLabelConnector: function _getLabelConnector() {
    var that = this;
    var rad = that.radiusOuter;
    var seriesStyle = that._options.styles.normal;
    var strokeWidthBy2 = seriesStyle['stroke-width'] / 2;
    var borderWidth = that.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2);
    var angleFunctions = (0, _utils.getCosAndSin)(_round(that.middleAngle));
    return {
      x: _round(that.centerX + (rad - borderWidth) * angleFunctions.cos),
      y: _round(that.centerY - (rad - borderWidth) * angleFunctions.sin),
      angle: that.middleAngle
    };
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled, firstDrawing) {
    var that = this;
    var radiusOuter = that.radiusOuter;
    var radiusInner = that.radiusInner;
    var fromAngle = that.fromAngle;
    var toAngle = that.toAngle;
    if (animationEnabled) {
      radiusInner = radiusOuter = 0;
      if (!firstDrawing) {
        fromAngle = toAngle = that.shiftedAngle;
      }
    }
    that.graphic = renderer.arc(that.centerX, that.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({
      'stroke-linejoin': 'round'
    }).smartAttr(that._getStyle()).data({
      'chart-data-point': that
    }).sharp().append(group);
  },
  getTooltipParams: function getTooltipParams() {
    var that = this;
    var angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    var radiusInner = that.radiusInner;
    var radiusOuter = that.radiusOuter;
    return {
      x: that.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,
      y: that.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,
      offset: 0
    };
  },
  _translate: function _translate() {
    var that = this;
    var angle = that.shiftedAngle || 0;
    var value = that.value;
    var minValue = that.minValue;
    var translator = that._getValTranslator();
    that.fromAngle = translator.translate(minValue) + angle;
    that.toAngle = translator.translate(value) + angle;
    that.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;
    if (!that.isVisible()) {
      that.middleAngle = that.toAngle = that.fromAngle = that.fromAngle || angle;
    }
  },
  getMarkerVisibility: function getMarkerVisibility() {
    return true;
  },
  _updateMarker: function _updateMarker(animationEnabled, style, _, callback) {
    var that = this;
    if (!animationEnabled) {
      style = _extend({
        x: that.centerX,
        y: that.centerY,
        outerRadius: that.radiusOuter,
        innerRadius: that.radiusInner,
        startAngle: that.toAngle,
        endAngle: that.fromAngle
      }, style);
    }
    that.graphic.smartAttr(style).sharp();
    callback && callback();
  },
  getLegendStyles: function getLegendStyles() {
    return this._styles.legendStyles;
  },
  isInVisibleArea: function isInVisibleArea() {
    return true;
  },
  hide: function hide() {
    var that = this;
    if (that._visible) {
      that._visible = false;
      that.hideTooltip();
      that._options.visibilityChanged();
    }
  },
  show: function show() {
    var that = this;
    if (!that._visible) {
      that._visible = true;
      that._options.visibilityChanged();
    }
  },
  setInvisibility: function setInvisibility() {
    this._label.draw(false);
  },
  isVisible: function isVisible() {
    return this._visible;
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var formatObject = _symbol_point.default._getFormatObject.call(this, tooltip);
    var percent = this.percent;
    formatObject.percent = percent;
    formatObject.percentText = tooltip.formatValue(percent, 'percent');
    return formatObject;
  },
  getColor: function getColor() {
    return this._styles.normal.fill;
  },
  coordsIn: function coordsIn(x, y) {
    var that = this;
    var lx = x - that.centerX;
    var ly = y - that.centerY;
    var r = _sqrt(lx * lx + ly * ly);
    var fromAngle = that.fromAngle % 360;
    var toAngle = that.toAngle % 360;
    var angle;
    if (r < that.radiusInner || r > that.radiusOuter || r === 0) {
      return false;
    }
    angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);
    if (angle < 0) {
      angle += 360;
    }
    if (fromAngle === toAngle && _abs(that.toAngle - that.fromAngle) > 1E-4) {
      return true;
    } else {
      return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle);
    }
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 38234:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polarSymbolPoint = exports.polarBarPoint = void 0;
var _extend2 = __webpack_require__(13306);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
var _pie_point = _interopRequireDefault(__webpack_require__(85912));
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _consts = _interopRequireDefault(__webpack_require__(32410));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _extend = _extend2.extend;
var _math = Math;
var _max = _math.max;
var RADIAL_LABEL_INDENT = _consts.default.radialLabelIndent;
var ERROR_BARS_ANGLE_OFFSET = 90;
var CANVAS_POSITION_START = 'canvas_position_start';
var CANVAS_POSITION_END = 'canvas_position_end';
var CANVAS_POSITION_DEFAULT = 'canvas_position_default';
var polarSymbolPoint = _extend({}, _symbol_point.default, {
  _getLabelCoords: _pie_point.default._getLabelCoords,
  _getElementCoords: _pie_point.default._getElementCoords,
  _moveLabelOnCanvas: function _moveLabelOnCanvas(coord, visibleArea, labelBBox) {
    var x = coord.x;
    var y = coord.y;
    if (visibleArea.minX > x) {
      x = visibleArea.minX;
    }
    if (visibleArea.maxX < x + labelBBox.width) {
      x = visibleArea.maxX - labelBBox.width;
    }
    if (visibleArea.minY > y) {
      y = visibleArea.minY;
    }
    if (visibleArea.maxY < y + labelBBox.height) {
      y = visibleArea.maxY - labelBBox.height;
    }
    return {
      x: x,
      y: y
    };
  },
  _getLabelPosition: function _getLabelPosition() {
    return 'outside';
  },
  _getCoords: function _getCoords(argument, value) {
    var axis = this.series.getValueAxis();
    var startAngle = axis.getAngles()[0];
    var angle = this._getArgTranslator().translate(argument);
    var radius = this._getValTranslator().translate(value);
    var coords = (0, _utils.convertPolarToXY)(axis.getCenter(), axis.getAngles()[0], angle, radius);
    coords.angle = angle + startAngle - 90, coords.radius = radius;
    return coords;
  },
  _translate() {
    var that = this;
    var center = that.series.getValueAxis().getCenter();
    var coord = that._getCoords(that.argument, that.value);
    var translator = that._getValTranslator();
    var maxRadius = translator.isInverted() ? translator.translate(CANVAS_POSITION_START) : translator.translate(CANVAS_POSITION_END);
    var normalizedRadius = (0, _type.isDefined)(coord.radius) && coord.radius >= 0 ? coord.radius : null;
    that.vx = (0, _utils.normalizeAngle)(coord.angle);
    that.vy = that.radiusOuter = that.radiusLabels = normalizedRadius;
    that.radiusLabels += RADIAL_LABEL_INDENT;
    that.radius = normalizedRadius;
    that.middleAngle = -coord.angle;
    that.angle = -coord.angle;
    that.x = coord.x;
    that.y = coord.y;
    that.defaultX = that.centerX = center.x;
    that.defaultY = that.centerY = center.y;
    that._translateErrorBars();
    that.inVisibleArea = that._checkRadiusForVisibleArea(normalizedRadius, maxRadius);
  },
  _checkRadiusForVisibleArea(radius, maxRadius) {
    return (0, _type.isDefined)(radius) && radius <= maxRadius;
  },
  _translateErrorBars: function _translateErrorBars() {
    var that = this;
    var errorBars = that._options.errorBars;
    var translator = that._getValTranslator();
    if (!errorBars) {
      return;
    }
    (0, _type.isDefined)(that.lowError) && (that._lowErrorCoord = that.centerY - translator.translate(that.lowError));
    (0, _type.isDefined)(that.highError) && (that._highErrorCoord = that.centerY - translator.translate(that.highError));
    that._errorBarPos = that.centerX;
    that._baseErrorBarPos = errorBars.type === 'stdDeviation' ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : that.centerY - that.radius;
  },
  _getTranslates: function _getTranslates(animationEnabled) {
    return animationEnabled ? this.getDefaultCoords() : {
      x: this.x,
      y: this.y
    };
  },
  getDefaultCoords: function getDefaultCoords() {
    var cosSin = (0, _utils.getCosAndSin)(-this.angle);
    var radius = this._getValTranslator().translate(CANVAS_POSITION_DEFAULT);
    var x = this.defaultX + radius * cosSin.cos;
    var y = this.defaultY + radius * cosSin.sin;
    return {
      x: x,
      y: y
    };
  },
  _addLabelAlignmentAndOffset: function _addLabelAlignmentAndOffset(label, coord) {
    return coord;
  },
  _checkLabelPosition: function _checkLabelPosition(label, coord) {
    var that = this;
    var visibleArea = that._getVisibleArea();
    var graphicBBox = that._getGraphicBBox();
    if (that._isPointInVisibleArea(visibleArea, graphicBBox)) {
      coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect());
    }
    return coord;
  },
  _getErrorBarSettings: function _getErrorBarSettings(errorBarOptions, animationEnabled) {
    var settings = _symbol_point.default._getErrorBarSettings.call(this, errorBarOptions, animationEnabled);
    settings.rotate = ERROR_BARS_ANGLE_OFFSET - this.angle;
    settings.rotateX = this.centerX;
    settings.rotateY = this.centerY;
    return settings;
  },
  getCoords: function getCoords(min) {
    return min ? this.getDefaultCoords() : {
      x: this.x,
      y: this.y
    };
  }
});
exports.polarSymbolPoint = polarSymbolPoint;
var polarBarPoint = _extend({}, _bar_point.default, {
  _translateErrorBars: polarSymbolPoint._translateErrorBars,
  _getErrorBarSettings: polarSymbolPoint._getErrorBarSettings,
  _moveLabelOnCanvas: polarSymbolPoint._moveLabelOnCanvas,
  _getLabelCoords: _pie_point.default._getLabelCoords,
  _getElementCoords: _pie_point.default._getElementCoords,
  _getLabelConnector: _pie_point.default._getLabelConnector,
  getTooltipParams: _pie_point.default.getTooltipParams,
  _getLabelPosition: _pie_point.default._getLabelPosition,
  _getCoords: polarSymbolPoint._getCoords,
  _translate() {
    var that = this;
    var translator = that._getValTranslator();
    var businessRange = translator.getBusinessRange();
    var maxRadius = translator.isInverted() ? translator.translate(CANVAS_POSITION_START) : translator.translate(CANVAS_POSITION_END);
    that.radiusInner = translator.translate(that.minValue);
    polarSymbolPoint._translate.call(that);
    if (that.radiusInner === null) {
      that.radiusInner = that.radius = maxRadius;
    } else if (that.radius === null) {
      that.radius = that.value >= businessRange.minVisible ? maxRadius : 0;
    } else if (that.radius > maxRadius) {
      that.radius = maxRadius;
    }
    that.radiusOuter = that.radiusLabels = _max(that.radiusInner, that.radius);
    that.radiusLabels += RADIAL_LABEL_INDENT;
    that.radiusInner = that.defaultRadius = _math.min(that.radiusInner, that.radius);
    that.middleAngle = that.angle = -(0, _utils.normalizeAngle)(that.middleAngleCorrection - that.angle);
  },
  _checkRadiusForVisibleArea(radius) {
    return (0, _type.isDefined)(radius) || this._getValTranslator().translate(this.minValue) > 0;
  },
  _getErrorBarBaseEdgeLength() {
    var coord = this.getMarkerCoords();
    return _math.PI * coord.outerRadius * _math.abs(coord.startAngle - coord.endAngle) / 180;
  },
  getMarkerCoords: function getMarkerCoords() {
    return {
      x: this.centerX,
      y: this.centerY,
      outerRadius: this.radiusOuter,
      innerRadius: this.defaultRadius,
      startAngle: this.middleAngle - this.interval / 2,
      endAngle: this.middleAngle + this.interval / 2
    };
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {
    var that = this;
    var styles = that._getStyle();
    var coords = that.getMarkerCoords();
    var innerRadius = coords.innerRadius;
    var outerRadius = coords.outerRadius;
    var start = that._getCoords(that.argument, CANVAS_POSITION_DEFAULT);
    var x = coords.x;
    var y = coords.y;
    if (animationEnabled) {
      innerRadius = 0;
      outerRadius = 0;
      x = start.x;
      y = start.y;
    }
    that.graphic = renderer.arc(x, y, innerRadius, outerRadius, coords.startAngle, coords.endAngle).attr(styles).data({
      'chart-data-point': that
    }).append(group);
  },
  _checkLabelPosition: function _checkLabelPosition(label, coord) {
    var that = this;
    var visibleArea = that._getVisibleArea();
    var angleFunctions = (0, _utils.getCosAndSin)(that.middleAngle);
    var x = that.centerX + that.defaultRadius * angleFunctions.cos;
    var y = that.centerY - that.defaultRadius * angleFunctions.sin;
    if (x > visibleArea.minX && x < visibleArea.maxX && y > visibleArea.minY && y < visibleArea.maxY) {
      coord = that._moveLabelOnCanvas(coord, visibleArea, label.getBoundingRect());
    }
    return coord;
  },
  _addLabelAlignmentAndOffset: function _addLabelAlignmentAndOffset(label, coord) {
    return coord;
  },
  correctCoordinates: function correctCoordinates(correctOptions) {
    this.middleAngleCorrection = correctOptions.offset;
    this.interval = correctOptions.width;
  },
  coordsIn: function coordsIn(x, y) {
    var val = (0, _utils.convertXYToPolar)(this.series.getValueAxis().getCenter(), x, y);
    var coords = this.getMarkerCoords();
    var isBetweenAngles = coords.startAngle < coords.endAngle ? -val.phi >= coords.startAngle && -val.phi <= coords.endAngle : -val.phi <= coords.startAngle && -val.phi >= coords.endAngle;
    return val.r >= coords.innerRadius && val.r <= coords.outerRadius && isBetweenAngles;
  }
});
exports.polarBarPoint = polarBarPoint;

/***/ }),

/***/ 73206:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _bar_point = _interopRequireDefault(__webpack_require__(27428));
var _range_symbol_point = _interopRequireDefault(__webpack_require__(97319));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _extend = _extend2.extend;
var _default = _extend({}, _bar_point.default, {
  deleteLabel: _range_symbol_point.default.deleteLabel,
  _getFormatObject: _range_symbol_point.default._getFormatObject,
  clearVisibility: function clearVisibility() {
    var graphic = this.graphic;
    if (graphic && graphic.attr('visibility')) {
      graphic.attr({
        visibility: null
      });
    }
  },
  setInvisibility: function setInvisibility() {
    var graphic = this.graphic;
    if (graphic && graphic.attr('visibility') !== 'hidden') {
      graphic.attr({
        visibility: 'hidden'
      });
    }
    this._topLabel.draw(false);
    this._bottomLabel.draw(false);
  },
  getTooltipParams: function getTooltipParams(location) {
    var that = this;
    var edgeLocation = location === 'edge';
    var x;
    var y;
    if (that._options.rotated) {
      x = edgeLocation ? that.x + that.width : that.x + that.width / 2;
      y = that.y + that.height / 2;
    } else {
      x = that.x + that.width / 2;
      y = edgeLocation ? that.y : that.y + that.height / 2;
    }
    return {
      x: x,
      y: y,
      offset: 0
    };
  },
  _translate: function _translate() {
    var that = this;
    var barMethods = _bar_point.default;
    barMethods._translate.call(that);
    if (that._options.rotated) {
      that.width = that.width || 1;
    } else {
      that.height = that.height || 1;
    }
  },
  hasCoords: _range_symbol_point.default.hasCoords,
  _updateData: _range_symbol_point.default._updateData,
  _getLabelPosition: _range_symbol_point.default._getLabelPosition,
  _getLabelMinFormatObject: _range_symbol_point.default._getLabelMinFormatObject,
  _updateLabelData: _range_symbol_point.default._updateLabelData,
  _updateLabelOptions: _range_symbol_point.default._updateLabelOptions,
  getCrosshairData: _range_symbol_point.default.getCrosshairData,
  _createLabel: _range_symbol_point.default._createLabel,
  _checkOverlay: _range_symbol_point.default._checkOverlay,
  _checkLabelsOverlay: _range_symbol_point.default._checkLabelsOverlay,
  _getOverlayCorrections: _range_symbol_point.default._getOverlayCorrections,
  _drawLabel: _range_symbol_point.default._drawLabel,
  _getLabelCoords: _range_symbol_point.default._getLabelCoords,
  getLabel: _range_symbol_point.default.getLabel,
  getLabels: _range_symbol_point.default.getLabels,
  getBoundingRect: _common.noop,
  getMinValue: _range_symbol_point.default.getMinValue,
  getMaxValue: _range_symbol_point.default.getMaxValue
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 97319:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _extend2 = __webpack_require__(13306);
var _common = __webpack_require__(20576);
var _label = __webpack_require__(28318);
var _symbol_point = _interopRequireDefault(__webpack_require__(24894));
var _type = __webpack_require__(35922);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _extend = _extend2.extend;
var _math = Math;
var _abs = _math.abs;
var _min = _math.min;
var _max = _math.max;
var _round = _math.round;
var DEFAULT_IMAGE_WIDTH = 20;
var DEFAULT_IMAGE_HEIGHT = 20;
var _default = _extend({}, _symbol_point.default, {
  deleteLabel: function deleteLabel() {
    var that = this;
    that._topLabel.dispose();
    that._topLabel = null;
    that._bottomLabel.dispose();
    that._bottomLabel = null;
  },
  hideMarker: function hideMarker(type) {
    var graphic = this.graphic;
    var marker = graphic && graphic[type + 'Marker'];
    var label = this['_' + type + 'Label'];
    if (marker && marker.attr('visibility') !== 'hidden') {
      marker.attr({
        visibility: 'hidden'
      });
    }
    label.draw(false);
  },
  setInvisibility: function setInvisibility() {
    this.hideMarker('top');
    this.hideMarker('bottom');
  },
  clearVisibility: function clearVisibility() {
    var that = this;
    var graphic = that.graphic;
    var topMarker = graphic && graphic.topMarker;
    var bottomMarker = graphic && graphic.bottomMarker;
    if (topMarker && topMarker.attr('visibility')) {
      topMarker.attr({
        visibility: null
      });
    }
    if (bottomMarker && bottomMarker.attr('visibility')) {
      bottomMarker.attr({
        visibility: null
      });
    }
  },
  clearMarker: function clearMarker() {
    var that = this;
    var graphic = that.graphic;
    var topMarker = graphic && graphic.topMarker;
    var bottomMarker = graphic && graphic.bottomMarker;
    var emptySettings = that._emptySettings;
    topMarker && topMarker.attr(emptySettings);
    bottomMarker && bottomMarker.attr(emptySettings);
  },
  _getLabelPosition: function _getLabelPosition(markerType) {
    var position;
    var labelsInside = this._options.label.position === 'inside';
    if (!this._options.rotated) {
      position = markerType === 'top' ^ labelsInside ? 'top' : 'bottom';
    } else {
      position = markerType === 'top' ^ labelsInside ? 'right' : 'left';
    }
    return position;
  },
  _getLabelMinFormatObject: function _getLabelMinFormatObject() {
    var that = this;
    return {
      index: 0,
      argument: that.initialArgument,
      value: that.initialMinValue,
      seriesName: that.series.name,
      originalValue: that.originalMinValue,
      originalArgument: that.originalArgument,
      point: that
    };
  },
  _updateLabelData: function _updateLabelData() {
    var maxFormatObject = this._getLabelFormatObject();
    maxFormatObject.index = 1;
    this._topLabel.setData(maxFormatObject);
    this._bottomLabel.setData(this._getLabelMinFormatObject());
  },
  _updateLabelOptions: function _updateLabelOptions() {
    var that = this;
    var options = this._options.label;
    (!that._topLabel || !that._bottomLabel) && that._createLabel();
    that._topLabel.setOptions(options);
    that._bottomLabel.setOptions(options);
  },
  _createLabel: function _createLabel() {
    var options = {
      renderer: this.series._renderer,
      labelsGroup: this.series._labelsGroup,
      point: this
    };
    this._topLabel = new _label.Label(options);
    this._bottomLabel = new _label.Label(options);
  },
  _getGraphicBBox: function _getGraphicBBox(location) {
    var options = this._options;
    var images = this._getImage(options.image);
    var image = location === 'top' ? this._checkImage(images.top) : this._checkImage(images.bottom);
    var bBox;
    var coord = this._getPositionFromLocation(location);
    if (options.visible) {
      bBox = image ? this._getImageBBox(coord.x, coord.y) : this._getSymbolBBox(coord.x, coord.y, options.styles.normal.r);
    } else {
      bBox = {
        x: coord.x,
        y: coord.y,
        width: 0,
        height: 0
      };
    }
    return bBox;
  },
  _getPositionFromLocation: function _getPositionFromLocation(location) {
    var x;
    var y;
    var isTop = location === 'top';
    if (!this._options.rotated) {
      x = this.x;
      y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY);
    } else {
      x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);
      y = this.y;
    }
    return {
      x: x,
      y: y
    };
  },
  _checkOverlay: function _checkOverlay(bottomCoord, topCoord, topValue) {
    return bottomCoord < topCoord + topValue;
  },
  _getOverlayCorrections: function _getOverlayCorrections(topCoords, bottomCoords) {
    var rotated = this._options.rotated;
    var coordSelector = !rotated ? 'y' : 'x';
    var valueSelector = !rotated ? 'height' : 'width';
    var visibleArea = this.series.getValueAxis().getVisibleArea();
    var minBound = visibleArea[0];
    var maxBound = visibleArea[1];
    var delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2);
    var coord1 = topCoords[coordSelector] - delta;
    var coord2 = bottomCoords[coordSelector] + delta;
    if (coord1 < minBound) {
      delta = minBound - coord1;
      coord1 += delta;
      coord2 += delta;
    } else if (coord2 + bottomCoords[valueSelector] > maxBound) {
      delta = maxBound - coord2 - bottomCoords[valueSelector];
      coord1 += delta;
      coord2 += delta;
    }
    return {
      coord1: coord1,
      coord2: coord2
    };
  },
  _checkLabelsOverlay: function _checkLabelsOverlay(topLocation) {
    var that = this;
    var topCoords = that._topLabel.getBoundingRect();
    var bottomCoords = that._bottomLabel.getBoundingRect();
    var corrections = {};
    if (!that._options.rotated) {
      if (topLocation === 'top') {
        if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {
          corrections = this._getOverlayCorrections(topCoords, bottomCoords);
          that._topLabel.shift(topCoords.x, corrections.coord1);
          that._bottomLabel.shift(bottomCoords.x, corrections.coord2);
        }
      } else {
        if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {
          corrections = this._getOverlayCorrections(bottomCoords, topCoords);
          that._topLabel.shift(topCoords.x, corrections.coord2);
          that._bottomLabel.shift(bottomCoords.x, corrections.coord1);
        }
      }
    } else {
      if (topLocation === 'top') {
        if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {
          corrections = this._getOverlayCorrections(bottomCoords, topCoords);
          that._topLabel.shift(corrections.coord2, topCoords.y);
          that._bottomLabel.shift(corrections.coord1, bottomCoords.y);
        }
      } else {
        if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {
          corrections = this._getOverlayCorrections(topCoords, bottomCoords);
          that._topLabel.shift(corrections.coord1, topCoords.y);
          that._bottomLabel.shift(corrections.coord2, bottomCoords.y);
        }
      }
    }
  },
  _drawLabel: function _drawLabel() {
    var that = this;
    var labels = [];
    var notInverted = that._options.rotated ? that.x >= that.minX : that.y < that.minY;
    var customVisibility = that._getCustomLabelVisibility();
    var topLabel = that._topLabel;
    var bottomLabel = that._bottomLabel;
    topLabel.pointPosition = notInverted ? 'top' : 'bottom';
    bottomLabel.pointPosition = notInverted ? 'bottom' : 'top';
    if ((that.series.getLabelVisibility() || customVisibility) && that.hasValue() && customVisibility !== false) {
      that.visibleTopMarker !== false && labels.push(topLabel);
      that.visibleBottomMarker !== false && labels.push(bottomLabel);
      (0, _iterator.each)(labels, function (_, label) {
        label.draw(true);
      });
      that._checkLabelsOverlay(that._topLabel.pointPosition);
    } else {
      topLabel.draw(false);
      bottomLabel.draw(false);
    }
  },
  _getImage: function _getImage(imageOption) {
    var image = {};
    if ((0, _type.isDefined)(imageOption)) {
      if (typeof imageOption === 'string') {
        image.top = image.bottom = imageOption;
      } else {
        image.top = {
          url: typeof imageOption.url === 'string' ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,
          width: typeof imageOption.width === 'number' ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,
          height: typeof imageOption.height === 'number' ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint
        };
        image.bottom = {
          url: typeof imageOption.url === 'string' ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,
          width: typeof imageOption.width === 'number' ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,
          height: typeof imageOption.height === 'number' ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint
        };
      }
    }
    return image;
  },
  _checkSymbol: function _checkSymbol(oldOptions, newOptions) {
    var that = this;
    var oldSymbol = oldOptions.symbol;
    var newSymbol = newOptions.symbol;
    var symbolChanged = oldSymbol === 'circle' && newSymbol !== 'circle' || oldSymbol !== 'circle' && newSymbol === 'circle';
    var oldImages = that._getImage(oldOptions.image);
    var newImages = that._getImage(newOptions.image);
    var topImageChanged = that._checkImage(oldImages.top) !== that._checkImage(newImages.top);
    var bottomImageChanged = that._checkImage(oldImages.bottom) !== that._checkImage(newImages.bottom);
    return symbolChanged || topImageChanged || bottomImageChanged;
  },
  _getSettingsForTwoMarkers: function _getSettingsForTwoMarkers(style) {
    var that = this;
    var options = that._options;
    var settings = {};
    var x = options.rotated ? _min(that.x, that.minX) : that.x;
    var y = options.rotated ? that.y : _min(that.y, that.minY);
    var radius = style.r;
    var points = that._populatePointShape(options.symbol, radius);
    settings.top = _extend({
      translateX: x + that.width,
      translateY: y,
      r: radius
    }, style);
    settings.bottom = _extend({
      translateX: x,
      translateY: y + that.height,
      r: radius
    }, style);
    if (points) {
      settings.top.points = settings.bottom.points = points;
    }
    return settings;
  },
  _hasGraphic: function _hasGraphic() {
    return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker;
  },
  _drawOneMarker: function _drawOneMarker(renderer, markerType, imageSettings, settings) {
    var that = this;
    var graphic = that.graphic;
    if (graphic[markerType]) {
      that._updateOneMarker(markerType, settings);
    } else {
      graphic[markerType] = that._createMarker(renderer, graphic, imageSettings, settings);
    }
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled, firstDrawing, style) {
    var that = this;
    var settings = that._getSettingsForTwoMarkers(style || that._getStyle());
    var image = that._getImage(that._options.image);
    if (that._checkImage(image.top)) {
      settings.top = that._getImageSettings(settings.top, image.top);
    }
    if (that._checkImage(image.bottom)) {
      settings.bottom = that._getImageSettings(settings.bottom, image.bottom);
    }
    that.graphic = that.graphic || renderer.g().append(group);
    that.visibleTopMarker && that._drawOneMarker(renderer, 'topMarker', image.top, settings.top);
    that.visibleBottomMarker && that._drawOneMarker(renderer, 'bottomMarker', image.bottom, settings.bottom);
  },
  _getSettingsForTracker: function _getSettingsForTracker(radius) {
    var that = this;
    var rotated = that._options.rotated;
    return {
      translateX: rotated ? _min(that.x, that.minX) - radius : that.x - radius,
      translateY: rotated ? that.y - radius : _min(that.y, that.minY) - radius,
      width: that.width + 2 * radius,
      height: that.height + 2 * radius
    };
  },
  isInVisibleArea: function isInVisibleArea() {
    var that = this;
    var rotated = that._options.rotated;
    var argument = !rotated ? that.x : that.y;
    var maxValue = !rotated ? _max(that.minY, that.y) : _max(that.minX, that.x);
    var minValue = !rotated ? _min(that.minY, that.y) : _min(that.minX, that.x);
    var tmp;
    var visibleTopMarker;
    var visibleBottomMarker;
    var visibleRangeArea = true;
    var visibleArgArea = that.series.getArgumentAxis().getVisibleArea();
    var visibleValArea = that.series.getValueAxis().getVisibleArea();
    var notVisibleByArg = visibleArgArea[1] < argument || visibleArgArea[0] > argument;
    var notVisibleByVal = visibleValArea[0] > minValue && visibleValArea[0] > maxValue || visibleValArea[1] < minValue && visibleValArea[1] < maxValue;
    if (notVisibleByArg || notVisibleByVal) {
      visibleTopMarker = visibleBottomMarker = visibleRangeArea = false;
    } else {
      visibleTopMarker = visibleValArea[0] <= minValue && visibleValArea[1] > minValue;
      visibleBottomMarker = visibleValArea[0] < maxValue && visibleValArea[1] >= maxValue;
      if (rotated) {
        tmp = visibleTopMarker;
        visibleTopMarker = visibleBottomMarker;
        visibleBottomMarker = tmp;
      }
    }
    that.visibleTopMarker = visibleTopMarker;
    that.visibleBottomMarker = visibleBottomMarker;
    return visibleRangeArea;
  },
  getTooltipParams: function getTooltipParams() {
    var that = this;
    var x;
    var y;
    var rotated = that._options.rotated;
    var minValue = !rotated ? _min(that.y, that.minY) : _min(that.x, that.minX);
    var side = !rotated ? 'height' : 'width';
    var visibleArea = that._getVisibleArea();
    var minVisible = rotated ? visibleArea.minX : visibleArea.minY;
    var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;
    var min = _max(minVisible, minValue);
    var max = _min(maxVisible, minValue + that[side]);
    if (!rotated) {
      x = that.x;
      y = min + (max - min) / 2;
    } else {
      y = that.y;
      x = min + (max - min) / 2;
    }
    return {
      x: x,
      y: y,
      offset: 0
    };
  },
  _translate: function _translate() {
    var that = this;
    var rotated = that._options.rotated;
    _symbol_point.default._translate.call(that);
    that.height = rotated ? 0 : _abs(that.minY - that.y);
    that.width = rotated ? _abs(that.x - that.minX) : 0;
  },
  hasCoords: function hasCoords() {
    return _symbol_point.default.hasCoords.call(this) && !(this.minX === null || this.minY === null);
  },
  _updateData: function _updateData(data) {
    var that = this;
    _symbol_point.default._updateData.call(that, data);
    that.minValue = that.initialMinValue = that.originalMinValue = data.minValue;
  },
  _getImageSettings: function _getImageSettings(settings, image) {
    return {
      href: image.url || image.toString(),
      width: image.width || DEFAULT_IMAGE_WIDTH,
      height: image.height || DEFAULT_IMAGE_HEIGHT,
      translateX: settings.translateX,
      translateY: settings.translateY
    };
  },
  getCrosshairData: function getCrosshairData(x, y) {
    var that = this;
    var rotated = that._options.rotated;
    var minX = that.minX;
    var minY = that.minY;
    var vx = that.vx;
    var vy = that.vy;
    var value = that.value;
    var minValue = that.minValue;
    var argument = that.argument;
    var coords = {
      axis: that.series.axis,
      x: vx,
      y: vy,
      yValue: value,
      xValue: argument
    };
    if (rotated) {
      coords.yValue = argument;
      if (_abs(vx - x) < _abs(minX - x)) {
        coords.xValue = value;
      } else {
        coords.x = minX;
        coords.xValue = minValue;
      }
    } else {
      if (_abs(vy - y) >= _abs(minY - y)) {
        coords.y = minY;
        coords.yValue = minValue;
      }
    }
    return coords;
  },
  _updateOneMarker: function _updateOneMarker(markerType, settings) {
    this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings);
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    this._drawMarker(undefined, undefined, false, false, style);
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var that = this;
    var initialMinValue = that.initialMinValue;
    var initialValue = that.initialValue;
    var initialArgument = that.initialArgument;
    var minValue = tooltip.formatValue(initialMinValue);
    var value = tooltip.formatValue(initialValue);
    return {
      argument: initialArgument,
      argumentText: tooltip.formatValue(initialArgument, 'argument'),
      valueText: minValue + ' - ' + value,
      rangeValue1Text: minValue,
      rangeValue2Text: value,
      rangeValue1: initialMinValue,
      rangeValue2: initialValue,
      seriesName: that.series.name,
      point: that,
      originalMinValue: that.originalMinValue,
      originalValue: that.originalValue,
      originalArgument: that.originalArgument
    };
  },
  getLabel: function getLabel() {
    return [this._topLabel, this._bottomLabel];
  },
  getLabels: function getLabels() {
    return [this._topLabel, this._bottomLabel];
  },
  getBoundingRect: _common.noop,
  coordsIn: function coordsIn(x, y) {
    var trackerRadius = this._storeTrackerR();
    var xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius;
    var yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;
    if (this._options.rotated) {
      return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius);
    } else {
      return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius);
    }
  },
  getMaxValue: function getMaxValue() {
    if (this.series.valueAxisType !== 'discrete') {
      return this.minValue > this.value ? this.minValue : this.value;
    }
    return this.value;
  },
  getMinValue: function getMinValue() {
    if (this.series.valueAxisType !== 'discrete') {
      return this.minValue < this.value ? this.minValue : this.value;
    }
    return this.minValue;
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 71678:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _candlestick_point = _interopRequireDefault(__webpack_require__(69297));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _extend = _extend2.extend;
var _isNumeric = _type.isNumeric;
var _default = _extend({}, _candlestick_point.default, {
  _getPoints: function _getPoints() {
    var that = this;
    var createPoint = that._options.rotated ? function (x, y) {
      return [y, x];
    } : function (x, y) {
      return [x, y];
    };
    var openYExist = _isNumeric(that.openY);
    var closeYExist = _isNumeric(that.closeY);
    var x = that.x;
    var width = that.width;
    var points = [].concat(createPoint(x, that.highY));
    openYExist && (points = points.concat(createPoint(x, that.openY)));
    openYExist && (points = points.concat(createPoint(x - width / 2, that.openY)));
    openYExist && (points = points.concat(createPoint(x, that.openY)));
    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
    closeYExist && (points = points.concat(createPoint(x + width / 2, that.closeY)));
    closeYExist && (points = points.concat(createPoint(x, that.closeY)));
    points = points.concat(createPoint(x, that.lowY));
    return points;
  },
  _drawMarkerInGroup: function _drawMarkerInGroup(group, attributes, renderer) {
    this.graphic = renderer.path(this._getPoints(), 'line').attr({
      'stroke-linecap': 'square'
    }).attr(attributes).data({
      'chart-data-point': this
    }).sharp().append(group);
  },
  _getMinTrackerWidth: function _getMinTrackerWidth() {
    var width = 2 + this._styles.normal['stroke-width'];
    return width + width % 2;
  }
});
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 24894:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _common = __webpack_require__(20576);
var _window = __webpack_require__(58201);
var _label = __webpack_require__(28318);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var window = (0, _window.getWindow)();
var _extend = _extend2.extend;
var _math = Math;
var _round = _math.round;
var _floor = _math.floor;
var _ceil = _math.ceil;
var DEFAULT_IMAGE_WIDTH = 20;
var DEFAULT_IMAGE_HEIGHT = 20;
var LABEL_OFFSET = 10;
var CANVAS_POSITION_DEFAULT = 'canvas_position_default';
function getSquareMarkerCoords(radius) {
  return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius];
}
function getPolygonMarkerCoords(radius) {
  var r = _ceil(radius); // T100386
  return [-r, 0, 0, -r, r, 0, 0, r, -r, 0];
}
function getCrossMarkerCoords(radius) {
  var r = _ceil(radius); // T100386
  var floorHalfRadius = _floor(r / 2);
  var ceilHalfRadius = _ceil(r / 2);
  return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0];
}
function getTriangleDownMarkerCoords(radius) {
  return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius];
}
function getTriangleUpMarkerCoords(radius) {
  return [-radius, radius, radius, radius, 0, -radius, -radius, radius];
}
var _default = {
  deleteLabel: function deleteLabel() {
    this._label.dispose();
    this._label = null;
  },
  _hasGraphic: function _hasGraphic() {
    return this.graphic;
  },
  clearVisibility: function clearVisibility() {
    var that = this;
    var graphic = that.graphic;
    if (graphic && graphic.attr('visibility')) {
      graphic.attr({
        visibility: null
      });
    }
  },
  isVisible: function isVisible() {
    return this.inVisibleArea && this.series.isVisible();
  },
  setInvisibility: function setInvisibility() {
    var that = this;
    var graphic = that.graphic;
    if (graphic && graphic.attr('visibility') !== 'hidden') {
      graphic.attr({
        visibility: 'hidden'
      });
    }
    that._errorBar && that._errorBar.attr({
      visibility: 'hidden'
    });
    that._label.draw(false);
  },
  clearMarker: function clearMarker() {
    var graphic = this.graphic;
    graphic && graphic.attr(this._emptySettings);
  },
  _createLabel: function _createLabel() {
    this._label = new _label.Label({
      renderer: this.series._renderer,
      labelsGroup: this.series._labelsGroup,
      point: this
    });
  },
  _calculateVisibility: function _calculateVisibility(x, y) {
    var _this$_getVisibleArea = this._getVisibleArea(),
      minX = _this$_getVisibleArea.minX,
      maxX = _this$_getVisibleArea.maxX,
      minY = _this$_getVisibleArea.minY,
      maxY = _this$_getVisibleArea.maxY;
    this.inVisibleArea = minX <= x && maxX >= x && minY <= y && maxY >= y;
  },
  _updateLabelData: function _updateLabelData() {
    this._label.setData(this._getLabelFormatObject());
  },
  _updateLabelOptions: function _updateLabelOptions() {
    !this._label && this._createLabel();
    this._label.setOptions(this._options.label);
  },
  _checkImage: function _checkImage(image) {
    return (0, _type.isDefined)(image) && (typeof image === 'string' || (0, _type.isDefined)(image.url));
  },
  _fillStyle: function _fillStyle() {
    this._styles = this._options.styles;
  },
  _checkSymbol: function _checkSymbol(oldOptions, newOptions) {
    var oldSymbol = oldOptions.symbol;
    var newSymbol = newOptions.symbol;
    var symbolChanged = oldSymbol === 'circle' && newSymbol !== 'circle' || oldSymbol !== 'circle' && newSymbol === 'circle';
    var imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);
    return !!(symbolChanged || imageChanged);
  },
  _populatePointShape: function _populatePointShape(symbol, radius) {
    switch (symbol) {
      case 'square':
        return getSquareMarkerCoords(radius);
      case 'polygon':
        return getPolygonMarkerCoords(radius);
      case 'triangle':
      case 'triangleDown':
        return getTriangleDownMarkerCoords(radius);
      case 'triangleUp':
        return getTriangleUpMarkerCoords(radius);
      case 'cross':
        return getCrossMarkerCoords(radius);
    }
  },
  hasCoords: function hasCoords() {
    return this.x !== null && this.y !== null;
  },
  correctValue: function correctValue(correction) {
    var that = this;
    var axis = that.series.getValueAxis();
    if (that.hasValue()) {
      that.value = that.properValue = axis.validateUnit(that.initialValue.valueOf() + correction.valueOf());
      that.minValue = axis.validateUnit(correction);
    }
  },
  resetCorrection: function resetCorrection() {
    this.value = this.properValue = this.initialValue;
    this.minValue = CANVAS_POSITION_DEFAULT;
  },
  resetValue: function resetValue() {
    var that = this;
    if (that.hasValue()) {
      that.value = that.properValue = that.initialValue = 0;
      that.minValue = 0;
      that._label.setDataField('value', that.value);
    }
  },
  _getTranslates: function _getTranslates(animationEnabled) {
    var translateX = this.x;
    var translateY = this.y;
    if (animationEnabled) {
      if (this._options.rotated) {
        translateX = this.defaultX;
      } else {
        translateY = this.defaultY;
      }
    }
    return {
      x: translateX,
      y: translateY
    };
  },
  _createImageMarker: function _createImageMarker(renderer, settings, options) {
    var width = options.width || DEFAULT_IMAGE_WIDTH;
    var height = options.height || DEFAULT_IMAGE_HEIGHT;
    return renderer.image(-_round(width * 0.5), -_round(height * 0.5), width, height, options.url ? options.url.toString() : options.toString(), 'center').attr({
      translateX: settings.translateX,
      translateY: settings.translateY,
      visibility: settings.visibility
    });
  },
  _createSymbolMarker: function _createSymbolMarker(renderer, pointSettings) {
    var marker;
    var symbol = this._options.symbol;
    if (symbol === 'circle') {
      delete pointSettings.points;
      marker = renderer.circle().attr(pointSettings);
    } else if (symbol === 'square' || symbol === 'polygon' || symbol === 'triangle' || symbol === 'triangleDown' || symbol === 'triangleUp' || symbol === 'cross') {
      marker = renderer.path([], 'area').attr(pointSettings).sharp();
    }
    return marker;
  },
  _createMarker: function _createMarker(renderer, group, image, settings) {
    var that = this;
    var marker = that._checkImage(image) ? that._createImageMarker(renderer, settings, image) : that._createSymbolMarker(renderer, settings);
    if (marker) {
      marker.data({
        'chart-data-point': that
      }).append(group);
    }
    return marker;
  },
  _getSymbolBBox: function _getSymbolBBox(x, y, r) {
    return {
      x: x - r,
      y: y - r,
      width: r * 2,
      height: r * 2
    };
  },
  _getImageBBox: function _getImageBBox(x, y) {
    var image = this._options.image;
    var width = image.width || DEFAULT_IMAGE_WIDTH;
    var height = image.height || DEFAULT_IMAGE_HEIGHT;
    return {
      x: x - _round(width / 2),
      y: y - _round(height / 2),
      width: width,
      height: height
    };
  },
  _getGraphicBBox: function _getGraphicBBox() {
    var that = this;
    var options = that._options;
    var x = that.x;
    var y = that.y;
    var bBox;
    if (options.visible) {
      bBox = that._checkImage(options.image) ? that._getImageBBox(x, y) : that._getSymbolBBox(x, y, options.styles.normal.r);
    } else {
      bBox = {
        x: x,
        y: y,
        width: 0,
        height: 0
      };
    }
    return bBox;
  },
  hideInsideLabel: _common.noop,
  _getShiftLabelCoords: function _getShiftLabelCoords(label) {
    var coord = this._addLabelAlignmentAndOffset(label, this._getLabelCoords(label));
    return this._checkLabelPosition(label, coord);
  },
  _drawLabel: function _drawLabel() {
    var that = this;
    var customVisibility = that._getCustomLabelVisibility();
    var label = that._label;
    var isVisible = that._showForZeroValues() && that.hasValue() && customVisibility !== false && (that.series.getLabelVisibility() || customVisibility);
    label.draw(!!isVisible);
  },
  correctLabelPosition: function correctLabelPosition(label) {
    var that = this;
    var coord = that._getShiftLabelCoords(label);
    if (!that.hideInsideLabel(label, coord)) {
      label.setFigureToDrawConnector(that._getLabelConnector(label.pointPosition));
      label.shift(_round(coord.x), _round(coord.y));
    }
  },
  _showForZeroValues: function _showForZeroValues() {
    return true;
  },
  _getLabelConnector: function _getLabelConnector(pointPosition) {
    var bBox = this._getGraphicBBox(pointPosition);
    var w2 = bBox.width / 2;
    var h2 = bBox.height / 2;
    // This is to make label connector end at the center of point; "width" and "height" are required by the path building algorithm
    // TODO: When path building algorithm is updated remove "width" and "height"
    return {
      x: bBox.x + w2,
      y: bBox.y + h2,
      r: this._options.visible ? Math.max(w2, h2) : 0
    };
  },
  _getPositionFromLocation: function _getPositionFromLocation() {
    return {
      x: this.x,
      y: this.y
    };
  },
  _isPointInVisibleArea: function _isPointInVisibleArea(visibleArea, graphicBBox) {
    return visibleArea.minX <= graphicBBox.x + graphicBBox.width && visibleArea.maxX >= graphicBBox.x && visibleArea.minY <= graphicBBox.y + graphicBBox.height && visibleArea.maxY >= graphicBBox.y;
  },
  _checkLabelPosition: function _checkLabelPosition(label, coord) {
    var that = this;
    var visibleArea = that._getVisibleArea();
    var labelBBox = label.getBoundingRect();
    var graphicBBox = that._getGraphicBBox(label.pointPosition);
    var fullGraphicBBox = that._getGraphicBBox();
    var isInside = label.getLayoutOptions().position === 'inside';
    var offset = LABEL_OFFSET;
    if (that._isPointInVisibleArea(visibleArea, fullGraphicBBox)) {
      if (!that._options.rotated) {
        if (visibleArea.minX > coord.x) {
          coord.x = visibleArea.minX;
        }
        if (visibleArea.maxX < coord.x + labelBBox.width) {
          coord.x = visibleArea.maxX - labelBBox.width;
        }
        if (visibleArea.minY > coord.y) {
          coord.y = isInside ? visibleArea.minY : graphicBBox.y + graphicBBox.height + offset;
        }
        if (visibleArea.maxY < coord.y + labelBBox.height) {
          coord.y = isInside ? visibleArea.maxY - labelBBox.height : graphicBBox.y - labelBBox.height - offset;
        }
      } else {
        if (visibleArea.minX > coord.x) {
          coord.x = isInside ? visibleArea.minX : graphicBBox.x + graphicBBox.width + offset;
        }
        if (visibleArea.maxX < coord.x + labelBBox.width) {
          coord.x = isInside ? visibleArea.maxX - labelBBox.width : graphicBBox.x - offset - labelBBox.width;
        }
        if (visibleArea.minY > coord.y) {
          coord.y = visibleArea.minY;
        }
        if (visibleArea.maxY < coord.y + labelBBox.height) {
          coord.y = visibleArea.maxY - labelBBox.height;
        }
      }
    }
    return coord;
  },
  _addLabelAlignmentAndOffset: function _addLabelAlignmentAndOffset(label, coord) {
    var labelBBox = label.getBoundingRect();
    var labelOptions = label.getLayoutOptions();
    if (!this._options.rotated) {
      if (labelOptions.alignment === 'left') {
        coord.x += labelBBox.width / 2;
      } else if (labelOptions.alignment === 'right') {
        coord.x -= labelBBox.width / 2;
      }
    }
    coord.x += labelOptions.horizontalOffset;
    coord.y += labelOptions.verticalOffset;
    return coord;
  },
  _getLabelCoords: function _getLabelCoords(label) {
    return this._getLabelCoordOfPosition(label, this._getLabelPosition(label.pointPosition));
  },
  _getLabelCoordOfPosition: function _getLabelCoordOfPosition(label, position) {
    var that = this;
    var labelBBox = label.getBoundingRect();
    var graphicBBox = that._getGraphicBBox(label.pointPosition);
    var offset = LABEL_OFFSET;
    var centerY = graphicBBox.height / 2 - labelBBox.height / 2;
    var centerX = graphicBBox.width / 2 - labelBBox.width / 2;
    var x = graphicBBox.x;
    var y = graphicBBox.y;
    switch (position) {
      case 'left':
        x -= labelBBox.width + offset;
        y += centerY;
        break;
      case 'right':
        x += graphicBBox.width + offset;
        y += centerY;
        break;
      case 'top':
        x += centerX;
        y -= labelBBox.height + offset;
        break;
      case 'bottom':
        x += centerX;
        y += graphicBBox.height + offset;
        break;
      case 'inside':
        x += centerX;
        y += centerY;
        break;
    }
    return {
      x: x,
      y: y
    };
  },
  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {
    var that = this;
    var options = that._options;
    var translates = that._getTranslates(animationEnabled);
    var style = that._getStyle();
    that.graphic = that._createMarker(renderer, group, options.image, _extend({
      translateX: translates.x,
      translateY: translates.y,
      points: that._populatePointShape(options.symbol, style.r)
    }, style));
  },
  _getErrorBarSettings: function _getErrorBarSettings() {
    return {
      visibility: 'visible'
    };
  },
  _getErrorBarBaseEdgeLength() {
    return this.getPointRadius() * 2;
  },
  _drawErrorBar: function _drawErrorBar(renderer, group) {
    if (!this._options.errorBars) {
      return;
    }
    var that = this;
    var options = that._options;
    var errorBarOptions = options.errorBars;
    var points = [];
    var settings;
    var pos = that._errorBarPos;
    var high = that._highErrorCoord;
    var low = that._lowErrorCoord;
    var displayMode = (0, _utils.normalizeEnum)(errorBarOptions.displayMode);
    var isHighDisplayMode = displayMode === 'high';
    var isLowDisplayMode = displayMode === 'low';
    var highErrorOnly = (isHighDisplayMode || !(0, _type.isDefined)(low)) && (0, _type.isDefined)(high) && !isLowDisplayMode;
    var lowErrorOnly = (isLowDisplayMode || !(0, _type.isDefined)(high)) && (0, _type.isDefined)(low) && !isHighDisplayMode;
    var edgeLength = errorBarOptions.edgeLength;
    if (edgeLength <= 1 && edgeLength > 0) {
      edgeLength = this._getErrorBarBaseEdgeLength() * errorBarOptions.edgeLength;
    }
    edgeLength = _floor(parseInt(edgeLength) / 2);
    highErrorOnly && (low = that._baseErrorBarPos);
    lowErrorOnly && (high = that._baseErrorBarPos);
    if (displayMode !== 'none' && (0, _type.isDefined)(high) && (0, _type.isDefined)(low) && (0, _type.isDefined)(pos)) {
      !lowErrorOnly && points.push([pos - edgeLength, high, pos + edgeLength, high]);
      points.push([pos, high, pos, low]);
      !highErrorOnly && points.push([pos + edgeLength, low, pos - edgeLength, low]);
      options.rotated && (0, _iterator.each)(points, function (_, p) {
        p.reverse();
      });
      settings = that._getErrorBarSettings(errorBarOptions);
      if (!that._errorBar) {
        that._errorBar = renderer.path(points, 'line').attr(settings).append(group);
      } else {
        settings.points = points;
        that._errorBar.attr(settings);
      }
    } else {
      that._errorBar && that._errorBar.attr({
        visibility: 'hidden'
      });
    }
  },
  getTooltipParams: function getTooltipParams() {
    var that = this;
    var graphic = that.graphic;
    return {
      x: that.x,
      y: that.y,
      offset: graphic ? graphic.getBBox().height / 2 : 0
    };
  },
  setPercentValue: function setPercentValue(absTotal, total, leftHoleTotal, rightHoleTotal) {
    var that = this;
    var valuePercent = that.value / absTotal || 0;
    var minValuePercent = that.minValue / absTotal || 0;
    var percent = valuePercent - minValuePercent;
    that._label.setDataField('percent', percent);
    that._label.setDataField('total', total);
    if (that.series.isFullStackedSeries() && that.hasValue()) {
      if (that.leftHole) {
        that.leftHole /= absTotal - leftHoleTotal;
        that.minLeftHole /= absTotal - leftHoleTotal;
      }
      if (that.rightHole) {
        that.rightHole /= absTotal - rightHoleTotal;
        that.minRightHole /= absTotal - rightHoleTotal;
      }
      that.value = that.properValue = valuePercent;
      that.minValue = !minValuePercent ? that.minValue : minValuePercent;
    }
  },
  _storeTrackerR: function _storeTrackerR() {
    var that = this;
    var navigator = window.navigator;
    var r = that._options.styles.normal.r;
    var minTrackerSize = (0, _window.hasProperty)('ontouchstart') || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;
    that._options.trackerR = r < minTrackerSize ? minTrackerSize : r;
    return that._options.trackerR;
  },
  _translateErrorBars: function _translateErrorBars() {
    var that = this;
    var options = that._options;
    var rotated = options.rotated;
    var errorBars = options.errorBars;
    var translator = that._getValTranslator();
    if (!errorBars) {
      return;
    }
    (0, _type.isDefined)(that.lowError) && (that._lowErrorCoord = translator.translate(that.lowError));
    (0, _type.isDefined)(that.highError) && (that._highErrorCoord = translator.translate(that.highError));
    that._errorBarPos = _floor(rotated ? that.vy : that.vx);
    that._baseErrorBarPos = errorBars.type === 'stdDeviation' ? that._lowErrorCoord + (that._highErrorCoord - that._lowErrorCoord) / 2 : rotated ? that.vx : that.vy;
  },
  _translate: function _translate() {
    var that = this;
    var valTranslator = that._getValTranslator();
    var argTranslator = that._getArgTranslator();
    if (that._options.rotated) {
      that.vx = that.x = valTranslator.translate(that.value);
      that.vy = that.y = argTranslator.translate(that.argument);
      that.minX = valTranslator.translate(that.minValue);
      that.defaultX = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    } else {
      that.vy = that.y = valTranslator.translate(that.value);
      that.vx = that.x = argTranslator.translate(that.argument);
      that.minY = valTranslator.translate(that.minValue);
      that.defaultY = valTranslator.translate(CANVAS_POSITION_DEFAULT);
    }
    that._translateErrorBars();
    that._calculateVisibility(that.x, that.y);
  },
  _updateData: function _updateData(data) {
    var that = this;
    that.value = that.properValue = that.initialValue = that.originalValue = data.value;
    that.minValue = that.initialMinValue = that.originalMinValue = (0, _type.isDefined)(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT;
  },
  _getImageSettings: function _getImageSettings(image) {
    return {
      href: image.url || image.toString(),
      width: image.width || DEFAULT_IMAGE_WIDTH,
      height: image.height || DEFAULT_IMAGE_HEIGHT
    };
  },
  getCrosshairData: function getCrosshairData() {
    var that = this;
    var r = that._options.rotated;
    var value = that.properValue;
    var argument = that.argument;
    return {
      x: that.vx,
      y: that.vy,
      xValue: r ? value : argument,
      yValue: r ? argument : value,
      axis: that.series.axis
    };
  },
  getPointRadius: function getPointRadius() {
    var style = this._getStyle();
    var options = this._options;
    var r = style.r;
    var extraSpace;
    var symbol = options.symbol;
    var isSquare = symbol === 'square';
    var isTriangle = symbol === 'triangle' || symbol === 'triangleDown' || symbol === 'triangleUp';
    if (options.visible && !options.image && r) {
      extraSpace = style['stroke-width'] / 2;
      return (isSquare || isTriangle ? 1.4 * r : r) + extraSpace;
    }
    return 0;
  },
  _updateMarker: function _updateMarker(animationEnabled, style) {
    var that = this;
    var options = that._options;
    var settings;
    var image = options.image;
    var visibility = !that.isVisible() ? {
      visibility: 'hidden'
    } : {};
    if (that._checkImage(image)) {
      settings = _extend({}, {
        visibility: style.visibility
      }, visibility, that._getImageSettings(image));
    } else {
      settings = _extend({}, style, visibility, {
        points: that._populatePointShape(options.symbol, style.r)
      });
    }
    if (!animationEnabled) {
      settings.translateX = that.x;
      settings.translateY = that.y;
    }
    that.graphic.attr(settings).sharp();
  },
  _getLabelFormatObject: function _getLabelFormatObject() {
    var that = this;
    return {
      argument: that.initialArgument,
      value: that.initialValue,
      originalArgument: that.originalArgument,
      originalValue: that.originalValue,
      seriesName: that.series.name,
      lowErrorValue: that.lowError,
      highErrorValue: that.highError,
      point: that
    };
  },
  _getLabelPosition: function _getLabelPosition() {
    var rotated = this._options.rotated;
    if (this.initialValue > 0) {
      return rotated ? 'right' : 'top';
    } else {
      return rotated ? 'left' : 'bottom';
    }
  },
  _getFormatObject: function _getFormatObject(tooltip) {
    var that = this;
    var labelFormatObject = that._label.getData();
    return _extend({}, labelFormatObject, {
      argumentText: tooltip.formatValue(that.initialArgument, 'argument'),
      valueText: tooltip.formatValue(that.initialValue)
    }, (0, _type.isDefined)(labelFormatObject.percent) ? {
      percentText: tooltip.formatValue(labelFormatObject.percent, 'percent')
    } : {}, (0, _type.isDefined)(labelFormatObject.total) ? {
      totalText: tooltip.formatValue(labelFormatObject.total)
    } : {});
  },
  getMarkerVisibility: function getMarkerVisibility() {
    return this._options.visible;
  },
  coordsIn: function coordsIn(x, y) {
    var trackerRadius = this._storeTrackerR();
    return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius;
  },
  getMinValue: function getMinValue(noErrorBar) {
    var errorBarOptions = this._options.errorBars;
    if (errorBarOptions && !noErrorBar) {
      var displayMode = errorBarOptions.displayMode;
      var lowValue = displayMode !== 'high' && (0, _type.isDefined)(this.lowError) ? this.lowError : this.value;
      var highValue = displayMode !== 'low' && (0, _type.isDefined)(this.highError) ? this.highError : this.value;
      return lowValue < highValue ? lowValue : highValue;
    } else {
      return this.value;
    }
  },
  getMaxValue: function getMaxValue(noErrorBar) {
    var errorBarOptions = this._options.errorBars;
    if (errorBarOptions && !noErrorBar) {
      var displayMode = errorBarOptions.displayMode;
      var lowValue = displayMode !== 'high' && (0, _type.isDefined)(this.lowError) ? this.lowError : this.value;
      var highValue = displayMode !== 'low' && (0, _type.isDefined)(this.highError) ? this.highError : this.value;
      return lowValue > highValue ? lowValue : highValue;
    } else {
      return this.value;
    }
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57402:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.chart = void 0;
var _extend2 = __webpack_require__(13306);
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
var _scatter_series = __webpack_require__(21667);
var _bar_series = __webpack_require__(58821);
var _area_series = __webpack_require__(90048);
// there are rangebar, rangearea

var _extend = _extend2.extend;
var barSeries = _bar_series.chart.bar;
var areaSeries = _area_series.chart.area;
var chart = {};
exports.chart = chart;
var baseRangeSeries = {
  areErrorBarsVisible: _common.noop,
  _createErrorBarGroup: _common.noop,
  _checkData: function _checkData(data, skippedFields) {
    var valueFields = this.getValueFields();
    return _scatter_series.chart._checkData.call(this, data, skippedFields, {
      minValue: valueFields[0],
      value: valueFields[1]
    }) && data.minValue === data.minValue;
  },
  getValueRangeInitialValue: _scatter_series.chart.getValueRangeInitialValue,
  _getPointDataSelector: function _getPointDataSelector(data) {
    var _this = this;
    var valueFields = this.getValueFields();
    var val1Field = valueFields[0];
    var val2Field = valueFields[1];
    var tagField = this.getTagField();
    var argumentField = this.getArgumentField();
    return function (data) {
      return {
        tag: data[tagField],
        minValue: _this._processEmptyValue(data[val1Field]),
        value: _this._processEmptyValue(data[val2Field]),
        argument: data[argumentField],
        data: data
      };
    };
  },
  _defaultAggregator: 'range',
  _aggregators: {
    range(_ref, series) {
      var intervalStart = _ref.intervalStart,
        intervalEnd = _ref.intervalEnd,
        data = _ref.data;
      if (!data.length) {
        return;
      }
      var valueFields = series.getValueFields();
      var val1Field = valueFields[0];
      var val2Field = valueFields[1];
      var result = data.reduce(function (result, item) {
        var val1 = item[val1Field];
        var val2 = item[val2Field];
        if (!(0, _type.isDefined)(val1) || !(0, _type.isDefined)(val2)) {
          return result;
        }
        result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));
        result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));
        return result;
      }, {
        [val1Field]: Infinity,
        [val2Field]: -Infinity,
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      });
      if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {
        if (data.filter(function (i) {
          return i[val1Field] === null && i[val2Field] === null;
        }).length === data.length) {
          result[val1Field] = result[val2Field] = null;
        } else {
          return;
        }
      }
      return result;
    }
  },
  getValueFields: function getValueFields() {
    return [this._options.rangeValue1Field || 'val1', this._options.rangeValue2Field || 'val2'];
  },
  getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var rotated = this._options.rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = isOpposite ? 'vy' : 'vx';
    var minCoordName = rotated ? 'minX' : 'minY';
    var oppositeCoordName = isOpposite ? 'vx' : 'vy';
    var points = this.getPoints();
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = void 0;
      if (isArgument) {
        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : undefined;
      } else {
        var coords = [Math.min(p[coordName], p[minCoordName]), Math.max(p[coordName], p[minCoordName])];
        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p[oppositeCoordName] : undefined;
      }
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  }
};
chart['rangebar'] = _extend({}, barSeries, baseRangeSeries);
chart['rangearea'] = _extend({}, areaSeries, {
  _drawPoint: function _drawPoint(options) {
    var point = options.point;
    if (point.isInVisibleArea()) {
      point.clearVisibility();
      point.draw(this._renderer, options.groups);
      this._drawnPoints.push(point);
      if (!point.visibleTopMarker) {
        point.hideMarker('top');
      }
      if (!point.visibleBottomMarker) {
        point.hideMarker('bottom');
      }
    } else {
      point.setInvisibility();
    }
  },
  _prepareSegment: function _prepareSegment(points, rotated) {
    var processedPoints = this._processSinglePointsAreaSegment(points, rotated);
    var processedMinPointsCoords = (0, _utils.map)(processedPoints, function (pt) {
      return pt.getCoords(true);
    });
    return {
      line: processedPoints,
      bottomLine: processedMinPointsCoords,
      area: (0, _utils.map)(processedPoints, function (pt) {
        return pt.getCoords();
      }).concat(processedMinPointsCoords.slice().reverse()),
      singlePointSegment: processedPoints !== points
    };
  },
  _getDefaultSegment: function _getDefaultSegment(segment) {
    var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);
    defaultSegment.bottomLine = defaultSegment.line;
    return defaultSegment;
  },
  _removeElement: function _removeElement(element) {
    areaSeries._removeElement.call(this, element);
    element.bottomLine && element.bottomLine.remove();
  },
  _drawElement: function _drawElement(segment, group) {
    var that = this;
    var drawnElement = areaSeries._drawElement.call(that, segment, group);
    drawnElement.bottomLine = that._bordersGroup && that._createBorderElement(segment.bottomLine, {
      'stroke-width': that._styles.normal.border['stroke-width']
    }).append(that._bordersGroup);
    return drawnElement;
  },
  _applyStyle: function _applyStyle(style) {
    var that = this;
    var elementsGroup = that._elementsGroup;
    var bordersGroup = that._bordersGroup;
    elementsGroup && elementsGroup.smartAttr(style.elements);
    bordersGroup && bordersGroup.attr(style.border);
    (that._graphics || []).forEach(function (graphic) {
      graphic.line && graphic.line.attr({
        'stroke-width': style.border['stroke-width']
      });
      graphic.bottomLine && graphic.bottomLine.attr({
        'stroke-width': style.border['stroke-width']
      });
    });
  },
  _updateElement: function _updateElement(element, segment, animate, complete) {
    var bottomLineParams = {
      points: segment.bottomLine
    };
    var bottomBorderElement = element.bottomLine;
    areaSeries._updateElement.apply(this, arguments);
    if (bottomBorderElement) {
      animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams);
    }
  }
}, baseRangeSeries);

/***/ }),

/***/ 21667:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _range_data_calculator = _interopRequireDefault(__webpack_require__(63407));
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var math = Math;
var _abs = math.abs;
var _sqrt = math.sqrt;
var _max = math.max;
var DEFAULT_TRACKER_WIDTH = 12;
var DEFAULT_DURATION = 400;
var HIGH_ERROR = 'highError';
var LOW_ERROR = 'lowError';
var VARIANCE = 'variance';
var STANDARD_DEVIATION = 'stddeviation';
var STANDARD_ERROR = 'stderror';
var PERCENT = 'percent';
var FIXED = 'fixed';
var UNDEFINED = 'undefined';
var DISCRETE = 'discrete';
var LOGARITHMIC = 'logarithmic';
var DATETIME = 'datetime';
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
function sum(array) {
  var result = 0;
  (0, _iterator.each)(array, function (_, value) {
    result += value;
  });
  return result;
}
function isErrorBarTypeCorrect(type) {
  // TODO why UNDEFINED is here
  // return inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR, UNDEFINED]) !== -1;
  return [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR].includes(type);
}
function variance(array, expectedValue) {
  return sum((0, _utils.map)(array, function (value) {
    return (value - expectedValue) * (value - expectedValue);
  })) / array.length;
}
function calculateAvgErrorBars(result, data, series) {
  var errorBarsOptions = series.getOptions().valueErrorBar;
  var valueField = series.getValueFields()[0];
  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
  if (series.areErrorBarsVisible() && errorBarsOptions.type === undefined) {
    var fusionData = data.reduce(function (result, item) {
      if ((0, _type.isDefined)(item[lowValueField])) {
        result[0] += item[valueField] - item[lowValueField];
        result[1]++;
      }
      if ((0, _type.isDefined)(item[highValueField])) {
        result[2] += item[highValueField] - item[valueField];
        result[3]++;
      }
      return result;
    }, [0, 0, 0, 0]);
    if (fusionData[1]) {
      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];
    }
    if (fusionData[2]) {
      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];
    }
  }
  return result;
}
function calculateSumErrorBars(result, data, series) {
  var errorBarsOptions = series.getOptions().valueErrorBar;
  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
  if (series.areErrorBarsVisible() && errorBarsOptions.type === undefined) {
    result[lowValueField] = 0;
    result[highValueField] = 0;
    result = data.reduce(function (result, item) {
      result[lowValueField] += item[lowValueField];
      result[highValueField] += item[highValueField];
      return result;
    }, result);
  }
  return result;
}
function getMinMaxAggregator(compare) {
  return function (_ref, series) {
    var intervalStart = _ref.intervalStart,
      intervalEnd = _ref.intervalEnd,
      data = _ref.data;
    var valueField = series.getValueFields()[0];
    var targetData = data[0];
    targetData = data.reduce(function (result, item) {
      var value = item[valueField];
      if (result[valueField] === null) {
        result = item;
      }
      if (value !== null && compare(value, result[valueField])) {
        return item;
      }
      return result;
    }, targetData);
    return (0, _extend2.extend)({}, targetData, {
      [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
    });
  };
}
function checkFields(data, fieldsToCheck, skippedFields) {
  var allFieldsIsValid = true;
  for (var field in fieldsToCheck) {
    var isArgument = field === 'argument';
    if (isArgument || field === 'size' ? !(0, _type.isDefined)(data[field]) : data[field] === undefined) {
      var selector = fieldsToCheck[field];
      if (!isArgument) {
        skippedFields[selector] = (skippedFields[selector] || 0) + 1;
      }
      allFieldsIsValid = false;
    }
  }
  return allFieldsIsValid;
}
var baseScatterMethods = {
  _defaultDuration: DEFAULT_DURATION,
  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,
  _applyStyle: _common.noop,
  _updateOptions: _common.noop,
  _parseStyle: _common.noop,
  _prepareSegment: _common.noop,
  _drawSegment: _common.noop,
  _appendInGroup: function _appendInGroup() {
    this._group.append(this._extGroups.seriesGroup);
  },
  _createLegendState: function _createLegendState(styleOptions, defaultColor) {
    return {
      fill: (0, _utils.extractColor)(styleOptions.color, true) || defaultColor,
      hatching: styleOptions.hatching ? (0, _extend2.extend)({}, styleOptions.hatching, {
        direction: 'right'
      }) : undefined
    };
  },
  _getColorId: _common.noop,
  _applyElementsClipRect: function _applyElementsClipRect(settings) {
    settings['clip-path'] = this._paneClipRectID;
  },
  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {
    settings['clip-path'] = this._forceClipping ? this._paneClipRectID : null;
  },
  _createGroup: function _createGroup(groupName, parent, target, settings) {
    var group = parent[groupName] = parent[groupName] || this._renderer.g();
    target && group.append(target);
    settings && group.attr(settings);
  },
  _applyClearingSettings: function _applyClearingSettings(settings) {
    settings.opacity = null;
    settings.scale = null;
    if (this._options.rotated) {
      settings.translateX = null;
    } else {
      settings.translateY = null;
    }
  },
  _createGroups: function _createGroups() {
    var that = this;
    that._createGroup('_markersGroup', that, that._group);
    that._createGroup('_labelsGroup', that);
  },
  _setMarkerGroupSettings: function _setMarkerGroupSettings() {
    var that = this;
    var settings = that._createPointStyles(that._getMarkerGroupOptions()).normal;
    settings['class'] = 'dxc-markers';
    settings.opacity = 1; // T172577
    that._applyMarkerClipRect(settings);
    that._markersGroup.attr(settings);
  },
  getVisibleArea: function getVisibleArea() {
    return this._visibleArea;
  },
  areErrorBarsVisible: function areErrorBarsVisible() {
    var errorBarOptions = this._options.valueErrorBar;
    return errorBarOptions && this._errorBarsEnabled() && errorBarOptions.displayMode !== 'none' && (isErrorBarTypeCorrect((0, _utils.normalizeEnum)(errorBarOptions.type)) || (0, _type.isDefined)(errorBarOptions.lowValueField) || (0, _type.isDefined)(errorBarOptions.highValueField));
  },
  groupPointsByCoords(rotated) {
    var cat = [];
    (0, _iterator.each)(this.getVisiblePoints(), function (_, p) {
      var pointCoord = parseInt(rotated ? p.vy : p.vx);
      if (!cat[pointCoord]) {
        cat[pointCoord] = p;
      } else {
        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];
      }
    });
    return cat;
  },
  _createErrorBarGroup: function _createErrorBarGroup(animationEnabled) {
    var that = this;
    var errorBarOptions = that._options.valueErrorBar;
    var settings;
    if (that.areErrorBarsVisible()) {
      settings = {
        'class': 'dxc-error-bars',
        stroke: errorBarOptions.color,
        'stroke-width': errorBarOptions.lineWidth,
        opacity: animationEnabled ? 0.001 : errorBarOptions.opacity || 1,
        'stroke-linecap': 'square',
        sharp: true,
        'clip-path': that._forceClipping ? that._paneClipRectID : that._widePaneClipRectID
      };
      that._createGroup('_errorBarGroup', that, that._group, settings);
    }
  },
  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {
    var that = this;
    that._setMarkerGroupSettings();
    that._setLabelGroupSettings(animationEnabled);
    that._createErrorBarGroup(animationEnabled);
  },
  _getCreatingPointOptions: function _getCreatingPointOptions() {
    var that = this;
    var defaultPointOptions;
    var creatingPointOptions = that._predefinedPointOptions;
    var normalStyle;
    if (!creatingPointOptions) {
      defaultPointOptions = that._getPointOptions();
      that._predefinedPointOptions = creatingPointOptions = (0, _extend2.extend)(true, {
        styles: {}
      }, defaultPointOptions);
      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};
      creatingPointOptions.styles = creatingPointOptions.styles || {};
      creatingPointOptions.styles.normal = {
        'stroke-width': normalStyle['stroke-width'],
        r: normalStyle.r,
        opacity: normalStyle.opacity
      };
    }
    return creatingPointOptions;
  },
  _getPointOptions: function _getPointOptions() {
    return this._parsePointOptions(this._preparePointOptions(), this._options.label);
  },
  _getOptionsForPoint: function _getOptionsForPoint() {
    return this._options.point;
  },
  _parsePointStyle: function _parsePointStyle(style, defaultColor, defaultBorderColor, defaultSize) {
    var border = style.border || {};
    var sizeValue = style.size !== undefined ? style.size : defaultSize;
    return {
      fill: (0, _utils.extractColor)(style.color, true) || defaultColor,
      stroke: border.color || defaultBorderColor,
      'stroke-width': border.visible ? border.width : 0,
      r: sizeValue / 2 + (border.visible && sizeValue !== 0 ? ~~(border.width / 2) || 0 : 0)
    };
  },
  _createPointStyles: function _createPointStyles(pointOptions) {
    var that = this;
    var mainPointColor = (0, _utils.extractColor)(pointOptions.color, true) || that._options.mainSeriesColor;
    var containerColor = that._options.containerBackgroundColor;
    var normalStyle = that._parsePointStyle(pointOptions, mainPointColor, mainPointColor);
    normalStyle.visibility = pointOptions.visible ? 'visible' : 'hidden';
    return {
      labelColor: mainPointColor,
      normal: normalStyle,
      hover: that._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),
      selection: that._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)
    };
  },
  _checkData: function _checkData(data, skippedFields, fieldsToCheck) {
    fieldsToCheck = fieldsToCheck || {
      value: this.getValueFields()[0]
    };
    fieldsToCheck.argument = this.getArgumentField();
    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;
  },
  getArgumentRangeInitialValue() {
    var points = this.getPoints();
    if (this.useAggregation() && points.length) {
      var _points$0$aggregation, _points$aggregationIn;
      return {
        min: (_points$0$aggregation = points[0].aggregationInfo) === null || _points$0$aggregation === void 0 ? void 0 : _points$0$aggregation.intervalStart,
        max: (_points$aggregationIn = points[points.length - 1].aggregationInfo) === null || _points$aggregationIn === void 0 ? void 0 : _points$aggregationIn.intervalEnd
      };
    }
    return undefined;
  },
  getValueRangeInitialValue: function getValueRangeInitialValue() {
    return undefined;
  },
  _getRangeData: function _getRangeData() {
    return _range_data_calculator.default.getRangeData(this);
  },
  _getPointDataSelector: function _getPointDataSelector() {
    var _this = this;
    var valueField = this.getValueFields()[0];
    var argumentField = this.getArgumentField();
    var tagField = this.getTagField();
    var areErrorBarsVisible = this.areErrorBarsVisible();
    var lowValueField;
    var highValueField;
    if (areErrorBarsVisible) {
      var errorBarOptions = this._options.valueErrorBar;
      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;
      highValueField = errorBarOptions.highValueField || HIGH_ERROR;
    }
    return function (data) {
      var pointData = {
        value: _this._processEmptyValue(data[valueField]),
        argument: data[argumentField],
        tag: data[tagField],
        data: data
      };
      if (areErrorBarsVisible) {
        pointData.lowError = data[lowValueField];
        pointData.highError = data[highValueField];
      }
      return pointData;
    };
  },
  _errorBarsEnabled: function _errorBarsEnabled() {
    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;
  },
  _drawPoint: function _drawPoint(options) {
    var point = options.point;
    if (point.isInVisibleArea()) {
      point.clearVisibility();
      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);
      this._drawnPoints.push(point);
    } else {
      point.setInvisibility();
    }
  },
  _animateComplete: function _animateComplete() {
    var that = this;
    var animationSettings = {
      duration: that._defaultDuration
    };
    that._labelsGroup && that._labelsGroup.animate({
      opacity: 1
    }, animationSettings);
    that._errorBarGroup && that._errorBarGroup.animate({
      opacity: that._options.valueErrorBar.opacity || 1
    }, animationSettings);
  },
  _animate: function _animate() {
    var that = this;
    var lastPointIndex = that._drawnPoints.length - 1;
    (0, _iterator.each)(that._drawnPoints || [], function (i, p) {
      p.animate(i === lastPointIndex ? function () {
        that._animateComplete();
      } : undefined, {
        translateX: p.x,
        translateY: p.y
      });
    });
  },
  _getIntervalCenter(intervalStart, intervalEnd) {
    var argAxis = this.getArgumentAxis();
    var axisOptions = argAxis.getOptions();
    if (argAxis.aggregatedPointBetweenTicks()) {
      return intervalStart;
    }
    return axisOptions.type !== 'discrete' ? argAxis.getVisualRangeCenter({
      minVisible: intervalStart,
      maxVisible: intervalEnd
    }, true) : intervalStart;
  },
  _defaultAggregator: 'avg',
  _aggregators: {
    avg(_ref2, series) {
      var data = _ref2.data,
        intervalStart = _ref2.intervalStart,
        intervalEnd = _ref2.intervalEnd;
      if (!data.length) {
        return;
      }
      var valueField = series.getValueFields()[0];
      var aggregationResult = data.reduce(function (result, item) {
        var value = item[valueField];
        if ((0, _type.isDefined)(value)) {
          result[0] += value;
          result[1]++;
        } else if (value === null) {
          result[2]++;
        }
        return result;
      }, [0, 0, 0]);
      return calculateAvgErrorBars({
        [valueField]: aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1],
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      }, data, series);
    },
    sum(_ref3, series) {
      var intervalStart = _ref3.intervalStart,
        intervalEnd = _ref3.intervalEnd,
        data = _ref3.data;
      if (!data.length) {
        return;
      }
      var valueField = series.getValueFields()[0];
      var aggregationResult = data.reduce(function (result, item) {
        var value = item[valueField];
        if (value !== undefined) {
          result[0] += value;
        }
        if (value === null) {
          result[1]++;
        } else if (value === undefined) {
          result[2]++;
        }
        return result;
      }, [0, 0, 0]);
      var value = aggregationResult[0];
      if (aggregationResult[1] === data.length) {
        value = null;
      }
      if (aggregationResult[2] === data.length) {
        return;
      }
      return calculateSumErrorBars({
        [valueField]: value,
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd)
      }, data, series);
    },
    count(_ref4, series) {
      var data = _ref4.data,
        intervalStart = _ref4.intervalStart,
        intervalEnd = _ref4.intervalEnd;
      var valueField = series.getValueFields()[0];
      return {
        [series.getArgumentField()]: series._getIntervalCenter(intervalStart, intervalEnd),
        [valueField]: data.filter(function (i) {
          return i[valueField] !== undefined;
        }).length
      };
    },
    min: getMinMaxAggregator(function (a, b) {
      return a < b;
    }),
    max: getMinMaxAggregator(function (a, b) {
      return a > b;
    })
  },
  _endUpdateData: function _endUpdateData() {
    delete this._predefinedPointOptions;
  },
  getArgumentField: function getArgumentField() {
    return this._options.argumentField || 'arg';
  },
  getValueFields: function getValueFields() {
    var options = this._options;
    var errorBarsOptions = options.valueErrorBar;
    var valueFields = [options.valueField || 'val'];
    var lowValueField;
    var highValueField;
    if (errorBarsOptions) {
      lowValueField = errorBarsOptions.lowValueField;
      highValueField = errorBarsOptions.highValueField;
      (0, _type.isString)(lowValueField) && valueFields.push(lowValueField);
      (0, _type.isString)(highValueField) && valueFields.push(highValueField);
    }
    return valueFields;
  },
  _calculateErrorBars: function _calculateErrorBars(data) {
    if (!this.areErrorBarsVisible()) {
      return;
    }
    var that = this;
    var options = that._options;
    var errorBarsOptions = options.valueErrorBar;
    var errorBarType = (0, _utils.normalizeEnum)(errorBarsOptions.type);
    var floatErrorValue = parseFloat(errorBarsOptions.value);
    var valueField = that.getValueFields()[0];
    var value;
    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;
    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;
    var valueArray;
    var valueArrayLength;
    var meanValue;
    var processDataItem;
    var addSubError = function addSubError(_i, item) {
      value = item.value;
      item.lowError = value - floatErrorValue;
      item.highError = value + floatErrorValue;
    };
    switch (errorBarType) {
      case FIXED:
        processDataItem = addSubError;
        break;
      case PERCENT:
        processDataItem = function processDataItem(_, item) {
          value = item.value;
          var error = value * floatErrorValue / 100;
          item.lowError = value - error;
          item.highError = value + error;
        };
        break;
      case UNDEFINED:
        // TODO: rework this
        processDataItem = function processDataItem(_, item) {
          item.lowError = item.data[lowValueField];
          item.highError = item.data[highValueField];
        };
        break;
      default:
        valueArray = (0, _utils.map)(data, function (item) {
          return (0, _type.isDefined)(item.data[valueField]) ? item.data[valueField] : null;
        });
        valueArrayLength = valueArray.length;
        floatErrorValue = floatErrorValue || 1;
        switch (errorBarType) {
          case VARIANCE:
            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;
            processDataItem = addSubError;
            break;
          case STANDARD_DEVIATION:
            meanValue = sum(valueArray) / valueArrayLength;
            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;
            processDataItem = function processDataItem(_, item) {
              item.lowError = meanValue - floatErrorValue;
              item.highError = meanValue + floatErrorValue;
            };
            break;
          case STANDARD_ERROR:
            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;
            processDataItem = addSubError;
            break;
        }
    }
    processDataItem && (0, _iterator.each)(data, processDataItem);
  },
  _patchMarginOptions: function _patchMarginOptions(options) {
    var pointOptions = this._getCreatingPointOptions();
    var styles = pointOptions.styles;
    var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {
      return _max(max, style.r * 2 + style['stroke-width']);
    }, 0);
    options.size = pointOptions.visible ? maxSize : 0;
    options.sizePointNormalState = pointOptions.visible ? styles.normal.r * 2 + styles.normal['stroke-width'] : 2;
    return options;
  },
  usePointsToDefineAutoHiding() {
    return true;
  }
};
exports.chart = chart = (0, _extend2.extend)({}, baseScatterMethods, {
  drawTrackers: function drawTrackers() {
    var that = this;
    var trackers;
    var trackersGroup;
    var segments = that._segments || [];
    var rotated = that._options.rotated;
    if (!that.isVisible()) {
      return;
    }
    if (segments.length) {
      trackers = that._trackers = that._trackers || [];
      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({
        fill: 'gray',
        opacity: 0.001,
        stroke: 'gray',
        'class': 'dxc-trackers'
      })).attr({
        'clip-path': this._paneClipRectID || null
      }).append(that._group);
      (0, _iterator.each)(segments, function (i, segment) {
        if (!trackers[i]) {
          trackers[i] = that._drawTrackerElement(segment).data({
            'chart-data-series': that
          }).append(trackersGroup);
        } else {
          that._updateTrackerElement(segment, trackers[i]);
        }
      });
    }
    that._trackersTranslator = that.groupPointsByCoords(rotated);
  },
  _checkAxisVisibleAreaCoord(isArgument, coord) {
    var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();
    var visibleArea = axis.getVisibleArea();
    return (0, _type.isDefined)(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;
  },
  checkSeriesViewportCoord(axis, coord) {
    return this.getPoints().length && this.isVisible();
  },
  getSeriesPairCoord(coord, isArgument) {
    var oppositeCoord = null;
    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;
    var coordName = !isOpposite ? 'vx' : 'vy';
    var oppositeCoordName = !isOpposite ? 'vy' : 'vx';
    var points = this.getVisiblePoints();
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : undefined;
      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {
        oppositeCoord = tmpCoord;
        break;
      }
    }
    return oppositeCoord;
  },
  _getNearestPoints(point, nextPoint) {
    return [point, nextPoint];
  },
  _getBezierPoints() {
    return [];
  },
  _getNearestPointsByCoord(coord, isArgument) {
    var that = this;
    var rotated = that.getOptions().rotated;
    var isOpposite = !isArgument && !rotated || isArgument && rotated;
    var coordName = isOpposite ? 'vy' : 'vx';
    var allPoints = that.getPoints();
    var bezierPoints = that._getBezierPoints();
    var nearestPoints = [];
    if (allPoints.length > 1) {
      allPoints.forEach(function (point, i) {
        var nextPoint = allPoints[i + 1];
        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {
          nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints));
        }
      });
    } else {
      nearestPoints.push([allPoints[0], allPoints[0]]);
    }
    return nearestPoints;
  },
  getNeighborPoint: function getNeighborPoint(x, y) {
    var pCoord = this._options.rotated ? y : x;
    var nCoord = pCoord;
    var cat = this._trackersTranslator;
    var point = null;
    var minDistance;
    var oppositeCoord = this._options.rotated ? x : y;
    var oppositeCoordName = this._options.rotated ? 'vx' : 'vy';
    if (this.isVisible() && cat) {
      point = cat[pCoord];
      do {
        point = cat[nCoord] || cat[pCoord];
        pCoord--;
        nCoord++;
      } while ((pCoord >= 0 || nCoord < cat.length) && !point);
      if (Array.isArray(point)) {
        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);
        (0, _iterator.each)(point, function (i, p) {
          var distance = _abs(p[oppositeCoordName] - oppositeCoord);
          if (minDistance >= distance) {
            minDistance = distance;
            point = p;
          }
        });
      }
    }
    return point;
  },
  _applyVisibleArea: function _applyVisibleArea() {
    var that = this;
    var rotated = that._options.rotated;
    var visibleX = (rotated ? that.getValueAxis() : that.getArgumentAxis()).getVisibleArea();
    var visibleY = (rotated ? that.getArgumentAxis() : that.getValueAxis()).getVisibleArea();
    that._visibleArea = {
      minX: visibleX[0],
      maxX: visibleX[1],
      minY: visibleY[0],
      maxY: visibleY[1]
    };
  },
  getPointCenterByArg(arg) {
    var point = this.getPointsByArg(arg)[0];
    return point ? point.getCenterCoord() : undefined;
  }
});
exports.polar = polar = (0, _extend2.extend)({}, baseScatterMethods, {
  drawTrackers: function drawTrackers() {
    chart.drawTrackers.call(this);
    var cat = this._trackersTranslator;
    var index;
    if (!this.isVisible()) {
      return;
    }
    (0, _iterator.each)(cat, function (i, category) {
      if (category) {
        index = i;
        return false;
      }
    });
    cat[index + 360] = cat[index];
  },
  getNeighborPoint: function getNeighborPoint(x, y) {
    var pos = (0, _utils.convertXYToPolar)(this.getValueAxis().getCenter(), x, y);
    return chart.getNeighborPoint.call(this, pos.phi, pos.r);
  },
  _applyVisibleArea: function _applyVisibleArea() {
    var that = this;
    var canvas = that.getValueAxis().getCanvas();
    that._visibleArea = {
      minX: canvas.left,
      maxX: canvas.width - canvas.right,
      minY: canvas.top,
      maxY: canvas.height - canvas.bottom
    };
  },
  getSeriesPairCoord(params, isArgument) {
    var coords = null;
    var paramName = isArgument ? 'argument' : 'radius';
    var points = this.getVisiblePoints();
    for (var i = 0; i < points.length; i++) {
      var p = points[i];
      var tmpPoint = (0, _type.isDefined)(p[paramName]) && (0, _type.isDefined)(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {
        x: p.x,
        y: p.y
      } : undefined;
      if ((0, _type.isDefined)(tmpPoint)) {
        coords = tmpPoint;
        break;
      }
    }
    return coords;
  }
});

/***/ }),

/***/ 92057:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.polar = exports.chart = void 0;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _area_series = __webpack_require__(90048);
var _bar_series = __webpack_require__(58821);
var _line_series = __webpack_require__(7222);
var _utils = __webpack_require__(19157);
var _object = __webpack_require__(48013);
// there stackedline, fullstackedline, stackedbar, fullstackedbar, stackedarea, fullstackedarea

var chartAreaSeries = _area_series.chart.area;
var chartBarSeries = _bar_series.chart.bar;
var baseStackedSeries = {
  _calculateErrorBars: _common.noop,
  _updateOptions: function _updateOptions(options) {
    this._stackName = 'axis_' + (options.axis || 'default');
  }
};
var chart = {};
exports.chart = chart;
var polar = {};
exports.polar = polar;
chart['stackedline'] = (0, _extend2.extend)({}, _line_series.chart.line, baseStackedSeries, {});
chart['stackedspline'] = (0, _extend2.extend)({}, _line_series.chart['spline'], baseStackedSeries, {});
chart['fullstackedline'] = (0, _extend2.extend)({}, _line_series.chart.line, baseStackedSeries, {
  getValueRangeInitialValue: _area_series.chart.area.getValueRangeInitialValue
});
chart['fullstackedspline'] = (0, _extend2.extend)({}, _line_series.chart['spline'], baseStackedSeries, {
  getValueRangeInitialValue: _area_series.chart.area.getValueRangeInitialValue
});
var stackedBar = chart['stackedbar'] = (0, _extend2.extend)({}, chartBarSeries, baseStackedSeries, {
  _updateOptions: function _updateOptions(options) {
    baseStackedSeries._updateOptions.call(this, options);
    this._stackName = this._stackName + '_stack_' + (options.stack || 'default');
  }
});
chart['fullstackedbar'] = (0, _extend2.extend)({}, chartBarSeries, baseStackedSeries, {
  _updateOptions: stackedBar._updateOptions
});
function clonePoint(point, value, minValue, position) {
  point = (0, _object.clone)(point);
  point.value = value;
  point.minValue = minValue;
  point.translate();
  point.argument = point.argument + position;
  return point;
}
function preparePointsForStackedAreaSegment(points) {
  var i = 0;
  var p;
  var result = [];
  var array;
  var len = points.length;
  while (i < len) {
    p = points[i];
    array = [p];
    if (p.leftHole) {
      array = [clonePoint(p, p.leftHole, p.minLeftHole, 'left'), p];
    }
    if (p.rightHole) {
      array.push(clonePoint(p, p.rightHole, p.minRightHole, 'right'));
    }
    result.push(array);
    i++;
  }
  return [].concat.apply([], result);
}
chart['stackedarea'] = (0, _extend2.extend)({}, chartAreaSeries, baseStackedSeries, {
  _prepareSegment: function _prepareSegment(points, rotated) {
    return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points), rotated);
  },
  _appendInGroup: function _appendInGroup() {
    this._group.append(this._extGroups.seriesGroup).toBackground();
  }
});
function getPointsByArgFromPrevSeries(prevSeries, argument) {
  var result;
  while (!result && prevSeries) {
    result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument]; // T357324
    prevSeries = prevSeries._prevSeries;
  }
  return result;
}
chart['stackedsplinearea'] = (0, _extend2.extend)({}, _area_series.chart['splinearea'], baseStackedSeries, {
  _prepareSegment: function _prepareSegment(points, rotated) {
    var that = this;
    var areaSegment;
    points = preparePointsForStackedAreaSegment(points);
    if (!this._prevSeries || points.length === 1) {
      areaSegment = _area_series.chart['splinearea']._prepareSegment.call(this, points, rotated);
    } else {
      var forwardPoints = _line_series.chart.spline._calculateBezierPoints(points, rotated);
      var backwardPoints = (0, _utils.map)(points, function (p) {
        var point = p.getCoords(true);
        point.argument = p.argument;
        return point;
      });
      var prevSeriesForwardPoints = [];
      var pointByArg = {};
      var i = 0;
      var len = that._prevSeries._segments.length;
      while (i < len) {
        prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);
        i++;
      }
      (0, _iterator.each)(prevSeriesForwardPoints, function (_, p) {
        if (p.argument !== null) {
          var argument = p.argument.valueOf();
          if (!pointByArg[argument]) {
            pointByArg[argument] = [p];
          } else {
            pointByArg[argument].push(p);
          }
        }
      });
      that._prevSeries._segmentByArg = pointByArg;
      backwardPoints = _line_series.chart.spline._calculateBezierPoints(backwardPoints, rotated);
      (0, _iterator.each)(backwardPoints, function (i, p) {
        var argument = p.argument.valueOf();
        var prevSeriesPoints;
        if (i % 3 === 0) {
          prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);
          if (prevSeriesPoints) {
            backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);
            backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p);
          }
        }
      });
      areaSegment = {
        line: forwardPoints,
        area: forwardPoints.concat(backwardPoints.reverse())
      };
      that._areaPointsToSplineAreaPoints(areaSegment.area);
    }
    return areaSegment;
  },
  _appendInGroup: chart['stackedarea']._appendInGroup
});
chart['fullstackedarea'] = (0, _extend2.extend)({}, chartAreaSeries, baseStackedSeries, {
  _prepareSegment: chart['stackedarea']._prepareSegment,
  _appendInGroup: chart['stackedarea']._appendInGroup
});
chart['fullstackedsplinearea'] = (0, _extend2.extend)({}, _area_series.chart['splinearea'], baseStackedSeries, {
  _prepareSegment: chart['stackedsplinearea']._prepareSegment,
  _appendInGroup: chart['stackedarea']._appendInGroup
});
polar['stackedbar'] = (0, _extend2.extend)({}, _bar_series.polar.bar, baseStackedSeries, {});

/***/ }),

/***/ 43759:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _sparkline = _interopRequireDefault(__webpack_require__(51876));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _sparkline.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 55628:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _type = __webpack_require__(35922);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _extend2 = __webpack_require__(13306);
var _index = __webpack_require__(39611);
var _pointer = _interopRequireDefault(__webpack_require__(93786));
var _utils = __webpack_require__(19157);
var _renderer = _interopRequireDefault(__webpack_require__(68374));
var _translator2d = __webpack_require__(87276);
var _common = __webpack_require__(20576);
var _tooltip = __webpack_require__(14371);
var _export = __webpack_require__(82454);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DEFAULT_LINE_SPACING = 2;
var TOOLTIP_TABLE_BORDER_SPACING = 0;
var TOOLTIP_TABLE_KEY_VALUE_SPACE = 15;
var EVENT_NS = 'sparkline-tooltip';
var POINTER_ACTION = (0, _index.addNamespace)([_pointer.default.down, _pointer.default.move], EVENT_NS);
var _extend = _extend2.extend;
var _floor = Math.floor;
function inCanvas(_ref, x, y) {
  var width = _ref.width,
    height = _ref.height;
  return (0, _utils.pointInCanvas)({
    left: 0,
    top: 0,
    right: width,
    bottom: height,
    width,
    height
  }, x, y);
}
function pointerHandler(_ref2) {
  var data = _ref2.data;
  var that = data.widget;
  that._enableOutHandler();
  that._showTooltip();
}
function getDefaultTemplate(_ref3, textAlign) {
  var lineSpacing = _ref3.lineSpacing,
    size = _ref3.size;
  var lineHeight = "".concat((lineSpacing !== null && lineSpacing !== void 0 ? lineSpacing : DEFAULT_LINE_SPACING) + size, "px");
  return function (_ref4, container) {
    var valueText = _ref4.valueText;
    var table = (0, _renderer.default)('<table>').css({
      borderSpacing: TOOLTIP_TABLE_BORDER_SPACING,
      lineHeight
    });
    for (var i = 0; i < valueText.length; i += 2) {
      var tr = (0, _renderer.default)('<tr>');
      (0, _renderer.default)('<td>').text(valueText[i]).appendTo(tr);
      (0, _renderer.default)('<td>').css({
        width: TOOLTIP_TABLE_KEY_VALUE_SPACE
      }).appendTo(tr);
      (0, _renderer.default)('<td>').css({
        textAlign
      }).text(valueText[i + 1]).appendTo(tr);
      table.append(tr);
    }
    container.append(table);
  };
}
function createAxis(isHorizontal) {
  var translator = new _translator2d.Translator2D({}, {}, {
    shiftZeroValue: !isHorizontal,
    isHorizontal: !!isHorizontal
  });
  return {
    getTranslator: function getTranslator() {
      return translator;
    },
    update: function update(range, canvas, options) {
      translator.update(range, canvas, options);
    },
    getVisibleArea() {
      var visibleArea = translator.getCanvasVisibleArea();
      return [visibleArea.min, visibleArea.max];
    },
    visualRange: _common.noop,
    calculateInterval: _common.noop,
    getMarginOptions() {
      return {};
    },
    aggregatedPointBetweenTicks() {
      return false;
    }
  };
}

/* eslint-disable-next-line */
var _initTooltip;
var BaseSparkline = _m_base_widget.default.inherit({
  _getLayoutItems: _common.noop,
  _useLinks: false,
  _themeDependentChanges: ['OPTIONS'],
  _initCore: function _initCore() {
    var that = this;
    that._tooltipTracker = that._renderer.root;
    that._tooltipTracker.attr({
      'pointer-events': 'visible'
    });
    that._createHtmlElements();
    that._initTooltipEvents();
    that._argumentAxis = createAxis(true);
    that._valueAxis = createAxis();
  },
  _getDefaultSize: function _getDefaultSize() {
    return this._defaultSize;
  },
  _disposeCore: function _disposeCore() {
    this._disposeWidgetElements();
    this._disposeTooltipEvents();
    this._ranges = null;
  },
  _optionChangesOrder: ['OPTIONS'],
  _change_OPTIONS: function _change_OPTIONS() {
    this._prepareOptions();
    this._change(['UPDATE']);
  },
  _customChangesOrder: ['UPDATE'],
  _change_UPDATE: function _change_UPDATE() {
    this._update();
  },
  _update: function _update() {
    var that = this;
    if (that._tooltipShown) {
      that._tooltipShown = false;
      that._tooltip.hide();
    }
    that._cleanWidgetElements();
    that._updateWidgetElements();
    that._drawWidgetElements();
  },
  _updateWidgetElements: function _updateWidgetElements() {
    var canvas = this._getCorrectCanvas();
    this._updateRange();
    this._argumentAxis.update(this._ranges.arg, canvas, this._getStick());
    this._valueAxis.update(this._ranges.val, canvas);
  },
  _getStick: function _getStick() {},
  _applySize: function _applySize(rect) {
    this._allOptions.size = {
      width: rect[2] - rect[0],
      height: rect[3] - rect[1]
    };
    this._change(['UPDATE']);
  },
  _setupResizeHandler: _common.noop,
  _prepareOptions: function _prepareOptions() {
    return _extend(true, {}, this._themeManager.theme(), this.option());
  },
  _getTooltipCoords: function _getTooltipCoords() {
    var canvas = this._canvas;
    var rootOffset = this._renderer.getRootOffset();
    return {
      x: canvas.width / 2 + rootOffset.left,
      y: canvas.height / 2 + rootOffset.top
    };
  },
  _initTooltipEvents() {
    var data = {
      widget: this
    };
    this._renderer.root.off('.' + EVENT_NS).on(POINTER_ACTION, data, pointerHandler);
  },
  _showTooltip() {
    var that = this;
    var tooltip;
    if (!that._tooltipShown) {
      that._tooltipShown = true;
      tooltip = that._getTooltip();
      tooltip.isEnabled() && that._tooltip.show(that._getTooltipData(), that._getTooltipCoords(), {});
    }
  },
  _hideTooltip() {
    if (this._tooltipShown) {
      this._tooltipShown = false;
      this._tooltip.hide();
    }
  },
  _stopCurrentHandling() {
    this._hideTooltip();
  },
  _enableOutHandler() {
    var that = this;
    if (that._outHandler) {
      return;
    }
    var handler = function handler(_ref5) {
      var pageX = _ref5.pageX,
        pageY = _ref5.pageY;
      var _that$_renderer$getRo = that._renderer.getRootOffset(),
        left = _that$_renderer$getRo.left,
        top = _that$_renderer$getRo.top;
      var x = _floor(pageX - left);
      var y = _floor(pageY - top);
      if (!inCanvas(that._canvas, x, y)) {
        that._hideTooltip();
        that._disableOutHandler();
      }
    };
    _events_engine.default.on(_dom_adapter.default.getDocument(), POINTER_ACTION, handler);
    this._outHandler = handler;
  },
  _disableOutHandler() {
    this._outHandler && _events_engine.default.off(_dom_adapter.default.getDocument(), POINTER_ACTION, this._outHandler);
    this._outHandler = null;
  },
  _disposeTooltipEvents: function _disposeTooltipEvents() {
    this._tooltipTracker.off();
    this._disableOutHandler();
    this._renderer.root.off('.' + EVENT_NS);
  },
  _getTooltip: function _getTooltip() {
    var that = this;
    if (!that._tooltip) {
      _initTooltip.apply(this, arguments);
      that._setTooltipRendererOptions(that._tooltipRendererOptions);
      that._tooltipRendererOptions = null;
      that._setTooltipOptions();
    }
    return that._tooltip;
  }
});
var _default = BaseSparkline; // PLUGINS_SECTION
exports["default"] = _default;
BaseSparkline.addPlugin(_tooltip.plugin);

// These are sparklines specifics on using tooltip - they cannot be omitted because of tooltip laziness.
_initTooltip = BaseSparkline.prototype._initTooltip;
BaseSparkline.prototype._initTooltip = _common.noop;
var _disposeTooltip = BaseSparkline.prototype._disposeTooltip;
BaseSparkline.prototype._disposeTooltip = function () {
  if (this._tooltip) {
    _disposeTooltip.apply(this, arguments);
  }
};
BaseSparkline.prototype._setTooltipRendererOptions = function () {
  var options = this._getRendererOptions();
  if (this._tooltip) {
    this._tooltip.setRendererOptions(options);
  } else {
    this._tooltipRendererOptions = options;
  }
};
BaseSparkline.prototype._setTooltipOptions = function () {
  if (this._tooltip) {
    var options = this._getOption('tooltip');
    var defaultContentTemplate = this._getDefaultTooltipTemplate(options);
    var contentTemplateOptions = defaultContentTemplate ? {
      contentTemplate: defaultContentTemplate
    } : {};
    var optionsToUpdate = _extend(contentTemplateOptions, options, {
      enabled: options.enabled && this._isTooltipEnabled()
    });
    this._tooltip.update(optionsToUpdate);
  }
};
BaseSparkline.prototype._getDefaultTooltipTemplate = function (options) {
  var defaultTemplateNeeded = true;
  var textAlign = this.option('rtlEnabled') ? 'left' : 'right';
  if ((0, _type.isFunction)(options.customizeTooltip)) {
    var _options$customizeToo;
    this._tooltip.update(options);
    var formatObject = this._getTooltipData();
    var customizeResult = (_options$customizeToo = options.customizeTooltip.call(formatObject, formatObject)) !== null && _options$customizeToo !== void 0 ? _options$customizeToo : {};
    defaultTemplateNeeded = !('html' in customizeResult) && !('text' in customizeResult);
  }
  return defaultTemplateNeeded && getDefaultTemplate(options.font, textAlign);
};

// PLUGINS_SECTION
// T422022
var exportPlugin = (0, _extend2.extend)(true, {}, _export.plugin, {
  init: _common.noop,
  dispose: _common.noop,
  customize: null,
  members: {
    _getExportMenuOptions: null
  }
});
BaseSparkline.addPlugin(exportPlugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 59989:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _iterator = __webpack_require__(95479);
var _base_sparkline = _interopRequireDefault(__webpack_require__(55628));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var TARGET_MIN_Y = 0.02;
var TARGET_MAX_Y = 0.98;
var BAR_VALUE_MIN_Y = 0.1;
var BAR_VALUE_MAX_Y = 0.9;
var DEFAULT_CANVAS_WIDTH = 300;
var DEFAULT_CANVAS_HEIGHT = 30;
var DEFAULT_HORIZONTAL_MARGIN = 1;
var DEFAULT_VERTICAL_MARGIN = 2;
var _Number = Number;
var _isFinite = isFinite;
var dxBullet = _base_sparkline.default.inherit({
  _rootClassPrefix: 'dxb',
  _rootClass: 'dxb-bullet',
  _themeSection: 'bullet',
  _defaultSize: {
    width: DEFAULT_CANVAS_WIDTH,
    height: DEFAULT_CANVAS_HEIGHT,
    left: DEFAULT_HORIZONTAL_MARGIN,
    right: DEFAULT_HORIZONTAL_MARGIN,
    top: DEFAULT_VERTICAL_MARGIN,
    bottom: DEFAULT_VERTICAL_MARGIN
  },
  _disposeWidgetElements: function _disposeWidgetElements() {
    delete this._zeroLevelPath;
    delete this._targetPath;
    delete this._barValuePath;
  },
  _cleanWidgetElements: function _cleanWidgetElements() {
    this._zeroLevelPath.remove();
    this._targetPath.remove();
    this._barValuePath.remove();
  },
  _drawWidgetElements: function _drawWidgetElements() {
    this._drawBullet();
    this._drawn();
  },
  _createHtmlElements: function _createHtmlElements() {
    var renderer = this._renderer;
    this._zeroLevelPath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-zero-level',
      'stroke-linecap': 'square'
    });
    this._targetPath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-target',
      'stroke-linecap': 'square'
    });
    this._barValuePath = renderer.path(undefined, 'line').attr({
      'class': 'dxb-bar-value',
      'stroke-linecap': 'square'
    });
  },
  _prepareOptions: function _prepareOptions() {
    var that = this;
    var options;
    var startScaleValue;
    var endScaleValue;
    var level;
    var value;
    var target;
    that._allOptions = options = that.callBase();
    var isValueUndefined = that._allOptions.value === undefined;
    var isTargetUndefined = that._allOptions.target === undefined;
    that._tooltipEnabled = !(isValueUndefined && isTargetUndefined);
    if (isValueUndefined) {
      that._allOptions.value = 0;
    }
    if (isTargetUndefined) {
      that._allOptions.target = 0;
    }
    options.value = value = _Number(options.value);
    options.target = target = _Number(options.target);
    if (that._allOptions.startScaleValue === undefined) {
      that._allOptions.startScaleValue = target < value ? target : value;
      that._allOptions.startScaleValue = that._allOptions.startScaleValue < 0 ? that._allOptions.startScaleValue : 0;
    }
    if (that._allOptions.endScaleValue === undefined) {
      that._allOptions.endScaleValue = target > value ? target : value;
    }
    options.startScaleValue = startScaleValue = _Number(options.startScaleValue);
    options.endScaleValue = endScaleValue = _Number(options.endScaleValue);
    if (endScaleValue < startScaleValue) {
      level = endScaleValue;
      that._allOptions.endScaleValue = startScaleValue;
      that._allOptions.startScaleValue = level;
      that._allOptions.inverted = true;
    }
  },
  _updateRange: function _updateRange() {
    var that = this;
    var options = that._allOptions;
    that._ranges = {
      arg: {
        invert: options.rtlEnabled ? !options.inverted : options.inverted,
        min: options.startScaleValue,
        max: options.endScaleValue,
        axisType: 'continuous',
        dataType: 'numeric'
      },
      val: {
        min: 0,
        max: 1,
        axisType: 'continuous',
        dataType: 'numeric'
      }
    };
  },
  _drawBullet: function _drawBullet() {
    var that = this;
    var options = that._allOptions;
    var isValidBounds = options.startScaleValue !== options.endScaleValue;
    var isValidMin = _isFinite(options.startScaleValue);
    var isValidMax = _isFinite(options.endScaleValue);
    var isValidValue = _isFinite(options.value);
    var isValidTarget = _isFinite(options.target);
    if (isValidBounds && isValidMax && isValidMin && isValidTarget && isValidValue) {
      this._drawBarValue();
      this._drawTarget();
      this._drawZeroLevel();
    }
  },
  _getTargetParams: function _getTargetParams() {
    var that = this;
    var options = that._allOptions;
    var translatorY = that._valueAxis.getTranslator();
    var x = that._argumentAxis.getTranslator().translate(options.target);
    return {
      points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
      stroke: options.targetColor,
      'stroke-width': options.targetWidth
    };
  },
  _getBarValueParams: function _getBarValueParams() {
    var that = this;
    var options = that._allOptions;
    var translatorX = that._argumentAxis.getTranslator();
    var translatorY = that._valueAxis.getTranslator();
    var startLevel = options.startScaleValue;
    var endLevel = options.endScaleValue;
    var value = options.value;
    var y2 = translatorY.translate(BAR_VALUE_MIN_Y);
    var y1 = translatorY.translate(BAR_VALUE_MAX_Y);
    var x1;
    var x2;
    if (value > 0) {
      x1 = startLevel <= 0 ? 0 : startLevel;
      x2 = value >= endLevel ? endLevel : value < x1 ? x1 : value;
    } else {
      x1 = endLevel >= 0 ? 0 : endLevel;
      x2 = value < startLevel ? startLevel : value > x1 ? x1 : value;
    }
    x1 = translatorX.translate(x1);
    x2 = translatorX.translate(x2);
    return {
      points: [x1, y1, x2, y1, x2, y2, x1, y2],
      fill: options.color
    };
  },
  _getCorrectCanvas: function _getCorrectCanvas() {
    return this._canvas;
  },
  _getZeroLevelParams: function _getZeroLevelParams() {
    var that = this;
    var translatorY = that._valueAxis.getTranslator();
    var x = that._argumentAxis.getTranslator().translate(0);
    return {
      points: [x, translatorY.translate(TARGET_MIN_Y), x, translatorY.translate(TARGET_MAX_Y)],
      stroke: that._allOptions.targetColor,
      'stroke-width': 1
    };
  },
  _drawZeroLevel: function _drawZeroLevel() {
    var that = this;
    var options = that._allOptions;
    if (0 > options.endScaleValue || 0 < options.startScaleValue || !options.showZeroLevel) {
      return;
    }
    that._zeroLevelPath.attr(that._getZeroLevelParams()).sharp().append(that._renderer.root);
  },
  _drawTarget: function _drawTarget() {
    var that = this;
    var options = that._allOptions;
    var target = options.target;
    if (target > options.endScaleValue || target < options.startScaleValue || !options.showTarget) {
      return;
    }
    that._targetPath.attr(that._getTargetParams()).sharp().append(that._renderer.root);
  },
  _drawBarValue: function _drawBarValue() {
    this._barValuePath.attr(this._getBarValueParams()).append(this._renderer.root);
  },
  _getTooltipCoords: function _getTooltipCoords() {
    var canvas = this._canvas;
    var rootOffset = this._renderer.getRootOffset();
    var bBox = this._barValuePath.getBBox();
    return {
      x: bBox.x + bBox.width / 2 + rootOffset.left,
      y: canvas.height / 2 + rootOffset.top
    };
  },
  _getTooltipData: function _getTooltipData() {
    var that = this;
    var tooltip = that._tooltip;
    var options = that._allOptions;
    var value = options.value;
    var target = options.target;
    var valueText = tooltip.formatValue(value);
    var targetText = tooltip.formatValue(target);
    return {
      originalValue: value,
      originalTarget: target,
      value: valueText,
      target: targetText,
      valueText: ['Actual Value:', valueText, 'Target Value:', targetText]
    };
  },
  _isTooltipEnabled: function _isTooltipEnabled() {
    return this._tooltipEnabled;
  }
});
(0, _iterator.each)(['color', 'targetColor', 'targetWidth', 'showTarget', 'showZeroLevel', 'value', 'target', 'startScaleValue', 'endScaleValue'], function (_, name) {
  dxBullet.prototype._optionChangesMap[name] = 'OPTIONS';
});
(0, _component_registrator.default)('dxBullet', dxBullet);
var _default = dxBullet;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 51876:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _base_sparkline = _interopRequireDefault(__webpack_require__(55628));
var _data_validator = __webpack_require__(45865);
var _base_series = __webpack_require__(54932);
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var MIN_BAR_WIDTH = 1;
var MAX_BAR_WIDTH = 50;
var DEFAULT_BAR_INTERVAL = 4;
var DEFAULT_CANVAS_WIDTH = 250;
var DEFAULT_CANVAS_HEIGHT = 30;
var DEFAULT_POINT_BORDER = 2;
var ALLOWED_TYPES = {
  'line': true,
  'spline': true,
  'stepline': true,
  'area': true,
  'steparea': true,
  'splinearea': true,
  'bar': true,
  'winloss': true
};
var _math = Math;
var _abs = _math.abs;
var _round = _math.round;
var _max = _math.max;
var _min = _math.min;
var _isFinite = isFinite;
var _Number = Number;
var _String = String;
function findMinMax(data, valField) {
  var firstItem = data[0] || {};
  var firstValue = firstItem[valField] || 0;
  var min = firstValue;
  var max = firstValue;
  var minIndexes = [0];
  var maxIndexes = [0];
  var dataLength = data.length;
  var value;
  var i;
  for (i = 1; i < dataLength; i++) {
    value = data[i][valField];
    if (value < min) {
      min = value;
      minIndexes = [i];
    } else if (value === min) {
      minIndexes.push(i);
    }
    if (value > max) {
      max = value;
      maxIndexes = [i];
    } else if (value === max) {
      maxIndexes.push(i);
    }
  }
  if (max === min) {
    minIndexes = maxIndexes = [];
  }
  return {
    minIndexes,
    maxIndexes
  };
}
function parseNumericDataSource(data, argField, valField, ignoreEmptyPoints) {
  return (0, _utils.map)(data, function (dataItem, index) {
    var item = null;
    var isDataNumber;
    var value;
    if (dataItem !== undefined) {
      item = {};
      isDataNumber = _isFinite(dataItem);
      item[argField] = isDataNumber ? _String(index) : dataItem[argField];
      value = isDataNumber ? dataItem : dataItem[valField];
      item[valField] = value === null ? ignoreEmptyPoints ? undefined : value : _Number(value);
      item = item[argField] !== undefined && item[valField] !== undefined ? item : null;
    }
    return item;
  });
}
function parseWinlossDataSource(data, argField, valField, target) {
  var lowBarValue = -1;
  var zeroBarValue = 0;
  var highBarValue = 1;
  var delta = 0.0001;
  return (0, _utils.map)(data, function (dataItem) {
    var item = {};
    item[argField] = dataItem[argField];
    if (_abs(dataItem[valField] - target) < delta) {
      item[valField] = zeroBarValue;
    } else if (dataItem[valField] > target) {
      item[valField] = highBarValue;
    } else {
      item[valField] = lowBarValue;
    }
    return item;
  });
}
function selectPointColor(color, options, index, pointIndexes) {
  if (index === pointIndexes.first || index === pointIndexes.last) {
    color = options.firstLastColor;
  }
  if ((pointIndexes.min || []).indexOf(index) >= 0) {
    color = options.minColor;
  }
  if ((pointIndexes.max || []).indexOf(index) >= 0) {
    color = options.maxColor;
  }
  return color;
}
function createLineCustomizeFunction(pointIndexes, options) {
  return function () {
    var color = selectPointColor(undefined, options, this.index, pointIndexes);
    return color ? {
      visible: true,
      border: {
        color: color
      }
    } : {};
  };
}
function createBarCustomizeFunction(pointIndexes, options, winlossData) {
  return function () {
    var index = this.index;
    var isWinloss = options.type === 'winloss';
    var target = isWinloss ? options.winlossThreshold : 0;
    var value = isWinloss ? winlossData[index][options.valueField] : this.value;
    var positiveColor = isWinloss ? options.winColor : options.barPositiveColor;
    var negativeColor = isWinloss ? options.lossColor : options.barNegativeColor;
    return {
      color: selectPointColor(value >= target ? positiveColor : negativeColor, options, index, pointIndexes)
    };
  };
}
var dxSparkline = _base_sparkline.default.inherit({
  _rootClassPrefix: 'dxsl',
  _rootClass: 'dxsl-sparkline',
  _themeSection: 'sparkline',
  _defaultSize: {
    width: DEFAULT_CANVAS_WIDTH,
    height: DEFAULT_CANVAS_HEIGHT
  },
  _initCore: function _initCore() {
    this.callBase();
    this._createSeries();
  },
  _initialChanges: ['DATA_SOURCE'],
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    this._requestChange(['UPDATE']);
  },
  _updateWidgetElements: function _updateWidgetElements() {
    this._updateSeries();
    this.callBase();
  },
  _disposeWidgetElements: function _disposeWidgetElements() {
    var that = this;
    that._series && that._series.dispose();
    that._series = that._seriesGroup = that._seriesLabelGroup = null;
  },
  _cleanWidgetElements: function _cleanWidgetElements() {
    this._seriesGroup.remove();
    this._seriesLabelGroup.remove();
    this._seriesGroup.clear();
    this._seriesLabelGroup.clear();
    this._series.removeGraphicElements();
    this._series.removePointElements();
    this._series.removeBordersGroup();
  },
  _drawWidgetElements: function _drawWidgetElements() {
    if (this._dataIsLoaded()) {
      this._drawSeries();
      this._drawn();
    }
  },
  _getCorrectCanvas: function _getCorrectCanvas() {
    var options = this._allOptions;
    var canvas = this._canvas;
    var halfPointSize = options.pointSize && Math.ceil(options.pointSize / 2) + DEFAULT_POINT_BORDER;
    var type = options.type;
    if (type !== 'bar' && type !== 'winloss' && (options.showFirstLast || options.showMinMax)) {
      return {
        width: canvas.width,
        height: canvas.height,
        left: canvas.left + halfPointSize,
        right: canvas.right + halfPointSize,
        top: canvas.top + halfPointSize,
        bottom: canvas.bottom + halfPointSize
      };
    }
    return canvas;
  },
  _prepareOptions: function _prepareOptions() {
    var that = this;
    that._allOptions = that.callBase();
    that._allOptions.type = (0, _utils.normalizeEnum)(that._allOptions.type);
    if (!ALLOWED_TYPES[that._allOptions.type]) {
      that._allOptions.type = 'line';
    }
  },
  _createHtmlElements: function _createHtmlElements() {
    this._seriesGroup = this._renderer.g().attr({
      'class': 'dxsl-series'
    });
    this._seriesLabelGroup = this._renderer.g().attr({
      'class': 'dxsl-series-labels'
    });
  },
  _createSeries: function _createSeries() {
    this._series = new _base_series.Series({
      renderer: this._renderer,
      seriesGroup: this._seriesGroup,
      labelsGroup: this._seriesLabelGroup,
      argumentAxis: this._argumentAxis,
      valueAxis: this._valueAxis,
      incidentOccurred: this._incidentOccurred
    }, {
      widgetType: 'chart',
      type: 'line'
    });
  },
  _updateSeries: function _updateSeries() {
    var that = this;
    var singleSeries = that._series;
    that._prepareDataSource();
    var seriesOptions = that._prepareSeriesOptions();
    singleSeries.updateOptions(seriesOptions);
    var groupsData = {
      groups: [{
        series: [singleSeries]
      }]
    };
    groupsData.argumentOptions = {
      type: seriesOptions.type === 'bar' ? 'discrete' : undefined
    };
    that._simpleDataSource = (0, _data_validator.validateData)(that._simpleDataSource, groupsData, that._incidentOccurred, {
      checkTypeForAllData: false,
      convertToAxisDataType: true,
      sortingMethod: true
    })[singleSeries.getArgumentField()];
    seriesOptions.customizePoint = that._getCustomizeFunction();
    singleSeries.updateData(that._simpleDataSource);
    singleSeries.createPoints();
    that._groupsDataCategories = groupsData.categories;
  },
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE'
  },
  _optionChangesOrder: ['DATA_SOURCE'],
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._updateDataSource();
  },
  _prepareDataSource: function _prepareDataSource() {
    var that = this;
    var options = that._allOptions;
    var argField = options.argumentField;
    var valField = options.valueField;
    var dataSource = that._dataSourceItems() || [];
    var data = parseNumericDataSource(dataSource, argField, valField, that.option('ignoreEmptyPoints'));
    if (options.type === 'winloss') {
      that._winlossDataSource = data;
      that._simpleDataSource = parseWinlossDataSource(data, argField, valField, options.winlossThreshold);
    } else {
      that._simpleDataSource = data;
    }
  },
  _prepareSeriesOptions: function _prepareSeriesOptions() {
    var that = this;
    var options = that._allOptions;
    var type = options.type === 'winloss' ? 'bar' : options.type;
    return {
      visible: true,
      argumentField: options.argumentField,
      valueField: options.valueField,
      color: options.lineColor,
      width: options.lineWidth,
      widgetType: 'chart',
      name: '',
      type: type,
      opacity: type.indexOf('area') !== -1 ? that._allOptions.areaOpacity : undefined,
      point: {
        size: options.pointSize,
        symbol: options.pointSymbol,
        border: {
          visible: true,
          width: DEFAULT_POINT_BORDER
        },
        color: options.pointColor,
        visible: false,
        hoverStyle: {
          border: {}
        },
        selectionStyle: {
          border: {}
        }
      },
      border: {
        color: options.lineColor,
        width: options.lineWidth,
        visible: type !== 'bar'
      }
    };
  },
  _getCustomizeFunction: function _getCustomizeFunction() {
    var that = this;
    var options = that._allOptions;
    var dataSource = that._winlossDataSource || that._simpleDataSource;
    var drawnPointIndexes = that._getExtremumPointsIndexes(dataSource);
    var customizeFunction;
    if (options.type === 'winloss' || options.type === 'bar') {
      customizeFunction = createBarCustomizeFunction(drawnPointIndexes, options, that._winlossDataSource);
    } else {
      customizeFunction = createLineCustomizeFunction(drawnPointIndexes, options);
    }
    return customizeFunction;
  },
  _getExtremumPointsIndexes: function _getExtremumPointsIndexes(data) {
    var that = this;
    var options = that._allOptions;
    var lastIndex = data.length - 1;
    var indexes = {};
    that._minMaxIndexes = findMinMax(data, options.valueField);
    if (options.showFirstLast) {
      indexes.first = 0;
      indexes.last = lastIndex;
    }
    if (options.showMinMax) {
      indexes.min = that._minMaxIndexes.minIndexes;
      indexes.max = that._minMaxIndexes.maxIndexes;
    }
    return indexes;
  },
  _getStick: function _getStick() {
    return {
      stick: this._series.type !== 'bar'
    };
  },
  _updateRange: function _updateRange() {
    var that = this;
    var series = that._series;
    var type = series.type;
    var isBarType = type === 'bar';
    var isWinlossType = type === 'winloss';
    var DEFAULT_VALUE_RANGE_MARGIN = 0.15;
    var DEFAULT_ARGUMENT_RANGE_MARGIN = 0.1;
    var WINLOSS_MAX_RANGE = 1;
    var WINLOSS_MIN_RANGE = -1;
    var rangeData = series.getRangeData();
    var minValue = that._allOptions.minValue;
    var hasMinY = (0, _type.isDefined)(minValue) && _isFinite(minValue);
    var maxValue = that._allOptions.maxValue;
    var hasMaxY = (0, _type.isDefined)(maxValue) && _isFinite(maxValue);
    var argCoef;
    var valCoef = (rangeData.val.max - rangeData.val.min) * DEFAULT_VALUE_RANGE_MARGIN;
    if (isBarType || isWinlossType || type === 'area') {
      if (rangeData.val.min !== 0) {
        rangeData.val.min -= valCoef;
      }
      if (rangeData.val.max !== 0) {
        rangeData.val.max += valCoef;
      }
    } else {
      rangeData.val.min -= valCoef;
      rangeData.val.max += valCoef;
    }
    if (hasMinY || hasMaxY) {
      if (hasMinY && hasMaxY) {
        rangeData.val.minVisible = _min(minValue, maxValue);
        rangeData.val.maxVisible = _max(minValue, maxValue);
      } else {
        rangeData.val.minVisible = hasMinY ? _Number(minValue) : undefined;
        rangeData.val.maxVisible = hasMaxY ? _Number(maxValue) : undefined;
      }
      if (isWinlossType) {
        rangeData.val.minVisible = hasMinY ? _max(rangeData.val.minVisible, WINLOSS_MIN_RANGE) : undefined;
        rangeData.val.maxVisible = hasMaxY ? _min(rangeData.val.maxVisible, WINLOSS_MAX_RANGE) : undefined;
      }
    }
    if (series.getPoints().length > 1) {
      if (isBarType) {
        argCoef = (rangeData.arg.max - rangeData.arg.min) * DEFAULT_ARGUMENT_RANGE_MARGIN;
        rangeData.arg.min = rangeData.arg.min - argCoef;
        rangeData.arg.max = rangeData.arg.max + argCoef;
      }
    }
    rangeData.arg.categories = that._groupsDataCategories;
    that._ranges = rangeData;
  },
  _getBarWidth: function _getBarWidth(pointsCount) {
    var that = this;
    var canvas = that._canvas;
    var intervalWidth = pointsCount * DEFAULT_BAR_INTERVAL;
    var rangeWidth = canvas.width - canvas.left - canvas.right - intervalWidth;
    var width = _round(rangeWidth / pointsCount);
    if (width < MIN_BAR_WIDTH) {
      width = MIN_BAR_WIDTH;
    }
    if (width > MAX_BAR_WIDTH) {
      width = MAX_BAR_WIDTH;
    }
    return width;
  },
  _correctPoints: function _correctPoints() {
    var that = this;
    var seriesType = that._allOptions.type;
    var seriesPoints = that._series.getPoints();
    var pointsLength = seriesPoints.length;
    var barWidth;
    var i;
    if (seriesType === 'bar' || seriesType === 'winloss') {
      barWidth = that._getBarWidth(pointsLength);
      for (i = 0; i < pointsLength; i++) {
        seriesPoints[i].correctCoordinates({
          width: barWidth,
          offset: 0
        });
      }
    }
  },
  _drawSeries: function _drawSeries() {
    var that = this;
    if (that._simpleDataSource.length > 0) {
      that._correctPoints();
      that._series.draw();
      that._seriesGroup.append(that._renderer.root);
    }
  },
  _isTooltipEnabled: function _isTooltipEnabled() {
    return !!this._simpleDataSource.length;
  },
  _getTooltipData: function _getTooltipData() {
    var that = this;
    var options = that._allOptions;
    var dataSource = that._winlossDataSource || that._simpleDataSource;
    var tooltip = that._tooltip;
    if (dataSource.length === 0) {
      return {};
    }
    var minMax = that._minMaxIndexes;
    var valueField = options.valueField;
    var first = dataSource[0][valueField];
    var last = dataSource[dataSource.length - 1][valueField];
    var min = (0, _type.isDefined)(minMax.minIndexes[0]) ? dataSource[minMax.minIndexes[0]][valueField] : first;
    var max = (0, _type.isDefined)(minMax.maxIndexes[0]) ? dataSource[minMax.maxIndexes[0]][valueField] : first;
    var formattedFirst = tooltip.formatValue(first);
    var formattedLast = tooltip.formatValue(last);
    var formattedMin = tooltip.formatValue(min);
    var formattedMax = tooltip.formatValue(max);
    var customizeObject = {
      firstValue: formattedFirst,
      lastValue: formattedLast,
      minValue: formattedMin,
      maxValue: formattedMax,
      originalFirstValue: first,
      originalLastValue: last,
      originalMinValue: min,
      originalMaxValue: max,
      valueText: ['Start:', formattedFirst, 'End:', formattedLast, 'Min:', formattedMin, 'Max:', formattedMax]
    };
    if (options.type === 'winloss') {
      customizeObject.originalThresholdValue = options.winlossThreshold;
      customizeObject.thresholdValue = tooltip.formatValue(options.winlossThreshold);
    }
    return customizeObject;
  }
});
(0, _utils.map)(['lineColor', 'lineWidth', 'areaOpacity', 'minColor', 'maxColor', 'barPositiveColor', 'barNegativeColor', 'winColor', 'lessColor', 'firstLastColor', 'pointSymbol', 'pointColor', 'pointSize', 'type', 'argumentField', 'valueField', 'winlossThreshold', 'showFirstLast', 'showMinMax', 'ignoreEmptyPoints', 'minValue', 'maxValue'], function (name) {
  dxSparkline.prototype._optionChangesMap[name] = 'OPTIONS';
});
(0, _component_registrator.default)('dxSparkline', dxSparkline);
var _default = dxSparkline; // PLUGINS_SECTION
exports["default"] = _default;
dxSparkline.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 86231:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addCacheItem = addCacheItem;
exports.currentTheme = currentTheme;
exports.getTheme = getTheme;
exports.refreshTheme = refreshTheme;
exports.registerTheme = registerTheme;
exports.registerThemeSchemeAlias = registerThemeSchemeAlias;
exports.removeCacheItem = removeCacheItem;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _utils = __webpack_require__(19157);
var _themes = __webpack_require__(75811);
var _type = __webpack_require__(35922);
var _generic = _interopRequireDefault(__webpack_require__(8839));
var _generic2 = _interopRequireDefault(__webpack_require__(39726));
var _generic3 = _interopRequireDefault(__webpack_require__(17374));
var _generic4 = _interopRequireDefault(__webpack_require__(14870));
var _generic5 = _interopRequireDefault(__webpack_require__(83313));
var _generic6 = _interopRequireDefault(__webpack_require__(25257));
var _generic7 = _interopRequireDefault(__webpack_require__(84253));
var _generic8 = _interopRequireDefault(__webpack_require__(60350));
var _material = _interopRequireDefault(__webpack_require__(11239));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var themes = {};
var themesMapping = {};
var themesSchemeMapping = {};
var _extend = _extend2.extend;
var _each = _iterator.each;
var currentThemeName = null;
var defaultTheme;
var nextCacheUid = 0;
var widgetsCache = {};
function getTheme(themeName) {
  var name = (0, _utils.normalizeEnum)(themeName);
  return themes[name] || themes[themesMapping[name] || currentTheme()];
}
function findThemeNameByName(name, scheme) {
  return themesMapping[name + '.' + scheme] || themesSchemeMapping[name + '.' + scheme] || themesMapping[name];
}
function findThemeNameByPlatform(platform, version, scheme) {
  return findThemeNameByName(platform + version, scheme) || findThemeNameByName(platform, scheme);
}
function currentTheme(themeName, colorScheme) {
  if (!arguments.length) {
    return currentThemeName || findThemeNameByName((0, _themes.current)()) || defaultTheme;
  }
  var scheme = (0, _utils.normalizeEnum)(colorScheme);
  currentThemeName = (themeName && themeName.platform ? findThemeNameByPlatform((0, _utils.normalizeEnum)(themeName.platform), themeName.version, scheme) : findThemeNameByName((0, _utils.normalizeEnum)(themeName), scheme)) || currentThemeName;
  // For chaining only
  return this;
}
function getThemeInfo(themeName, splitter) {
  var k = themeName.indexOf(splitter);
  return k > 0 ? {
    name: themeName.substring(0, k),
    scheme: themeName.substring(k + 1)
  } : null;
}
function registerThemeName(themeName, targetThemeName) {
  var themeInfo = getThemeInfo(themeName, '.') || {
    name: themeName
  };
  var name = themeInfo.name;
  var scheme = themeInfo.scheme;
  if (scheme) {
    themesMapping[name] = themesMapping[name] || targetThemeName;
    themesMapping[name + '.' + scheme] = targetThemeName;
  } else {
    themesMapping[name] = targetThemeName;
  }
}
function registerTheme(theme, baseThemeName) {
  var themeName = (0, _utils.normalizeEnum)(theme && theme.name);
  if (themeName) {
    theme.isDefault && (defaultTheme = themeName);
    registerThemeName(themeName, themeName);
    themes[themeName] = _extend(true, {}, getTheme(baseThemeName), patchTheme(theme));
  }
}
function registerThemeSchemeAlias(from, to) {
  themesSchemeMapping[from] = to;
}
function mergeScalar(target, field, source, sourceValue) {
  var _value = source ? source[field] : sourceValue;
  if (_value !== undefined && target[field] === undefined) {
    target[field] = _value;
  }
}
function mergeObject(target, field, source, sourceValue) {
  var _value = source ? source[field] : sourceValue;
  if (_value !== undefined) {
    target[field] = _extend(true, {}, _value, target[field]);
  }
}

// TODO: Font initialization should be done here
function patchTheme(theme) {
  theme = _extend(true, {
    loadingIndicator: {
      font: {}
    },
    'export': {
      font: {}
    },
    legend: {
      font: {},
      border: {}
    },
    title: {
      font: {}
    },
    tooltip: {
      font: {}
    },
    'chart:common': {},
    'chart:common:axis': {
      grid: {},
      minorGrid: {},
      tick: {},
      minorTick: {},
      title: {
        font: {}
      },
      label: {
        font: {}
      }
    },
    'chart:common:annotation': {
      font: {},
      border: {}
    },
    chart: {
      commonSeriesSettings: {
        candlestick: {}
      }
    },
    pie: {},
    polar: {},
    gauge: {
      scale: {
        tick: {},
        minorTick: {},
        label: {
          font: {}
        }
      }
    },
    barGauge: {},
    funnel: {},
    sankey: {},
    map: {
      background: {}
    },
    treeMap: {
      tile: {
        selectionStyle: {
          border: {}
        }
      },
      group: {
        border: {},
        selectionStyle: {
          border: {}
        },
        label: {
          font: {}
        }
      }
    },
    rangeSelector: {
      scale: {
        tick: {},
        minorTick: {},
        label: {
          font: {}
        }
      },
      chart: {}
    },
    sparkline: {},
    bullet: {}
  }, theme);
  mergeScalar(theme.loadingIndicator, 'backgroundColor', theme);
  mergeScalar(theme.chart.commonSeriesSettings.candlestick, 'innerColor', null, theme.backgroundColor);
  mergeScalar(theme.map.background, 'color', null, theme.backgroundColor);
  mergeScalar(theme.title.font, 'color', null, theme.primaryTitleColor);
  mergeObject(theme.title, 'subtitle', null, theme.title);
  mergeScalar(theme.legend.font, 'color', null, theme.secondaryTitleColor);
  mergeScalar(theme.legend.border, 'color', null, theme.gridColor);
  patchAxes(theme);
  _each(['chart', 'pie', 'polar', 'gauge', 'barGauge', 'map', 'treeMap', 'funnel', 'rangeSelector', 'sparkline', 'bullet', 'sankey'], function (_, section) {
    mergeScalar(theme[section], 'redrawOnResize', theme);
    mergeScalar(theme[section], 'containerBackgroundColor', null, theme.backgroundColor);
    mergeObject(theme[section], 'tooltip', theme);
    mergeObject(theme[section], 'export', theme);
  });
  _each(['chart', 'pie', 'polar', 'gauge', 'barGauge', 'map', 'treeMap', 'funnel', 'rangeSelector', 'sankey'], function (_, section) {
    mergeObject(theme[section], 'loadingIndicator', theme);
    mergeObject(theme[section], 'legend', theme);
    mergeObject(theme[section], 'title', theme);
  });
  _each(['chart', 'pie', 'polar'], function (_, section) {
    mergeObject(theme, section, null, theme['chart:common']);
  });
  _each(['chart', 'polar'], function (_, section) {
    theme[section] = theme[section] || {};
    mergeObject(theme[section], 'commonAxisSettings', null, theme['chart:common:axis']);
  });
  _each(['chart', 'polar', 'map', 'pie'], function (_, section) {
    theme[section] = theme[section] || {};
    mergeObject(theme[section], 'commonAnnotationSettings', null, theme['chart:common:annotation']);
  });
  mergeObject(theme.rangeSelector.chart, 'commonSeriesSettings', theme.chart);
  mergeObject(theme.rangeSelector.chart, 'dataPrepareSettings', theme.chart);
  mergeScalar(theme.treeMap.group.border, 'color', null, theme.gridColor);
  mergeScalar(theme.treeMap.tile.selectionStyle.border, 'color', null, theme.primaryTitleColor);
  mergeScalar(theme.treeMap.group.selectionStyle.border, 'color', null, theme.primaryTitleColor);
  mergeScalar(theme.map.legend, 'backgroundColor', theme);
  patchMapLayers(theme);
  return theme;
}
function patchAxes(theme) {
  var commonAxisSettings = theme['chart:common:axis'];
  var colorFieldName = 'color';
  _each([commonAxisSettings.grid, commonAxisSettings.minorGrid], function (_, obj) {
    mergeScalar(obj, colorFieldName, null, theme.gridColor);
  });
  _each([commonAxisSettings, commonAxisSettings.tick, commonAxisSettings.minorTick, commonAxisSettings.label.font], function (_, obj) {
    mergeScalar(obj, colorFieldName, null, theme.axisColor);
  });
  mergeScalar(commonAxisSettings.title.font, colorFieldName, null, theme.secondaryTitleColor);
  mergeScalar(theme.gauge.scale.label.font, colorFieldName, null, theme.axisColor);
  mergeScalar(theme.gauge.scale.tick, colorFieldName, null, theme.backgroundColor);
  mergeScalar(theme.gauge.scale.minorTick, colorFieldName, null, theme.backgroundColor);
  mergeScalar(theme.rangeSelector.scale.label.font, colorFieldName, null, theme.axisColor);
}
function patchMapLayers(theme) {
  var map = theme.map;
  _each(['area', 'line', 'marker'], function (_, section) {
    mergeObject(map, 'layer:' + section, null, map.layer);
  });
  _each(['dot', 'bubble', 'pie', 'image'], function (_, section) {
    mergeObject(map, 'layer:marker:' + section, null, map['layer:marker']);
  });
}
function addCacheItem(target) {
  var cacheUid = ++nextCacheUid;
  target._cache = cacheUid;
  widgetsCache[cacheUid] = target;
}
function removeCacheItem(target) {
  delete widgetsCache[target._cache];
}
function refreshTheme() {
  _each(widgetsCache, function () {
    this.refresh();
  });
  // For chaining only
  return this;
}

// register themes
if ((0, _type.isEmptyObject)(themes) && (0, _type.isEmptyObject)(themesMapping) && !defaultTheme) {
  [].concat(_generic.default, _generic2.default, _generic3.default, _generic4.default, _generic5.default, _generic6.default, _generic7.default, _generic8.default, _material.default).forEach(function (t) {
    registerTheme(t.theme, t.baseThemeName);
  });
}

/***/ }),

/***/ 46163:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
var round = Math.round;
function getValue(value) {
  return value;
}
var _default = {
  translate: function translate(category, directionOffset) {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var categoryIndex = that._categoriesToPoints[category === null || category === void 0 ? void 0 : category.valueOf()];
    var specialValue = that.translateSpecialCase(category);
    var startPointIndex = canvasOptions.startPointIndex || 0;
    var stickInterval = that._options.stick ? 0 : 0.5;
    if ((0, _type.isDefined)(specialValue)) {
      return round(specialValue);
    }

    // Q522516
    if (!categoryIndex && categoryIndex !== 0) {
      return null;
    }
    directionOffset = directionOffset || 0;
    var stickDelta = categoryIndex + stickInterval - startPointIndex + directionOffset * 0.5;
    return round(that._calculateProjection(canvasOptions.interval * stickDelta));
  },
  getInterval: function getInterval() {
    return this._canvasOptions.interval;
  },
  getEventScale: function getEventScale(zoomEvent) {
    var scale = zoomEvent.deltaScale || 1;
    return 1 - (1 - scale) / (0.75 + this.visibleCategories.length / this._categories.length);
  },
  zoom: function zoom(translate, scale) {
    var that = this;
    var categories = that._categories;
    var canvasOptions = that._canvasOptions;
    var stick = that._options.stick;
    var invert = canvasOptions.invert;
    var interval = canvasOptions.interval * scale;
    var translateCategories = translate / interval;
    var visibleCount = (that.visibleCategories || []).length;
    var startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + 0.5);
    var categoriesLength = parseInt((0, _math.adjust)(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;
    var endCategoryIndex;
    if (invert) {
      startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + 0.5) - categoriesLength;
    }
    if (startCategoryIndex < 0) {
      startCategoryIndex = 0;
    }
    endCategoryIndex = startCategoryIndex + categoriesLength;
    if (endCategoryIndex > categories.length) {
      endCategoryIndex = categories.length;
      startCategoryIndex = endCategoryIndex - categoriesLength;
      if (startCategoryIndex < 0) {
        startCategoryIndex = 0;
      }
    }
    var newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));
    var newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);
    scale = newInterval / canvasOptions.interval;
    translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));
    return {
      min: newVisibleCategories[0],
      max: newVisibleCategories[newVisibleCategories.length - 1],
      translate: translate,
      scale: scale
    };
  },
  getMinScale: function getMinScale(zoom) {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var categoriesLength = (that.visibleCategories || that._categories).length;
    categoriesLength += (parseInt(categoriesLength * 0.1) || 1) * (zoom ? -2 : 2);
    return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval);
  },
  getScale: function getScale(min, max) {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var visibleArea = that.getCanvasVisibleArea();
    var stickOffset = !that._options.stick && 1;
    var minPoint = (0, _type.isDefined)(min) ? that.translate(min, -stickOffset) : null;
    var maxPoint = (0, _type.isDefined)(max) ? that.translate(max, +stickOffset) : null;
    if (minPoint === null) {
      minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min;
    }
    if (maxPoint === null) {
      maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max;
    }
    return that.canvasLength / Math.abs(maxPoint - minPoint);
  },
  // dxRangeSelector

  isValid: function isValid(value) {
    return (0, _type.isDefined)(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false;
  },
  getCorrectValue: getValue,
  to: function to(value, direction) {
    var canvasOptions = this._canvasOptions;
    var categoryIndex = this._categoriesToPoints[value === null || value === void 0 ? void 0 : value.valueOf()];
    var startPointIndex = canvasOptions.startPointIndex || 0;
    var stickDelta = categoryIndex + (this._options.stick ? 0 : 0.5) - startPointIndex + (this._businessRange.invert ? -1 : +1) * direction * 0.5;
    return round(this._calculateProjection(canvasOptions.interval * stickDelta));
  },
  from: function from(position) {
    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var canvasOptions = this._canvasOptions;
    var startPoint = canvasOptions.startPoint;
    var categories = this.visibleCategories || this._categories;
    var categoriesLength = categories.length;
    var stickInterval = this._options.stick ? 0.5 : 0;
    // It is strange - while "businessRange.invert" check is required in "to" here it is not.
    // Check that translator.from(translator.to(x, -1), -1) equals x.
    // And check that translator.untranslate(translator.translate(x, -1), -1) does not equal x - is it really supposed to be so?
    var result = round((position - startPoint) / canvasOptions.interval + stickInterval - 0.5 - /* (businessRange.invert ? -1 : +1) * */direction * 0.5);
    if (result >= categoriesLength) {
      result = categoriesLength - 1;
    }
    if (result < 0) {
      result = 0;
    }
    if (canvasOptions.invert) {
      result = categoriesLength - result - 1;
    }
    return categories[result];
  },
  _add: function _add() {
    return NaN;
  },
  toValue: getValue,
  isValueProlonged: true,
  getRangeByMinZoomValue(minZoom, visualRange) {
    var categories = this._categories;
    var minVisibleIndex = categories.indexOf(visualRange.minVisible);
    var maxVisibleIndex = categories.indexOf(visualRange.maxVisible);
    var startIndex = minVisibleIndex + minZoom - 1;
    var endIndex = maxVisibleIndex - minZoom + 1;
    if (categories[startIndex]) {
      return [visualRange.minVisible, categories[startIndex]];
    } else {
      return [categories[endIndex], visualRange.maxVisible];
    }
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 75480:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function parse(value) {
  return value !== null ? new Date(value) : value;
}
var _default = {
  fromValue: parse,
  toValue: parse,
  _add: _date.default.addDateInterval,
  convert: _date.default.dateToMilliseconds
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 93175:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _type = __webpack_require__(35922);
var _date = _interopRequireDefault(__webpack_require__(91198));
var _math = __webpack_require__(60810);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var floor = Math.floor;
var _default = {
  _intervalize: function _intervalize(value, interval) {
    if (!(0, _type.isDefined)(value)) {
      return undefined;
    }
    if (this._businessRange.dataType === 'datetime') {
      if ((0, _type.isNumeric)(value)) {
        value = new Date(value);
      } else {
        value = new Date(value.getTime());
      }
      value = _date.default.correctDateWithUnitBeginning(value, interval, null, this._options.firstDayOfWeek);
    } else {
      value = (0, _math.adjust)(floor((0, _math.adjust)(value / interval)) * interval, interval);
    }
    return value;
  },
  translate: function translate(bp, direction, interval) {
    var that = this;
    var specialValue = that.translateSpecialCase(bp);
    if ((0, _type.isDefined)(specialValue)) {
      return Math.round(specialValue);
    }
    interval = interval || that._options.interval;

    // TODO B253861
    if (!that.isValid(bp, interval)) {
      return null;
    }
    return that.to(bp, direction, interval);
  },
  getInterval: function getInterval() {
    return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)));
  },
  zoom: function zoom() {},
  getMinScale: function getMinScale() {},
  getScale: function getScale() {},
  _parse: function _parse(value) {
    return this._businessRange.dataType === 'datetime' ? new Date(value) : Number(value);
  },
  fromValue: function fromValue(value) {
    return this._parse(value);
  },
  toValue: function toValue(value) {
    return this._parse(value);
  },
  isValid: function isValid(value, interval) {
    var that = this;
    var co = that._canvasOptions;
    var rangeMin = co.rangeMin;
    var rangeMax = co.rangeMax;
    interval = interval || that._options.interval;
    if (value === null || isNaN(value)) {
      return false;
    }
    value = that._businessRange.dataType === 'datetime' && (0, _type.isNumeric)(value) ? new Date(value) : value;
    if (interval !== that._options.interval) {
      rangeMin = that._intervalize(rangeMin, interval);
      rangeMax = that._intervalize(rangeMax, interval);
    }
    if (value.valueOf() < rangeMin || value.valueOf() >= _date.default.addInterval(rangeMax, interval)) {
      return false;
    }
    return true;
  },
  to: function to(bp, direction, interval) {
    var that = this;
    interval = interval || that._options.interval;
    var v1 = that._intervalize(bp, interval);
    var v2 = _date.default.addInterval(v1, interval);
    var res = that._to(v1);
    var p2 = that._to(v2);
    if (!direction) {
      res = floor((res + p2) / 2);
    } else if (direction > 0) {
      res = p2;
    }
    return res;
  },
  _to: function _to(value) {
    var co = this._canvasOptions;
    var rMin = co.rangeMinVisible;
    var rMax = co.rangeMaxVisible;
    var offset = value - rMin;
    if (value < rMin) {
      offset = 0;
    } else if (value > rMax) {
      offset = _date.default.addInterval(rMax, this._options.interval) - rMin;
    }
    return this._conversionValue(this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange));
  },
  from: function from(position, direction) {
    var that = this;
    var origInterval = that._options.interval;
    var interval = origInterval;
    var co = that._canvasOptions;
    var rMin = co.rangeMinVisible;
    var rMax = co.rangeMaxVisible;
    var value;
    if (that._businessRange.dataType === 'datetime') {
      interval = _date.default.dateToMilliseconds(origInterval);
    }
    value = that._calculateUnProjection((position - that._canvasOptions.startPoint) / that._canvasOptions.ratioOfCanvasRange);
    value = that._intervalize(_date.default.addInterval(value, interval / 2, direction > 0), origInterval);
    if (value < rMin) {
      value = rMin;
    } else if (value > rMax) {
      value = rMax;
    }
    return value;
  },
  _add: function _add() {
    return NaN;
  },
  isValueProlonged: true
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 1804:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _default = {
  fromValue: function fromValue(value) {
    return value !== null ? (0, _utils.getLogExt)(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value;
  },
  toValue: function toValue(value) {
    return value !== null ? (0, _utils.raiseToExt)(value, this._canvasOptions.base, this._businessRange.allowNegatives, this._businessRange.linearThreshold) : value;
  },
  getMinBarSize: function getMinBarSize(minBarSize) {
    var visibleArea = this.getCanvasVisibleArea();
    var minValue = this.from(visibleArea.min + minBarSize);
    var canvasOptions = this._canvasOptions;
    var startValue = this.fromValue(this.from(visibleArea.min));
    var endValue = this.fromValue(minValue !== null && minValue !== void 0 ? minValue : this.from(visibleArea.max));
    var value = Math.abs(startValue - endValue);
    return Math.pow(canvasOptions.base, value);
  },
  checkMinBarSize: function checkMinBarSize(initialValue, minShownValue, stackValue) {
    var canvasOptions = this._canvasOptions;
    var prevValue = stackValue ? stackValue - initialValue : 0;
    var baseMethod = this.constructor.prototype.checkMinBarSize;
    var minBarSize;
    var updateValue;
    if ((0, _type.isDefined)(minShownValue) && prevValue > 0) {
      minBarSize = baseMethod(this.fromValue(stackValue / prevValue), this.fromValue(minShownValue) - canvasOptions.rangeMinVisible);
      updateValue = Math.pow(canvasOptions.base, this.fromValue(prevValue) + minBarSize) - prevValue;
    } else {
      updateValue = baseMethod(initialValue, minShownValue);
    }
    return updateValue;
  }
};
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 21177:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Range = void 0;
var _type = __webpack_require__(35922);
var _extend = __webpack_require__(13306);
var _utils = __webpack_require__(19157);
var _isDefined = _type.isDefined;
var _isDate = _type.isDate;
var _isFunction = _type.isFunction;
var minSelector = 'min';
var maxSelector = 'max';
var minVisibleSelector = 'minVisible';
var maxVisibleSelector = 'maxVisible';
var baseSelector = 'base';
var axisTypeSelector = 'axisType';
function otherLessThan(thisValue, otherValue) {
  return otherValue < thisValue;
}
function otherGreaterThan(thisValue, otherValue) {
  return otherValue > thisValue;
}
function compareAndReplace(thisValue, otherValue, setValue, compare) {
  var otherValueDefined = _isDefined(otherValue);
  if (_isDefined(thisValue)) {
    if (otherValueDefined && compare(thisValue, otherValue)) {
      setValue(otherValue);
    }
  } else if (otherValueDefined) {
    setValue(otherValue);
  }
}
var Range = function Range(range) {
  range && (0, _extend.extend)(this, range);
};
exports.Range = Range;
var _Range = Range;
_Range.prototype = {
  constructor: _Range,
  addRange: function addRange(otherRange) {
    var that = this;
    var categories = that.categories;
    var otherCategories = otherRange.categories;
    var isDiscrete = that[axisTypeSelector] === 'discrete';
    var compareAndReplaceByField = function compareAndReplaceByField(field, compare) {
      compareAndReplace(that[field], otherRange[field], function (value) {
        that[field] = value;
      }, compare);
    };
    var controlValuesByVisibleBounds = function controlValuesByVisibleBounds(valueField, visibleValueField, compare) {
      compareAndReplace(that[valueField], that[visibleValueField], function (value) {
        _isDefined(that[valueField]) && (that[valueField] = value);
      }, compare);
    };
    var checkField = function checkField(field) {
      that[field] = that[field] || otherRange[field];
    };
    checkField('invert');
    checkField('containsConstantLine');
    checkField(axisTypeSelector);
    checkField('dataType');
    checkField('isSpacedMargin');
    if (that[axisTypeSelector] === 'logarithmic') {
      checkField(baseSelector);
    } else {
      that[baseSelector] = undefined;
    }
    compareAndReplaceByField(minSelector, otherLessThan);
    compareAndReplaceByField(maxSelector, otherGreaterThan);
    if (isDiscrete) {
      checkField(minVisibleSelector);
      checkField(maxVisibleSelector);
    } else {
      compareAndReplaceByField(minVisibleSelector, otherLessThan);
      compareAndReplaceByField(maxVisibleSelector, otherGreaterThan);
    }
    compareAndReplaceByField('interval', otherLessThan);
    if (!isDiscrete) {
      controlValuesByVisibleBounds(minSelector, minVisibleSelector, otherLessThan);
      controlValuesByVisibleBounds(minSelector, maxVisibleSelector, otherLessThan);
      controlValuesByVisibleBounds(maxSelector, maxVisibleSelector, otherGreaterThan);
      controlValuesByVisibleBounds(maxSelector, minVisibleSelector, otherGreaterThan);
    }
    if (categories === undefined) {
      that.categories = otherCategories;
    } else {
      that.categories = otherCategories ? (0, _utils.unique)(categories.concat(otherCategories)) : categories;
    }
    if (that[axisTypeSelector] === 'logarithmic') {
      checkField('allowNegatives');
      compareAndReplaceByField('linearThreshold', otherLessThan);
    }
    return that;
  },
  isEmpty: function isEmpty() {
    return (!_isDefined(this[minSelector]) || !_isDefined(this[maxSelector])) && (!this.categories || this.categories.length === 0);
  },
  correctValueZeroLevel: function correctValueZeroLevel() {
    var that = this;
    if (_isDate(that[maxSelector]) || _isDate(that[minSelector])) {
      return that;
    }
    function setZeroLevel(min, max) {
      that[min] < 0 && that[max] < 0 && (that[max] = 0);
      that[min] > 0 && that[max] > 0 && (that[min] = 0);
    }
    setZeroLevel(minSelector, maxSelector);
    setZeroLevel(minVisibleSelector, maxVisibleSelector);
    return that;
  },
  sortCategories(sort) {
    if (sort === false || !this.categories) {
      return;
    }
    if (Array.isArray(sort)) {
      var sortValues = sort.map(function (item) {
        return item.valueOf();
      });
      var filteredSeriesCategories = this.categories.filter(function (item) {
        return sortValues.indexOf(item.valueOf()) === -1;
      });
      this.categories = sort.concat(filteredSeriesCategories);
    } else {
      var notAFunction = !_isFunction(sort);
      if (notAFunction && this.dataType !== 'string') {
        sort = function sort(a, b) {
          return a.valueOf() - b.valueOf();
        };
      } else if (notAFunction) {
        sort = false;
      }
      sort && this.categories.sort(sort);
    }
  }
};

/***/ }),

/***/ 17953:
/***/ (function(__unused_webpack_module, exports) {



exports.Translator1D = Translator1D;
var _Number = Number;
function Translator1D() {
  this.setDomain(arguments[0], arguments[1]).setCodomain(arguments[2], arguments[3]).setInverted(false);
}
Translator1D.prototype = {
  constructor: Translator1D,
  setDomain: function setDomain(domain1, domain2) {
    var that = this;
    that._domain1 = _Number(domain1);
    that._domain2 = _Number(domain2);
    that._domainDelta = that._domain2 - that._domain1;
    return that;
  },
  setCodomain: function setCodomain(codomain1, codomain2) {
    var that = this;
    that._codomain1 = _Number(codomain1);
    that._codomain2 = _Number(codomain2);
    that._codomainDelta = that._codomain2 - that._codomain1;
    return that;
  },
  setInverted(state) {
    this.inverted = state;
  },
  getDomain: function getDomain() {
    return [this._domain1, this._domain2];
  },
  getCodomain: function getCodomain() {
    return [this._codomain1, this._codomain2];
  },
  getDomainStart: function getDomainStart() {
    return this._domain1;
  },
  getDomainEnd: function getDomainEnd() {
    return this._domain2;
  },
  getCodomainStart: function getCodomainStart() {
    return this._codomain1;
  },
  getCodomainEnd: function getCodomainEnd() {
    return this._codomain2;
  },
  getDomainRange: function getDomainRange() {
    return this._domainDelta;
  },
  getCodomainRange: function getCodomainRange() {
    return this._codomainDelta;
  },
  translate: function translate(value) {
    var ratio = (_Number(value) - this._domain1) / this._domainDelta;
    this.inverted && (ratio = 1 - ratio);
    return 0 <= ratio && ratio <= 1 ? this._codomain1 + ratio * this._codomainDelta : NaN;
  },
  adjust: function adjust(value) {
    var ratio = (_Number(value) - this._domain1) / this._domainDelta;
    var result = NaN;
    if (ratio < 0) {
      result = this._domain1;
    } else if (ratio > 1) {
      result = this._domain2;
    } else if (0 <= ratio && ratio <= 1) {
      result = _Number(value);
    }
    return result;
  }
};

/***/ }),

/***/ 87276:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Translator2D = void 0;
var _extend = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _range = __webpack_require__(21177);
var _category_translator = _interopRequireDefault(__webpack_require__(46163));
var _interval_translator = _interopRequireDefault(__webpack_require__(93175));
var _datetime_translator = _interopRequireDefault(__webpack_require__(75480));
var _logarithmic_translator = _interopRequireDefault(__webpack_require__(1804));
var _utils = __webpack_require__(19157);
var _type = __webpack_require__(35922);
var _math = __webpack_require__(60810);
var _date = _interopRequireDefault(__webpack_require__(91198));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _abs = Math.abs;
var CANVAS_PROP = ['width', 'height', 'left', 'top', 'bottom', 'right'];
var dummyTranslator = {
  to(value) {
    var coord = this._canvasOptions.startPoint + (this._options.conversionValue ? value : Math.round(value));
    return coord > this._canvasOptions.endPoint ? this._canvasOptions.endPoint : coord;
  },
  from(value) {
    return value - this._canvasOptions.startPoint;
  }
};
var validateCanvas = function validateCanvas(canvas) {
  (0, _iterator.each)(CANVAS_PROP, function (_, prop) {
    canvas[prop] = parseInt(canvas[prop]) || 0;
  });
  return canvas;
};
var makeCategoriesToPoints = function makeCategoriesToPoints(categories) {
  var categoriesToPoints = {};
  categories.forEach(function (item, i) {
    categoriesToPoints[item.valueOf()] = i;
  });
  return categoriesToPoints;
};
var validateBusinessRange = function validateBusinessRange(businessRange) {
  if (!(businessRange instanceof _range.Range)) {
    businessRange = new _range.Range(businessRange);
  }
  function validate(valueSelector, baseValueSelector) {
    if (!(0, _type.isDefined)(businessRange[valueSelector]) && (0, _type.isDefined)(businessRange[baseValueSelector])) {
      businessRange[valueSelector] = businessRange[baseValueSelector];
    }
  }
  validate('minVisible', 'min');
  validate('maxVisible', 'max');
  return businessRange;
};
function prepareBreaks(breaks, range) {
  var transform = range.axisType === 'logarithmic' ? function (value) {
    return (0, _utils.getLogExt)(value, range.base);
  } : function (value) {
    return value;
  };
  var array = [];
  var br;
  var transformFrom;
  var transformTo;
  var i;
  var length = breaks.length;
  var sum = 0;
  for (i = 0; i < length; i++) {
    br = breaks[i];
    transformFrom = transform(br.from);
    transformTo = transform(br.to);
    sum += transformTo - transformFrom;
    array.push({
      trFrom: transformFrom,
      trTo: transformTo,
      from: br.from,
      to: br.to,
      length: sum,
      cumulativeWidth: br.cumulativeWidth
    });
  }
  return array;
}
function getCanvasBounds(range) {
  var min = range.min;
  var max = range.max;
  var minVisible = range.minVisible;
  var maxVisible = range.maxVisible;
  var isLogarithmic = range.axisType === 'logarithmic';
  if (isLogarithmic) {
    maxVisible = (0, _utils.getLogExt)(maxVisible, range.base, range.allowNegatives, range.linearThreshold);
    minVisible = (0, _utils.getLogExt)(minVisible, range.base, range.allowNegatives, range.linearThreshold);
    min = (0, _utils.getLogExt)(min, range.base, range.allowNegatives, range.linearThreshold);
    max = (0, _utils.getLogExt)(max, range.base, range.allowNegatives, range.linearThreshold);
  }
  return {
    base: range.base,
    rangeMin: min,
    rangeMax: max,
    rangeMinVisible: minVisible,
    rangeMaxVisible: maxVisible
  };
}
function getCheckingMethodsAboutBreaks(inverted) {
  return {
    isStartSide: !inverted ? function (pos, breaks, start, end) {
      return pos < breaks[0][start];
    } : function (pos, breaks, start, end) {
      return pos <= breaks[breaks.length - 1][end];
    },
    isEndSide: !inverted ? function (pos, breaks, start, end) {
      return pos >= breaks[breaks.length - 1][end];
    } : function (pos, breaks, start, end) {
      return pos > breaks[0][start];
    },
    isInBreak: !inverted ? function (pos, br, start, end) {
      return pos >= br[start] && pos < br[end];
    } : function (pos, br, start, end) {
      return pos > br[end] && pos <= br[start];
    },
    isBetweenBreaks: !inverted ? function (pos, br, prevBreak, start, end) {
      return pos < br[start] && pos >= prevBreak[end];
    } : function (pos, br, prevBreak, start, end) {
      return pos >= br[end] && pos < prevBreak[start];
    },
    getLength: !inverted ? function (br) {
      return br.length;
    } : function (br, lastBreak) {
      return lastBreak.length - br.length;
    },
    getBreaksSize: !inverted ? function (br) {
      return br.cumulativeWidth;
    } : function (br, lastBreak) {
      return lastBreak.cumulativeWidth - br.cumulativeWidth;
    }
  };
}
var _Translator2d = function _Translator2d(businessRange, canvas, options) {
  this.update(businessRange, canvas, options);
};
exports.Translator2D = _Translator2d;
_Translator2d.prototype = {
  constructor: _Translator2d,
  reinit: function reinit() {
    // TODO: parseInt canvas
    var that = this;
    var options = that._options;
    var range = that._businessRange;
    var categories = range.categories || [];
    var script = {};
    var canvasOptions = that._prepareCanvasOptions();
    var visibleCategories = (0, _utils.getCategoriesInfo)(categories, range.minVisible, range.maxVisible).categories;
    var categoriesLength = visibleCategories.length;
    if (range.isEmpty()) {
      script = dummyTranslator;
    } else {
      switch (range.axisType) {
        case 'logarithmic':
          script = _logarithmic_translator.default;
          break;
        case 'semidiscrete':
          script = _interval_translator.default;
          canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (_date.default.addInterval(canvasOptions.rangeMaxVisible, options.interval) - canvasOptions.rangeMinVisible);
          break;
        case 'discrete':
          script = _category_translator.default;
          that._categories = categories;
          canvasOptions.interval = that._getDiscreteInterval(options.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);
          that._categoriesToPoints = makeCategoriesToPoints(categories);
          if (categoriesLength) {
            canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0].valueOf()];
            that.visibleCategories = visibleCategories;
          }
          break;
        default:
          if (range.dataType === 'datetime') {
            script = _datetime_translator.default;
          }
      }
    }
    (that._oldMethods || []).forEach(function (methodName) {
      delete that[methodName];
    });
    that._oldMethods = Object.keys(script);
    (0, _extend.extend)(that, script);
    that._conversionValue = options.conversionValue ? function (value) {
      return value;
    } : function (value) {
      return Math.round(value);
    };
    that.sc = {};
    that._checkingMethodsAboutBreaks = [getCheckingMethodsAboutBreaks(false), getCheckingMethodsAboutBreaks(that.isInverted())];
    that._translateBreaks();
    that._calculateSpecialValues();
  },
  _translateBreaks: function _translateBreaks() {
    var breaks = this._breaks;
    var size = this._options.breaksSize;
    var i;
    var b;
    var end;
    var length;
    if (breaks === undefined) {
      return;
    }
    for (i = 0, length = breaks.length; i < length; i++) {
      b = breaks[i];
      end = this.translate(b.to);
      b.end = end;
      b.start = !b.gapSize ? !this.isInverted() ? end - size : end + size : end;
    }
  },
  _checkValueAboutBreaks: function _checkValueAboutBreaks(breaks, pos, start, end, methods) {
    var i;
    var length;
    var prop = {
      length: 0,
      breaksSize: undefined,
      inBreak: false
    };
    var br;
    var prevBreak;
    var lastBreak = breaks[breaks.length - 1];
    if (methods.isStartSide(pos, breaks, start, end)) {
      return prop;
    } else if (methods.isEndSide(pos, breaks, start, end)) {
      return {
        length: lastBreak.length,
        breaksSize: lastBreak.cumulativeWidth,
        inBreak: false
      };
    }
    for (i = 0, length = breaks.length; i < length; i++) {
      br = breaks[i];
      prevBreak = breaks[i - 1];
      if (methods.isInBreak(pos, br, start, end)) {
        prop.inBreak = true;
        prop.break = br;
        break;
      }
      if (prevBreak && methods.isBetweenBreaks(pos, br, prevBreak, start, end)) {
        prop = {
          length: methods.getLength(prevBreak, lastBreak),
          breaksSize: methods.getBreaksSize(prevBreak, lastBreak),
          inBreak: false
        };
        break;
      }
    }
    return prop;
  },
  isInverted: function isInverted() {
    return !(this._options.isHorizontal ^ this._businessRange.invert);
  },
  _getDiscreteInterval: function _getDiscreteInterval(categoriesLength, canvasOptions) {
    var correctedCategoriesCount = categoriesLength - (this._options.stick ? 1 : 0);
    return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength;
  },
  _prepareCanvasOptions() {
    var that = this;
    var businessRange = that._businessRange;
    var canvasOptions = that._canvasOptions = getCanvasBounds(businessRange);
    var canvas = that._canvas;
    var breaks = that._breaks;
    var length;
    canvasOptions.startPadding = canvas.startPadding || 0;
    canvasOptions.endPadding = canvas.endPadding || 0;
    if (that._options.isHorizontal) {
      canvasOptions.startPoint = canvas.left + canvasOptions.startPadding;
      length = canvas.width;
      canvasOptions.endPoint = canvas.width - canvas.right - canvasOptions.endPadding;
      canvasOptions.invert = businessRange.invert;
    } else {
      canvasOptions.startPoint = canvas.top + canvasOptions.startPadding;
      length = canvas.height;
      canvasOptions.endPoint = canvas.height - canvas.bottom - canvasOptions.endPadding;
      canvasOptions.invert = !businessRange.invert; // axis inverted because display drawn to bottom
    }

    that.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;
    canvasOptions.rangeDoubleError = Math.pow(10, (0, _utils.getPower)(canvasOptions.rangeMax - canvasOptions.rangeMin) - (0, _utils.getPower)(length) - 2); // B253861
    canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);
    if (breaks !== undefined) {
      canvasOptions.ratioOfCanvasRange = (canvasOptions.canvasLength - breaks[breaks.length - 1].cumulativeWidth) / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible - breaks[breaks.length - 1].length);
    }
    return canvasOptions;
  },
  updateCanvas: function updateCanvas(canvas) {
    this._canvas = validateCanvas(canvas);
    this.reinit();
  },
  updateBusinessRange: function updateBusinessRange(businessRange) {
    var that = this;
    var breaks = businessRange.breaks || [];
    that._userBreaks = businessRange.userBreaks || [];
    that._businessRange = validateBusinessRange(businessRange);
    that._breaks = breaks.length ? prepareBreaks(breaks, that._businessRange) : undefined;
    that.reinit();
  },
  update: function update(businessRange, canvas, options) {
    var that = this;
    that._options = (0, _extend.extend)(that._options || {}, options);
    that._canvas = validateCanvas(canvas);
    that.updateBusinessRange(businessRange);
  },
  getBusinessRange: function getBusinessRange() {
    return this._businessRange;
  },
  getEventScale: function getEventScale(zoomEvent) {
    return zoomEvent.deltaScale || 1;
  },
  getCanvasVisibleArea: function getCanvasVisibleArea() {
    return {
      min: this._canvasOptions.startPoint,
      max: this._canvasOptions.endPoint
    };
  },
  _calculateSpecialValues: function _calculateSpecialValues() {
    var that = this;
    var canvasOptions = that._canvasOptions;
    var startPoint = canvasOptions.startPoint - canvasOptions.startPadding;
    var endPoint = canvasOptions.endPoint + canvasOptions.endPadding;
    var range = that._businessRange;
    var minVisible = range.minVisible;
    var maxVisible = range.maxVisible;
    var canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;
    var canvas_position_default;
    if (minVisible < 0 && maxVisible > 0 && minVisible !== maxVisible) {
      canvas_position_default = that.translate(0, 1);
    }
    if (!(0, _type.isDefined)(canvas_position_default)) {
      var invert = range.invert ^ (minVisible < 0 && maxVisible <= 0);
      if (that._options.isHorizontal) {
        canvas_position_default = invert ? endPoint : startPoint;
      } else {
        canvas_position_default = invert ? startPoint : endPoint;
      }
    }
    that.sc = {
      'canvas_position_default': canvas_position_default,
      'canvas_position_left': startPoint,
      'canvas_position_top': startPoint,
      'canvas_position_center': canvas_position_center_middle,
      'canvas_position_middle': canvas_position_center_middle,
      'canvas_position_right': endPoint,
      'canvas_position_bottom': endPoint,
      'canvas_position_start': canvasOptions.invert ? endPoint : startPoint,
      'canvas_position_end': canvasOptions.invert ? startPoint : endPoint
    };
  },
  translateSpecialCase(value) {
    return this.sc[value];
  },
  _calculateProjection: function _calculateProjection(distance) {
    var canvasOptions = this._canvasOptions;
    return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance;
  },
  _calculateUnProjection: function _calculateUnProjection(distance) {
    var canvasOptions = this._canvasOptions;
    this._businessRange.dataType === 'datetime' && (distance = Math.round(distance));
    return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance;
  },
  getMinBarSize: function getMinBarSize(minBarSize) {
    var visibleArea = this.getCanvasVisibleArea();
    var minValue = this.from(visibleArea.min + minBarSize);
    return _abs(this.from(visibleArea.min) - (!(0, _type.isDefined)(minValue) ? this.from(visibleArea.max) : minValue));
  },
  checkMinBarSize: function checkMinBarSize(value, minShownValue) {
    return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value;
  },
  translate(bp, direction) {
    var specialValue = this.translateSpecialCase(bp);
    if ((0, _type.isDefined)(specialValue)) {
      return Math.round(specialValue);
    }
    if (isNaN(bp)) {
      return null;
    }
    return this.to(bp, direction);
  },
  getInterval: function getInterval(interval) {
    var _interval;
    var canvasOptions = this._canvasOptions;
    interval = (_interval = interval) !== null && _interval !== void 0 ? _interval : this._businessRange.interval;
    if (interval) {
      return Math.round(canvasOptions.ratioOfCanvasRange * interval);
    }
    return Math.round(canvasOptions.endPoint - canvasOptions.startPoint);
  },
  zoom(translate, scale, wholeRange) {
    var canvasOptions = this._canvasOptions;
    if (canvasOptions.rangeMinVisible.valueOf() === canvasOptions.rangeMaxVisible.valueOf() && translate !== 0) {
      return this.zoomZeroLengthRange(translate, scale);
    }
    var startPoint = canvasOptions.startPoint;
    var endPoint = canvasOptions.endPoint;
    var isInverted = this.isInverted();
    var newStart = (startPoint + translate) / scale;
    var newEnd = (endPoint + translate) / scale;
    wholeRange = wholeRange || {};
    var minPoint = this.to(isInverted ? wholeRange.endValue : wholeRange.startValue);
    var maxPoint = this.to(isInverted ? wholeRange.startValue : wholeRange.endValue);
    var min;
    var max;
    if (minPoint > newStart) {
      newEnd -= newStart - minPoint;
      newStart = minPoint;
      min = isInverted ? wholeRange.endValue : wholeRange.startValue;
    }
    if (maxPoint < newEnd) {
      newStart -= newEnd - maxPoint;
      newEnd = maxPoint;
      max = isInverted ? wholeRange.startValue : wholeRange.endValue;
    }
    if (maxPoint - minPoint < newEnd - newStart) {
      newStart = minPoint;
      newEnd = maxPoint;
    }
    translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;
    scale = (startPoint + translate) / newStart || 1;
    min = (0, _type.isDefined)(min) ? min : (0, _math.adjust)(this.from(newStart, 1));
    max = (0, _type.isDefined)(max) ? max : (0, _math.adjust)(this.from(newEnd, -1));
    if (scale <= 1) {
      min = this._correctValueAboutBreaks(min, scale === 1 ? translate : -1);
      max = this._correctValueAboutBreaks(max, scale === 1 ? translate : 1);
    }
    if (min > max) {
      min = min > wholeRange.endValue ? wholeRange.endValue : min;
      max = max < wholeRange.startValue ? wholeRange.startValue : max;
    } else {
      min = min < wholeRange.startValue ? wholeRange.startValue : min;
      max = max > wholeRange.endValue ? wholeRange.endValue : max;
    }
    return {
      min,
      max,
      translate: (0, _math.adjust)(translate),
      scale: (0, _math.adjust)(scale)
    };
  },
  _correctValueAboutBreaks(value, direction) {
    var br = this._userBreaks.filter(function (br) {
      return value >= br.from && value <= br.to;
    });
    if (br.length) {
      return direction > 0 ? br[0].to : br[0].from;
    } else {
      return value;
    }
  },
  zoomZeroLengthRange(translate, scale) {
    var canvasOptions = this._canvasOptions;
    var min = canvasOptions.rangeMin;
    var max = canvasOptions.rangeMax;
    var correction = (max.valueOf() !== min.valueOf() ? max.valueOf() - min.valueOf() : _abs(canvasOptions.rangeMinVisible.valueOf() - min.valueOf())) / canvasOptions.canvasLength;
    var isDateTime = (0, _type.isDate)(max) || (0, _type.isDate)(min);
    var isLogarithmic = this._businessRange.axisType === 'logarithmic';
    var newMin = canvasOptions.rangeMinVisible.valueOf() - correction;
    var newMax = canvasOptions.rangeMaxVisible.valueOf() + correction;
    newMin = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMin, canvasOptions.base)) : isDateTime ? new Date(newMin) : newMin;
    newMax = isLogarithmic ? (0, _math.adjust)((0, _utils.raiseToExt)(newMax, canvasOptions.base)) : isDateTime ? new Date(newMax) : newMax;
    return {
      min: newMin,
      max: newMax,
      translate: translate,
      scale: scale
    };
  },
  getMinScale: function getMinScale(zoom) {
    var _this$_businessRange = this._businessRange,
      dataType = _this$_businessRange.dataType,
      interval = _this$_businessRange.interval;
    if (dataType === 'datetime' && interval === 1) {
      return this.getDateTimeMinScale(zoom);
    }
    return zoom ? 1.1 : 0.9;
  },
  getDateTimeMinScale(zoom) {
    var canvasOptions = this._canvasOptions;
    var length = canvasOptions.canvasLength / canvasOptions.ratioOfCanvasRange;
    length += (parseInt(length * 0.1) || 1) * (zoom ? -2 : 2);
    return canvasOptions.canvasLength / (Math.max(length, 1) * canvasOptions.ratioOfCanvasRange);
  },
  getScale: function getScale(val1, val2) {
    var canvasOptions = this._canvasOptions;
    if (canvasOptions.rangeMax === canvasOptions.rangeMin) {
      return 1;
    }
    val1 = (0, _type.isDefined)(val1) ? this.fromValue(val1) : canvasOptions.rangeMin;
    val2 = (0, _type.isDefined)(val2) ? this.fromValue(val2) : canvasOptions.rangeMax;
    return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2);
  },
  // dxRangeSelector
  isValid: function isValid(value) {
    var co = this._canvasOptions;
    value = this.fromValue(value);
    return value !== null && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax;
  },
  getCorrectValue: function getCorrectValue(value, direction) {
    var that = this;
    var breaks = that._breaks;
    var prop;
    value = that.fromValue(value);
    if (that._breaks) {
      prop = that._checkValueAboutBreaks(breaks, value, 'trFrom', 'trTo', that._checkingMethodsAboutBreaks[0]);
      if (prop.inBreak === true) {
        return that.toValue(direction > 0 ? prop.break.trTo : prop.break.trFrom);
      }
    }
    return that.toValue(value);
  },
  to: function to(bp, direction) {
    var range = this.getBusinessRange();
    if ((0, _type.isDefined)(range.maxVisible) && (0, _type.isDefined)(range.minVisible) && range.maxVisible.valueOf() === range.minVisible.valueOf()) {
      if (!(0, _type.isDefined)(bp) || range.maxVisible.valueOf() !== bp.valueOf()) {
        return null;
      }
      return this.translateSpecialCase(bp === 0 && this._options.shiftZeroValue ? 'canvas_position_default' : 'canvas_position_middle');
    }
    bp = this.fromValue(bp);
    var that = this;
    var canvasOptions = that._canvasOptions;
    var breaks = that._breaks;
    var prop = {
      length: 0
    };
    var commonBreakSize = 0;
    if (breaks !== undefined) {
      prop = that._checkValueAboutBreaks(breaks, bp, 'trFrom', 'trTo', that._checkingMethodsAboutBreaks[0]);
      commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0;
    }
    if (prop.inBreak === true) {
      if (direction > 0) {
        return prop.break.start;
      } else if (direction < 0) {
        return prop.break.end;
      } else {
        return null;
      }
    }
    return that._conversionValue(that._calculateProjection((bp - canvasOptions.rangeMinVisible - prop.length) * canvasOptions.ratioOfCanvasRange + commonBreakSize));
  },
  from: function from(pos, direction) {
    var that = this;
    var breaks = that._breaks;
    var prop = {
      length: 0
    };
    var canvasOptions = that._canvasOptions;
    var startPoint = canvasOptions.startPoint;
    var commonBreakSize = 0;
    if (breaks !== undefined) {
      prop = that._checkValueAboutBreaks(breaks, pos, 'start', 'end', that._checkingMethodsAboutBreaks[1]);
      commonBreakSize = (0, _type.isDefined)(prop.breaksSize) ? prop.breaksSize : 0;
    }
    if (prop.inBreak === true) {
      if (direction > 0) {
        return that.toValue(prop.break.trTo);
      } else if (direction < 0) {
        return that.toValue(prop.break.trFrom);
      } else {
        return null;
      }
    }
    return that.toValue(that._calculateUnProjection((pos - startPoint - commonBreakSize) / canvasOptions.ratioOfCanvasRange + prop.length));
  },
  isValueProlonged: false,
  // dxRangeSelector specific

  // TODO: Rename to getValueRange
  getRange: function getRange() {
    return [this.toValue(this._canvasOptions.rangeMin), this.toValue(this._canvasOptions.rangeMax)];
  },
  getScreenRange: function getScreenRange() {
    return [this._canvasOptions.startPoint, this._canvasOptions.endPoint];
  },
  add: function add(value, diff, dir) {
    return this._add(value, diff, (this._businessRange.invert ? -1 : +1) * dir);
  },
  _add: function _add(value, diff, coeff) {
    return this.toValue(this.fromValue(value) + diff * coeff);
  },
  fromValue: function fromValue(value) {
    return value !== null ? Number(value) : null;
  },
  toValue: function toValue(value) {
    return value !== null ? Number(value) : null;
  },
  ratioOfCanvasRange() {
    return this._canvasOptions.ratioOfCanvasRange;
  },
  convert(value) {
    return value;
  },
  getRangeByMinZoomValue(minZoom, visualRange) {
    if (visualRange.minVisible + minZoom <= this._businessRange.max) {
      return [visualRange.minVisible, visualRange.minVisible + minZoom];
    } else {
      return [visualRange.maxVisible - minZoom, visualRange.maxVisible];
    }
  }
};

/***/ }),

/***/ 15584:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tree_map = _interopRequireDefault(__webpack_require__(4080));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _tree_map.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 4815:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _extend2 = __webpack_require__(13306);
var _common = __webpack_require__(20576);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
proto._eventsMap.onNodesInitialized = {
  name: 'nodesInitialized'
};
proto._eventsMap.onNodesRendering = {
  name: 'nodesRendering'
};
proto._createProxyType = function () {
  var that = this;
  var nodes;
  Proxy.prototype = {
    constructor: Proxy,
    getParent: function getParent() {
      return nodes[this._id].parent.proxy || null;
    },
    getChild: function getChild(index) {
      var _nodes = nodes[this._id].nodes;
      return _nodes ? _nodes[index].proxy : null;
    },
    getChildrenCount: function getChildrenCount() {
      var _nodes = nodes[this._id].nodes;
      return _nodes ? _nodes.length : 0;
    },
    getAllChildren: function getAllChildren() {
      var _nodes = nodes[this._id].nodes;
      var i;
      var ii = _nodes && _nodes.length;
      var list = [];
      for (i = 0; i < ii; ++i) {
        list.push(_nodes[i].proxy);
      }
      return list;
    },
    getAllNodes: function getAllNodes() {
      var list = [];
      collectNodes(nodes[this._id], list);
      return list;
    },
    isLeaf: function isLeaf() {
      return !nodes[this._id].isNode();
    },
    isActive: function isActive() {
      return nodes[this._id].isActive();
    },
    value: function value(arg) {
      var node = nodes[this._id];
      var result;
      if (arg !== undefined) {
        updateValue(node, arg > 0 ? Number(arg) : 0);
        change(node, ['TILING']);
        result = this;
      } else {
        result = node.value;
      }
      return result;
    },
    label: function label(arg) {
      var node = nodes[this._id];
      var result;
      if (arg !== undefined) {
        node.customLabel = arg ? String(arg) : null;
        change(node, ['LABELS']);
        result = this;
      } else {
        result = node.customLabel || node.label;
      }
      return result;
    },
    customize: function customize(settings) {
      var node = nodes[this._id];
      if (settings) {
        node._custom = node._custom || {};
        (0, _extend2.extend)(true, node._custom, settings);
        node._partialState = node._partialLabelState = null;
      }
      change(node, ['TILES', 'LABELS']);
      return this;
    },
    resetCustomization: function resetCustomization() {
      var node = nodes[this._id];
      node._custom = node._partialState = node._partialLabelState = null;
      change(node, ['TILES', 'LABELS']);
      return this;
    }
  };
  that._extendProxyType(Proxy.prototype);
  function Proxy(node) {
    var that = this;
    node.proxy = that;
    that._id = node._id;
    that.level = node.level;
    that.index = node.index;
    that.data = node.data;
  }

  // TODO: Find a way to make the following methods exist one per module rather then one per instance
  that._handlers.beginBuildNodes = function () {
    nodes = that._nodes;
    new Proxy(that._root);
  };
  that._handlers.buildNode = function (node) {
    new Proxy(node);
  };
  that._handlers.endBuildNodes = function () {
    that._eventTrigger('nodesInitialized', {
      root: that._root.proxy
    });
  };
};
function change(node, codes) {
  var ctx = node.ctx;
  ctx.suspend();
  ctx.change(codes);
  ctx.resume();
}
function collectNodes(node, list) {
  var nodes = node.nodes;
  var i;
  var ii = nodes && nodes.length;
  for (i = 0; i < ii; ++i) {
    list.push(nodes[i].proxy);
    collectNodes(nodes[i], list);
  }
}
function updateValue(node, value) {
  var delta = value - node.value;
  while (node) {
    node.value += delta;
    node = node.parent;
  }
}
proto._extendProxyType = _common.noop;
var _resetNodes = proto._resetNodes;
proto._resetNodes = function () {
  _resetNodes.call(this);
  this._eventTrigger('nodesRendering', {
    node: this._topNode.proxy
  });
};
var _updateStyles = nodeProto.updateStyles;
nodeProto.updateStyles = function () {
  var that = this;
  _updateStyles.call(that);
  if (that._custom) {
    that._partialState = !that.ctx.forceReset && that._partialState || that.ctx.calculateState(that._custom);
    (0, _extend2.extend)(true, that.state, that._partialState);
  }
};
var _updateLabelStyle = nodeProto.updateLabelStyle;
nodeProto.updateLabelStyle = function () {
  var that = this;
  var custom = that._custom;
  _updateLabelStyle.call(that);
  if (custom && custom.label) {
    that._partialLabelState = !that.ctx.forceReset && that._partialLabelState || calculatePartialLabelState(that, custom.label);
    that.labelState = (0, _extend2.extend)(true, {}, that.labelState, that._partialLabelState);
  }
};
function calculatePartialLabelState(node, settings) {
  var state = node.ctx.calculateLabelState(settings);
  if ('visible' in settings) {
    state.visible = !!settings.visible;
  }
  return state;
}
proto.getRootNode = function () {
  return this._root.proxy;
};
proto.resetNodes = function () {
  var context = this._context;
  context.suspend();
  context.change(['NODES_CREATE']);
  context.resume();
  return this;
};

/***/ }),

/***/ 66831:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _colorizing = __webpack_require__(19910);
function discreteColorizer(options, themeManager, root) {
  var palette = themeManager.createPalette(options.palette, {
    useHighlight: true,
    extensionMode: options.paletteExtensionMode,
    count: options.colorizeGroups ? getNodesCount(root) : getLeafsCount(root)
  });
  return (options.colorizeGroups ? discreteGroupColorizer : discreteLeafColorizer)(palette, root);
}
function getLeafsCount(root) {
  var allNodes = root.nodes.slice();
  var i;
  var ii = allNodes.length;
  var count = 0;
  var node;
  for (i = 0; i < ii; ++i) {
    node = allNodes[i];
    if (node.isNode()) {
      count = Math.max(count, getLeafsCount(node));
    } else {
      count += 1;
    }
  }
  return count;
}
function discreteLeafColorizer(palette) {
  var colors = palette.generateColors();
  return function (node) {
    return colors[node.index];
  };
}
function getNodesCount(root) {
  var allNodes = root.nodes.slice();
  var i;
  var ii = allNodes.length;
  var count = 0;
  var node;
  for (i = 0; i < ii; ++i) {
    node = allNodes[i];
    if (node.isNode()) {
      count += getNodesCount(node) + 1;
    }
  }
  return count;
}
function prepareDiscreteGroupColors(palette, root) {
  var colors = {};
  var allNodes = root.nodes.slice();
  var i;
  var ii = allNodes.length;
  var node;
  for (i = 0; i < ii; ++i) {
    node = allNodes[i];
    if (node.isNode()) {
      allNodes = allNodes.concat(node.nodes);
      ii = allNodes.length;
    } else if (!colors[node.parent._id]) {
      colors[node.parent._id] = palette.getNextColor();
    }
  }
  return colors;
}
function discreteGroupColorizer(palette, root) {
  var colors = prepareDiscreteGroupColors(palette, root);
  return function (node) {
    return colors[node._id];
  };
}
(0, _colorizing.addColorizer)('discrete', discreteColorizer);
var _default = discreteColorizer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 13652:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _colorizing = __webpack_require__(19910);
var _min = Math.min;
var _max = Math.max;
function createSimpleColorizer(getColor, range) {
  return function (node) {
    return getColor(node, range);
  };
}
function getRangeData(range) {
  return [Number(range[0]) || 0, range[1] - range[0] || 1];
}
function calculateRange(nodes, getValue) {
  var i;
  var ii = nodes.length;
  var codes = [];
  var code;
  for (i = 0; i < ii; ++i) {
    code = getValue(nodes[i]);
    if (isFinite(code)) {
      codes.push(code);
    }
  }
  return getRangeData([_min.apply(null, codes), _max.apply(null, codes)]);
}
function createGuessingColorizer(getColor, getValue) {
  var ranges = {};
  return function (node) {
    var parent = node.parent;
    return getColor(node, ranges[parent._id] || (ranges[parent._id] = calculateRange(parent.nodes, getValue)));
  };
}
function gradientColorizer(options, themeManager) {
  var palette = themeManager.createGradientPalette(options.palette);
  var getValue = (0, _colorizing.createColorCodeGetter)(options);
  return 'range' in options ? createSimpleColorizer(getColor, getRangeData(options.range || [])) : createGuessingColorizer(getColor, getValue);
  function getColor(node, arg) {
    return palette.getColor((getValue(node) - arg[0]) / arg[1]);
  }
}
(0, _colorizing.addColorizer)('gradient', gradientColorizer);
var _default = gradientColorizer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 19910:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addColorizer = addColorizer;
exports.createColorCodeGetter = createColorCodeGetter;
exports.getColorizer = getColorizer;
exports.setDefaultColorizer = setDefaultColorizer;
var _utils = __webpack_require__(19157);
var _common = __webpack_require__(20576);
var colorizers = {};
var defaultColorizerName;
function wrapLeafColorGetter(getter) {
  return function (node) {
    return !node.isNode() ? getter(node) : undefined;
  };
}
function wrapGroupColorGetter(getter) {
  return function (node) {
    var parent = !node.isNode() && node.parent;
    return parent ? parent._groupColor = parent._groupColor || getter(parent) : undefined;
  };
}
function getColorizer(options, themeManager, root) {
  var type = (0, _utils.normalizeEnum)(options.type || defaultColorizerName);
  var colorizer = colorizers[type] && colorizers[type](options, themeManager, root);
  return colorizer ? (options.colorizeGroups ? wrapGroupColorGetter : wrapLeafColorGetter)(colorizer) : _common.noop;
}
function addColorizer(name, colorizer) {
  colorizers[name] = colorizer;
}
function setDefaultColorizer(name) {
  defaultColorizerName = name;
}
function getValueAsColorCode(node) {
  return node.value;
}
function createColorCode(colorCodeField) {
  return function (node) {
    return Number(node.data[colorCodeField]);
  };
}
function createColorCodeGetter(options) {
  return options.colorCodeField ? createColorCode(options.colorCodeField) : getValueAsColorCode;
}

/***/ }),

/***/ 73675:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _colorizing = __webpack_require__(19910);
function getPaletteIndex(value, items) {
  var start = 0;
  var end = items.length - 1;
  var index = -1;
  var middle;
  if (items[start] <= value && value <= items[end]) {
    if (value === items[end]) {
      index = end - 1;
    } else {
      while (end - start > 1) {
        middle = start + end >> 1;
        if (value < items[middle]) {
          end = middle;
        } else {
          start = middle;
        }
      }
      index = start;
    }
  }
  return index;
}
function rangeColorizer(options, themeManager) {
  var range = options.range || [];
  var palette = themeManager.createDiscretePalette(options.palette, range.length - 1);
  var getValue = (0, _colorizing.createColorCodeGetter)(options);
  return function (node) {
    return palette.getColor(getPaletteIndex(getValue(node), range));
  };
}
(0, _colorizing.addColorizer)('range', rangeColorizer);
var _default = rangeColorizer;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 77707:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.buildRectAppearance = buildRectAppearance;
exports.buildTextAppearance = buildTextAppearance;
var _utils = __webpack_require__(19157);
function buildRectAppearance(option) {
  var border = option.border || {};
  return {
    fill: option.color,
    opacity: option.opacity,
    'stroke': border.color,
    'stroke-width': border.width,
    'stroke-opacity': border.opacity,
    hatching: option.hatching
  };
}
function buildTextAppearance(options, filter) {
  return {
    attr: {
      filter
    },
    css: (0, _utils.patchFontOptions)(options.font)
  };
}

/***/ }),

/***/ 61104:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _helpers = __webpack_require__(3603);
__webpack_require__(4815);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _tree_map.default.prototype;
proto._eventsMap.onDrill = {
  name: 'drill'
};
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;
  proto.drillDown = function () {
    that._drillToNode(this._id);
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._drilldownIndex = -1;
});
proto._drillToNode = function (index) {
  var that = this;
  var node;
  if (that._drilldownIndex !== index) {
    node = that._nodes[index] || that._root;
    if (node.nodes) {
      that._drilldownIndex = index;
      that._topNode = node;
      that._context.suspend();
      that._context.change(['MAX_DEPTH', 'NODES_RESET']);
      that._context.resume();
      that._eventTrigger('drill', {
        node: node.proxy
      });
    }
  }
};
proto.resetDrillDown = function () {
  this._drillToNode(-1);
  return this;
};
proto.drillUp = function () {
  this._drillToNode(this._topNode.parent._id || -1);
  return this;
};
proto.getCurrentNode = function () {
  return this._topNode.proxy;
};

/***/ }),

/***/ 9888:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _helpers = __webpack_require__(3603);
var _common = __webpack_require__(77707);
var _utils = __webpack_require__(19157);
__webpack_require__(4815);
__webpack_require__(83469);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
var STATE_CODE = 1;
proto._eventsMap.onHoverChanged = {
  name: 'hoverChanged'
};
(0, _helpers.expand)(proto._handlers, 'calculateAdditionalStates', function (states, options) {
  states[1] = options.hoverStyle ? (0, _common.buildRectAppearance)(options.hoverStyle) : {};
});
_tree_map.default.addChange({
  code: 'HOVER_ENABLED',
  handler: function handler() {
    var hoverEnabled = (0, _utils.parseScalar)(this._getOption('hoverEnabled', true), true);
    if (!hoverEnabled) {
      this.clearHover();
    }
    this._hoverEnabled = hoverEnabled;
  },
  isThemeDependent: true,
  isOptionChange: true,
  option: 'hoverEnabled'
});
nodeProto.statesMap[1] = 1;
nodeProto.additionalStates.push(1);
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;
  proto.setHover = function () {
    that._hoverNode(this._id);
  };
  proto.isHovered = function () {
    return that._hoverIndex === this._id;
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._hoverIndex = -1;
});
(0, _helpers.expand)(proto, '_changeGroupSettings', function () {
  var that = this;
  that._groupHoverEnabled = (0, _utils.parseScalar)(that._getOption('group').hoverEnabled, true);
  if (!that._groupHoverEnabled) {
    that.clearHover();
  }
});
proto._applyHoverState = function (index, state) {
  setNodeStateRecursive(this._nodes[index], STATE_CODE, state);
  this._eventTrigger('hoverChanged', {
    node: this._nodes[index].proxy
  });
};
function setNodeStateRecursive(node, code, state) {
  var nodes = node.isNode() && node.nodes;
  var i;
  var ii = nodes && nodes.length;
  node.setState(code, state);
  for (i = 0; i < ii; ++i) {
    setNodeStateRecursive(nodes[i], code, state);
  }
}
proto._hoverNode = function (index) {
  var that = this;
  var currentIndex = that._hoverIndex;
  if (that._hoverEnabled && currentIndex !== index) {
    if (!that._groupHoverEnabled && index >= 0 && that._nodes[index].isNode()) {
      that.clearHover();
      return;
    }
    that._context.suspend();
    that._hoverIndex = -1;
    if (currentIndex >= 0) {
      that._applyHoverState(currentIndex, false);
    }
    that._hoverIndex = index;
    if (index >= 0) {
      that._applyHoverState(index, true);
    }
    that._context.resume();
  }
};
proto.clearHover = function () {
  this._hoverNode(-1);
};

/***/ }),

/***/ 21168:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _extend2 = __webpack_require__(13306);
function Node() {}
var updateTile = [updateLeaf, updateGroup];
(0, _extend2.extend)(Node.prototype, {
  value: 0,
  isNode: function isNode() {
    return !!(this.nodes && this.level < this.ctx.maxLevel);
  },
  isActive: function isActive() {
    var ctx = this.ctx;
    return this.level >= ctx.minLevel && this.level <= ctx.maxLevel;
  },
  updateStyles: function updateStyles() {
    var that = this;
    var isNode = Number(that.isNode());
    that.state = that._buildState(that.ctx.settings[isNode].state, !isNode && that.color && {
      fill: that.color
    });
  },
  _buildState: function _buildState(state, extra) {
    var base = (0, _extend2.extend)({}, state);
    return extra ? (0, _extend2.extend)(base, extra) : base;
  },
  updateLabelStyle: function updateLabelStyle() {
    var settings = this.ctx.settings[Number(this.isNode())];
    this.labelState = settings.labelState;
    this.labelParams = settings.labelParams;
  },
  _getState: function _getState() {
    return this.state;
  },
  applyState: function applyState() {
    updateTile[Number(this.isNode())](this.tile, this._getState());
  }
});
function updateLeaf(content, attrs) {
  content.smartAttr(attrs);
}
function updateGroup(content, attrs) {
  content.outer.attr({
    stroke: attrs.stroke,
    'stroke-width': attrs['stroke-width'],
    'stroke-opacity': attrs['stroke-opacity']
  });
  content.inner.smartAttr({
    fill: attrs.fill,
    opacity: attrs.opacity,
    hatching: attrs.hatching
  });
}
var _default = Node;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 74958:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _tree_map.default.prototype;
proto._optionChangesMap.idField = proto._optionChangesMap.parentField = 'NODES_CREATE';
proto._processDataSourceItems = function (items) {
  var i;
  var struct = {};
  var currentItem;
  var idField = this._getOption('idField', true);
  var parentField = this._getOption('parentField', true);
  var parentId;
  var rootNodes = [];
  var tmpItems;
  var item;
  if (!idField || !parentField || items.length === 0) {
    return {
      items: items,
      isPlain: false
    };
  }
  for (i = 0; i < items.length; i++) {
    currentItem = items[i];
    parentId = currentItem[parentField];
    if (parentId) {
      struct[parentId] = struct[parentId] || {
        items: []
      };
      tmpItems = struct[parentId].items;
    } else {
      tmpItems = rootNodes;
    }
    tmpItems.push(currentItem);
  }
  treeFiller({
    struct: struct,
    idField: idField
  }, rootNodes);
  for (item in struct) {
    struct[item] && rootNodes.push(struct[item]);
  }
  return {
    items: rootNodes,
    isPlain: true
  };
};
function treeFiller(context, items) {
  var currentItem;
  var i;
  var struct = context.struct;
  var id;
  for (i = 0; i < items.length; i++) {
    currentItem = items[i];
    id = currentItem[context.idField];
    if (struct[id]) {
      currentItem.items = struct[id].items;
      struct[id] = null;
      treeFiller(context, currentItem.items);
    }
  }
}

/***/ }),

/***/ 13099:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _helpers = __webpack_require__(3603);
var _common = __webpack_require__(77707);
var _utils = __webpack_require__(19157);
__webpack_require__(4815);
__webpack_require__(83469);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
var MODE_NONE = 0;
var MODE_SINGLE = 1;
var MODE_MULTIPLE = 2;
var STATE_CODE = 2;
proto._eventsMap.onSelectionChanged = {
  name: 'selectionChanged'
};
(0, _helpers.expand)(proto._handlers, 'calculateAdditionalStates', function (states, options) {
  states[2] = options.selectionStyle ? (0, _common.buildRectAppearance)(options.selectionStyle) : {};
});
nodeProto.statesMap[2] = nodeProto.statesMap[3] = STATE_CODE;
nodeProto.additionalStates.push(2);
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  this._selectionList.length = 0;
});
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;
  proto.select = function (state) {
    that._selectNode(this._id, !!state);
  };
  proto.isSelected = function () {
    return that._selectionList.includes(this._id);
  };
  that._selectionList = [];
});
_tree_map.default.addChange({
  code: 'SELECTION_MODE',
  handler: function handler() {
    var that = this;
    var option = (0, _utils.normalizeEnum)(that._getOption('selectionMode', true));
    var selectionList = that._selectionList;
    var tmp;
    var mode = option === 'none' ? MODE_NONE : option === 'multiple' ? MODE_MULTIPLE : MODE_SINGLE;
    if (mode === MODE_SINGLE && selectionList.length > 1) {
      tmp = selectionList.pop();
      that.clearSelection();
      selectionList.push(tmp);
    } else if (mode === MODE_NONE) {
      that.clearSelection();
    }
    that._selectionMode = mode;
  },
  isThemeDependent: true,
  isOptionChange: true,
  option: 'selectionMode'
});
(0, _helpers.expand)(proto, '_applyTilesAppearance', function () {
  if (this._selectionList.length) {
    bringSelectedTilesToForeground(this._nodes, this._selectionList);
  }
});
var tileToFront = [leafToFront, groupToFront];
function bringSelectedTilesToForeground(nodes, selectionList) {
  var i;
  var ii = selectionList.length;
  var node;
  for (i = 0; i < ii; ++i) {
    node = nodes[selectionList[i]];
    tileToFront[Number(node.isNode())](node.tile);
  }
}
function leafToFront(content) {
  content.toForeground();
}
function groupToFront(content) {
  content.outer.toForeground();
  content.inner.toForeground();
}
proto._applySelectionState = function (index, state) {
  var node = this._nodes[index];
  node.setState(STATE_CODE, state);
  this._eventTrigger('selectionChanged', {
    node: node.proxy
  });
};
proto._selectNode = function (index, state) {
  var that = this;
  var selectionList;
  var k;
  var tmp;
  if (that._selectionMode !== MODE_NONE) {
    that._context.suspend();
    selectionList = that._selectionList;
    k = selectionList.indexOf(index);
    if (state && k === -1) {
      if (that._selectionMode === MODE_SINGLE) {
        if (selectionList.length) {
          tmp = selectionList.pop();
          that._applySelectionState(tmp, false);
        }
      }
      selectionList.push(index);
      that._applySelectionState(index, true);
    } else if (!state && k >= 0) {
      selectionList.splice(k, 1);
      that._applySelectionState(index, false);
    }
    that._context.resume();
  }
};
proto.clearSelection = function () {
  var that = this;
  var selectionList = that._selectionList;
  var i;
  var ii = selectionList.length;
  if (that._selectionMode !== MODE_NONE) {
    that._context.suspend();
    for (i = 0; i < ii; ++i) {
      that._applySelectionState(selectionList[i], false);
    }
    selectionList.length = 0;
    that._context.resume();
  }
};

/***/ }),

/***/ 83469:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _node = _interopRequireDefault(__webpack_require__(21168));
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _tree_map.default.prototype;
var nodeProto = _node.default.prototype;
var handlers = proto._handlers;
var _calculateState = handlers.calculateState;
var _buildState = nodeProto._buildState;
handlers.calculateState = function (options) {
  var states = {
    0: _calculateState(options)
  };
  handlers.calculateAdditionalStates(states, options);
  return states;
};
handlers.calculateAdditionalStates = _common.noop;
nodeProto.code = 0;
nodeProto.statesMap = {
  0: 0
};
nodeProto.additionalStates = [];
nodeProto._buildState = function (state, extra) {
  var states = {
    0: _buildState(state[0], extra)
  };
  if (this.additionalStates.length) {
    buildAdditionalStates(states, states[0], state, this.additionalStates);
  }
  return states;
};
nodeProto._getState = function () {
  return this.state[this.statesMap[this.code]];
};
nodeProto.setState = function (code, state) {
  if (state) {
    this.code |= code;
  } else {
    this.code &= ~code;
  }
  this.ctx.change(['TILES']);
};
function buildAdditionalStates(states, base, source, list) {
  var i;
  var ii = list.length;
  for (i = 0; i < ii; ++i) {
    states[list[i]] = (0, _extend2.extend)({}, base, source[list[i]]);
  }
}

/***/ }),

/***/ 60642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.addAlgorithm = addAlgorithm;
exports.buildSidesData = buildSidesData;
exports.calculateRectangles = calculateRectangles;
exports.getAlgorithm = getAlgorithm;
exports.getStaticSideIndex = void 0;
exports.setDefaultAlgorithm = setDefaultAlgorithm;
var _type = __webpack_require__(35922);
var _utils = __webpack_require__(19157);
var _round = Math.round;
var algorithms = {};
var defaultAlgorithm;
function getAlgorithm(value) {
  return algorithms[(0, _utils.normalizeEnum)(value)] || (0, _type.isFunction)(value) && value || defaultAlgorithm;
}
function addAlgorithm(name, callback) {
  algorithms[name] = callback;
}
function setDefaultAlgorithm(name) {
  defaultAlgorithm = algorithms[name];
}
var directionToIndexOffsets = {};
directionToIndexOffsets[-1] = [2, 0];
directionToIndexOffsets[+1] = [0, 2];
var getStaticSideIndex = function getStaticSideIndex(rect) {
  return rect[2] - rect[0] < rect[3] - rect[1] ? 0 : 1;
};
exports.getStaticSideIndex = getStaticSideIndex;
function buildSidesData(rect, directions, _staticSideIndex) {
  var staticSideIndex = _staticSideIndex !== undefined ? _staticSideIndex : getStaticSideIndex(rect);
  var variedSideIndex = 1 - staticSideIndex;
  var staticSideDirection = directions[staticSideIndex];
  var variedSideDirection = directions[variedSideIndex];
  var staticSideIndexOffsets = directionToIndexOffsets[staticSideDirection];
  var variedSideIndexOffsets = directionToIndexOffsets[variedSideDirection];
  return {
    staticSide: rect[2 + staticSideIndex] - rect[staticSideIndex],
    variedSide: rect[2 + variedSideIndex] - rect[variedSideIndex],
    static1: staticSideIndex + staticSideIndexOffsets[0],
    static2: staticSideIndex + staticSideIndexOffsets[1],
    varied1: variedSideIndex + variedSideIndexOffsets[0],
    varied2: variedSideIndex + variedSideIndexOffsets[1],
    staticDir: staticSideDirection,
    variedDir: variedSideDirection
  };
}
function calculateRectangles(nodes, head, totalRect, sidesData, rowData) {
  var i;
  var ii;
  var variedSidePart = [0, 0, 0, 0];
  var static1 = sidesData.static1;
  var static2 = sidesData.static2;
  var position = totalRect[static1];
  var dir = sidesData.staticDir;
  var side = sidesData.staticSide;
  var sum = rowData.sum;
  var rect;
  var delta;
  variedSidePart[sidesData.varied1] = totalRect[sidesData.varied1];
  variedSidePart[sidesData.varied2] = totalRect[sidesData.varied1] + sidesData.variedDir * rowData.side;
  for (i = head, ii = head + rowData.count; i < ii; ++i) {
    rect = variedSidePart.slice();
    rect[static1] = position;
    delta = _round(side * nodes[i].value / sum) || 0;
    sum -= nodes[i].value;
    side -= delta;
    position += dir * delta;
    rect[static2] = position;
    nodes[i].rect = rect;
  }
  totalRect[sidesData.varied1] = variedSidePart[sidesData.varied2];
}

/***/ }),

/***/ 36061:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tiling = __webpack_require__(60642);
var sliceAndDiceAlgorithm = (0, _tiling.getAlgorithm)('sliceanddice');
function rotatedSliceAndDice(data) {
  data.isRotated = !data.isRotated;
  return sliceAndDiceAlgorithm.call(this, data);
}
(0, _tiling.addAlgorithm)('rotatedsliceanddice', rotatedSliceAndDice);

/***/ }),

/***/ 56369:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tiling = __webpack_require__(60642);
function sliceAndDice(data) {
  var items = data.items;
  var sidesData = (0, _tiling.buildSidesData)(data.rect, data.directions, data.isRotated ? 1 : 0);
  (0, _tiling.calculateRectangles)(items, 0, data.rect, sidesData, {
    sum: data.sum,
    count: items.length,
    side: sidesData.variedSide
  });
}
(0, _tiling.addAlgorithm)('sliceanddice', sliceAndDice);
var _default = sliceAndDice;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 57200:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = _default;
var _tiling = __webpack_require__(60642);
var _max = Math.max;
var _round = Math.round;
function compare(a, b) {
  return b.value - a.value;
}
function getAspectRatio(value) {
  return _max(value, 1 / value);
}
function findAppropriateCollection(nodes, head, context) {
  var bestAspectRatio = Infinity;
  var nextAspectRatio;
  var sum = 0;
  var nextSum;
  var i;
  var j;
  var ii = nodes.length;
  var coeff = context.areaToValue / context.staticSide;
  var totalAspectRatio;
  for (i = head; i < ii;) {
    nextSum = sum + nodes[i].value;
    totalAspectRatio = context.staticSide / coeff / nextSum;
    nextAspectRatio = 0;
    for (j = head; j <= i; ++j) {
      nextAspectRatio = context.accumulate(nextAspectRatio, getAspectRatio(totalAspectRatio * nodes[j].value / nextSum), j - head + 1);
    }
    if (nextAspectRatio < bestAspectRatio) {
      bestAspectRatio = nextAspectRatio;
      sum = nextSum;
      ++i;
    } else {
      break;
    }
  }
  return {
    sum: sum,
    count: i - head,
    side: _round(coeff * sum)
  };
}
function getArea(rect) {
  return (rect[2] - rect[0]) * (rect[3] - rect[1]);
}
function doStep(nodes, head, context) {
  var sidesData = (0, _tiling.buildSidesData)(context.rect, context.directions, context.staticSideIndex);
  var area = getArea(context.rect);
  var rowData = area > 0 ? findAppropriateCollection(nodes, head, {
    areaToValue: area / context.sum,
    accumulate: context.accumulate,
    staticSide: sidesData.staticSide
  }) : {
    sum: 1,
    side: sidesData.variedSide,
    count: nodes.length - head
  };
  (0, _tiling.calculateRectangles)(nodes, head, context.rect, sidesData, rowData);
  context.sum -= rowData.sum;
  return head + rowData.count;
}
function _default(data, accumulate, isFixedStaticSide) {
  var items = data.items;
  var ii = items.length;
  var i;
  var context = {
    sum: data.sum,
    rect: data.rect,
    directions: data.directions,
    accumulate: accumulate
  };
  if (isFixedStaticSide) {
    context.staticSideIndex = (0, _tiling.getStaticSideIndex)(context.rect);
  }
  items.sort(compare);
  for (i = 0; i < ii;) {
    i = doStep(items, i, context);
  }
}
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 46576:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tilingSquarified = _interopRequireDefault(__webpack_require__(57200));
var _tiling = __webpack_require__(60642);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _max = Math.max;
function accumulate(total, current) {
  return _max(total, current);
}
function squarified(data) {
  return (0, _tilingSquarified.default)(data, accumulate, false);
}
(0, _tiling.addAlgorithm)('squarified', squarified);
var _default = squarified;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 20957:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tilingSquarified = _interopRequireDefault(__webpack_require__(57200));
var _tiling = __webpack_require__(60642);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function accumulate(total, current, count) {
  return ((count - 1) * total + current) / count;
}
function strip(data) {
  return (0, _tilingSquarified.default)(data, accumulate, true);
}
(0, _tiling.addAlgorithm)('strip', strip);
var _default = strip;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 2322:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _helpers = __webpack_require__(3603);
var _tree_map = _interopRequireDefault(__webpack_require__(49983));
__webpack_require__(4815);
var _tooltip = __webpack_require__(14371);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var proto = _tree_map.default.prototype;
(0, _helpers.expand)(proto, '_extendProxyType', function (proto) {
  var that = this;
  proto.showTooltip = function (coords) {
    that._showTooltip(this._id, coords);
  };
});
(0, _helpers.expand)(proto, '_onNodesCreated', function () {
  if (this._tooltipIndex >= 0) {
    this._tooltip.hide();
  }
  this._tooltipIndex = -1;
});
(0, _helpers.expand)(proto, '_onTilingPerformed', function () {
  if (this._tooltipIndex >= 0) {
    this._moveTooltip(this._nodes[this._tooltipIndex]);
  }
});
function getCoords(coords, rect, renderer) {
  var offset = renderer.getRootOffset();
  return coords || rect && [(rect[0] + rect[2]) / 2 + offset.left, (rect[1] + rect[3]) / 2 + offset.top] || [-1000, -1000];
}
proto._showTooltip = function (index, coords) {
  var that = this;
  var tooltip = that._tooltip;
  var node = that._nodes[index];
  if (that._tooltipIndex === index) {
    that._moveTooltip(node, coords);
    return;
  }
  var callback = function callback(result) {
    if (result === undefined) {
      return;
    }
    if (!result) {
      tooltip.hide();
    }
    that._tooltipIndex = result ? index : -1;
  };
  var xy = getCoords(coords, node.rect, this._renderer);
  callback(tooltip.show({
    value: node.value,
    valueText: tooltip.formatValue(node.value),
    node: node.proxy
  }, {
    x: xy[0],
    y: xy[1],
    offset: 0
  }, {
    node: node.proxy
  }, undefined, callback));
};
proto._moveTooltip = function (node, coords) {
  var xy = getCoords(coords, node.rect, this._renderer);
  this._tooltip.move(xy[0], xy[1], 0);
};
proto.hideTooltip = function () {
  if (this._tooltipIndex >= 0) {
    this._tooltipIndex = -1;
    this._tooltip.hide();
  }
};

// PLUGINS_SECTION\

_tree_map.default.addPlugin(_tooltip.plugin);

/***/ }),

/***/ 66681:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



var _tree_map = _interopRequireDefault(__webpack_require__(49983));
var _tracker = __webpack_require__(88997);
var _helpers = __webpack_require__(3603);
var _utils = __webpack_require__(19157);
__webpack_require__(4815);
__webpack_require__(9888);
__webpack_require__(2322);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DATA_KEY_BASE = '__treemap_data_';
var dataKeyModifier = 0;
var proto = _tree_map.default.prototype;
proto._eventsMap.onClick = {
  name: 'click'
};
var getDataKey = function getDataKey() {
  var dataKey = DATA_KEY_BASE + dataKeyModifier++;
  return dataKey;
};
(0, _helpers.expand)(proto, '_initCore', function () {
  var that = this;
  var dataKey = getDataKey();
  var getProxy = function getProxy(index) {
    return that._nodes[index].proxy;
  };
  that._tracker = new _tracker.Tracker({
    widget: that,
    root: that._renderer.root,
    getNode: function getNode(id) {
      var proxy = getProxy(id);
      var interactWithGroup = (0, _utils.parseScalar)(that._getOption('interactWithGroup', true));
      return interactWithGroup && proxy.isLeaf() && proxy.getParent().isActive() ? proxy.getParent() : proxy;
    },
    getData: function getData(e) {
      var target = e.target;
      return (target.tagName === 'tspan' ? target.parentNode : target)[dataKey];
    },
    getProxy: getProxy,
    click: function click(e) {
      that._eventTrigger('click', e);
    }
  });
  that._handlers.setTrackerData = function (node, element) {
    element.data(dataKey, node._id);
  };
});
(0, _helpers.expand)(proto, '_disposeCore', function () {
  this._tracker.dispose();
});

/***/ }),

/***/ 49983:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _common = __webpack_require__(77707);
var _node = _interopRequireDefault(__webpack_require__(21168));
var _tiling = __webpack_require__(60642);
var _colorizing = __webpack_require__(19910);
var _utils = __webpack_require__(19157);
var _common2 = __webpack_require__(20576);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
__webpack_require__(46576);
__webpack_require__(66831);
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _data_source = __webpack_require__(1539);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _max = Math.max;
var directions = {
  'lefttoprightbottom': [+1, +1],
  'leftbottomrighttop': [+1, -1],
  'righttopleftbottom': [-1, +1],
  'rightbottomlefttop': [-1, -1]
};

// At least one algorithm is required.

(0, _tiling.setDefaultAlgorithm)('squarified');

// By design discrete colorizing is used by default.

(0, _colorizing.setDefaultColorizer)('discrete');
function pickPositiveInteger(val) {
  return val > 0 ? Math.round(val) : 0;
}
var dxTreeMap = _m_base_widget.default.inherit({
  _handlers: {
    beginBuildNodes: _common2.noop,
    buildNode: _common2.noop,
    endBuildNodes: _common2.noop,
    setTrackerData: _common2.noop,
    calculateState: function calculateState(options) {
      return (0, _common.buildRectAppearance)(options);
    }
  },
  _rootClass: 'dxtm-tree-map',
  _rootClassPrefix: 'dxtm',
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: 400,
      height: 400
    };
  },
  _themeSection: 'treeMap',
  _fontFields: ['tile.label.font', 'group.label.font'],
  _init: function _init() {
    var that = this;
    that._rectOffsets = {};
    that._handlers = Object.create(that._handlers);
    that._context = {
      suspend: function suspend() {
        if (!that._applyingChanges) {
          that._suspendChanges();
        }
      },
      resume: function resume() {
        if (!that._applyingChanges) {
          that._resumeChanges();
        }
      },
      change: function change(codes) {
        that._change(codes);
      },
      settings: [{}, {}],
      calculateState: that._handlers.calculateState,
      calculateLabelState: _common.buildTextAppearance
    };
    that._root = that._topNode = {
      nodes: []
    };
    that.callBase.apply(that, arguments);
  },
  _initialChanges: ['DATA_SOURCE'],
  _initCore: function _initCore() {
    var that = this;
    var renderer = that._renderer;
    that._createProxyType();
    that._tilesGroup = renderer.g().linkOn(renderer.root, 'tiles').linkAppend();
    that._labelsGroup = renderer.g().linkOn(renderer.root, 'labels').linkAppend();
  },
  _createProxyType: _common2.noop,
  _disposeCore: function _disposeCore() {
    var that = this;
    that._filter && that._filter.dispose();
    that._labelsGroup.linkOff();
    that._tilesGroup.linkOff();
  },
  _applySize: function _applySize(rect) {
    this._tilingRect = rect.slice();
    this._change(['TILING']);
  },
  _optionChangesMap: {
    dataSource: 'DATA_SOURCE',
    valueField: 'NODES_CREATE',
    childrenField: 'NODES_CREATE',
    colorField: 'TILES',
    colorizer: 'TILES',
    labelField: 'LABELS',
    tile: 'TILE_SETTINGS',
    group: 'GROUP_SETTINGS',
    maxDepth: 'MAX_DEPTH',
    layoutAlgorithm: 'TILING',
    layoutDirection: 'TILING'
  },
  _themeDependentChanges: ['TILE_SETTINGS', 'GROUP_SETTINGS', 'MAX_DEPTH'],
  _changeDataSource: function _changeDataSource() {
    var that = this;
    that._isDataExpected = that._isSyncData = true;
    that._updateDataSource();
    that._isSyncData = false;
    if (that._isDataExpected) {
      that._suspendChanges();
    }
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    var that = this;
    if (that._isDataExpected) {
      that._isDataExpected = false;
      that._change(['NODES_CREATE']);
      if (!that._isSyncData) {
        that._resumeChanges();
      }
    } else {
      that._requestChange(['NODES_CREATE']);
    }
  },
  _optionChangesOrder: ['DATA_SOURCE', 'TILE_SETTINGS', 'GROUP_SETTINGS', 'MAX_DEPTH'],
  _change_DATA_SOURCE: function _change_DATA_SOURCE() {
    this._changeDataSource();
  },
  _change_TILE_SETTINGS: function _change_TILE_SETTINGS() {
    this._changeTileSettings();
  },
  _change_GROUP_SETTINGS: function _change_GROUP_SETTINGS() {
    this._changeGroupSettings();
  },
  _change_MAX_DEPTH: function _change_MAX_DEPTH() {
    this._changeMaxDepth();
  },
  _customChangesOrder: ['NODES_CREATE', 'NODES_RESET', 'TILES', 'LABELS', 'TILING', 'LABELS_LAYOUT'],
  _change_NODES_CREATE: function _change_NODES_CREATE() {
    this._buildNodes();
  },
  _change_NODES_RESET: function _change_NODES_RESET() {
    this._resetNodes();
  },
  _change_TILES: function _change_TILES() {
    this._applyTilesAppearance();
  },
  _change_LABELS: function _change_LABELS() {
    this._applyLabelsAppearance();
  },
  _change_TILING: function _change_TILING() {
    this._performTiling();
  },
  _change_LABELS_LAYOUT: function _change_LABELS_LAYOUT() {
    this._performLabelsLayout();
  },
  _applyChanges: function _applyChanges() {
    var that = this;
    that.callBase.apply(that, arguments);
    // This looks dirty.
    if (!that._isDataExpected) {
      that._drawn();
    }
    // Looks dirty but let it stay so until there is only one such case.
    that._context.forceReset = false;
  },
  _buildNodes: function _buildNodes() {
    var that = this;
    var root = that._root = that._topNode = new _node.default();
    root._id = 0;
    root.parent = {};
    root.data = {};
    root.level = root.index = -1;
    root.ctx = that._context;
    root.label = null;
    that._nodes = [root];
    that._handlers.beginBuildNodes();
    var processedData = that._processDataSourceItems(that._dataSourceItems() || []);
    traverseDataItems(root, processedData.items, 0, {
      itemsField: !processedData.isPlain && that._getOption('childrenField', true) || 'items',
      valueField: that._getOption('valueField', true) || 'value',
      buildNode: that._handlers.buildNode,
      ctx: that._context,
      nodes: that._nodes
    });
    that._onNodesCreated();
    that._handlers.endBuildNodes();
    that._change(['NODES_RESET']);
  },
  _onNodesCreated: _common2.noop,
  _processDataSourceItems: function _processDataSourceItems(items) {
    return {
      items: items,
      isPlain: false
    };
  },
  _changeTileSettings: function _changeTileSettings() {
    var that = this;
    var options = that._getOption('tile');
    var offsets = that._rectOffsets;
    var borderWidth = pickPositiveInteger(options.border.width);
    var edgeOffset = borderWidth / 2;
    var innerOffset = borderWidth & 1 ? 0.5 : 0;
    var labelOptions = options.label;
    var settings = that._context.settings[0];
    that._change(['TILES', 'LABELS']);
    settings.state = that._handlers.calculateState(options);
    // TODO: There should be some way (option) to prevent filter creation
    that._filter = that._filter || that._renderer.shadowFilter('-50%', '-50%', '200%', '200%');
    that._filter.attr(labelOptions.shadow);
    that._calculateLabelSettings(settings, labelOptions, that._filter.id);
    if (offsets.tileEdge !== edgeOffset || offsets.tileInner !== innerOffset) {
      offsets.tileEdge = edgeOffset;
      offsets.tileInner = innerOffset;
      that._change(['TILING']);
    }
  },
  _changeGroupSettings: function _changeGroupSettings() {
    var that = this;
    var options = that._getOption('group');
    var labelOptions = options.label;
    var offsets = that._rectOffsets;
    var borderWidth = pickPositiveInteger(options.border.width);
    var edgeOffset = borderWidth / 2;
    var innerOffset = borderWidth & 1 ? 0.5 : 0;
    var headerHeight = 0;
    var groupPadding = pickPositiveInteger(options.padding);
    var settings = that._context.settings[1];
    that._change(['TILES', 'LABELS']);
    settings.state = that._handlers.calculateState(options);
    that._calculateLabelSettings(settings, labelOptions);
    if (options.headerHeight >= 0) {
      headerHeight = pickPositiveInteger(options.headerHeight);
    } else {
      headerHeight = settings.labelParams.height + 2 * pickPositiveInteger(labelOptions.paddingTopBottom);
    }
    if (that._headerHeight !== headerHeight) {
      that._headerHeight = headerHeight;
      that._change(['TILING']);
    }
    if (that._groupPadding !== groupPadding) {
      that._groupPadding = groupPadding;
      that._change(['TILING']);
    }
    if (offsets.headerEdge !== edgeOffset || offsets.headerInner !== innerOffset) {
      offsets.headerEdge = edgeOffset;
      offsets.headerInner = innerOffset;
      that._change(['TILING']);
    }
  },
  _calculateLabelSettings: function _calculateLabelSettings(settings, options, filter) {
    var bBox = this._getTextBBox(options.font);
    var paddingLeftRight = pickPositiveInteger(options.paddingLeftRight);
    var paddingTopBottom = pickPositiveInteger(options.paddingTopBottom);
    var tileLabelOptions = this._getOption('tile.label');
    var groupLabelOptions = this._getOption('group.label');
    settings.labelState = (0, _common.buildTextAppearance)(options, filter);
    settings.labelState.visible = !('visible' in options) || !!options.visible;
    settings.labelParams = {
      height: bBox.height,
      rtlEnabled: this._getOption('rtlEnabled', true),
      paddingTopBottom: paddingTopBottom,
      paddingLeftRight: paddingLeftRight,
      tileLabelWordWrap: tileLabelOptions.wordWrap,
      tileLabelOverflow: tileLabelOptions.textOverflow,
      groupLabelOverflow: groupLabelOptions.textOverflow
    };
  },
  _changeMaxDepth: function _changeMaxDepth() {
    var maxDepth = this._getOption('maxDepth', true);
    maxDepth = maxDepth >= 1 ? Math.round(maxDepth) : Infinity;
    if (this._maxDepth !== maxDepth) {
      this._maxDepth = maxDepth;
      this._change(['NODES_RESET']);
    }
  },
  _resetNodes: function _resetNodes() {
    var that = this;
    that._tilesGroup.clear();
    that._renderer.initDefsElements();
    that._context.forceReset = true;
    that._context.minLevel = that._topNode.level + 1;
    that._context.maxLevel = that._context.minLevel + that._maxDepth - 1;
    that._change(['TILES', 'LABELS', 'TILING']);
  },
  _processNodes: function _processNodes(context, process) {
    processNodes(context, this._topNode, process);
  },
  _applyTilesAppearance: function _applyTilesAppearance() {
    var that = this;
    // Passing *themeManager* looks dirty but is excused by necessity of palettes (and default palette specifically).
    // Passing *topNode* looks awfully dirty and is performed only because of discrete group colorizing.
    // Aforementioned colorizing requires breadth-first tree traversal and nodes processing is performed in a depth-first order.
    // TODO: Find a way to stop passing *topNode*
    var colorizer = (0, _colorizing.getColorizer)(that._getOption('colorizer'), that._themeManager, that._topNode);
    that._processNodes({
      renderer: that._renderer,
      group: that._tilesGroup,
      setTrackerData: that._handlers.setTrackerData,
      colorField: that._getOption('colorField', true) || 'color',
      getColor: colorizer
    }, processTileAppearance);
  },
  _applyLabelsAppearance: function _applyLabelsAppearance() {
    var that = this;
    that._labelsGroup.clear();
    that._processNodes({
      renderer: that._renderer,
      group: that._labelsGroup,
      setTrackerData: that._handlers.setTrackerData,
      labelField: that._getOption('labelField', true) || 'name'
    }, processLabelAppearance);
    // Actually that is strange - for example if just "font.color" is changed then there is no need to layout labels.
    // But for <text> element can change its size because of rather many reasons - so for simplicity layout is always performed.
    that._change(['LABELS_LAYOUT']);
  },
  _performTiling: function _performTiling() {
    var that = this;
    var context = {
      algorithm: (0, _tiling.getAlgorithm)(that._getOption('layoutAlgorithm', true)),
      directions: directions[String(that._getOption('layoutDirection', true)).toLowerCase()] || directions['lefttoprightbottom'],
      headerHeight: that._headerHeight,
      groupPadding: that._groupPadding,
      rectOffsets: that._rectOffsets
    };
    that._topNode.innerRect = that._tilingRect;
    calculateRects(context, that._topNode);
    that._processNodes(context, processTiling);
    that._change(['LABELS_LAYOUT']);
    that._onTilingPerformed();
  },
  _onTilingPerformed: _common2.noop,
  _performLabelsLayout: function _performLabelsLayout() {
    this._processNodes(null, processLabelsLayout);
  },
  _getTextBBox: function _getTextBBox(fontOptions) {
    var renderer = this._renderer;
    var text = this._textForCalculations || renderer.text('0', 0, 0);
    this._textForCalculations = text;
    text.css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);
    var bBox = text.getBBox();
    text.remove();
    return bBox;
  }
});
function traverseDataItems(root, dataItems, level, params) {
  var nodes = [];
  var allNodes = params.nodes;
  var node;
  var i;
  var ii = dataItems.length;
  var dataItem;
  var totalValue = 0;
  var items;
  for (i = 0; i < ii; ++i) {
    var _items;
    dataItem = dataItems[i];
    node = new _node.default();
    node._id = allNodes.length;
    node.ctx = params.ctx;
    node.parent = root;
    node.level = level;
    node.index = nodes.length;
    node.data = dataItem;
    params.buildNode(node);
    allNodes.push(node);
    nodes.push(node);
    items = dataItem[params.itemsField];
    if ((_items = items) !== null && _items !== void 0 && _items.length) {
      traverseDataItems(node, items, level + 1, params);
    }
    if (dataItem[params.valueField] > 0) {
      node.value = Number(dataItem[params.valueField]);
    }
    totalValue += node.value;
  }
  root.nodes = nodes;
  root.value = totalValue;
}
function processNodes(context, root, process) {
  var nodes = root.nodes;
  var node;
  var i;
  var ii = nodes.length;
  for (i = 0; i < ii; ++i) {
    node = nodes[i];
    process(context, node);
    if (node.isNode()) {
      processNodes(context, node, process);
    }
  }
}
var createTile = [createLeaf, createGroup];
function processTileAppearance(context, node) {
  node.color = node.data[context.colorField] || context.getColor(node) || node.parent.color;
  node.updateStyles();
  node.tile = !node.ctx.forceReset && node.tile || createTile[Number(node.isNode())](context, node);
  node.applyState();
}
function createLeaf(context, node) {
  var tile = context.renderer.simpleRect().append(context.group);
  context.setTrackerData(node, tile);
  return tile;
}
function createGroup(context, node) {
  var outer = context.renderer.simpleRect().append(context.group);
  var inner = context.renderer.simpleRect().append(context.group);
  context.setTrackerData(node, inner);
  return {
    outer: outer,
    inner: inner
  };
}
function processLabelAppearance(context, node) {
  node.updateLabelStyle();
  if (node.labelState.visible) {
    createLabel(context, node, node.labelState, node.labelParams);
  }
}
function createLabel(context, currentNode, settings, params) {
  var textData = currentNode.data[context.labelField];
  currentNode.label = textData ? String(textData) : null;
  textData = currentNode.customLabel || currentNode.label;
  if (textData) {
    currentNode.text = context.renderer.text(textData).attr(settings.attr).css(settings.css).append(context.group);
    context.setTrackerData(currentNode, currentNode.text);
  }
}
var emptyRect = [0, 0, 0, 0];
function calculateRects(context, root) {
  var nodes = root.nodes;
  var items = [];
  var rects = [];
  var sum = 0;
  var i;
  var ii = items.length = rects.length = nodes.length;
  for (i = 0; i < ii; ++i) {
    sum += nodes[i].value;
    items[i] = {
      value: nodes[i].value,
      i: i
    };
  }
  if (sum > 0) {
    context.algorithm({
      items: items.slice(),
      sum: sum,
      rect: root.innerRect.slice(),
      isRotated: nodes[0].level & 1,
      directions: context.directions
    });
  }
  for (i = 0; i < ii; ++i) {
    rects[i] = items[i].rect || emptyRect;
  }
  root.rects = rects;
}
function processTiling(context, node) {
  var rect = node.parent.rects[node.index];
  var rectOffsets = context.rectOffsets;
  var headerHeight;
  if (node.isNode()) {
    setRectAttrs(node.tile.outer, buildTileRect(rect, node.parent.innerRect, rectOffsets.headerEdge, rectOffsets.headerInner));
    rect = marginateRect(rect, context.groupPadding);
    headerHeight = Math.min(context.headerHeight, rect[3] - rect[1]);
    node.rect = [rect[0], rect[1], rect[2], rect[1] + headerHeight];
    setRectAttrs(node.tile.inner, marginateRect(node.rect, rectOffsets.headerEdge));
    rect[1] += headerHeight;
    node.innerRect = rect;
    calculateRects(context, node);
  } else {
    node.rect = rect;
    setRectAttrs(node.tile, buildTileRect(rect, node.parent.innerRect, rectOffsets.tileEdge, rectOffsets.tileInner));
  }
}
function marginateRect(rect, margin) {
  return [rect[0] + margin, rect[1] + margin, rect[2] - margin, rect[3] - margin];
}
function buildTileRect(rect, outer, edgeOffset, innerOffset) {
  return [rect[0] + (rect[0] === outer[0] ? edgeOffset : +innerOffset), rect[1] + (rect[1] === outer[1] ? edgeOffset : +innerOffset), rect[2] - (rect[2] === outer[2] ? edgeOffset : -innerOffset), rect[3] - (rect[3] === outer[3] ? edgeOffset : -innerOffset)];
}
function setRectAttrs(element, rect) {
  element.attr({
    x: rect[0],
    y: rect[1],
    width: _max(rect[2] - rect[0], 0),
    height: _max(rect[3] - rect[1], 0)
  });
}
function processLabelsLayout(context, node) {
  if (node.text && node.labelState.visible) {
    layoutTextNode(node, node.labelParams);
  }
}
function layoutTextNode(node, params) {
  var rect = node.rect;
  var text = node.text;
  var bBox = text.getBBox();
  var paddingLeftRight = params.paddingLeftRight;
  var paddingTopBottom = params.paddingTopBottom;
  var effectiveWidth = rect[2] - rect[0] - 2 * paddingLeftRight;
  text.setMaxSize(effectiveWidth, rect[3] - rect[1] - paddingTopBottom, node.isNode() ? {
    textOverflow: params.groupLabelOverflow,
    wordWrap: 'none'
  } : {
    textOverflow: params.tileLabelOverflow,
    wordWrap: params.tileLabelWordWrap,
    hideOverflowEllipsis: true
  });
  text.move(params.rtlEnabled ? rect[2] - paddingLeftRight - bBox.x - bBox.width : rect[0] + paddingLeftRight - bBox.x, rect[1] + paddingTopBottom - bBox.y);
}
(0, _component_registrator.default)('dxTreeMap', dxTreeMap);
var _default = dxTreeMap; // PLUGINS_SECTION
exports["default"] = _default;
dxTreeMap.addPlugin(_data_source.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 4080:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _tree_map = _interopRequireDefault(__webpack_require__(49983));
__webpack_require__(46576);
__webpack_require__(20957);
__webpack_require__(56369);
__webpack_require__(36061);
__webpack_require__(66831);
__webpack_require__(13652);
__webpack_require__(73675);
__webpack_require__(4815);
__webpack_require__(9888);
__webpack_require__(13099);
__webpack_require__(2322);
__webpack_require__(66681);
__webpack_require__(61104);
__webpack_require__(74958);
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _loading_indicator = __webpack_require__(64758);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _tree_map.default; // PLUGINS_SECTION
exports["default"] = _default;
_tree_map.default.addPlugin(_export.plugin);
_tree_map.default.addPlugin(_title.plugin);
_tree_map.default.addPlugin(_loading_indicator.plugin);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 34434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.prepareSegmentRectPoints = void 0;
Object.defineProperty(exports, "refreshPaths", ({
  enumerable: true,
  get: function get() {
    return _renderer.refreshPaths;
  }
}));
var _renderer = __webpack_require__(56453);
var _iterator = __webpack_require__(95479);
// 'var' because JSHint throws W021 error
var prepareSegmentRectPoints = function prepareSegmentRectPoints(left, top, width, height, borderOptions) {
  var maxSW = ~~((width < height ? width : height) / 2);
  var sw = borderOptions.width || 0;
  var newSW = sw < maxSW ? sw : maxSW;
  left = left + newSW / 2;
  top = top + newSW / 2;
  width = width - newSW;
  height = height - newSW;
  var right = left + width;
  var bottom = top + height;
  var points = [];
  var segments = [];
  var segmentSequence;
  var visiblyOpt = 0;
  var prevSegmentVisibility = 0;
  var allSegment = {
    top: [[left, top], [right, top]],
    right: [[right, top], [right, bottom]],
    bottom: [[right, bottom], [left, bottom]],
    left: [[left, bottom], [left, top]]
  };
  (0, _iterator.each)(allSegment, function (seg) {
    var visibility = !!borderOptions[seg];
    visiblyOpt = visiblyOpt * 2 + ~~visibility;
  });
  switch (visiblyOpt) {
    case 13:
    case 9:
      segmentSequence = ['left', 'top', 'right', 'bottom'];
      break;
    case 11:
      segmentSequence = ['bottom', 'left', 'top', 'right'];
      break;
    default:
      segmentSequence = ['top', 'right', 'bottom', 'left'];
  }
  (0, _iterator.each)(segmentSequence, function (_, seg) {
    var segmentVisibility = !!borderOptions[seg];
    if (!prevSegmentVisibility && segments.length) {
      points.push(segments);
      segments = [];
    }
    if (segmentVisibility) {
      (0, _iterator.each)(allSegment[seg].slice(prevSegmentVisibility), function (_, segment) {
        segments = segments.concat(segment);
      });
    }
    prevSegmentVisibility = ~~segmentVisibility;
  });
  segments.length && points.push(segments);
  points.length === 1 && (points = points[0]);
  return {
    points: points,
    pathType: visiblyOpt === 15 ? 'area' : 'line'
  };
};
exports.prepareSegmentRectPoints = prepareSegmentRectPoints;

/***/ }),

/***/ 81849:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _vector_map = _interopRequireDefault(__webpack_require__(13711));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = _vector_map.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 17323:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.ControlBar = ControlBar;
var _utils = __webpack_require__(19157);
var _utils2 = __webpack_require__(77891);
var _math = Math;
var _min = _math.min;
var _max = _math.max;
var _round = _math.round;
var _floor = _math.floor;
var _sqrt = _math.sqrt;
var parseHorizontalAlignment = (0, _utils.enumParser)(['left', 'center', 'right']);
var parseVerticalAlignment = (0, _utils.enumParser)(['top', 'bottom']);
var COMMAND_RESET = 'command-reset';
var COMMAND_MOVE_UP = 'command-move-up';
var COMMAND_MOVE_RIGHT = 'command-move-right';
var COMMAND_MOVE_DOWN = 'command-move-down';
var COMMAND_MOVE_LEFT = 'command-move-left';
var COMMAND_ZOOM_IN = 'command-zoom-in';
var COMMAND_ZOOM_OUT = 'command-zoom-out';
var COMMAND_ZOOM_DRAG_LINE = 'command-zoom-drag-line';
var COMMAND_ZOOM_DRAG = 'command-zoom-drag';
var EVENT_TARGET_TYPE = 'control-bar';
var FLAG_CENTERING = 1;
var FLAG_ZOOMING = 2;

// TODO: This should be specified in options - seems like everything can be calculated from "buttonSize" and "zoomSliderLength"
var SIZE_OPTIONS = {
  bigCircleSize: 58,
  smallCircleSize: 28,
  buttonSize: 10,
  arrowButtonOffset: 20,
  incDecButtonSize: 11,
  incButtonOffset: 66,
  decButtonOffset: 227,
  sliderLineStartOffset: 88.5,
  sliderLineEndOffset: 205.5,
  sliderLength: 20,
  sliderWidth: 8,
  trackerGap: 4
};
var OFFSET_X = 30.5;
var OFFSET_Y = 30.5;
var TOTAL_WIDTH = 61;
var TOTAL_HEIGHT = 274;
var COMMAND_TO_TYPE_MAP = {};
COMMAND_TO_TYPE_MAP[COMMAND_RESET] = ResetCommand;
COMMAND_TO_TYPE_MAP[COMMAND_MOVE_UP] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_RIGHT] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_DOWN] = COMMAND_TO_TYPE_MAP[COMMAND_MOVE_LEFT] = MoveCommand;
COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_IN] = COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_OUT] = ZoomCommand;
COMMAND_TO_TYPE_MAP[COMMAND_ZOOM_DRAG] = ZoomDragCommand;
function ControlBar(parameters) {
  var that = this;
  that._params = parameters;
  that._createElements(parameters.renderer, parameters.container, parameters.dataKey);
  parameters.layoutControl.addItem(that);
  that._subscribeToProjection(parameters.projection);
  that._subscribeToTracker(parameters.tracker);
  that._createCallbacks(parameters.projection);
}
ControlBar.prototype = {
  constructor: ControlBar,
  _flags: 0,
  dispose: function dispose() {
    var that = this;
    that._params.layoutControl.removeItem(that);
    that._root.linkRemove().linkOff();
    that._offProjection();
    that._offTracker();
    that._params = that._root = that._offProjection = that._offTracker = that._callbacks = null;
  },
  _subscribeToProjection: function _subscribeToProjection(projection) {
    var that = this;
    that._offProjection = projection.on({
      'engine': function engine() {
        that._update();
      },
      'zoom': updateZoom,
      'max-zoom': function maxZoom() {
        that._zoomPartition = projection.getZoomScalePartition();
        that._sliderUnitLength = that._sliderLineLength / that._zoomPartition;
        updateZoom();
      }
    });
    function updateZoom() {
      that._adjustZoom(projection.getScaledZoom());
    }
  },
  _subscribeToTracker: function _subscribeToTracker(tracker) {
    var that = this;
    var isActive = false;
    that._offTracker = tracker.on({
      'start': function start(arg) {
        isActive = arg.data.name === EVENT_TARGET_TYPE;
        if (isActive) {
          that._processStart(arg.data.index, arg);
        }
      },
      'move': function move(arg) {
        if (isActive) {
          that._processMove(arg.data.index, arg);
        }
      },
      'end': function end() {
        if (isActive) {
          that._processEnd();
          isActive = false;
        }
      }
    });
  },
  _createCallbacks: function _createCallbacks(projection) {
    var that = this;
    that._callbacks = {
      reset: function reset(isCenter, isZoom) {
        if (isCenter) {
          projection.setCenter(null);
        }
        if (isZoom) {
          projection.setZoom(null);
        }
      },
      beginMove: function beginMove() {
        projection.beginMoveCenter();
      },
      endMove: function endMove() {
        projection.endMoveCenter();
      },
      move: function move(shift) {
        projection.moveCenter(shift);
      },
      zoom: function zoom(_zoom) {
        projection.setScaledZoom(_zoom);
      }
    };
  },
  _createElements: function _createElements(renderer, container, dataKey) {
    var that = this;
    that._root = renderer.g().attr({
      'class': 'dxm-control-bar'
    }).linkOn(container, 'control-bar');
    var panControl = that._panControl = (0, _utils2.createVisibilityGroup)(renderer, that._root, 'dxm-pan-control');
    var zoomBar = that._zoomBar = (0, _utils2.createVisibilityGroup)(renderer, that._root, 'dxm-zoom-bar');
    var trackersPan = that._trackersPan = (0, _utils2.createTracker)(renderer, that._root);
    var trackersZoom = that._trackersZoom = (0, _utils2.createTracker)(renderer, that._root);
    that._createTrackersPan(renderer, dataKey, trackersPan);
    that._createTrackersZoom(renderer, dataKey, trackersZoom);
    that._createPanControl(renderer, dataKey, panControl);
    that._createZoomBar(renderer, dataKey, zoomBar);
  },
  _createPanControl: function _createPanControl(renderer, dataKey, group) {
    var options = SIZE_OPTIONS;
    var size = options.buttonSize / 2;
    var offset1 = options.arrowButtonOffset - size;
    var offset2 = options.arrowButtonOffset;
    var directionOptions = {
      'stroke-linecap': 'square',
      fill: 'none'
    };
    var line = 'line';
    renderer.circle(0, 0, options.bigCircleSize / 2).append(group);
    renderer.circle(0, 0, size).attr({
      fill: 'none'
    }).append(group);
    renderer.path([-size, -offset1, 0, -offset2, size, -offset1], line).attr(directionOptions).append(group);
    renderer.path([offset1, -size, offset2, 0, offset1, size], line).attr(directionOptions).append(group);
    renderer.path([size, offset1, 0, offset2, -size, offset1], line).attr(directionOptions).append(group);
    renderer.path([-offset1, size, -offset2, 0, -offset1, -size], line).attr(directionOptions).append(group);
  },
  _createZoomBar: function _createZoomBar(renderer, dataKey, group) {
    var that = this;
    var options = SIZE_OPTIONS;
    var incDecButtonSize = options.incDecButtonSize / 2;
    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).append(group);
    renderer.path([[-incDecButtonSize, options.incButtonOffset, incDecButtonSize, options.incButtonOffset], [0, options.incButtonOffset - incDecButtonSize, 0, options.incButtonOffset + incDecButtonSize]], 'area').append(group);
    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).append(group);
    renderer.path([-incDecButtonSize, options.decButtonOffset, incDecButtonSize, options.decButtonOffset], 'area').append(group);
    that._zoomLine = renderer.path([], 'line').append(group);
    that._zoomDrag = renderer.rect(_floor(-options.sliderLength / 2), _floor(options.sliderLineEndOffset - options.sliderWidth / 2), options.sliderLength, options.sliderWidth).append(group);
    that._sliderLineLength = options.sliderLineEndOffset - options.sliderLineStartOffset;
  },
  _createTrackersPan: function _createTrackersPan(renderer, dataKey, group) {
    var options = SIZE_OPTIONS;
    var size = _round((options.arrowButtonOffset - options.trackerGap) / 2);
    var offset1 = options.arrowButtonOffset - size;
    var offset2 = _round(_sqrt(options.bigCircleSize * options.bigCircleSize / 4 - size * size));
    var size2 = offset2 - offset1;
    renderer.rect(-size, -size, size * 2, size * 2).data(dataKey, {
      index: COMMAND_RESET,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-size, -offset2, size * 2, size2).data(dataKey, {
      index: COMMAND_MOVE_UP,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(offset1, -size, size2, size * 2).data(dataKey, {
      index: COMMAND_MOVE_RIGHT,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-size, offset1, size * 2, size2).data(dataKey, {
      index: COMMAND_MOVE_DOWN,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-offset2, -size, size2, size * 2).data(dataKey, {
      index: COMMAND_MOVE_LEFT,
      name: EVENT_TARGET_TYPE
    }).append(group);
  },
  _createTrackersZoom: function _createTrackersZoom(renderer, dataKey, group) {
    var options = SIZE_OPTIONS;
    renderer.circle(0, options.incButtonOffset, options.smallCircleSize / 2).data(dataKey, {
      index: COMMAND_ZOOM_IN,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.circle(0, options.decButtonOffset, options.smallCircleSize / 2).data(dataKey, {
      index: COMMAND_ZOOM_OUT,
      name: EVENT_TARGET_TYPE
    }).append(group);
    renderer.rect(-2, options.sliderLineStartOffset - 2, 4, options.sliderLineEndOffset - options.sliderLineStartOffset + 4).css({
      cursor: 'default'
    }).data(dataKey, {
      index: COMMAND_ZOOM_DRAG_LINE,
      name: EVENT_TARGET_TYPE
    }).append(group);
    this._zoomDragTracker = renderer.rect(-options.sliderLength / 2, options.sliderLineEndOffset - options.sliderWidth / 2, options.sliderLength, options.sliderWidth).data(dataKey, {
      index: COMMAND_ZOOM_DRAG,
      name: EVENT_TARGET_TYPE
    }).append(group);
  },
  // BEGIN: Implementation of LayoutTarget interface
  resize: function resize(size) {
    if (this._isActive) {
      this._root.attr({
        visibility: size !== null ? null : 'hidden'
      });
    }
  },
  getLayoutOptions: function getLayoutOptions() {
    return this._isActive ? this._layoutOptions : null;
  },
  locate: function locate(x, y) {
    this._root.attr({
      translateX: x + this._margin + OFFSET_X,
      translateY: y + this._margin + OFFSET_Y
    });
  },
  // END: Implementation of LayoutTarget interface

  _update: function _update() {
    var that = this;
    that._isActive = that._isEnabled && that._flags && that._params.projection.isInvertible();
    var groupPan = [that._panControl, that._trackersPan];
    var groupZoom = [that._zoomBar, that._trackersZoom];
    if (that._isActive) {
      that._root.linkAppend();
      (0, _utils2.toggleDisplay)(groupPan, that._isPanVisible);
      (0, _utils2.toggleDisplay)(groupZoom, that._isZoomVisible);
    } else {
      that._root.linkRemove();
    }
    that._processEnd();
    that.updateLayout();
  },
  setInteraction: function setInteraction(interaction) {
    var that = this;
    if ((0, _utils.parseScalar)(interaction.centeringEnabled, true)) {
      that._flags |= FLAG_CENTERING;
    } else {
      that._flags &= ~FLAG_CENTERING;
    }
    if ((0, _utils.parseScalar)(interaction.zoomingEnabled, true)) {
      that._flags |= FLAG_ZOOMING;
    } else {
      that._flags &= ~FLAG_ZOOMING;
    }
    that._update();
  },
  setOptions: function setOptions(options) {
    var that = this;
    var styleSvg = {
      'stroke-width': options.borderWidth,
      stroke: options.borderColor,
      fill: options.color,
      'fill-opacity': options.opacity
    };
    that._isEnabled = !!(0, _utils.parseScalar)(options.enabled, true);
    that._margin = options.margin || 0;
    that._layoutOptions = {
      width: 2 * that._margin + TOTAL_WIDTH,
      height: 2 * that._margin + TOTAL_HEIGHT,
      horizontalAlignment: parseHorizontalAlignment(options.horizontalAlignment, 'left'),
      verticalAlignment: parseVerticalAlignment(options.verticalAlignment, 'top')
    };
    that._isPanVisible = !!(0, _utils.parseScalar)(options.panVisible, true);
    that._isZoomVisible = !!(0, _utils.parseScalar)(options.zoomVisible, true);
    that._panControl.attr(styleSvg);
    that._zoomBar.attr(styleSvg);
    that._update();
  },
  _adjustZoom: function _adjustZoom(zoom) {
    var that = this;
    var start = SIZE_OPTIONS.sliderLineStartOffset;
    var end = SIZE_OPTIONS.sliderLineEndOffset;
    var h = SIZE_OPTIONS.sliderWidth;
    that._zoomFactor = _max(_min(_round(zoom), that._zoomPartition), 0);
    var transform = {
      translateY: -_round(that._zoomFactor * that._sliderUnitLength)
    };
    var y = end - h / 2 + transform.translateY;
    that._zoomLine.attr({
      points: [[0, start, 0, _max(start, y)], [0, _min(end, y + h), 0, end]]
    });
    that._zoomDrag.attr(transform);
    that._zoomDragTracker.attr(transform);
  },
  _applyZoom: function _applyZoom() {
    this._callbacks.zoom(this._zoomFactor);
  },
  _processStart: function _processStart(command, arg) {
    var commandType;
    if (this._isActive) {
      commandType = COMMAND_TO_TYPE_MAP[command];
      this._command = commandType && commandType.flags & this._flags ? new commandType(this, command, arg) : null;
    }
  },
  _processMove: function _processMove(command, arg) {
    this._command && this._command.update(command, arg);
  },
  _processEnd: function _processEnd() {
    this._command && this._command.finish();
    this._command = null;
  }
};
function disposeCommand(command) {
  delete command._owner;
  command.update = function () {};
  command.finish = function () {};
}
function ResetCommand(owner, command) {
  this._owner = owner;
  this._command = command;
}
ResetCommand.flags = FLAG_CENTERING | FLAG_ZOOMING;
ResetCommand.prototype.update = function (command) {
  command !== this._command && disposeCommand(this);
};
ResetCommand.prototype.finish = function () {
  var flags = this._owner._flags;
  this._owner._callbacks.reset(!!(flags & FLAG_CENTERING), !!(flags & FLAG_ZOOMING));
  disposeCommand(this);
};
function MoveCommand(owner, command, arg) {
  this._command = command;
  var timeout = null;
  var interval = 100;
  var dx = 0;
  var dy = 0;
  switch (this._command) {
    case COMMAND_MOVE_UP:
      dy = -10;
      break;
    case COMMAND_MOVE_RIGHT:
      dx = 10;
      break;
    case COMMAND_MOVE_DOWN:
      dy = 10;
      break;
    case COMMAND_MOVE_LEFT:
      dx = -10;
      break;
  }
  function callback() {
    owner._callbacks.move([dx, dy]);
    timeout = setTimeout(callback, interval);
  }
  this._stop = function () {
    clearTimeout(timeout);
    owner._callbacks.endMove();
    this._stop = owner = null;
    return this;
  };
  arg = null;
  owner._callbacks.beginMove();
  callback();
}
MoveCommand.flags = FLAG_CENTERING;
MoveCommand.prototype.update = function (command) {
  this._command !== command && this.finish();
};
MoveCommand.prototype.finish = function () {
  disposeCommand(this._stop());
};
function ZoomCommand(owner, command) {
  this._owner = owner;
  this._command = command;
  var timeout = null;
  var interval = 150;
  var dZoom = this._command === COMMAND_ZOOM_IN ? 1 : -1;
  function callback() {
    owner._adjustZoom(owner._zoomFactor + dZoom);
    timeout = setTimeout(callback, interval);
  }
  this._stop = function () {
    clearTimeout(timeout);
    this._stop = owner = null;
    return this;
  };
  callback();
}
ZoomCommand.flags = FLAG_ZOOMING;
ZoomCommand.prototype.update = function (command) {
  this._command !== command && this.finish();
};
ZoomCommand.prototype.finish = function () {
  this._owner._applyZoom();
  disposeCommand(this._stop());
};
function ZoomDragCommand(owner, command, arg) {
  this._owner = owner;
  this._zoomFactor = owner._zoomFactor;
  this._pos = arg.y;
}
ZoomDragCommand.flags = FLAG_ZOOMING;
ZoomDragCommand.prototype.update = function (command, arg) {
  var owner = this._owner;
  owner._adjustZoom(this._zoomFactor + owner._zoomPartition * (this._pos - arg.y) / owner._sliderLineLength);
};
ZoomDragCommand.prototype.finish = function () {
  this._owner._applyZoom();
  disposeCommand(this);
};

/***/ }),

/***/ 77891:
/***/ (function(__unused_webpack_module, exports) {



exports.toggleDisplay = exports.createVisibilityGroup = exports.createTracker = void 0;
var createTracker = function createTracker(renderer, root) {
  return renderer.g().attr({
    stroke: 'none',
    'stroke-width': 0,
    fill: '#000000',
    opacity: 0.0001
  }).css({
    cursor: 'pointer'
  }).append(root);
};
exports.createTracker = createTracker;
var createVisibilityGroup = function createVisibilityGroup(renderer, root) {
  var className = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return renderer.g().attr({
    'class': className
  }).append(root);
};
exports.createVisibilityGroup = createVisibilityGroup;
var toggleDisplay = function toggleDisplay(blocks, isVisible) {
  var cssDisplayBlock = {
    display: 'block'
  };
  var cssDisplayNone = {
    display: 'none'
  };
  var style = isVisible ? cssDisplayBlock : cssDisplayNone;
  blocks.map(function (item) {
    return item.css(style);
  });
};
exports.toggleDisplay = toggleDisplay;

/***/ }),

/***/ 93699:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.DataExchanger = DataExchanger;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function DataExchanger() {
  this._store = {};
}
DataExchanger.prototype = {
  constructor: DataExchanger,
  dispose: function dispose() {
    this._store = null;
    return this;
  },
  _get: function _get(category, name) {
    var store = this._store[category] || (this._store[category] = {});
    return store[name] || (store[name] = {
      callbacks: (0, _callbacks.default)()
    });
  },
  set: function set(category, name, data) {
    var item = this._get(category, name);
    item.data = data;
    item.callbacks.fire(data);
    return this;
  },
  bind: function bind(category, name, callback) {
    var item = this._get(category, name);
    item.callbacks.add(callback);
    item.data && callback(item.data);
    return this;
  },
  unbind: function unbind(category, name, callback) {
    var item = this._get(category, name);
    item.callbacks.remove(callback);
    return this;
  }
};

/***/ }),

/***/ 63832:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.makeEventEmitter = makeEventEmitter;
var _callbacks = _interopRequireDefault(__webpack_require__(44504));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var eventEmitterMethods = {
  _initEvents: function _initEvents() {
    var names = this._eventNames;
    var i;
    var ii = names.length;
    var events = this._events = {};
    for (i = 0; i < ii; ++i) {
      events[names[i]] = (0, _callbacks.default)();
    }
  },
  _disposeEvents: function _disposeEvents() {
    var events = this._events;
    var name;
    for (name in events) {
      events[name].empty();
    }
    this._events = null;
  },
  on: function on(handlers) {
    var events = this._events;
    var name;
    for (name in handlers) {
      events[name].add(handlers[name]);
    }
    return dispose;
    function dispose() {
      for (name in handlers) {
        events[name].remove(handlers[name]);
      }
    }
  },
  _fire: function _fire(name, arg) {
    this._events[name].fire(arg);
  }
};
function makeEventEmitter(target) {
  var proto = target.prototype;
  var name;
  for (name in eventEmitterMethods) {
    proto[name] = eventEmitterMethods[name];
  }
}

/***/ }),

/***/ 3797:
/***/ (function(__unused_webpack_module, exports) {



exports.GestureHandler = GestureHandler;
var _ln = Math.log;
var _LN2 = Math.LN2;
function GestureHandler(params) {
  var that = this;
  that._projection = params.projection;
  that._renderer = params.renderer;
  that._x = that._y = 0;
  that._subscribeToTracker(params.tracker);
}
GestureHandler.prototype = {
  constructor: GestureHandler,
  dispose: function dispose() {
    this._offTracker();
    this._offTracker = null;
  },
  _subscribeToTracker: function _subscribeToTracker(tracker) {
    var that = this;
    var isActive = false;
    that._offTracker = tracker.on({
      'start': function start(arg) {
        // TODO: This is an implicit dependency on the ControlBar which must be removed
        isActive = arg.data.name !== 'control-bar';
        if (isActive) {
          that._processStart(arg);
        }
      },
      'move': function move(arg) {
        if (isActive) {
          that._processMove(arg);
        }
      },
      'end': function end() {
        if (isActive) {
          that._processEnd();
        }
      },
      'zoom': function zoom(arg) {
        that._processZoom(arg);
      }
    });
  },
  setInteraction: function setInteraction(options) {
    this._processEnd();
    this._centeringEnabled = options.centeringEnabled;
    this._zoomingEnabled = options.zoomingEnabled;
  },
  _processStart: function _processStart(arg) {
    if (this._centeringEnabled) {
      this._x = arg.x;
      this._y = arg.y;
      this._projection.beginMoveCenter();
    }
  },
  _processMove: function _processMove(arg) {
    var that = this;
    if (that._centeringEnabled) {
      that._renderer.root.attr({
        cursor: 'move'
      });
      that._projection.moveCenter([that._x - arg.x, that._y - arg.y]);
      that._x = arg.x;
      that._y = arg.y;
    }
  },
  _processEnd: function _processEnd() {
    if (this._centeringEnabled) {
      this._renderer.root.attr({
        cursor: 'default'
      });
      this._projection.endMoveCenter();
    }
  },
  _processZoom: function _processZoom(arg) {
    var that = this;
    var delta;
    var screenPosition;
    var coords;
    if (that._zoomingEnabled) {
      if (arg.delta) {
        delta = arg.delta;
      } else if (arg.ratio) {
        delta = _ln(arg.ratio) / _LN2;
      }
      if (that._centeringEnabled) {
        screenPosition = that._renderer.getRootOffset();
        screenPosition = [arg.x - screenPosition.left, arg.y - screenPosition.top];
        coords = that._projection.fromScreenPoint(screenPosition);
      }
      that._projection.changeScaledZoom(delta);
      if (that._centeringEnabled) {
        that._projection.setCenterByPoint(coords, screenPosition);
      }
    }
  }
};

/***/ }),

/***/ 39378:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LayoutControl = LayoutControl;
var _iterator = __webpack_require__(95479);
var _round = Math.round;
var _min = Math.min;
var _max = Math.max;
var _each = _iterator.each;
var horizontalAlignmentMap = {
  'left': 0,
  'center': 1,
  'right': 2
};
var verticalAlignmentMap = {
  'top': 0,
  'bottom': 1
};
function getCellIndex(options) {
  return verticalAlignmentMap[options.verticalAlignment] * 3 + horizontalAlignmentMap[options.horizontalAlignment];
}
function createCells(canvas, items) {
  var hStep = (canvas.right - canvas.left) / 3;
  var vStep = (canvas.bottom - canvas.top) / 2;
  var h1 = canvas.left;
  var h2 = _round(h1 + hStep);
  var h3 = _round(h1 + hStep + hStep);
  var h4 = canvas.right;
  var v1 = canvas.top;
  var v2 = _round(v1 + vStep);
  var v3 = canvas.bottom;
  var cells = [{
    rect: [h1, v1, h2, v2]
  }, {
    rect: [h2, v1, h3, v2],
    center: true
  }, {
    rect: [h3, v1, h4, v2],
    horInversion: true
  }, {
    rect: [h1, v2, h2, v3],
    verInversion: true
  }, {
    rect: [h2, v2, h3, v3],
    center: true,
    verInversion: true
  }, {
    rect: [h3, v2, h4, v3],
    horInversion: true,
    verInversion: true
  }];
  var itemsList = [[], [], [], [], [], []];
  _each(items, function (_, item) {
    var options = item.getLayoutOptions();
    if (options) {
      itemsList[getCellIndex(options)].push({
        item: item,
        width: options.width,
        height: options.height
      });
    }
  });
  _each(cells, function (i, cell) {
    if (itemsList[i].length) {
      cell.items = itemsList[i];
    } else {
      if (cell.center) {
        cell.rect[0] = cell.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
      } else {
        cell.rect[cell.horInversion ? 0 : 2] = cell.rect[cell.horInversion ? 2 : 0];
      }
      cell.rect[cell.verInversion ? 1 : 3] = cell.rect[cell.verInversion ? 3 : 1];
    }
  });
  return cells;
}
function adjustCellSizes(cells) {
  _each([0, 1, 2, 3, 4, 5], function (_, index) {
    var cell = cells[index];
    var otherCell = cells[(index + 3) % 6];
    if (cell.items) {
      if (!otherCell.items) {
        cell.rect[1] = _min(cell.rect[1], otherCell.rect[3]);
        cell.rect[3] = _max(cell.rect[3], otherCell.rect[1]);
      }
    }
  });
  _each([1, 4], function (_, index) {
    var cell = cells[index];
    var otherCell1 = cells[index - 1];
    var otherCell2 = cells[index + 1];
    var size1;
    var size2;
    if (cell.items) {
      if (!otherCell1.items && !otherCell2.items) {
        size1 = cell.rect[0] - otherCell1.rect[2];
        size2 = otherCell2.rect[0] - cell.rect[2];
        if (size1 > size2) {
          if (size1 / size2 >= 2) {
            cell.rect[0] -= size1;
            cell.right = true;
          } else {
            cell.rect[0] -= size2;
            cell.rect[2] += size2;
          }
        } else {
          if (size2 / size1 >= 2) {
            cell.rect[2] += size2;
            cell.center = null;
          } else {
            cell.rect[0] -= size1;
            cell.rect[2] += size1;
          }
        }
      }
    } else {
      if (otherCell1.items) {
        otherCell1.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;
      }
      if (otherCell2.items) {
        otherCell2.rect[0] = (cell.rect[0] + cell.rect[2]) / 2;
      }
    }
  });
}
function adjustCellsAndApplyLayout(cells, forceMode) {
  var hasHiddenItems = false;
  adjustCellSizes(cells);
  _each(cells, function (_, cell) {
    if (cell.items) {
      hasHiddenItems = applyCellLayout(cell, forceMode) || hasHiddenItems;
    }
  });
  return hasHiddenItems;
}
function applyCellLayout(cell, forceMode) {
  var cellRect = cell.rect;
  var cellWidth = cellRect[2] - cellRect[0];
  var cellHeight = cellRect[3] - cellRect[1];
  var xOffset = 0;
  var yOffset = 0;
  var currentHeight = 0;
  var totalL = cellRect[2];
  var totalT = cellRect[3];
  var totalR = cellRect[0];
  var totalB = cellRect[1];
  var moves = [];
  var hasHiddenItems = false;
  _each(cell.items, function (_, item) {
    if (item.width > cellWidth || item.height > cellHeight) {
      moves.push(null);
      hasHiddenItems = true;
      return forceMode || false;
    }
    if (xOffset + item.width > cellWidth) {
      yOffset += currentHeight;
      xOffset = currentHeight = 0;
    }
    if (yOffset + item.height > cellHeight) {
      moves.push(null);
      hasHiddenItems = true;
      return forceMode || false;
    }
    currentHeight = _max(currentHeight, item.height);
    var dx = cell.horInversion ? cellRect[2] - item.width - xOffset : cellRect[0] + xOffset;
    var dy = cell.verInversion ? cellRect[3] - item.height - yOffset : cellRect[1] + yOffset;
    xOffset += item.width;
    totalL = _min(totalL, dx);
    totalT = _min(totalT, dy);
    totalR = _max(totalR, dx + item.width);
    totalB = _max(totalB, dy + item.height);
    moves.push([dx, dy]);
  });
  if (forceMode || !hasHiddenItems) {
    xOffset = 0;
    if (cell.right) {
      xOffset = cellRect[2] - cellRect[0] - totalR + totalL;
    } else if (cell.center) {
      xOffset = _round((cellRect[2] - cellRect[0] - totalR + totalL) / 2);
    }
    _each(cell.items, function (i, item) {
      var move = moves[i];
      if (move) {
        item.item.locate(move[0] + xOffset, move[1]);
      } else {
        item.item.resize(null);
      }
    });
    cell.rect = [totalL, totalT, totalR, totalB];
    cell.items = null;
  }
  return hasHiddenItems;
}
function applyLayout(canvas, items) {
  var cells = createCells(canvas, items);
  if (adjustCellsAndApplyLayout(cells)) {
    adjustCellsAndApplyLayout(cells, true);
  }
}
function LayoutControl(widget) {
  var that = this;
  that._items = [];
  that._suspended = 0;
  that._widget = widget;
  that._updateLayout = function () {
    that._update();
  };
}
LayoutControl.prototype = {
  constructor: LayoutControl,
  dispose: function dispose() {
    this._items = this._updateLayout = null;
  },
  setSize: function setSize(canvas) {
    this._canvas = canvas;
    this._update();
  },
  suspend: function suspend() {
    ++this._suspended;
  },
  resume: function resume() {
    if (--this._suspended === 0) {
      this._update();
    }
  },
  // It should return callback (update trigger) instead of injecting the argument
  addItem: function addItem(item) {
    this._items.push(item);
    item.updateLayout = this._updateLayout;
  },
  removeItem: function removeItem(item) {
    var index = this._items.indexOf(item);
    this._items.splice(index, 1);
    item.updateLayout = null;
  },
  _update: function _update() {
    var canvas;
    if (this._suspended === 0) {
      canvas = this._canvas;
      _each(this._items, function (_, item) {
        item.resize(canvas);
      });
      this._widget.resolveItemsDeferred(this._items.filter(function (el) {
        return el.getTemplatesGroups && el.getTemplatesDef;
      }));
      applyLayout({
        left: canvas.left,
        top: canvas.top,
        right: canvas.width + canvas.left,
        bottom: canvas.height + canvas.top
      }, this._items);
    }
  }
};

/***/ }),

/***/ 7291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.LegendsControl = LegendsControl;
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _object = __webpack_require__(48013);
var _legend = __webpack_require__(16342);
var _extend = _extend2.extend;
var _each = _iterator.each;
var unknownSource = {
  category: 'UNKNOWN',
  name: 'UNKNOWN'
};
function buildData(partition, values, field) {
  var i;
  var ii = values.length;
  var list = [];
  var item;
  for (i = 0; i < ii; ++i) {
    list[i] = item = {
      start: partition[i],
      end: partition[i + 1],
      index: i
    };
    item[field] = values[i];
    item.states = {
      normal: {
        fill: item.color
      }
    };
    item.visible = true;
  }
  return list;
}

// 'var' because JSHint throws W021 error
var Legend = function Legend(parameters) {
  var that = this;
  that._params = parameters;
  that._root = parameters.renderer.g().attr({
    'class': 'dxm-legend'
  }).linkOn(parameters.container, {
    name: 'legend',
    after: 'legend-base'
  }).enableLinks().linkAppend();
  parameters.layoutControl.addItem(that);
  _legend.Legend.call(that, {
    renderer: parameters.renderer,
    widget: parameters.widget,
    group: that._root,
    backgroundClass: null,
    itemsGroupClass: null,
    textField: 'text',
    getFormatObject: function getFormatObject(data) {
      return data;
    }
  });
  that._onDataChanged = function (data) {
    that._updateData(data);
  };
};
Legend.prototype = _extend((0, _object.clone)(_legend.Legend.prototype), {
  constructor: Legend,
  dispose: function dispose() {
    var that = this;
    that._params.layoutControl.removeItem(that);
    that._unbindData();
    that._root.linkRemove().linkOff();
    that._params = that._root = that._onDataChanged = null;
    return _legend.Legend.prototype.dispose.apply(that, arguments);
  },
  // This method is called only by the layout
  resize: function resize(size) {
    this._params.notifyDirty();
    if (size === null) {
      this.erase();
    } else {
      this.draw(size.width, size.height);
    }
    this._params.notifyReady();
  },
  locate: _legend.Legend.prototype.shift,
  _updateData: function _updateData(data) {
    this._options.defaultColor = data && data.defaultColor;
    this.update(data ? buildData(data.partition, data.values, this._dataName) : [], this._options, this._params.themeManager.theme('legend').title);
    this.updateLayout();
  },
  _unbindData: function _unbindData() {
    if (this._dataCategory) {
      this._params.dataExchanger.unbind(this._dataCategory, this._dataName, this._onDataChanged);
    }
  },
  _bindData: function _bindData(arg) {
    this._params.dataExchanger.bind(this._dataCategory = arg.category, this._dataName = arg.name, this._onDataChanged);
  },
  // The `_root` should be appended or removed here but there is no way to check if core.Legend is actually enabled or not
  setOptions: function setOptions(options) {
    var that = this;
    that.update(that._data, options, this._params.themeManager.theme('legend').title);
    that._unbindData();
    var source = options.source;
    that._bindData(source ? {
      category: source.layer,
      name: source.grouping
    } : unknownSource);
    that.updateLayout();
    return that;
  }
});
function LegendsControl(parameters) {
  this._params = parameters;
  this._items = [];
  parameters.container.virtualLink('legend-base');
}
LegendsControl.prototype = {
  constructor: LegendsControl,
  dispose: function dispose() {
    _each(this._items, function (_, item) {
      item.dispose();
    });
    this._params = this._items = null;
  },
  setOptions: function setOptions(options) {
    var optionList = options && options.length ? options : [];
    var items = this._items;
    var i;
    var ii = optionList.length;
    var params = this._params;
    var theme = params.themeManager.theme('legend');
    for (i = items.length; i < ii; ++i) {
      items[i] = new Legend(params);
    }
    for (i = items.length - 1; i >= ii; --i) {
      items[i].dispose();
      items.splice(i, 1);
    }
    params.layoutControl.suspend();
    for (i = 0; i < ii; ++i) {
      items[i].setOptions(_extend(true, {}, theme, optionList[i]));
    }
    params.layoutControl.resume();
  }
};

/***/ }),

/***/ 15151:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.MapLayerCollection = MapLayerCollection;
exports.getMaxBound = getMaxBound;
var _common = __webpack_require__(20576);
var _extend2 = __webpack_require__(13306);
var _iterator = __webpack_require__(95479);
var _data_helper = _interopRequireDefault(__webpack_require__(53305));
var _type = __webpack_require__(35922);
var _deferred = __webpack_require__(62754);
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _noop = _common.noop;
var _extend = _extend2.extend;
var _each = _iterator.each;
var _concat = Array.prototype.concat;
var TYPE_AREA = 'area';
var TYPE_LINE = 'line';
var TYPE_MARKER = 'marker';
var STATE_DEFAULT = 0;
var STATE_HOVERED = 1;
var STATE_SELECTED = 2;
var STATE_TO_INDEX = [0, 1, 2, 2];
var TOLERANCE = 1;
var SELECTIONS = {
  'none': null,
  'single': -1,
  'multiple': NaN
};
var _isArray = Array.isArray;
var _Number = Number;
var _String = String;
var _abs = Math.abs;
var _round = Math.round;
var _min = Math.min;
var _max = Math.max;
var _sqrt = Math.sqrt;
function getMaxBound(arr) {
  return arr.reduce(function (a, c) {
    return c ? [_min(a[0], c[0]), _min(a[1], c[1]), _max(a[2], c[2]), _max(a[3], c[3])] : a;
  }, arr[0]);
}
function getSelection(selectionMode) {
  var selection = (0, _utils.normalizeEnum)(selectionMode);
  selection = selection in SELECTIONS ? SELECTIONS[selection] : SELECTIONS.single;
  if (selection !== null) {
    selection = {
      state: {},
      single: selection
    };
  }
  return selection;
}
function getName(opt, index) {
  return (opt[index] || {}).name;
}
function EmptySource() {}
EmptySource.prototype.count = function () {
  return 0;
};
function ArraySource(raw) {
  this.raw = raw;
}
ArraySource.prototype = {
  constructor: ArraySource,
  count: function count() {
    return this.raw.length;
  },
  item: function item(index) {
    return this.raw[index];
  },
  geometry: function geometry(item) {
    return {
      coordinates: item.coordinates
    };
  },
  attributes: function attributes(item) {
    return item.attributes;
  },
  getBBox: function getBBox(index) {
    return arguments.length === 0 ? undefined : this.raw[index]['bbox'];
  }
};
function GeoJsonSource(raw) {
  this.raw = raw;
}
GeoJsonSource.prototype = {
  constructor: GeoJsonSource,
  count: function count() {
    return this.raw.features.length;
  },
  item: function item(index) {
    return this.raw.features[index];
  },
  geometry: function geometry(item) {
    return item.geometry;
  },
  attributes: function attributes(item) {
    return item.properties;
  },
  getBBox: function getBBox(index) {
    return arguments.length === 0 ? this.raw['bbox'] : this.raw.features[index]['bbox'];
  }
};
function isGeoJsonObject(obj) {
  return _isArray(obj.features);
}

// The problem is that when remote source returns an object (not an array) the data.DataSource internally wraps it into array (of one element)
// So specific `if` clause is required to recognize GeoJson object in the returned `items`
function unwrapFromDataSource(source) {
  var sourceType;
  if (source) {
    if (isGeoJsonObject(source)) {
      sourceType = GeoJsonSource;
    } else if (source.length === 1 && source[0] && isGeoJsonObject(source[0])) {
      sourceType = GeoJsonSource;
      source = source[0];
    } else if (_isArray(source)) {
      sourceType = ArraySource;
    }
  }
  sourceType = sourceType || EmptySource;
  return new sourceType(source);
}

// The first problem is that when our DataSource is updated with an object (not an array) it considers such object a bunch of options.
// So single object has to be wrapped into array in order to be passed to the data.DataSource as is.
// The second problem is that when our DataSource is updated with `null` or `undefined` it does nothing - callback is not triggered (it is because of charts).
// So `null` or `undefined` is changed to empty array.
function wrapToDataSource(option) {
  return option ? isGeoJsonObject(option) ? [option] : option : [];
}
function customizeHandles(proxies, callback, widget) {
  callback.call(widget, proxies);
}

// TODO: Consider moving it inside a strategy
function setAreaLabelVisibility(label) {
  label.text.attr({
    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE && label.size[1] / label.spaceSize[1] < TOLERANCE ? null : 'hidden'
  });
}

// TODO: Consider moving it inside a strategy
function setLineLabelVisibility(label) {
  label.text.attr({
    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE || label.size[1] / label.spaceSize[1] < TOLERANCE ? null : 'hidden'
  });
}
function getDataValue(proxy, dataField) {
  return proxy.attribute(dataField);
}
var TYPE_TO_TYPE_MAP = {
  Point: TYPE_MARKER,
  MultiPoint: TYPE_LINE,
  LineString: TYPE_LINE,
  MultiLineString: TYPE_LINE,
  Polygon: TYPE_AREA,
  MultiPolygon: TYPE_AREA
};
function pick(a, b) {
  return a !== undefined ? a : b;
}
function guessTypeByData(sample) {
  var type = TYPE_TO_TYPE_MAP[sample.type];
  var coordinates = sample.coordinates;
  if (!type) {
    if (typeof coordinates[0] === 'number') {
      type = TYPE_MARKER;
    } else if (typeof coordinates[0][0] === 'number') {
      type = TYPE_LINE;
    } else {
      type = TYPE_AREA;
    }
  }
  return type;
}
var emptyStrategy = {
  setup: _noop,
  reset: _noop,
  arrange: _noop,
  updateGrouping: _noop,
  getDefaultColor: _noop
};
var strategiesByType = {};
var strategiesByGeometry = {};
var strategiesByElementType = {};
var groupByColor;
var groupBySize;
var selectStrategy = function selectStrategy(options, data) {
  var type = (0, _utils.normalizeEnum)(options.type);
  var elementType = (0, _utils.normalizeEnum)(options.elementType);
  var sample;
  var strategy = _extend({}, emptyStrategy);
  if (data.count() > 0) {
    sample = data.geometry(data.item(0));
    type = strategiesByType[type] ? type : guessTypeByData(sample);
    _extend(strategy, strategiesByType[type]);
    strategy.fullType = strategy.type = type;
    if (strategiesByGeometry[type]) {
      _extend(strategy, strategiesByGeometry[type](sample));
    }
    if (strategiesByElementType[type]) {
      elementType = strategiesByElementType[type][elementType] ? elementType : strategiesByElementType[type]._default;
      _extend(strategy, strategiesByElementType[type][elementType]);
      strategy.elementType = elementType;
      strategy.fullType += ':' + elementType;
    }
  }
  return strategy;
};
function applyElementState(figure, styles, state, field) {
  figure[field].attr(styles[field][state]);
}
strategiesByType[TYPE_AREA] = {
  projectLabel: projectAreaLabel,
  transform: transformPointList,
  transformLabel: transformAreaLabel,
  draw: function draw(context, figure, data) {
    figure.root = context.renderer.path([], 'area').data(context.dataKey, data);
  },
  refresh: _noop,
  getLabelOffset: function getLabelOffset(label) {
    setAreaLabelVisibility(label);
    return [0, 0];
  },
  getStyles: function getStyles(settings) {
    var color = settings.color || null;
    var borderColor = settings.borderColor || null;
    var borderWidth = pick(settings.borderWidth, null);
    var opacity = pick(settings.opacity, null);
    return {
      root: [{
        'class': 'dxm-area',
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        'class': 'dxm-area dxm-area-hovered',
        stroke: settings.hoveredBorderColor || borderColor,
        'stroke-width': pick(settings.hoveredBorderWidth, borderWidth),
        fill: settings.hoveredColor || color,
        opacity: pick(settings.hoveredOpacity, opacity)
      }, {
        'class': 'dxm-area dxm-area-selected',
        stroke: settings.selectedBorderColor || borderColor,
        'stroke-width': pick(settings.selectedBorderWidth, borderWidth),
        fill: settings.selectedColor || color,
        opacity: pick(settings.selectedOpacity, opacity)
      }]
    };
  },
  setState: function setState(figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
  },
  hasLabelsGroup: true,
  updateGrouping: function updateGrouping(context) {
    groupByColor(context);
  },
  getDefaultColor: _noop
};
strategiesByType[TYPE_LINE] = {
  projectLabel: projectLineLabel,
  transform: transformPointList,
  transformLabel: transformLineLabel,
  draw: function draw(context, figure, data) {
    figure.root = context.renderer.path([], 'line').data(context.dataKey, data);
  },
  refresh: _noop,
  getLabelOffset: function getLabelOffset(label) {
    setLineLabelVisibility(label);
    return [0, 0];
  },
  getStyles: function getStyles(settings) {
    var color = settings.color || settings.borderColor || null;
    var width = pick(settings.borderWidth, null);
    var opacity = pick(settings.opacity, null);
    return {
      root: [{
        'class': 'dxm-line',
        stroke: color,
        'stroke-width': width,
        opacity: opacity
      }, {
        'class': 'dxm-line dxm-line-hovered',
        stroke: settings.hoveredColor || settings.hoveredBorderColor || color,
        'stroke-width': pick(settings.hoveredBorderWidth, width),
        opacity: pick(settings.hoveredOpacity, opacity)
      }, {
        'class': 'dxm-line dxm-line-selected',
        stroke: settings.selectedColor || settings.selectedBorderColor || color,
        'stroke-width': pick(settings.selectedBorderWidth, width),
        opacity: pick(settings.selectedOpacity, opacity)
      }]
    };
  },
  setState: function setState(figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
  },
  hasLabelsGroup: true,
  updateGrouping: function updateGrouping(context) {
    groupByColor(context);
  },
  getDefaultColor: _noop
};
strategiesByType[TYPE_MARKER] = {
  project: projectPoint,
  transform: transformPoint,
  draw: function draw(context, figure, data) {
    figure.root = context.renderer.g();
    this._draw(context, figure, data);
  },
  refresh: _noop,
  hasLabelsGroup: false,
  getLabelOffset: function getLabelOffset(label, settings) {
    return [_round((label.size[0] + _max(settings.size || 0, 0)) / 2) + 2, 0];
  },
  getStyles: function getStyles(settings) {
    var styles = {
      root: [{
        'class': 'dxm-marker'
      }, {
        'class': 'dxm-marker dxm-marker-hovered'
      }, {
        'class': 'dxm-marker dxm-marker-selected'
      }]
    };
    this._getStyles(styles, settings);
    return styles;
  },
  setState: function setState(figure, styles, state) {
    applyElementState(figure, styles, state, 'root');
    this._setState(figure, styles, state);
  },
  updateGrouping: function updateGrouping(context) {
    groupByColor(context);
    groupBySize(context);
  },
  getDefaultColor: function getDefaultColor(ctx, palette) {
    return ctx.params.themeManager.getAccentColor(palette);
  }
};
strategiesByGeometry[TYPE_AREA] = function (sample) {
  return {
    project(projection, coordinates) {
      return coordinates[0] && coordinates[0][0] && coordinates[0][0][0] && typeof coordinates[0][0][0][0] === 'number' ? projectMultiPolygon(projection, coordinates) : projectPolygon(projection, coordinates);
    }
  };
};
strategiesByGeometry[TYPE_LINE] = function (sample) {
  var coordinates = sample.coordinates;
  return {
    project: coordinates[0] && coordinates[0][0] && typeof coordinates[0][0][0] === 'number' ? projectPolygon : projectLineString
  };
};
strategiesByElementType[TYPE_MARKER] = {
  _default: 'dot',
  dot: {
    setup: function setup(context) {
      context.filter = context.renderer.shadowFilter('-40%', '-40%', '180%', '200%', 0, 1, 1, '#000000', 0.2);
    },
    reset: function reset(context) {
      context.filter.dispose();
      context.filter = null;
    },
    _draw: function _draw(ctx, figure, data) {
      figure.back = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
      figure.dot = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy, settings) {
      figure.dot.attr({
        filter: settings.shadow ? ctx.filter.id : null
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var size = style.size > 0 ? _Number(style.size) : 0;
      var hoveredSize = size;
      var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
      var hoveredBackSize = hoveredSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
      var selectedBackSize = selectedSize + (style.backStep > 0 ? _Number(style.backStep) : 0);
      var color = style.color || null;
      var borderColor = style.borderColor || null;
      var borderWidth = pick(style.borderWidth, null);
      var opacity = pick(style.opacity, null);
      var backColor = style.backColor || null;
      var backOpacity = pick(style.backOpacity, null);
      styles.dot = [{
        r: size / 2,
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        r: hoveredSize / 2,
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth),
        fill: style.hoveredColor || color,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        r: selectedSize / 2,
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth),
        fill: style.selectedColor || color,
        opacity: pick(style.selectedOpacity, opacity)
      }];
      styles.back = [{
        r: size / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }, {
        r: hoveredBackSize / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }, {
        r: selectedBackSize / 2,
        stroke: 'none',
        'stroke-width': 0,
        fill: backColor,
        opacity: backOpacity
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'dot');
      applyElementState(figure, styles, state, 'back');
    }
  },
  bubble: {
    _draw: function _draw(ctx, figure, data) {
      figure.bubble = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy, settings) {
      figure.bubble.attr({
        r: settings.size / 2
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var color = style.color || null;
      var borderColor = style.borderColor || null;
      var borderWidth = pick(style.borderWidth, null);
      var opacity = pick(style.opacity, null);
      styles.bubble = [{
        stroke: borderColor,
        'stroke-width': borderWidth,
        fill: color,
        opacity: opacity
      }, {
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth),
        fill: style.hoveredColor || style.color,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth),
        fill: style.selectedColor || style.color,
        opacity: pick(style.selectedOpacity, opacity)
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'bubble');
    },
    arrange: function arrange(context, handles) {
      var values = [];
      var i;
      var ii = values.length = handles.length;
      var settings = context.settings;
      var dataField = settings.dataField;
      var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
      var maxSize = settings.maxSize > minSize ? _Number(settings.maxSize) : minSize;
      if (settings.sizeGroups) {
        return;
      }
      for (i = 0; i < ii; ++i) {
        values[i] = _max(getDataValue(handles[i].proxy, dataField) || 0, 0);
      }
      var minValue = _min.apply(null, values);
      var maxValue = _max.apply(null, values);
      var deltaValue = maxValue - minValue || 1;
      var deltaSize = maxSize - minSize;
      for (i = 0; i < ii; ++i) {
        handles[i]._settings.size = minSize + deltaSize * (values[i] - minValue) / deltaValue;
      }
    },
    updateGrouping: function updateGrouping(context) {
      var dataField = context.settings.dataField;
      strategiesByType[TYPE_MARKER].updateGrouping(context);
      groupBySize(context, function (proxy) {
        return getDataValue(proxy, dataField);
      });
    }
  },
  pie: {
    _draw: function _draw(ctx, figure, data) {
      figure.pie = ctx.renderer.g().append(figure.root);
      figure.border = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy, settings) {
      var values = getDataValue(proxy, ctx.settings.dataField) || [];
      var colors = settings._colors;
      var sum = 0;
      var pie = figure.pie;
      var renderer = ctx.renderer;
      var dataKey = ctx.dataKey;
      var r = (settings.size > 0 ? _Number(settings.size) : 0) / 2;
      var start = 90;
      var end = start;
      var zeroSum = false;
      sum = values.reduce(function (total, item) {
        return total + (item || 0);
      }, 0);
      if (sum === 0) {
        zeroSum = true;
        sum = 360 / values.length;
      }
      values.forEach(function (item, i) {
        start = end;
        end += zeroSum ? sum : (item || 0) / sum * 360;
        renderer.arc(0, 0, 0, r, start, end).attr({
          'stroke-linejoin': 'round',
          fill: colors[i]
        }).data(dataKey, data).append(pie);
      });
      figure.border.attr({
        r: r
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var opacity = pick(style.opacity, null);
      var borderColor = style.borderColor || null;
      var borderWidth = pick(style.borderWidth, null);
      styles.pie = [{
        opacity: opacity
      }, {
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        opacity: pick(style.selectedOpacity, opacity)
      }];
      styles.border = [{
        stroke: borderColor,
        'stroke-width': borderWidth
      }, {
        stroke: style.hoveredBorderColor || borderColor,
        'stroke-width': pick(style.hoveredBorderWidth, borderWidth)
      }, {
        stroke: style.selectedBorderColor || borderColor,
        'stroke-width': pick(style.selectedBorderWidth, borderWidth)
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'pie');
      applyElementState(figure, styles, state, 'border');
    },
    arrange: function arrange(context, handles) {
      var i;
      var ii = handles.length;
      var dataField = context.settings.dataField;
      var values;
      var count = 0;
      var palette;
      for (i = 0; i < ii; ++i) {
        values = getDataValue(handles[i].proxy, dataField);
        if (values && values.length > count) {
          count = values.length;
        }
      }
      if (count > 0) {
        palette = context.params.themeManager.createPalette(context.settings.palette, {
          useHighlight: true,
          extensionMode: 'alternate'
        });
        values = palette.generateColors(count);
        context.settings._colors = values;
        context.grouping.color = {
          callback: _noop,
          field: '',
          partition: [],
          values: []
        };
        context.params.dataExchanger.set(context.name, 'color', {
          partition: [],
          values: values
        });
      }
    }
  },
  image: {
    _draw: function _draw(ctx, figure, data) {
      figure.image = ctx.renderer.image(null, null, null, null, null, 'center').attr({
        'pointer-events': 'visible'
      }) // T567545
      .data(ctx.dataKey, data).append(figure.root);
    },
    refresh: function refresh(ctx, figure, data, proxy) {
      figure.image.attr({
        href: getDataValue(proxy, ctx.settings.dataField)
      });
    },
    _getStyles: function _getStyles(styles, style) {
      var size = style.size > 0 ? _Number(style.size) : 0;
      var hoveredSize = size + (style.hoveredStep > 0 ? _Number(style.hoveredStep) : 0);
      var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);
      var opacity = pick(style.opacity, null);
      styles.image = [{
        x: -size / 2,
        y: -size / 2,
        width: size,
        height: size,
        opacity: opacity
      }, {
        x: -hoveredSize / 2,
        y: -hoveredSize / 2,
        width: hoveredSize,
        height: hoveredSize,
        opacity: pick(style.hoveredOpacity, opacity)
      }, {
        x: -selectedSize / 2,
        y: -selectedSize / 2,
        width: selectedSize,
        height: selectedSize,
        opacity: pick(style.selectedOpacity, opacity)
      }];
    },
    _setState: function _setState(figure, styles, state) {
      applyElementState(figure, styles, state, 'image');
    }
  }
};
function projectPoint(projection, coordinates) {
  return projection.project(coordinates);
}
function projectPointList(projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = projection.project(coordinates[i]);
  }
  return output;
}
function projectLineString(projection, coordinates) {
  return [projectPointList(projection, coordinates)];
}
function projectPolygon(projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = projectPointList(projection, coordinates[i]);
  }
  return output;
}
function projectMultiPolygon(projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = projectPolygon(projection, coordinates[i]);
  }
  return _concat.apply([], output);
}
function transformPoint(content, projection, coordinates) {
  var data = projection.transform(coordinates);
  content.root.attr({
    translateX: data[0],
    translateY: data[1]
  });
}
function transformList(projection, coordinates) {
  var output = [];
  var i;
  var ii = coordinates.length;
  var item;
  var k = 0;
  output.length = 2 * ii;
  for (i = 0; i < ii; ++i) {
    item = projection.transform(coordinates[i]);
    output[k++] = item[0];
    output[k++] = item[1];
  }
  return output;
}
function transformPointList(content, projection, coordinates) {
  var output = [];
  var i;
  var ii = output.length = coordinates.length;
  for (i = 0; i < ii; ++i) {
    output[i] = transformList(projection, coordinates[i]);
  }
  content.root.attr({
    points: output
  });
}
function transformAreaLabel(label, projection, coordinates) {
  var data = projection.transform(coordinates[0]);
  label.spaceSize = projection.getSquareSize(coordinates[1]);
  label.text.attr({
    translateX: data[0],
    translateY: data[1]
  });
  setAreaLabelVisibility(label);
}
function transformLineLabel(label, projection, coordinates) {
  var data = projection.transform(coordinates[0]);
  label.spaceSize = projection.getSquareSize(coordinates[1]);
  label.text.attr({
    translateX: data[0],
    translateY: data[1]
  });
  setLineLabelVisibility(label);
}
function getItemSettings(context, proxy, settings) {
  var result = combineSettings(context.settings, settings);
  applyGrouping(context.grouping, proxy, result);
  if (settings.color === undefined && settings.paletteIndex >= 0) {
    result.color = result._colors[settings.paletteIndex];
  }
  return result;
}
function applyGrouping(grouping, proxy, settings) {
  _each(grouping, function (name, data) {
    var index = findGroupingIndex(data.callback(proxy, data.field), data.partition);
    if (index >= 0) {
      settings[name] = data.values[index];
    }
  });
}
function findGroupingIndex(value, partition) {
  var start = 0;
  var end = partition.length - 1;
  var index = -1;
  var middle;
  if (partition[start] <= value && value <= partition[end]) {
    if (value === partition[end]) {
      index = end - 1;
    } else {
      while (end - start > 1) {
        middle = start + end >> 1;
        if (value < partition[middle]) {
          end = middle;
        } else {
          start = middle;
        }
      }
      index = start;
    }
  }
  return index;
}
function raiseChanged(context, handle, state, name) {
  context.params.eventTrigger(name, {
    target: handle.proxy,
    state: state
  });
}

// This is required because `$.extend` cannot be used - because of the `options.data` which is commonly a very large array
// TODO: Try to use our simple `extend` instead of `$.extend`
function combineSettings(common, partial) {
  var obj = _extend({}, common, partial);
  obj.label = _extend({}, common.label, obj.label);
  obj.label.font = _extend({}, common.label.font, obj.label.font);
  return obj;
}
function processCommonSettings(context, options) {
  var themeManager = context.params.themeManager;
  var strategy = context.str;
  var settings = combineSettings(_extend({
    label: {},
    color: strategy.getDefaultColor(context, options.palette)
  }, themeManager.theme('layer:' + strategy.fullType)), options);
  var colors;
  var i;
  var palette;
  if (settings.paletteSize > 0) {
    palette = themeManager.createDiscretePalette(settings.palette, settings.paletteSize);
    for (i = 0, colors = []; i < settings.paletteSize; ++i) {
      colors.push(palette.getColor(i));
    }
    settings._colors = colors;
  }
  return settings;
}
function valueCallback(proxy, dataField) {
  return proxy.attribute(dataField);
}
var performGrouping = function performGrouping(context, partition, settingField, dataField, valuesCallback) {
  var values;
  if (dataField && partition && partition.length > 1) {
    values = valuesCallback(partition.length - 1);
    context.grouping[settingField] = {
      callback: (0, _type.isFunction)(dataField) ? dataField : valueCallback,
      field: dataField,
      partition: partition,
      values: values
    };
    context.params.dataExchanger.set(context.name, settingField, {
      partition: partition,
      values: values,
      defaultColor: context.settings.color
    });
  }
};
function dropGrouping(context) {
  var name = context.name;
  var dataExchanger = context.params.dataExchanger;
  _each(context.grouping, function (field) {
    dataExchanger.set(name, field, null);
  });
  context.grouping = {};
}
groupByColor = function groupByColor(context) {
  performGrouping(context, context.settings.colorGroups, 'color', context.settings.colorGroupingField, function (count) {
    var _palette = context.params.themeManager.createDiscretePalette(context.settings.palette, count);
    var i;
    var list = [];
    for (i = 0; i < count; ++i) {
      list.push(_palette.getColor(i));
    }
    return list;
  });
};
groupBySize = function groupBySize(context, valueCallback) {
  var settings = context.settings;
  performGrouping(context, settings.sizeGroups, 'size', valueCallback || settings.sizeGroupingField, function (count) {
    var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;
    var maxSize = settings.maxSize >= minSize ? _Number(settings.maxSize) : 0;
    var i = 0;
    var sizes = [];
    if (count > 1) {
      for (i = 0; i < count; ++i) {
        sizes.push((minSize * (count - i - 1) + maxSize * i) / (count - 1));
      }
    } else if (count === 1) {
      sizes.push((minSize + maxSize) / 2);
    }
    return sizes;
  });
};
function setFlag(flags, flag, state) {
  if (state) {
    flags |= flag;
  } else {
    flags &= ~flag;
  }
  return flags;
}
function hasFlag(flags, flag) {
  return !!(flags & flag);
}
function createLayerProxy(layer, name, index) {
  var proxy = {
    index: index,
    name: name,
    getElements: function getElements() {
      return layer.getProxies();
    },
    clearSelection: function clearSelection(_noEvent) {
      layer.clearSelection(_noEvent);
      return proxy;
    },
    getDataSource: function getDataSource() {
      return layer.getDataSource();
    },
    getBounds() {
      return layer.getBounds();
    }
  };
  return proxy;
}
var MapLayerElement;
var MapLayer = function MapLayer(params, container, name, index) {
  var that = this;
  that._params = params;
  that._onProjection();
  that.proxy = createLayerProxy(that, name, index);
  that._context = {
    name: name,
    layer: that.proxy,
    renderer: params.renderer,
    projection: params.projection,
    params: params,
    dataKey: params.dataKey,
    str: emptyStrategy,
    hover: false,
    selection: null,
    grouping: {},
    // TODO: Link name should be built upon layer index rather than name
    root: params.renderer.g().attr({
      'class': 'dxm-layer'
    }).linkOn(container, name).linkAppend()
  };
  that._container = container;
  that._options = {};
  // Though the `_handles` field is set in the `_createHandles` it is required here because projection events are fired before data is set
  that._handles = [];
  // The `_data` field may be accessed in the `setOptions` when data is not set
  that._data = new EmptySource();
  that._dataSourceLoaded = null;
};
MapLayer.prototype = _extend({
  constructor: MapLayer,
  getDataReadyCallback() {
    return this._dataSourceLoaded;
  },
  _onProjection: function _onProjection() {
    var that = this;
    that._removeHandlers = that._params.projection.on({
      'engine': function engine() {
        that._project();
      },
      'screen': function screen() {
        that._transform();
      },
      'center': function center() {
        that._transformCore();
      },
      'zoom': function zoom() {
        that._transform();
      }
    });
  },
  getData() {
    return this._data;
  },
  _dataSourceLoadErrorHandler: function _dataSourceLoadErrorHandler() {
    this._dataSourceChangedHandler();
  },
  _dataSourceChangedHandler: function _dataSourceChangedHandler() {
    var that = this;
    that._data = unwrapFromDataSource(that._dataSource && that._dataSource.items());
    that._update(true);
  },
  _dataSourceOptions: function _dataSourceOptions() {
    return {
      paginate: false
    };
  },
  _getSpecificDataSourceOption: function _getSpecificDataSourceOption() {
    return this._specificDataSourceOption;
  },
  _normalizeDataSource: function _normalizeDataSource(dataSource) {
    var store = dataSource.store();
    if (store._loadMode === 'raw') {
      store._loadMode = undefined;
    }
    return dataSource;
  },
  _offProjection: function _offProjection() {
    this._removeHandlers();
    this._removeHandlers = null;
  },
  dispose: function dispose() {
    var that = this;
    that._disposeDataSource();
    that._destroyHandles();
    dropGrouping(that._context);
    that._context.root.linkRemove().linkOff();
    that._context.labelRoot && that._context.labelRoot.linkRemove().linkOff();
    that._context.str.reset(that._context);
    that._offProjection();
    that._params = that._container = that._context = that.proxy = null;
    return that;
  },
  setOptions: function setOptions(options) {
    var that = this;
    options = that._options = options || {};
    that._dataSourceLoaded = new _deferred.Deferred();
    if ('dataSource' in options && options.dataSource !== that._options_dataSource) {
      that._options_dataSource = options.dataSource;
      that._params.notifyDirty();
      that._specificDataSourceOption = wrapToDataSource(options.dataSource);
      that._refreshDataSource();
    } else if (that._data.count() > 0) {
      that._params.notifyDirty();
      that._update(options.type !== undefined && options.type !== that._context.str.type || options.elementType !== undefined && options.elementType !== that._context.str.elementType);
    }
    that._transformCore();
  },
  _update: function _update(isContextChanged) {
    var that = this;
    var context = that._context;
    if (isContextChanged) {
      context.str.reset(context);
      context.root.clear();
      context.labelRoot && context.labelRoot.clear();
      that._params.tracker.reset(); // T173037; TODO: There is no need to reset the entire tracker - only its memory about items
      that._destroyHandles();
      context.str = selectStrategy(that._options, that._data);
      context.str.setup(context);
      that.proxy.type = context.str.type;
      that.proxy.elementType = context.str.elementType;
    }
    context.settings = processCommonSettings(context, that._options);
    context.hasSeparateLabel = !!(context.settings.label.enabled && context.str.hasLabelsGroup);
    context.hover = !!(0, _utils.parseScalar)(context.settings.hoverEnabled, true);
    // There is intentionally no attempt to preserve previous selection (or part of it)
    // Otherwise it would require some stack-like structure to keep selected items
    // Let's not complicate
    if (context.selection) {
      _each(context.selection.state, function (_, handle) {
        handle && handle.resetSelected();
      });
    }
    context.selection = getSelection(context.settings.selectionMode);
    if (context.hasSeparateLabel) {
      if (!context.labelRoot) {
        // TODO: Link name should be built upon layer index rather than name
        context.labelRoot = context.renderer.g().attr({
          'class': 'dxm-layer-labels'
        }).linkOn(that._container, {
          name: context.name + '-labels',
          after: context.name
        }).linkAppend();
        that._transformCore();
      }
    } else {
      if (context.labelRoot) {
        context.labelRoot.linkRemove().linkOff();
        context.labelRoot = null;
      }
    }
    if (isContextChanged) {
      that._createHandles();
    }
    dropGrouping(context);
    context.str.arrange(context, that._handles);
    context.str.updateGrouping(context);
    that._updateHandles();
    that._params.notifyReady();
    if (that._dataSourceLoaded) {
      // T890687
      that._dataSourceLoaded.resolve();
      that._dataSourceLoaded = null;
    } else {
      that._params.dataReady();
    }
  },
  getBounds() {
    return getMaxBound(this._handles.map(function (_ref) {
      var proxy = _ref.proxy;
      return proxy.coordinates().map(function (coords) {
        if (!_isArray(coords)) {
          return;
        }
        var coordsToBoundsSearch = _isArray(coords[0][0]) ? coords.reduce(function (ac, val) {
          return ac.concat(val);
        }, []) : coords;
        var initValue = coordsToBoundsSearch[0];
        return coordsToBoundsSearch.reduce(function (min, c) {
          return [_min(min[0], c[0]), _min(min[1], c[1]), _max(min[2], c[0]), _max(min[3], c[1])];
        }, [initValue[0], initValue[1], initValue[0], initValue[1]]);
      });
    }).map(getMaxBound));
  },
  _destroyHandles() {
    this._handles.forEach(function (h) {
      return h.dispose();
    });
    if (this._context.selection) {
      this._context.selection.state = {};
    }
    this._handles = [];
  },
  _createHandles: function _createHandles() {
    var that = this;
    var handles = that._handles = [];
    var data = that._data;
    var i;
    var ii = handles.length = data.count();
    var context = that._context;
    var geometry = data.geometry;
    var attributes = data.attributes;
    var handle;
    var dataItem;
    for (i = 0; i < ii; ++i) {
      dataItem = data.item(i);
      handles[i] = new MapLayerElement(context, i, geometry(dataItem), attributes(dataItem));
    }
    // Customization must be performed before anything else happens to element (that is the idea of customization)
    (0, _type.isFunction)(that._options.customize) && customizeHandles(that.getProxies(), that._options.customize, that._params.widget);
    for (i = 0; i < ii; ++i) {
      handle = handles[i];
      handle.project();
      handle.draw();
      handle.transform();
    }
    if (context.selection) {
      _each(context.selection.state, function (_, handle) {
        handle && handle.restoreSelected();
      });
    }
  },
  _updateHandles: function _updateHandles() {
    var handles = this._handles;
    var i;
    var ii = handles.length;
    for (i = 0; i < ii; ++i) {
      handles[i].refresh();
    }
    if (this._context.settings.label.enabled) {
      for (i = 0; i < ii; ++i) {
        handles[i].measureLabel();
      }
      for (i = 0; i < ii; ++i) {
        handles[i].adjustLabel();
      }
    }
  },
  _transformCore: function _transformCore() {
    var transform = this._params.projection.getTransform();
    this._context.root.attr(transform);
    this._context.labelRoot && this._context.labelRoot.attr(transform);
  },
  _project: function _project() {
    var handles = this._handles;
    var i;
    var ii = handles.length;
    for (i = 0; i < ii; ++i) {
      handles[i].project();
    }
  },
  _transform: function _transform() {
    var handles = this._handles;
    var i;
    var ii = handles.length;
    this._transformCore();
    for (i = 0; i < ii; ++i) {
      handles[i].transform();
    }
  },
  getProxies() {
    return this._handles.map(function (p) {
      return p.proxy;
    });
  },
  getProxy: function getProxy(index) {
    return this._handles[index].proxy;
  },
  raiseClick: function raiseClick(i, dxEvent) {
    this._params.eventTrigger('click', {
      target: this._handles[i].proxy,
      event: dxEvent
    });
  },
  hoverItem: function hoverItem(i, state) {
    this._handles[i].setHovered(state);
  },
  selectItem: function selectItem(i, state, _noEvent) {
    this._handles[i].setSelected(state, _noEvent);
  },
  clearSelection: function clearSelection() {
    var selection = this._context.selection;
    if (selection) {
      _each(selection.state, function (_, handle) {
        handle && handle.setSelected(false);
      });
      selection.state = {};
    }
  }
}, _data_helper.default);
function createProxy(handle, coords, attrs) {
  var proxy = {
    coordinates: function coordinates() {
      return coords;
    },
    attribute: function attribute(name, value) {
      if (arguments.length > 1) {
        attrs[name] = value;
        return proxy;
      } else {
        return arguments.length > 0 ? attrs[name] : attrs;
      }
    },
    selected: function selected(state, _noEvent) {
      if (arguments.length > 0) {
        handle.setSelected(state, _noEvent);
        return proxy;
      } else {
        return handle.isSelected();
      }
    },
    applySettings: function applySettings(settings) {
      handle.update(settings);
      return proxy;
    }
  };
  return proxy;
}
MapLayerElement = function MapLayerElement(context, index, geometry, attributes) {
  var that = this;
  var proxy = that.proxy = createProxy(that, geometry.coordinates, _extend({}, attributes));
  that._ctx = context;
  that._index = index;
  that._fig = that._label = null;
  that._state = STATE_DEFAULT;
  that._coordinates = geometry.coordinates;
  that._settings = {
    label: {}
  };
  proxy.index = index;
  proxy.layer = context.layer;
  // TODO: Replace "name" field with one referencing layer index and use layer index (instead of name) as layer id
  // as it is more suitable, simple and consistent
  that._data = {
    name: context.name,
    index: index
  };
};
MapLayerElement.prototype = {
  constructor: MapLayerElement,
  dispose: function dispose() {
    var that = this;
    that._ctx = that.proxy = that._settings = that._fig = that._label = that.data = null;
    return that;
  },
  project: function project() {
    var context = this._ctx;
    this._projection = context.str.project(context.projection, this._coordinates);
    if (context.hasSeparateLabel && this._label) {
      this._projectLabel();
    }
  },
  _projectLabel: function _projectLabel() {
    this._labelProjection = this._ctx.str.projectLabel(this._projection);
  },
  draw: function draw() {
    var that = this;
    var context = this._ctx;
    context.str.draw(context, that._fig = {}, that._data);
    that._fig.root.append(context.root);
  },
  transform: function transform() {
    var that = this;
    var context = that._ctx;
    context.str.transform(that._fig, context.projection, that._projection);
    if (context.hasSeparateLabel && that._label) {
      that._transformLabel();
    }
  },
  _transformLabel: function _transformLabel() {
    this._ctx.str.transformLabel(this._label, this._ctx.projection, this._labelProjection);
  },
  refresh: function refresh() {
    var that = this;
    var strategy = that._ctx.str;
    var settings = getItemSettings(that._ctx, that.proxy, that._settings);
    that._styles = strategy.getStyles(settings);
    strategy.refresh(that._ctx, that._fig, that._data, that.proxy, settings);
    that._refreshLabel(settings);
    that._setState();
  },
  _refreshLabel: function _refreshLabel(settings) {
    var that = this;
    var context = that._ctx;
    var labelSettings = settings.label;
    var label = that._label;
    if (context.settings.label.enabled) {
      if (!label) {
        label = that._label = {
          root: context.labelRoot || that._fig.root,
          text: context.renderer.text().attr({
            'class': 'dxm-label'
          }),
          size: [0, 0]
        };
        if (context.hasSeparateLabel) {
          that._projectLabel();
          that._transformLabel();
        }
      }
      label.value = _String(that.proxy.text || that.proxy.attribute(labelSettings.dataField) || '');
      if (label.value) {
        // The data should be set when the element is created but it requires changes in the Renderer
        label.text.attr({
          text: label.value,
          x: 0,
          y: 0
        }).css((0, _utils.patchFontOptions)(labelSettings.font)).attr({
          align: 'center',
          stroke: labelSettings.stroke,
          'stroke-width': labelSettings['stroke-width'],
          'stroke-opacity': labelSettings['stroke-opacity']
        }).data(context.dataKey, that._data).append(label.root);
        label.settings = settings;
      }
    } else {
      if (label) {
        label.text.remove();
        that._label = null;
      }
    }
  },
  measureLabel: function measureLabel() {
    var label = this._label;
    var bBox;
    if (label.value) {
      bBox = label.text.getBBox();
      label.size = [bBox.width, bBox.height, -bBox.y - bBox.height / 2];
    }
  },
  adjustLabel: function adjustLabel() {
    var label = this._label;
    var offset;
    if (label.value) {
      offset = this._ctx.str.getLabelOffset(label, label.settings);
      label.settings = null;
      label.text.attr({
        x: offset[0],
        y: offset[1] + label.size[2]
      });
    }
  },
  update: function update(settings) {
    var that = this;
    that._settings = combineSettings(that._settings, settings);
    // This check is required because the method can be called during the customization stage when DOM content neither is created nor should be changed
    if (that._fig) {
      that.refresh();
      if (that._label && that._label.value) {
        that.measureLabel();
        that.adjustLabel();
      }
    }
  },
  _setState: function _setState() {
    this._ctx.str.setState(this._fig, this._styles, STATE_TO_INDEX[this._state]);
  },
  _setForeground: function _setForeground() {
    var root = this._fig.root;
    this._state ? root.toForeground() : root.toBackground();
  },
  setHovered: function setHovered(state) {
    var that = this;
    var currentState = hasFlag(that._state, STATE_HOVERED);
    var newState = !!state;
    if (that._ctx.hover && currentState !== newState) {
      that._state = setFlag(that._state, STATE_HOVERED, newState);
      that._setState();
      that._setForeground();
      raiseChanged(that._ctx, that, newState, 'hoverChanged');
    }
    return that;
  },
  setSelected: function setSelected(state, _noEvent) {
    var that = this;
    var currentState = hasFlag(that._state, STATE_SELECTED);
    var newState = !!state;
    var selection = that._ctx.selection;
    var tmp;
    if (selection && currentState !== newState) {
      that._state = setFlag(that._state, STATE_SELECTED, newState);
      tmp = selection.state[selection.single];
      selection.state[selection.single] = null; // This is to prevent stack overflow
      if (tmp) {
        tmp.setSelected(false);
      }
      selection.state[selection.single || that._index] = state ? that : null;
      // This check is required because the method can be called during the customization stage when DOM content neither is created nor should be changed
      if (that._fig) {
        that._setState();
        that._setForeground();
        if (!_noEvent) {
          raiseChanged(that._ctx, that, newState, 'selectionChanged');
        }
      }
    }
  },
  isSelected: function isSelected() {
    return hasFlag(this._state, STATE_SELECTED);
  },
  resetSelected: function resetSelected() {
    this._state = setFlag(this._state, STATE_SELECTED, false);
  },
  restoreSelected: function restoreSelected() {
    this._fig.root.toForeground();
  }
};

// http://en.wikipedia.org/wiki/Centroid
function calculatePolygonCentroid(coordinates) {
  var i;
  var length = coordinates.length;
  var v1;
  var v2 = coordinates[length - 1];
  var cross;
  var cx = 0;
  var cy = 0;
  var area = 0;
  var minX = Infinity;
  var maxX = -Infinity;
  var minY = Infinity;
  var maxY = -Infinity;
  for (i = 0; i < length; ++i) {
    v1 = v2;
    v2 = coordinates[i];
    cross = v1[0] * v2[1] - v2[0] * v1[1];
    area += cross;
    cx += (v1[0] + v2[0]) * cross;
    cy += (v1[1] + v2[1]) * cross;
    minX = _min(minX, v2[0]);
    maxX = _max(maxX, v2[0]);
    minY = _min(minY, v2[1]);
    maxY = _max(maxY, v2[1]);
  }
  // from centroid coords we need subtract the center of bbox coords to get a good geometrical center (T312029)
  return {
    area: _abs(area) / 2,
    center: [2 * cx / 3 / area - (minX + maxX) / 2, 2 * cy / 3 / area - (minY + maxY) / 2]
  };
}
function calculateLineStringData(coordinates) {
  var i;
  var ii = coordinates.length;
  var v1;
  var v2 = coordinates[0] || [];
  var totalLength = 0;
  var items = [0];
  var min0 = v2[0];
  var max0 = v2[0];
  var min1 = v2[1];
  var max1 = v2[1];
  for (i = 1; i < ii; ++i) {
    v1 = v2;
    v2 = coordinates[i];
    totalLength += _sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    items[i] = totalLength;
    min0 = _min(min0, v2[0]);
    max0 = _max(max0, v2[0]);
    min1 = _min(min1, v2[1]);
    max1 = _max(max1, v2[1]);
  }
  i = findGroupingIndex(totalLength / 2, items);
  v1 = coordinates[i];
  v2 = coordinates[i + 1];
  var t = (totalLength / 2 - items[i]) / (items[i + 1] - items[i]);
  return ii ? [[v1[0] * (1 - t) + v2[0] * t, v1[1] * (1 - t) + v2[1] * t], [max0 - min0, max1 - min1], totalLength] : [];
}

// TODO: Optimize!
// There are redundant iterations in the following cycle - interior holes of a polygon should not be taken into account
// So there is only centroid to be calculated for each "Polygon"
function projectAreaLabel(coordinates) {
  var i;
  var ii = coordinates.length;
  var centroid;
  var resultCentroid;
  var maxArea = 0;
  for (i = 0; i < ii; ++i) {
    centroid = calculatePolygonCentroid(coordinates[i]);
    if (centroid.area > maxArea) {
      maxArea = centroid.area;
      resultCentroid = centroid;
    }
  }
  // TODO: Move "_sqrt" to the "calculatePolygonCentroid"
  return resultCentroid ? [resultCentroid.center, [_sqrt(resultCentroid.area), _sqrt(resultCentroid.area)]] : [[], []];
}
function projectLineLabel(coordinates) {
  var i;
  var ii = coordinates.length;
  var maxLength = 0;
  var data;
  var resultData;
  for (i = 0; i < ii; ++i) {
    data = calculateLineStringData(coordinates[i]);
    if (data[2] > maxLength) {
      maxLength = data[2];
      resultData = data;
    }
  }
  return resultData || [[], []];
}
function MapLayerCollection(params) {
  var that = this;
  var renderer = params.renderer;
  that._params = params;
  that._layers = [];
  // TODO: Use Set instance instead of plain object
  that._layerByName = {};
  that._rect = [0, 0, 0, 0];
  that._clip = renderer.clipRect();
  that._background = renderer.rect().attr({
    'class': 'dxm-background'
  }).data(params.dataKey, {
    name: 'background'
  }).append(renderer.root);
  that._container = renderer.g().attr({
    'class': 'dxm-layers',
    'clip-path': that._clip.id
  }).append(renderer.root).enableLinks();
  that._subscribeToTracker(params.tracker, renderer, params.eventTrigger);
  that._dataReady = params.dataReady;
}
MapLayerCollection.prototype = {
  constructor: MapLayerCollection,
  dispose: function dispose() {
    var that = this;
    that._clip.dispose();
    that._layers.forEach(function (l) {
      return l.dispose();
    });
    that._offTracker();
    that._params = that._offTracker = that._layers = that._layerByName = that._clip = that._background = that._container = null;
  },
  _subscribeToTracker: function _subscribeToTracker(tracker, renderer, eventTrigger) {
    var that = this;
    that._offTracker = tracker.on({
      'click': function click(arg) {
        // TODO: Adjust `x` and `y` inside the Tracker
        var offset = renderer.getRootOffset();
        var layer = that.byName(arg.data.name);
        arg.$event.x = arg.x - offset.left;
        arg.$event.y = arg.y - offset.top;
        // TODO: Remove the "raiseClick" method
        if (layer) {
          layer.raiseClick(arg.data.index, arg.$event);
        } else if (arg.data.name === 'background') {
          eventTrigger('click', {
            event: arg.$event
          });
        }
      },
      'hover-on': function hoverOn(arg) {
        var layer = that.byName(arg.data.name);
        if (layer) {
          layer.hoverItem(arg.data.index, true);
        }
      },
      'hover-off': function hoverOff(arg) {
        var layer = that.byName(arg.data.name);
        if (layer) {
          layer.hoverItem(arg.data.index, false);
        }
      }
    });
  },
  setOptions(options) {
    var that = this;
    var optionList = options ? _isArray(options) ? options : [options] : [];
    var layers = that._layers;
    var readyCallbacks = [];
    var needToCreateLayers = optionList.length !== layers.length || layers.some(function (l, i) {
      var name = getName(optionList, i);
      return (0, _type.isDefined)(name) && name !== l.proxy.name;
    });
    if (needToCreateLayers) {
      that._params.tracker.reset();
      that._layers.forEach(function (l) {
        return l.dispose();
      });
      var layerByName = that._layerByName = {};
      that._layers = layers = [];
      for (var i = 0, ii = optionList.length; i < ii; ++i) {
        var name = getName(optionList, i) || 'map-layer-' + i;
        var layer = layers[i] = new MapLayer(that._params, that._container, name, i);
        layerByName[name] = layer;
      }
    }
    layers.forEach(function (l, i) {
      l.setOptions(optionList[i]);
    });
    readyCallbacks = layers.map(function (l) {
      return l.getDataReadyCallback();
    });
    readyCallbacks.length && _deferred.when.apply(undefined, readyCallbacks).done(that._dataReady);
  },
  _updateClip: function _updateClip() {
    var rect = this._rect;
    var bw = this._borderWidth;
    this._clip.attr({
      x: rect[0] + bw,
      y: rect[1] + bw,
      width: _max(rect[2] - bw * 2, 0),
      height: _max(rect[3] - bw * 2, 0)
    });
  },
  setBackgroundOptions: function setBackgroundOptions(options) {
    this._background.attr({
      stroke: options.borderColor,
      'stroke-width': options.borderWidth,
      fill: options.color
    });
    this._borderWidth = _max(options.borderWidth, 0);
    this._updateClip();
  },
  setRect: function setRect(rect) {
    this._rect = rect;
    this._background.attr({
      x: rect[0],
      y: rect[1],
      width: rect[2],
      height: rect[3]
    });
    this._updateClip();
  },
  byIndex: function byIndex(index) {
    return this._layers[index];
  },
  byName: function byName(name) {
    return this._layerByName[name];
  },
  items: function items() {
    return this._layers;
  }
};

/***/ }),

/***/ 102:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



Object.defineProperty(exports, "projection", ({
  enumerable: true,
  get: function get() {
    return _projection.projection;
  }
}));
var _projection = __webpack_require__(14316);
var _min = Math.min;
var _max = Math.max;
var _sin = Math.sin;
var _asin = Math.asin;
var _tan = Math.tan;
var _atan = Math.atan;
var _exp = Math.exp;
var _log = Math.log;
var PI = Math.PI;
var PI_DIV_4 = PI / 4;
var GEO_LON_BOUND = 180;
var GEO_LAT_BOUND = 90;
var RADIANS = PI / 180;
var MERCATOR_LAT_BOUND = (2 * _atan(_exp(PI)) - PI / 2) / RADIANS;
var MILLER_LAT_BOUND = (2.5 * _atan(_exp(0.8 * PI)) - 0.625 * PI) / RADIANS;
function clamp(value, threshold) {
  return _max(_min(value, +threshold), -threshold);
}

// https://en.wikipedia.org/wiki/Mercator_projection
_projection.projection.add('mercator', (0, _projection.projection)({
  aspectRatio: 1,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, _log(_tan(PI_DIV_4 + clamp(coordinates[1], MERCATOR_LAT_BOUND) * RADIANS / 2)) / PI];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, (2 * _atan(_exp(coordinates[1] * PI)) - PI / 2) / RADIANS];
  }
}));

// https://en.wikipedia.org/wiki/Equirectangular_projection
_projection.projection.add('equirectangular', (0, _projection.projection)({
  aspectRatio: 2,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, coordinates[1] / GEO_LAT_BOUND];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, coordinates[1] * GEO_LAT_BOUND];
  }
}));

// https://en.wikipedia.org/wiki/Lambert_cylindrical_equal-area_projection
_projection.projection.add('lambert', (0, _projection.projection)({
  aspectRatio: 2,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, _sin(clamp(coordinates[1], GEO_LAT_BOUND) * RADIANS)];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, _asin(clamp(coordinates[1], 1)) / RADIANS];
  }
}));

// https://en.wikipedia.org/wiki/Miller_cylindrical_projection
_projection.projection.add('miller', (0, _projection.projection)({
  aspectRatio: 1,
  to: function to(coordinates) {
    return [coordinates[0] / GEO_LON_BOUND, 1.25 * _log(_tan(PI_DIV_4 + clamp(coordinates[1], MILLER_LAT_BOUND) * RADIANS * 0.4)) / PI];
  },
  from: function from(coordinates) {
    return [coordinates[0] * GEO_LON_BOUND, (2.5 * _atan(_exp(0.8 * coordinates[1] * PI)) - 0.625 * PI) / RADIANS];
  }
}));

/***/ }),

/***/ 14316:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.projection = exports.Projection = void 0;
var _extend = __webpack_require__(13306);
var _event_emitter = __webpack_require__(63832);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var _Number = Number;
var _min = Math.min;
var _max = Math.max;
var _abs = Math.abs;
var _round = Math.round;
var _ln = Math.log;
var _pow = Math.pow;
var TWO_TO_LN2 = 2 / Math.LN2;

// T224204
// The value is selected so that bounds range of 1 angular second can be defined
// 1 angular second is (1 / 3600) degrees or (1 / 3600 / 180) after projection
// The value 10 times less than projected 1 angular second is chosen
var MIN_BOUNDS_RANGE = 1 / 3600 / 180 / 10;
var DEFAULT_MIN_ZOOM = 1;
var DEFAULT_MAX_ZOOM = 1 << 8;
var DEFAULT_CENTER = [NaN, NaN];
var DEFAULT_ENGINE_NAME = 'mercator';
function floatsEqual(f1, f2) {
  return _abs(f1 - f2) < 1E-8;
}
function arraysEqual(a1, a2) {
  return floatsEqual(a1[0], a2[0]) && floatsEqual(a1[1], a2[1]);
}
function parseAndClamp(value, minValue, maxValue, defaultValue) {
  var val = _Number(value);
  return isFinite(val) ? _min(_max(val, minValue), maxValue) : defaultValue;
}
function parseAndClampArray(value, minValue, maxValue, defaultValue) {
  return [parseAndClamp(value[0], minValue[0], maxValue[0], defaultValue[0]), parseAndClamp(value[1], minValue[1], maxValue[1], defaultValue[1])];
}
function getEngine(engine) {
  return engine instanceof Engine && engine || projection.get(engine) || projection(engine) || projection.get(DEFAULT_ENGINE_NAME);
}
var Projection = function Projection(parameters) {
  var that = this;
  that._initEvents();
  that._params = parameters;
  that._engine = getEngine();
  that._center = that._engine.center();
  that._adjustCenter();
};
exports.Projection = Projection;
Projection.prototype = {
  constructor: Projection,
  _minZoom: DEFAULT_MIN_ZOOM,
  _maxZoom: DEFAULT_MAX_ZOOM,
  _zoom: DEFAULT_MIN_ZOOM,
  _center: DEFAULT_CENTER,
  _canvas: {},
  _scale: [],
  dispose: function dispose() {
    this._disposeEvents();
  },
  setEngine: function setEngine(value) {
    var that = this;
    var engine = getEngine(value);
    if (that._engine !== engine) {
      that._engine = engine;
      that._fire('engine');
      if (that._changeCenter(engine.center())) {
        that._triggerCenterChanged();
      }
      if (that._changeZoom(that._minZoom)) {
        that._triggerZoomChanged();
      }
      that._adjustCenter();
      that._setupScreen();
    }
  },
  setBounds: function setBounds(bounds) {
    if (bounds !== undefined) {
      this.setEngine(this._engine.original().bounds(bounds));
    }
  },
  _setupScreen: function _setupScreen() {
    var that = this;
    var canvas = that._canvas;
    var width = canvas.width;
    var height = canvas.height;
    var engine = that._engine;
    var aspectRatio = engine.ar();
    that._x0 = canvas.left + width / 2;
    that._y0 = canvas.top + height / 2;
    var min = [that.project([engine.min()[0], 0])[0], that.project([0, engine.min()[1]])[1]];
    var max = [that.project([engine.max()[0], 0])[0], that.project([0, engine.max()[1]])[1]];
    var screenAR = width / height;
    var boundsAR = _abs(max[0] - min[0]) / _abs(max[1] - min[1]);
    var correction;
    if (isNaN(boundsAR) || boundsAR === 0 || _min(screenAR, aspectRatio) <= aspectRatio * boundsAR && aspectRatio * boundsAR <= _max(screenAR, aspectRatio)) {
      correction = 1;
    } else {
      correction = boundsAR > 1 ? boundsAR : 1 / boundsAR;
    }
    if (aspectRatio * boundsAR >= screenAR) {
      that._xRadius = width / 2 / correction;
      that._yRadius = width / 2 / (aspectRatio * correction);
    } else {
      that._xRadius = height / 2 * (aspectRatio / correction);
      that._yRadius = height / 2 / correction;
    }
    that._fire('screen');
  },
  setSize: function setSize(canvas) {
    this._canvas = canvas;
    this._setupScreen();
  },
  getCanvas: function getCanvas() {
    return this._canvas;
  },
  _toScreen: function _toScreen(coordinates) {
    return [this._x0 + this._xRadius * coordinates[0], this._y0 + this._yRadius * coordinates[1]];
  },
  _fromScreen: function _fromScreen(coordinates) {
    return [(coordinates[0] - this._x0) / this._xRadius, (coordinates[1] - this._y0) / this._yRadius];
  },
  _toTransformed: function _toTransformed(coordinates) {
    return [coordinates[0] * this._zoom + this._xCenter, coordinates[1] * this._zoom + this._yCenter];
  },
  _toTransformedFast: function _toTransformedFast(coordinates) {
    return [coordinates[0] * this._zoom, coordinates[1] * this._zoom];
  },
  _fromTransformed: function _fromTransformed(coordinates) {
    return [(coordinates[0] - this._xCenter) / this._zoom, (coordinates[1] - this._yCenter) / this._zoom];
  },
  _adjustCenter: function _adjustCenter() {
    var that = this;
    var center = that._engine.project(that._center);
    that._xCenter = -center[0] * that._zoom || 0;
    that._yCenter = -center[1] * that._zoom || 0;
  },
  project: function project(coordinates) {
    return this._engine.project(coordinates);
  },
  transform: function transform(coordinates) {
    return this._toScreen(this._toTransformedFast(coordinates));
  },
  isInvertible: function isInvertible() {
    return this._engine.isInvertible();
  },
  getSquareSize: function getSquareSize(size) {
    return [size[0] * this._zoom * this._xRadius, size[1] * this._zoom * this._yRadius];
  },
  getZoom: function getZoom() {
    return this._zoom;
  },
  _changeZoom: function _changeZoom(value) {
    var that = this;
    var oldZoom = that._zoom;
    var newZoom = that._zoom = parseAndClamp(value, that._minZoom, that._maxZoom, that._minZoom);
    var isChanged = !floatsEqual(oldZoom, newZoom);
    if (isChanged) {
      that._adjustCenter();
      that._fire('zoom');
    }
    return isChanged;
  },
  setZoom: function setZoom(value) {
    if (this._engine.isInvertible() && this._changeZoom(value)) {
      this._triggerZoomChanged();
    }
  },
  getScaledZoom: function getScaledZoom() {
    return _round((this._scale.length - 1) * _ln(this._zoom) / _ln(this._maxZoom));
  },
  setScaledZoom: function setScaledZoom(scaledZoom) {
    this.setZoom(this._scale[_round(scaledZoom)]);
  },
  changeScaledZoom: function changeScaledZoom(deltaZoom) {
    this.setZoom(this._scale[_max(_min(_round(this.getScaledZoom() + deltaZoom), this._scale.length - 1), 0)]);
  },
  getZoomScalePartition: function getZoomScalePartition() {
    return this._scale.length - 1;
  },
  _setupScaling: function _setupScaling() {
    var that = this;
    var k = _max(_round(TWO_TO_LN2 * _ln(that._maxZoom)), 4);
    var step = _pow(that._maxZoom, 1 / k);
    var zoom = that._minZoom;
    that._scale = [zoom];
    for (var i = 1; i <= k; ++i) {
      that._scale.push(zoom *= step);
    }
  },
  setMaxZoom: function setMaxZoom(maxZoom) {
    var that = this;
    that._minZoom = DEFAULT_MIN_ZOOM;
    that._maxZoom = parseAndClamp(maxZoom, that._minZoom, _Number.MAX_VALUE, DEFAULT_MAX_ZOOM);
    that._setupScaling();
    if (that._zoom > that._maxZoom) {
      that.setZoom(that._maxZoom);
    }
    that._fire('max-zoom');
  },
  getCenter: function getCenter() {
    return this._center.slice();
  },
  setCenter: function setCenter(value) {
    if (this._engine.isInvertible() && this._changeCenter(value || [])) {
      this._triggerCenterChanged();
    }
  },
  _changeCenter: function _changeCenter(value) {
    var that = this;
    var engine = that._engine;
    var oldCenter = that._center;
    var newCenter = that._center = parseAndClampArray(value, engine.min(), engine.max(), engine.center());
    var isChanged = !arraysEqual(oldCenter, newCenter);
    if (isChanged) {
      that._adjustCenter();
      that._fire('center');
    }
    return isChanged;
  },
  _triggerCenterChanged: function _triggerCenterChanged() {
    this._params.centerChanged(this.getCenter());
  },
  _triggerZoomChanged: function _triggerZoomChanged() {
    this._params.zoomChanged(this.getZoom());
  },
  setCenterByPoint: function setCenterByPoint(coordinates, screenPosition) {
    var that = this;
    var p = that._engine.project(coordinates);
    var q = that._fromScreen(screenPosition);
    that.setCenter(that._engine.unproject([-q[0] / that._zoom + p[0], -q[1] / that._zoom + p[1]]));
  },
  beginMoveCenter: function beginMoveCenter() {
    if (this._engine.isInvertible()) {
      this._moveCenter = this._center;
    }
  },
  endMoveCenter: function endMoveCenter() {
    var that = this;
    if (that._moveCenter) {
      if (!arraysEqual(that._moveCenter, that._center)) {
        that._triggerCenterChanged();
      }
      that._moveCenter = null;
    }
  },
  moveCenter: function moveCenter(shift) {
    var that = this;
    if (that._moveCenter) {
      var current = that.toScreenPoint(that._center);
      that._changeCenter(that.fromScreenPoint([current[0] + shift[0], current[1] + shift[1]]));
    }
  },
  getViewport: function getViewport() {
    var that = this;
    var unproject = that._engine.unproject;
    var lt = unproject(that._fromTransformed([-1, -1]));
    var lb = unproject(that._fromTransformed([-1, +1]));
    var rt = unproject(that._fromTransformed([+1, -1]));
    var rb = unproject(that._fromTransformed([+1, +1]));
    var minMax = findMinMax([selectFarthestPoint(lt[0], lb[0], rt[0], rb[0]), selectFarthestPoint(lt[1], rt[1], lb[1], rb[1])], [selectFarthestPoint(rt[0], rb[0], lt[0], lb[0]), selectFarthestPoint(lb[1], rb[1], lt[1], rt[1])]);
    return [].concat(minMax.min, minMax.max);
  },
  // T254127
  // There should be no expectation that if viewport is got with `getViewport` and set with `setViewport`
  // then center and zoom will be retained - in general case they will be not.
  // Such retaining requires invertibility of projection which is generally not available
  // Invertibility means that `project(unproject([x, y])) === [x, y]` and `unproject(project([x, y])) === [x, y]` for any reasonable `(x, y)`
  // For example:
  // the "mercator" is non invertible - longitude is invertible, latitude is not (because of tan and log)
  // the "equirectangular" is invertible (it uses simple linear transformations)
  setViewport: function setViewport(viewport) {
    var engine = this._engine;
    var data = viewport ? getZoomAndCenterFromViewport(engine.project, engine.unproject, viewport) : [this._minZoom, engine.center()];
    this.setZoom(data[0]);
    this.setCenter(data[1]);
  },
  getTransform: function getTransform() {
    return {
      translateX: this._xCenter * this._xRadius,
      translateY: this._yCenter * this._yRadius
    };
  },
  fromScreenPoint: function fromScreenPoint(coordinates) {
    return this._engine.unproject(this._fromTransformed(this._fromScreen(coordinates)));
  },
  toScreenPoint: function toScreenPoint(coordinates) {
    return this._toScreen(this._toTransformed(this._engine.project(coordinates)));
  },
  _eventNames: ['engine', 'screen', 'center', 'zoom', 'max-zoom']
};
(0, _event_emitter.makeEventEmitter)(Projection);
function selectFarthestPoint(point1, point2, basePoint1, basePoint2) {
  var basePoint = (basePoint1 + basePoint2) / 2;
  return _abs(point1 - basePoint) > _abs(point2 - basePoint) ? point1 : point2;
}
function selectClosestPoint(point1, point2, basePoint1, basePoint2) {
  var basePoint = (basePoint1 + basePoint2) / 2;
  return _abs(point1 - basePoint) < _abs(point2 - basePoint) ? point1 : point2;
}
function getZoomAndCenterFromViewport(project, unproject, viewport) {
  var lt = project([viewport[0], viewport[3]]);
  var lb = project([viewport[0], viewport[1]]);
  var rt = project([viewport[2], viewport[3]]);
  var rb = project([viewport[2], viewport[1]]);
  var l = selectClosestPoint(lt[0], lb[0], rt[0], rb[0]);
  var r = selectClosestPoint(rt[0], rb[0], lt[0], lb[0]);
  var t = selectClosestPoint(lt[1], rt[1], lb[1], rb[1]);
  var b = selectClosestPoint(lb[1], rb[1], lt[1], rt[1]);
  return [2 / _max(_abs(l - r), _abs(t - b)), unproject([(l + r) / 2, (t + b) / 2])];
}
function setMinMax(engine, p1, p2) {
  var _findMinMax = findMinMax(p1, p2),
    min = _findMinMax.min,
    max = _findMinMax.max;
  engine.min = returnArray(min);
  engine.max = returnArray(max);
}
var Engine = /*#__PURE__*/function () {
  function Engine(parameters) {
    var that = this;
    var project = createProjectMethod(parameters.to);
    var unproject = parameters.from ? createUnprojectMethod(parameters.from) : returnValue(DEFAULT_CENTER);
    that.project = project;
    that.unproject = unproject;
    that.original = returnValue(that);
    that.source = function () {
      return (0, _extend.extend)({}, parameters);
    };
    that.isInvertible = returnValue(!!parameters.from);
    that.ar = returnValue(parameters.aspectRatio > 0 ? _Number(parameters.aspectRatio) : 1);
    that.center = returnArray(unproject([0, 0]));
    setMinMax(that, [unproject([-1, 0])[0], unproject([0, +1])[1]], [unproject([+1, 0])[0], unproject([0, -1])[1]]);
  }
  var _proto = Engine.prototype;
  _proto.aspectRatio = function aspectRatio(_aspectRatio) {
    var engine = new Engine((0, _extend.extend)(this.source(), {
      aspectRatio: _aspectRatio
    }));
    engine.original = this.original;
    engine.min = this.min;
    engine.max = this.max;
    return engine;
  };
  _proto.bounds = function bounds(_bounds) {
    _bounds = _bounds || [];
    var parameters = this.source();
    var min = this.min();
    var max = this.max();
    var b1 = parseAndClampArray([_bounds[0], _bounds[1]], min, max, min);
    var b2 = parseAndClampArray([_bounds[2], _bounds[3]], min, max, max);
    var p1 = parameters.to(b1);
    var p2 = parameters.to(b2);
    var delta = _min(_abs(p2[0] - p1[0]) > MIN_BOUNDS_RANGE ? _abs(p2[0] - p1[0]) : 2, _abs(p2[1] - p1[1]) > MIN_BOUNDS_RANGE ? _abs(p2[1] - p1[1]) : 2);
    if (delta < 2) {
      (0, _extend.extend)(parameters, createProjectUnprojectMethods(parameters.to, parameters.from, p1, p2, delta));
    }
    var engine = new Engine(parameters);
    engine.original = this.original;
    setMinMax(engine, b1, b2);
    return engine;
  };
  return Engine;
}();
function invertVerticalAxis(pair) {
  return [pair[0], -pair[1]];
}
function createProjectMethod(method) {
  return function (arg) {
    return invertVerticalAxis(method(arg));
  };
}
function createUnprojectMethod(method) {
  return function (arg) {
    return method(invertVerticalAxis(arg));
  };
}
function returnValue(value) {
  return function () {
    return value;
  };
}
function returnArray(value) {
  return function () {
    return value.slice();
  };
}
function findMinMax(p1, p2) {
  return {
    min: [_min(p1[0], p2[0]), _min(p1[1], p2[1])],
    max: [_max(p1[0], p2[0]), _max(p1[1], p2[1])]
  };
}
var projection = function projection(parameters) {
  return parameters && parameters.to ? new Engine(parameters) : null;
};
exports.projection = projection;
var projectionsCache = {};
projection.get = function (name) {
  return projectionsCache[name] || null;
};
projection.add = function (name, engine) {
  engine = engine instanceof Engine && engine || projection(engine);
  if (!projectionsCache[name] && engine) {
    projectionsCache[name] = engine;
  }
  return projection; // For chaining
};

function createProjectUnprojectMethods(project, unproject, p1, p2, delta) {
  var x0 = (p1[0] + p2[0]) / 2 - delta / 2;
  var y0 = (p1[1] + p2[1]) / 2 - delta / 2;
  var k = 2 / delta;
  return {
    to: function to(coordinates) {
      var _project = project(coordinates),
        _project2 = _slicedToArray(_project, 2),
        p0 = _project2[0],
        p1 = _project2[1];
      return [-1 + (p0 - x0) * k, -1 + (p1 - y0) * k];
    },
    from: function from(coordinates) {
      return unproject([x0 + (coordinates[0] + 1) / k, y0 + (coordinates[1] + 1) / k]);
    }
  };
}

/***/ }),

/***/ 8068:
/***/ (function(__unused_webpack_module, exports) {



exports.TooltipViewer = TooltipViewer;
var TOOLTIP_OFFSET = 12;

// TODO: Somehow it should be merged with the core.Tooltip
function TooltipViewer(params) {
  this._subscribeToTracker(params.tracker, params.tooltip, params.layerCollection);
}
TooltipViewer.prototype = {
  constructor: TooltipViewer,
  dispose: function dispose() {
    this._offTracker();
    this._offTracker = null;
  },
  _subscribeToTracker: function _subscribeToTracker(tracker, tooltip, layerCollection) {
    this._offTracker = tracker.on({
      'focus-on': function focusOn(arg) {
        var layer;
        var proxy;
        if (tooltip.isEnabled()) {
          layer = layerCollection.byName(arg.data.name);
          proxy = layer && layer.getProxy(arg.data.index);
          var callback = function callback(result) {
            result && arg.done(result);
          };
          proxy && callback(tooltip.show(proxy, {
            x: arg.x,
            y: arg.y,
            offset: TOOLTIP_OFFSET
          }, {
            target: proxy
          }, undefined, callback));
        }
      },
      // There are no checks for `tooltip.isEnabled()` in the following two handlers because they are called only if the previous one has finished with `true`
      'focus-move': function focusMove(arg) {
        tooltip.move(arg.x, arg.y, TOOLTIP_OFFSET);
      },
      'focus-off': function focusOff() {
        tooltip.hide();
      }
    });
  }
};

/***/ }),

/***/ 49497:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



exports.Tracker = Tracker;
var _events_engine = _interopRequireDefault(__webpack_require__(55994));
var _window = __webpack_require__(58201);
var _dom_adapter = _interopRequireDefault(__webpack_require__(73349));
var _event_emitter = __webpack_require__(63832);
var _index = __webpack_require__(39611);
var _wheel = __webpack_require__(765);
var _utils = __webpack_require__(19157);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var navigator = (0, _window.getNavigator)();
var _math = Math;
var _abs = _math.abs;
var _sqrt = _math.sqrt;
var _round = _math.round;
var _addNamespace = _index.addNamespace;
var _NAME = 'dxVectorMap';
var EVENT_START = 'start';
var EVENT_MOVE = 'move';
var EVENT_END = 'end';
var EVENT_ZOOM = 'zoom';
var EVENT_HOVER_ON = 'hover-on';
var EVENT_HOVER_OFF = 'hover-off';
var EVENT_CLICK = 'click';
var EVENT_FOCUS_ON = 'focus-on';
var EVENT_FOCUS_MOVE = 'focus-move';
var EVENT_FOCUS_OFF = 'focus-off';
var CLICK_TIME_THRESHOLD = 500;
var CLICK_COORD_THRESHOLD_MOUSE = 5;
var CLICK_COORD_THRESHOLD_TOUCH = 20;
var DRAG_COORD_THRESHOLD_MOUSE = 5;
var DRAG_COORD_THRESHOLD_TOUCH = 10;
var FOCUS_OFF_DELAY = 100;
var WHEEL_COOLDOWN = 50;
var WHEEL_DIRECTION_COOLDOWN = 300;
var EVENTS;
var Focus;
setupEvents();
function Tracker(parameters) {
  var that = this;
  that._root = parameters.root;
  that._createEventHandlers(parameters.dataKey);
  that._createProjectionHandlers(parameters.projection);
  that._initEvents();
  that._focus = new Focus(function (name, arg) {
    that._fire(name, arg);
  });
  that._attachHandlers();
}
Tracker.prototype = {
  constructor: Tracker,
  dispose: function dispose() {
    var that = this;
    that._detachHandlers();
    that._disposeEvents();
    that._focus.dispose();
    that._root = that._focus = that._docHandlers = that._rootHandlers = null;
  },
  _eventNames: [EVENT_START, EVENT_MOVE, EVENT_END, EVENT_ZOOM, EVENT_CLICK, EVENT_HOVER_ON, EVENT_HOVER_OFF, EVENT_FOCUS_ON, EVENT_FOCUS_OFF, EVENT_FOCUS_MOVE],
  _startClick: function _startClick(event, data) {
    if (!data) {
      return;
    }
    var coords = getEventCoords(event);
    this._clickState = {
      x: coords.x,
      y: coords.y,
      threshold: isTouchEvent(event) ? CLICK_COORD_THRESHOLD_TOUCH : CLICK_COORD_THRESHOLD_MOUSE,
      time: Date.now()
    };
  },
  _endClick: function _endClick(event, data) {
    var state = this._clickState;
    var threshold;
    var coords;
    if (!state) {
      return;
    }
    if (data && Date.now() - state.time <= CLICK_TIME_THRESHOLD) {
      threshold = state.threshold;
      coords = getEventCoords(event);
      if (_abs(coords.x - state.x) <= threshold && _abs(coords.y - state.y) <= threshold) {
        this._fire(EVENT_CLICK, {
          data: data,
          x: coords.x,
          y: coords.y,
          $event: event
        });
      }
    }
    this._clickState = null;
  },
  _startDrag: function _startDrag(event, data) {
    if (!data) {
      return;
    }
    var coords = getEventCoords(event);
    var state = this._dragState = {
      x: coords.x,
      y: coords.y,
      data: data
    };
    this._fire(EVENT_START, {
      x: state.x,
      y: state.y,
      data: state.data
    });
  },
  _moveDrag: function _moveDrag(event, data) {
    var state = this._dragState;
    if (!state) {
      return;
    }
    var coords = getEventCoords(event);
    var threshold = isTouchEvent(event) ? DRAG_COORD_THRESHOLD_TOUCH : DRAG_COORD_THRESHOLD_MOUSE;
    if (state.active || _abs(coords.x - state.x) > threshold || _abs(coords.y - state.y) > threshold) {
      state.x = coords.x;
      state.y = coords.y;
      state.active = true;
      state.data = data || {};
      this._fire(EVENT_MOVE, {
        x: state.x,
        y: state.y,
        data: state.data
      });
    }
  },
  _endDrag: function _endDrag() {
    var state = this._dragState;
    if (!state) {
      return;
    }
    this._dragState = null;
    this._fire(EVENT_END, {
      x: state.x,
      y: state.y,
      data: state.data
    });
  },
  _wheelZoom: function _wheelZoom(event, data) {
    if (!data) {
      return;
    }
    var that = this;
    var lock = that._wheelLock;
    var time = Date.now();
    if (time - lock.time <= WHEEL_COOLDOWN) {
      return;
    }
    // T136650
    if (time - lock.dirTime > WHEEL_DIRECTION_COOLDOWN) {
      lock.dir = 0;
    }
    // T107589, T136650
    var delta = adjustWheelDelta(event.delta / 120 || 0, lock);
    if (delta === 0) {
      return;
    }
    var coords = getEventCoords(event);
    that._fire(EVENT_ZOOM, {
      delta: delta,
      x: coords.x,
      y: coords.y
    });
    lock.time = lock.dirTime = time;
  },
  _startZoom: function _startZoom(event, data) {
    if (!isTouchEvent(event) || !data) {
      return;
    }
    var state = this._zoomState = this._zoomState || {};
    var coords;
    var pointer2;
    if (state.pointer1 && state.pointer2) {
      return;
    }
    if (state.pointer1 === undefined) {
      state.pointer1 = getPointerId(event) || 0;
      coords = getMultitouchEventCoords(event, state.pointer1);
      state.x1 = state.x1_0 = coords.x;
      state.y1 = state.y1_0 = coords.y;
    }
    if (state.pointer2 === undefined) {
      pointer2 = getPointerId(event) || 1;
      if (pointer2 !== state.pointer1) {
        coords = getMultitouchEventCoords(event, pointer2);
        if (coords) {
          state.x2 = state.x2_0 = coords.x;
          state.y2 = state.y2_0 = coords.y;
          state.pointer2 = pointer2;
          state.ready = true;
          this._endDrag();
        }
      }
    }
  },
  _moveZoom: function _moveZoom(event) {
    var state = this._zoomState;
    var coords;
    if (!state || !isTouchEvent(event)) {
      return;
    }
    if (state.pointer1 !== undefined) {
      coords = getMultitouchEventCoords(event, state.pointer1);
      if (coords) {
        state.x1 = coords.x;
        state.y1 = coords.y;
      }
    }
    if (state.pointer2 !== undefined) {
      coords = getMultitouchEventCoords(event, state.pointer2);
      if (coords) {
        state.x2 = coords.x;
        state.y2 = coords.y;
      }
    }
  },
  _endZoom: function _endZoom(event) {
    var state = this._zoomState;
    var startDistance;
    var currentDistance;
    if (!state || !isTouchEvent(event)) {
      return;
    }
    if (state.ready) {
      startDistance = getDistance(state.x1_0, state.y1_0, state.x2_0, state.y2_0);
      currentDistance = getDistance(state.x1, state.y1, state.x2, state.y2);
      this._fire(EVENT_ZOOM, {
        ratio: currentDistance / startDistance,
        x: (state.x1_0 + state.x2_0) / 2,
        y: (state.y1_0 + state.y2_0) / 2
      });
    }
    this._zoomState = null;
  },
  _startHover: function _startHover(event, data) {
    this._doHover(event, data, true);
  },
  _moveHover: function _moveHover(event, data) {
    this._doHover(event, data, false);
  },
  _doHover: function _doHover(event, data, isTouch) {
    var that = this;
    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
      that._cancelHover();
      return;
    }
    if (isTouchEvent(event) !== isTouch || that._hoverTarget === event.target || that._hoverState && that._hoverState.data === data) {
      return;
    }
    that._cancelHover();
    if (data) {
      that._hoverState = {
        data: data
      };
      that._fire(EVENT_HOVER_ON, {
        data: data
      });
    }
    that._hoverTarget = event.target;
  },
  _cancelHover: function _cancelHover() {
    var state = this._hoverState;
    this._hoverState = this._hoverTarget = null;
    if (state) {
      this._fire(EVENT_HOVER_OFF, {
        data: state.data
      });
    }
  },
  _startFocus: function _startFocus(event, data) {
    this._doFocus(event, data, true);
  },
  _moveFocus: function _moveFocus(event, data) {
    this._doFocus(event, data, false);
  },
  _doFocus: function _doFocus(event, data, isTouch) {
    var that = this;
    if (that._dragState && that._dragState.active || that._zoomState && that._zoomState.ready) {
      that._cancelFocus();
      return;
    }
    if (isTouchEvent(event) !== isTouch) {
      return;
    }
    that._focus.turnOff();
    data && that._focus.turnOn(data, getEventCoords(event));
  },
  _cancelFocus: function _cancelFocus() {
    this._focus.cancel();
  },
  _createEventHandlers: function _createEventHandlers(DATA_KEY) {
    var that = this;
    that._docHandlers = {};
    that._rootHandlers = {};
    that._docHandlers[EVENTS.start] = function (event) {
      var isTouch = isTouchEvent(event);
      var data = getData(event);
      if (isTouch && !that._isTouchEnabled) {
        return;
      }
      if (data) {
        event.preventDefault();
      }
      that._startClick(event, data);
      that._startDrag(event, data);
      that._startZoom(event, data);
      that._startHover(event, data);
      that._startFocus(event, data);
    };
    that._docHandlers[EVENTS.move] = function (event) {
      var isTouch = isTouchEvent(event);
      var data = getData(event);
      if (isTouch && !that._isTouchEnabled) {
        return;
      }
      that._moveDrag(event, data);
      that._moveZoom(event, data);
      that._moveHover(event, data);
      that._moveFocus(event, data);
    };
    that._docHandlers[EVENTS.end] = function (event) {
      var isTouch = isTouchEvent(event);
      var data = getData(event);
      if (isTouch && !that._isTouchEnabled) {
        return;
      }
      that._endClick(event, data);
      that._endDrag(event, data);
      that._endZoom(event, data);
    };
    that._rootHandlers[EVENTS.wheel] = function (event) {
      that._cancelFocus();
      if (!that._isWheelEnabled) {
        return;
      }
      var data = getData(event);
      if (data) {
        event.preventDefault();
        event.stopPropagation(); // T249548
        that._wheelZoom(event, data);
      }
    };
    that._wheelLock = {
      dir: 0
    };

    // Actually it is responsibility of the text element wrapper to handle "data" to its span elements (if there are any).
    // Now to avoid not so necessary complication of renderer text-span issue is handled on the side of the tracker.
    function getData(event) {
      var target = event.target;
      return (target.tagName === 'tspan' ? target.parentNode : target)[DATA_KEY];
    }
  },
  _createProjectionHandlers: function _createProjectionHandlers(projection) {
    var that = this;
    projection.on({
      'center': handler,
      'zoom': handler
    }); // T247841
    function handler() {
      // `_cancelHover` probably should also be called here but for now let it not be so
      that._cancelFocus();
    }
  },
  reset: function reset() {
    var that = this;
    that._clickState = null;
    that._endDrag();
    that._cancelHover();
    that._cancelFocus();
  },
  setOptions: function setOptions(options) {
    var that = this;
    that.reset();
    that._detachHandlers();
    that._isTouchEnabled = !!(0, _utils.parseScalar)(options.touchEnabled, true);
    that._isWheelEnabled = !!(0, _utils.parseScalar)(options.wheelEnabled, true);
    that._attachHandlers();
  },
  _detachHandlers: function _detachHandlers() {
    var that = this;
    if (that._isTouchEnabled) {
      that._root.css({
        'touch-action': '',
        '-webkit-user-select': ''
      }).off(_addNamespace('MSHoldVisual', _NAME)).off(_addNamespace('contextmenu', _NAME));
    }
    _events_engine.default.off(_dom_adapter.default.getDocument(), that._docHandlers);
    that._root.off(that._rootHandlers);
  },
  _attachHandlers: function _attachHandlers() {
    var that = this;
    if (that._isTouchEnabled) {
      that._root.css({
        'touch-action': 'none',
        '-webkit-user-select': 'none'
      }).on(_addNamespace('MSHoldVisual', _NAME), function (event) {
        event.preventDefault();
      }).on(_addNamespace('contextmenu', _NAME), function (event) {
        isTouchEvent(event) && event.preventDefault();
      });
    }
    _events_engine.default.on(_dom_adapter.default.getDocument(), that._docHandlers);
    that._root.on(that._rootHandlers);
  }
};
Focus = function Focus(fire) {
  var that = this;
  var _activeData = null;
  var _data = null;
  var _disabled = false;
  var _offTimer = null;
  var _x;
  var _y;
  that.dispose = function () {
    clearTimeout(_offTimer);
    that.turnOn = that.turnOff = that.cancel = that.dispose = that = fire = _activeData = _data = _offTimer = null;
  };
  that.turnOn = function (data, coords) {
    if (data === _data && _disabled) {
      return;
    }
    _disabled = false;
    _data = data;
    if (_activeData) {
      _x = coords.x;
      _y = coords.y;
      if (_data === _activeData) {
        fire(EVENT_FOCUS_MOVE, {
          data: _data,
          x: _x,
          y: _y
        });
        onCheck(true);
      } else {
        fire(EVENT_FOCUS_ON, {
          data: _data,
          x: _x,
          y: _y,
          done: onCheck
        });
      }
    } else {
      _x = coords.x;
      _y = coords.y;
      fire(EVENT_FOCUS_ON, {
        data: _data,
        x: _x,
        y: _y,
        done: onCheck
      });
    }
    function onCheck(result) {
      _disabled = !result;
      if (result) {
        _activeData = _data;
        clearTimeout(_offTimer);
        _offTimer = null;
      }
    }
  };
  that.turnOff = function () {
    _data = null;
    if (_activeData && !_disabled) {
      _offTimer = _offTimer || setTimeout(function () {
        _offTimer = null;
        fire(EVENT_FOCUS_OFF, {
          data: _activeData
        });
        _activeData = null;
      }, FOCUS_OFF_DELAY);
    }
  };
  that.cancel = function () {
    clearTimeout(_offTimer);
    if (_activeData) {
      fire(EVENT_FOCUS_OFF, {
        data: _activeData
      });
    }
    _activeData = _data = _offTimer = null;
  };
};
(0, _event_emitter.makeEventEmitter)(Tracker);
function getDistance(x1, y1, x2, y2) {
  return _sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}
function isTouchEvent(event) {
  var type = event.originalEvent.type;
  var pointerType = event.originalEvent.pointerType;
  return /^touch/.test(type) || /^MSPointer/.test(type) && pointerType !== 4 || /^pointer/.test(type) && pointerType !== 'mouse';
}
function selectItem(flags, items) {
  var i = 0;
  var ii = flags.length;
  var item;
  for (; i < ii; ++i) {
    if (flags[i]) {
      item = items[i];
      break;
    }
  }
  return _addNamespace(item || items[i], _NAME);
}
function setupEvents() {
  var flags = [navigator.pointerEnabled, navigator.msPointerEnabled, (0, _window.hasProperty)('ontouchstart')];
  EVENTS = {
    start: selectItem(flags, ['pointerdown', 'MSPointerDown', 'touchstart mousedown', 'mousedown']),
    move: selectItem(flags, ['pointermove', 'MSPointerMove', 'touchmove mousemove', 'mousemove']),
    end: selectItem(flags, ['pointerup', 'MSPointerUp', 'touchend mouseup', 'mouseup']),
    wheel: _addNamespace(_wheel.name, _NAME)
  };
}
function getEventCoords(event) {
  var originalEvent = event.originalEvent;
  var touch = originalEvent.touches && originalEvent.touches[0] || {};
  return {
    x: touch.pageX || originalEvent.pageX || event.pageX,
    y: touch.pageY || originalEvent.pageY || event.pageY
  };
}
function getPointerId(event) {
  return event.originalEvent.pointerId;
}
function getMultitouchEventCoords(event, pointerId) {
  var originalEvent = event.originalEvent;
  if (originalEvent.pointerId !== undefined) {
    originalEvent = originalEvent.pointerId === pointerId ? originalEvent : null;
  } else {
    originalEvent = originalEvent.touches[pointerId];
  }
  return originalEvent ? {
    x: originalEvent.pageX || event.pageX,
    y: originalEvent.pageY || event.pageY
  } : null;
}
function adjustWheelDelta(delta, lock) {
  if (delta === 0) {
    return 0;
  }
  var _delta = _abs(delta);
  var sign = _round(delta / _delta);
  if (lock.dir && sign !== lock.dir) {
    return 0;
  }
  lock.dir = sign;
  if (_delta < 0.1) {
    _delta = 0;
  } else if (_delta < 1) {
    _delta = 1;
  } else if (_delta > 4) {
    _delta = 4;
  } else {
    _delta = _round(_delta);
  }
  return sign * _delta;
}

/***/ }),

/***/ 13711:
/***/ (function(module, exports, __webpack_require__) {



exports["default"] = void 0;
var _utils = __webpack_require__(19157);
var _projection = __webpack_require__(14316);
var _control_bar = __webpack_require__(17323);
var _gesture_handler = __webpack_require__(3797);
var _tracker = __webpack_require__(49497);
var _data_exchanger = __webpack_require__(93699);
var _legend = __webpack_require__(7291);
var _layout = __webpack_require__(39378);
var _map_layer = __webpack_require__(15151);
var _tooltip_viewer = __webpack_require__(8068);
var _vector_map = __webpack_require__(56145);
__webpack_require__(102);
var _m_base_widget = _interopRequireDefault(__webpack_require__(55845));
var _component_registrator = _interopRequireDefault(__webpack_require__(99393));
var _export = __webpack_require__(82454);
var _title = __webpack_require__(17384);
var _tooltip = __webpack_require__(14371);
var _loading_indicator = __webpack_require__(64758);
var _annotations = __webpack_require__(77129);
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var DEFAULT_WIDTH = 800;
var DEFAULT_HEIGHT = 400;
var RE_STARTS_LAYERS = /^layers/;
var RE_ENDS_DATA_SOURCE = /\.dataSource$/;
function mergeBounds(sumBounds, dataBounds) {
  return dataBounds ? [Math.min(dataBounds[0], dataBounds[2], sumBounds[0]), Math.min(dataBounds[1], dataBounds[3], sumBounds[3]), Math.max(dataBounds[0], dataBounds[2], sumBounds[2]), Math.max(dataBounds[1], dataBounds[3], sumBounds[1])] : sumBounds;
}
var dxVectorMap = _m_base_widget.default.inherit({
  _eventsMap: {
    'onClick': {
      name: 'click'
    },
    'onCenterChanged': {
      name: 'centerChanged'
    },
    'onZoomFactorChanged': {
      name: 'zoomFactorChanged'
    },
    'onHoverChanged': {
      name: 'hoverChanged'
    },
    'onSelectionChanged': {
      name: 'selectionChanged'
    }
  },
  _rootClassPrefix: 'dxm',
  _rootClass: 'dxm-vector-map',
  _themeSection: 'map',
  _fontFields: ['layer:area.label.font', 'layer:marker:dot.label.font', 'layer:marker:bubble.label.font', 'layer:marker:pie.label.font', 'layer:marker:image.label.font', 'legend.font', 'legend.title.font', 'legend.title.subtitle.font'],
  _initLayerCollection: function _initLayerCollection(dataKey) {
    var that = this;
    that._layerCollection = new _map_layer.MapLayerCollection({
      renderer: that._renderer,
      projection: that._projection,
      themeManager: that._themeManager,
      tracker: that._tracker,
      dataKey: dataKey,
      eventTrigger: that._eventTrigger,
      dataExchanger: that._dataExchanger,
      tooltip: that._tooltip,
      notifyDirty: that._notifyDirty,
      notifyReady: that._notifyReady,
      dataReady() {
        var bounds;
        if (that.option('getBoundsFromData') && !that.option('bounds')) {
          that._preventProjectionEvents();
          bounds = that._getBoundsFromData();
          that._projection.setBounds(bounds);
          that._allowProjectionEvents();
        }
        if (!that.option('projection')) {
          bounds = bounds || that._getBoundsFromData();
          if (Math.ceil(bounds[0]) < -180 || Math.ceil(bounds[3]) < -90 || Math.floor(bounds[2]) > 180 || Math.floor(bounds[1]) > 90) {
            var longitudeLength = bounds[2] - bounds[0];
            var latitudeLength = bounds[1] - bounds[3];
            that._projection.setEngine({
              to(coordinates) {
                return [(coordinates[0] - bounds[0]) * 2 / longitudeLength - 1, (coordinates[1] - bounds[3]) * 2 / latitudeLength - 1];
              },
              from(coordinates) {
                return [(coordinates[0] + 1) * longitudeLength / 2 + bounds[0], (coordinates[1] + 1) * latitudeLength / 2 + bounds[3]];
              }
            });
          }
        }
      }
    });
  },
  _getBoundsFromData() {
    var bounds = this._getBoundingBoxFromDataSource();
    if (!bounds) {
      var boundsByData = (0, _map_layer.getMaxBound)(this.getLayers().map(function (l) {
        return l.getBounds();
      }));
      if (boundsByData) {
        bounds = boundsByData;
      }
    }
    bounds = bounds || [];
    bounds = [bounds[0], bounds[3], bounds[2], bounds[1]];
    return bounds;
  },
  _initLegendsControl: function _initLegendsControl() {
    var that = this;
    that._legendsControl = new _legend.LegendsControl({
      renderer: that._renderer,
      container: that._root,
      widget: that,
      layoutControl: that._layoutControl,
      themeManager: that._themeManager,
      dataExchanger: that._dataExchanger,
      notifyDirty: that._notifyDirty,
      notifyReady: that._notifyReady
    });
  },
  _initControlBar: function _initControlBar(dataKey) {
    var that = this;
    that._controlBar = new _control_bar.ControlBar({
      renderer: that._renderer,
      container: that._root,
      layoutControl: that._layoutControl,
      projection: that._projection,
      tracker: that._tracker,
      dataKey: dataKey
    });
  },
  _initElements: function _initElements() {
    var that = this;
    var dataKey = (0, _vector_map.generateDataKey)();
    var notifyCounter = 0;
    var preventProjectionEvents;
    that._preventProjectionEvents = function () {
      preventProjectionEvents = true;
    };
    that._allowProjectionEvents = function () {
      preventProjectionEvents = false;
    };
    that._notifyDirty = function () {
      that._resetIsReady();
      ++notifyCounter;
    };
    that._notifyReady = function () {
      that._allowProjectionEvents();
      if (--notifyCounter === 0) {
        that._drawn();
      }
    };
    that._preventProjectionEvents();
    that._dataExchanger = new _data_exchanger.DataExchanger();

    // The `{ eventTrigger: that._eventTrigger }` object cannot be passed to the Projection because later backward option updating is going to be added.
    that._projection = new _projection.Projection({
      centerChanged: function centerChanged(value) {
        if (!preventProjectionEvents) {
          that._eventTrigger('centerChanged', {
            center: value
          });
        }
      },
      zoomChanged: function zoomChanged(value) {
        if (!preventProjectionEvents) {
          that._eventTrigger('zoomFactorChanged', {
            zoomFactor: value
          });
        }
      }
    });
    that._tracker = new _tracker.Tracker({
      root: that._root,
      projection: that._projection,
      dataKey: dataKey
    });
    that._gestureHandler = new _gesture_handler.GestureHandler({
      projection: that._projection,
      renderer: that._renderer,
      tracker: that._tracker
    });
    that._layoutControl = new _layout.LayoutControl(that);
    that._layoutControl.suspend();
    that._initLayerCollection(dataKey);
    that._createHtmlStructure();
    that._initControlBar(dataKey);
    that._initLegendsControl();
    that._prepareExtraElements();
    that._tooltipViewer = new _tooltip_viewer.TooltipViewer({
      tracker: that._tracker,
      tooltip: that._tooltip,
      layerCollection: that._layerCollection
    });
  },
  _change_RESUME_LAYOUT: function _change_RESUME_LAYOUT() {
    this._layoutControl.resume();
  },
  _initialChanges: ['PROJECTION', 'RESUME_LAYOUT', 'LAYOUT_INIT', 'BOUNDS', 'MAX_ZOOM_FACTOR', 'ZOOM_FACTOR', 'CENTER'],
  _layoutChangesOrder: ['RESUME_LAYOUT', 'LAYERS'],
  _customChangesOrder: ['EXTRA_ELEMENTS'],
  _initCore: function _initCore() {
    this._root = this._renderer.root.attr({
      align: 'center',
      cursor: 'default'
    });
    this._initElements();
  },
  _disposeCore: function _disposeCore() {
    var that = this;
    that._controlBar.dispose();
    that._gestureHandler.dispose();
    that._tracker.dispose();
    that._legendsControl.dispose();
    that._layerCollection.dispose();
    that._layoutControl.dispose();
    that._tooltipViewer.dispose();
    that._dataExchanger.dispose();
    that._projection.dispose();
    that._dataExchanger = that._gestureHandler = that._projection = that._tracker = that._layoutControl = that._root = that._layerCollection = that._controlBar = that._legendsControl = null;
  },
  _setupInteraction: function _setupInteraction() {
    var options = {
      centeringEnabled: !!(0, _utils.parseScalar)(this._getOption('panningEnabled', true), true),
      zoomingEnabled: !!(0, _utils.parseScalar)(this._getOption('zoomingEnabled', true), true)
    };
    this._gestureHandler.setInteraction(options);
    this._controlBar.setInteraction(options);
  },
  _getDefaultSize: function _getDefaultSize() {
    return {
      width: DEFAULT_WIDTH,
      height: DEFAULT_HEIGHT
    };
  },
  _applySize: function _applySize(rect) {
    var layout = {
      left: rect[0],
      top: rect[1],
      width: rect[2] - rect[0],
      height: rect[3] - rect[1],
      right: 0,
      bottom: 0
    };
    this._projection.setSize(layout);
    this._layoutControl.setSize(layout);
    this._layerCollection.setRect([layout.left, layout.top, layout.width, layout.height]);
    this._requestChange(['EXTRA_ELEMENTS']);
  },
  // The "layers_data", "mapData", "markers" options must never be merged (because of their meaning)
  // For "layers_data" there are special cases: "layers", "layers.data", "layers[i]", "layers[i].data"
  // Because of the cases (1) and (3) "option by reference" mechanism cannot be used -
  // so separate (for dxVectorMap only by now) mechanism is introduced - it handles all cases (including "option by reference")
  // T318992
  // Previously mechanism used the "_optionValuesEqual" method but after T318992 usage of "_optionValuesEqual" was stopped
  // and new (more meaningful) method was added - "_optionChanging"
  _optionChanging: function _optionChanging(name, currentValue, nextValue) {
    if (currentValue && nextValue) {
      if (RE_STARTS_LAYERS.test(name)) {
        if (currentValue.dataSource && nextValue.dataSource && currentValue !== nextValue) {
          currentValue.dataSource = null;
        } else if (RE_ENDS_DATA_SOURCE.test(name)) {
          this.option(name, null);
        }
      }
    }
  },
  _applyChanges: function _applyChanges() {
    this._notifyDirty();
    this.callBase.apply(this, arguments);
    this._notifyReady();
  },
  _optionChangesMap: {
    background: 'BACKGROUND',
    layers: 'LAYERS',
    extraElements: 'EXTRA_ELEMENTS',
    controlBar: 'CONTROL_BAR',
    legends: 'LEGENDS',
    touchEnabled: 'TRACKER',
    wheelEnabled: 'TRACKER',
    panningEnabled: 'INTERACTION',
    zoomingEnabled: 'INTERACTION',
    projection: 'PROJECTION',
    bounds: 'BOUNDS',
    maxZoomFactor: 'MAX_ZOOM_FACTOR',
    zoomFactor: 'ZOOM_FACTOR',
    center: 'CENTER'
  },
  _optionChangesOrder: ['PROJECTION', 'BOUNDS', 'MAX_ZOOM_FACTOR', 'ZOOM_FACTOR', 'CENTER', 'BACKGROUND', 'CONTROL_BAR', 'LEGENDS', 'TRACKER', 'INTERACTION'],
  _change_PROJECTION: function _change_PROJECTION() {
    this._setProjection();
  },
  _change_BOUNDS: function _change_BOUNDS() {
    this._setBounds();
  },
  _change_MAX_ZOOM_FACTOR: function _change_MAX_ZOOM_FACTOR() {
    this._setMaxZoom();
  },
  _change_ZOOM_FACTOR: function _change_ZOOM_FACTOR() {
    this._setZoom();
  },
  _change_CENTER: function _change_CENTER() {
    this._setCenter();
  },
  _change_BACKGROUND: function _change_BACKGROUND() {
    this._setBackgroundOptions();
  },
  _change_LAYERS: function _change_LAYERS() {
    this._setLayerCollectionOptions();
  },
  _change_CONTROL_BAR: function _change_CONTROL_BAR() {
    this._setControlBarOptions();
  },
  _change_EXTRA_ELEMENTS: function _change_EXTRA_ELEMENTS() {
    this._renderExtraElements();
  },
  _change_LEGENDS: function _change_LEGENDS() {
    this._setLegendsOptions();
  },
  _change_TRACKER: function _change_TRACKER() {
    this._setTrackerOptions();
  },
  _change_INTERACTION: function _change_INTERACTION() {
    this._setupInteraction();
  },
  _themeDependentChanges: ['BACKGROUND', 'LAYERS', 'CONTROL_BAR', 'LEGENDS', 'TRACKER', 'INTERACTION'],
  _setProjection: function _setProjection() {
    this._projection.setEngine(this.option('projection'));
  },
  _setBounds: function _setBounds() {
    this._projection.setBounds(this.option('bounds'));
  },
  _setMaxZoom: function _setMaxZoom() {
    this._projection.setMaxZoom(this.option('maxZoomFactor'));
  },
  _setZoom: function _setZoom() {
    this._projection.setZoom(this.option('zoomFactor'));
  },
  _setCenter: function _setCenter() {
    this._projection.setCenter(this.option('center'));
  },
  _setBackgroundOptions: function _setBackgroundOptions() {
    this._layerCollection.setBackgroundOptions(this._getOption('background'));
  },
  _setLayerCollectionOptions: function _setLayerCollectionOptions() {
    this._layerCollection.setOptions(this.option('layers'));
  },
  _getBoundingBoxFromDataSource() {
    var that = this;
    var layers = that._layerCollection.items();
    var infinityBounds = [Infinity, -Infinity, -Infinity, Infinity];
    var resultBBox = layers && layers.length ? layers.reduce(function (sumBBox, l) {
      var layerData = l.getData();
      var itemCount = layerData.count();
      if (itemCount > 0) {
        var rootBBox = layerData.getBBox();
        if (rootBBox) {
          sumBBox = mergeBounds(sumBBox, rootBBox);
        } else {
          for (var i = 0; i < itemCount; i++) {
            sumBBox = mergeBounds(sumBBox, layerData.getBBox(i));
          }
        }
      }
      return sumBBox;
    }, infinityBounds) : undefined;
    return resultBBox === infinityBounds ? undefined : resultBBox;
  },
  _setControlBarOptions: function _setControlBarOptions() {
    this._controlBar.setOptions(this._getOption('controlBar'));
  },
  _setLegendsOptions: function _setLegendsOptions() {
    this._legendsControl.setOptions(this.option('legends'));
  },
  _setTrackerOptions: function _setTrackerOptions() {
    this._tracker.setOptions({
      touchEnabled: this._getOption('touchEnabled', true),
      wheelEnabled: this._getOption('wheelEnabled', true)
    });
  },
  getLayers() {
    return this._layerCollection.items().map(function (l) {
      return l.proxy;
    });
  },
  getLayerByIndex: function getLayerByIndex(index) {
    var layer = this._layerCollection.byIndex(index);
    return layer ? layer.proxy : null;
  },
  getLayerByName: function getLayerByName(name) {
    var layer = this._layerCollection.byName(name);
    return layer ? layer.proxy : null;
  },
  clearSelection: function clearSelection(_noEvent) {
    var layers = this._layerCollection.items();
    var i;
    var ii = layers.length;
    for (i = 0; i < ii; ++i) {
      layers[i].clearSelection(_noEvent);
    }
    return this;
  },
  center: function center(value) {
    var that = this;
    if (value === undefined) {
      return that._projection.getCenter();
    } else {
      that._projection.setCenter(value);
      return that;
    }
  },
  zoomFactor: function zoomFactor(value) {
    var that = this;
    if (value === undefined) {
      return that._projection.getZoom();
    } else {
      that._projection.setZoom(value);
      return that;
    }
  },
  viewport: function viewport(value) {
    var that = this;
    if (value === undefined) {
      return that._projection.getViewport();
    } else {
      that._projection.setViewport(value);
      return that;
    }
  },
  convertCoordinates: function convertCoordinates(coordinates) {
    coordinates = coordinates && coordinates.length ? coordinates : [arguments[0], arguments[1]];
    return this.convertToGeo(coordinates[0], coordinates[1]);
  },
  convertToGeo: function convertToGeo(x, y) {
    return this._projection.fromScreenPoint([x, y]);
  },
  convertToXY: function convertToXY(longitude, latitude) {
    return this._projection.toScreenPoint([longitude, latitude]);
  }
});
(0, _component_registrator.default)('dxVectorMap', dxVectorMap);
var _default = dxVectorMap; // PLUGINS_SECTION
exports["default"] = _default;
dxVectorMap.addPlugin(_export.plugin);
dxVectorMap.addPlugin(_title.plugin);
dxVectorMap.addPlugin(_tooltip.plugin);
dxVectorMap.addPlugin(_loading_indicator.plugin);
dxVectorMap.addPlugin(_annotations.plugins.core);
dxVectorMap.addPlugin(_annotations.plugins.vectorMap);
module.exports = exports.default;
module.exports["default"] = exports.default;

/***/ }),

/***/ 56145:
/***/ (function(__unused_webpack_module, exports) {



exports.generateDataKey = generateDataKey;
var nextDataKey = 1;
function generateDataKey() {
  return 'vectormap-data-' + nextDataKey++;
}

/***/ }),

/***/ 71272:
/***/ (function(module) {

module.exports = window.Globalize;

/***/ }),

/***/ 62387:
/***/ (function(module) {

module.exports = window.angular;

/***/ }),

/***/ 96073:
/***/ (function(module) {

module.exports = window.jQuery;

/***/ }),

/***/ 76130:
/***/ (function(module) {

module.exports = window.ko;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {


__webpack_require__(66312);
}();
/******/ })()
;
